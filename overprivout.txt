
--app-start--
processing simulated-dimmer-switch.groovy
DECLARED METHODS
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],
installed: 
updated: 
refresh: 
configure: 
on: 
off: 
setLevel: [(levelEventMap = this.buildSetLevelEvent(value))][If (levelEventMap.value == 0),,],
setLevel: 
initialize: 
buildSetLevelEvent: [(intValue = (java.lang.Integer -> java.lang.Integer) value)][(newLevel = java.lang.Math.max(java.lang.Math.min(intValue, 99), 0))][(eventMap = [name:level, value:newLevel, unit:%])]
implicitOn: [If (device.currentValue(switch) != on),,],
turnOn: 
turnOff: 
onPhysical: 
offPhysical: 
setLevelPhysical: [(eventMap = this.buildSetLevelEvent(value))][If (eventMap.value == 0),[(eventMap.value = 1)],],[(eventMap.type = physical)]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-dimmer-switch.metadata() is applicable for argument types: (simulated-dimmer-switch$_run_closure1) values: [simulated-dimmer-switch$_run_closure1@47d9a273]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-button.groovy
DECLARED METHODS
parse: 
hold1: 
push1: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-button.metadata() is applicable for argument types: (simulated-button$_run_closure1) values: [simulated-button$_run_closure1@53aac487]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing speaker-control.groovy
DECLARED METHODS
mainPage: 
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]
ifUnset: [If settings[name],,],
ifSet: [If settings[name],,],
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [log.trace(subscribeToEvents())][this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,,],
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],
modeChangeHandler: [If (evt.value in triggerModes),,],
scheduledTimeHandler: 
appTouchHandler: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
takeAction: [(options = [:])][If volume,[(options.delay = 1000)],],
frequencyKey: 
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],
getAllOk: 
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]
timeIntervalLabel: 
Starting Points: []
req caps: [capability.motionsensor, capability.musicplayer, capability.contactsensor, capability.switch, capability.button, capability.smokedetector, capability.watersensor, capability.accelerationsensor, capability.presencesensor]
req cap size: 9
requested commands:[play, playtrack, mute, playtext, nexttrack, restoretrack, pause, off, settrack, resumetrack, previoustrack, setlevel, stop, unmute, on]
requested attrs:[motion, level, smoke, trackdescription, mute, water, switch, button, acceleration, trackdata, contact, presence, status]
Methods below
mainpage
anythingset
ifunset
ifset
installed
updated
subscribetoevents
eventhandler
modechangehandler
scheduledtimehandler
apptouchhandler
takeaction
frequencykey
daystring
onceperdayok
getallok
getmodeok
getdaysok
gettimeok
hhmm
timeintervallabel
type 2 attr uses
carbonmonoxide
called cap-methods by app
play
nexttrack
off
pause
previoustrack
setlevel
on
called cap-props by app
motion
smoke
water
switch
button
acceleration
contact
presence
status
attribute uses through subscriptions
button
acceleration
motion
contact
smoke
presence
carbonmonoxide
water
switch
status
cmd overpriv:[playtrack, mute, playtext, restoretrack, settrack, resumetrack, stop, unmute]
attr overpriv:[level, trackdescription, mute, trackdata]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 6d38663a-1703-46b6-9939-8c1fb9467cf9, 266374ae-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, ff20e87b-992b-42b0-9cd6-72b0030dedc3, 26d69a34-ada2-42dc-9e45-445c78ae2619, 1e88cabe-5ba4-4647-9a23-0ad5b887f94b, f730b653-b0b6-483e-8c84-977e240f5eb3, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.refresh, capability.polling]]
--app-start--
processing tile-multiattribute-lighting.groovy
DECLARED METHODS
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],
on: 
off: 
nextLevel: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][If (level <= 100),[(level = (java.lang.Integer -> java.lang.Integer) java.lang.Math.min((25 * (java.lang.Math.round((level / 25)) + 1)), 100))],[(level = 25)]],
setLevel: [(power = (java.lang.Math.round((percent / 1.175)) * 0.1))]
setSaturation: 
setHue: 
setColor: [If value.hue,,],[If value.saturation,,],[If value.hex,,],[If value.level,,],[If value.switch,,],
reset: 
setAdjustedColor: [If value,[(adjusted = (value + [:]))][(adjusted.hue = this.adjustOutgoingHue(value.hue))][(adjusted.level = null)],],
refresh: 
adjustOutgoingHue: [(adjusted = percent)][If (percent > 31),[If (percent < 63.0),[(adjusted = (percent + ((7 * (percent - 30)) / 32)))],[If (percent < 73.0),[(adjusted = (69 + ((5 * (percent - 62)) / 10)))],[(adjusted = (percent + ((2 * (100 - percent)) / 28)))]],],,],
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-lighting.metadata() is applicable for argument types: (tile-multiattribute-lighting$_run_closure1) values: [tile-multiattribute-lighting$_run_closure1@72035809]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing once-a-day.groovy
DECLARED METHODS
installed: 
updated: 
startTimerCallback: 
stopTimerCallback: 
Starting Points: []
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
Methods below
installed
updated
starttimercallback
stoptimercallback
called cap-methods by app
off
on
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing on-off-shield.groovy
DECLARED METHODS
parse: [(value = zigbee.parse(description)?.text)][(name = ((value in [on, off])) ? switch : null)][(result = this.createEvent([name:name, value:value]))]
on: 
off: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: on-off-shield.metadata() is applicable for argument types: (on-off-shield$_run_closure1) values: [on-off-shield$_run_closure1@1750fbeb]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-lock.groovy
DECLARED METHODS
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],
installed: 
updated: 
initialize: 
processPreferences: [(strBatteryLevel = $prefBatteryLevel)][(batteryLevel = (strBatteryLevel.isInteger()) ? strBatteryLevel.toInteger() : null)][If batteryLevel,,],[If prefJamNextOperation,,],[If prefJamImmediately,,],
refresh: 
ping: 
lock: [If (device.currentValue(doesNextOperationJam) == true),,],
unlock: [If (device.currentValue(doesNextOperationJam) == true),,],
jam: [If (device.currentValue(doesNextOperationJam) == true),,],
setJamNextOperation: 
clearJamNextOperation: 
setBatteryLevel: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-lock.metadata() is applicable for argument types: (simulated-lock$_run_closure1) values: [simulated-lock$_run_closure1@6be968ce]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-rgb-bulb.groovy
DECLARED METHODS
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],
installed: 
updated: 
ping: 
refresh: [(currentMode = device.currentValue(bulbMode))][If MODE.containsValue(currentMode),,],
configure: 
on: [this.simulateBulbState(state.lastMode)]
off: 
setLevel: [(boundedPercent = this.boundInt(levelPercent, PERCENT_RANGE))][(effectiveMode = device.currentValue(bulbMode))][If (boundedPercent > 0),,[(effectiveMode = MODE.OFF)]],
setSaturation: [(currentHue = device.currentValue(hue))]
setHue: [(currentSaturation = device.currentValue(saturation))]
setColor: [(boundedHue = this.boundInt(huePercent, PERCENT_RANGE))][(boundedSaturation = this.boundInt(saturationPercent, PERCENT_RANGE))][(logMsg = Executing 'setColor' from separate values hue: $boundedHue, saturation: $boundedSaturation)][If ((huePercent != boundedHue) || (saturationPercent != boundedSaturation)),[(logMsg +=  (pre-bounded values hue: $huePercent, saturation: $saturationPercent))],],[(colorHSMap = this.buildColorHSMap(hue, saturation))]
setColor: [If (hex == #000000),,[(hsvList = colorUtil.hexToHsv(hex))][(colorHSMap = this.buildColorHSMap(hsvList[0], hsvList[1]))]],
setColor: 
initialize: [(state.lastMode = MODE.COLOR)]
implicitOn: [If (device.currentValue(switch) != on),,],
turnOn: 
turnOff: 
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
buildColorHSMap: [(colorHSMap = [hue:0, saturation:0])]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
simulateBulbState: [(valueText = ---)][(hexColor = BLACK.rgb)][(colorIndicator = 0)]
flattenHueSat: [(flatHueSat = 0)][If (HUE_RANGE.contains(hue) && SAT_RANGE.contains(sat)),[(scaledHue = (hue * HUE_SCALE))][(flatHueSat = ((scaledHue + sat) + COLOR_OFFSET))],],
restoreHueSat: [(flatHueSat -= COLOR_OFFSET)][(sat = (flatHueSat % HUE_SCALE))][(hue = flatHueSat.intdiv(HUE_SCALE))]
done: 
boundInt: [(value = java.lang.Math.max(theRange.getFrom(), value))][(value = java.lang.Math.min(theRange.getTo(), value))]
Starting Points: []
IT HAS STATE
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-rgb-bulb.metadata() is applicable for argument types: (simulated-rgb-bulb$_run_closure1) values: [simulated-rgb-bulb$_run_closure1@4e5ed836]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing unknown.groovy
DECLARED METHODS
parse: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: unknown.metadata() is applicable for argument types: (unknown$_run_closure1) values: [unknown$_run_closure1@5b38c1ec]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing obything-music-connect.groovy
DECLARED METHODS
installed: 
updated: 
initialize: [(parts = theAddr.split(:))][(iphex = this.convertIPtoHex(parts[0]))][(porthex = this.convertPortToHex(parts[1]))][(dni = $iphex:$porthex)][(hubNames = location.hubs*?.name.findAll({ -> ... }))][(d = this.addChildDevice(com.obycode, ObyThing Music, dni, theHub.id, [label:$app.label, name:ObyThing]))]
convertIPtoHex: [(hex = ipAddress.tokenize(.).collect({ -> ... }).join())]
convertPortToHex: [(hexport = port.toString().format(%04X, port.toInteger()))]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
--app-start--
processing tile-multiattribute-generic.groovy
DECLARED METHODS
installed: 
parse: 
on: 
off: 
setLevel: 
randomizeLevel: [(level = java.lang.Math.round((java.lang.Math.random() * 100)))]
levelUp: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][If (level < 100),[(level = (level + 1))],],
levelDown: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][If (level > 0),[(level = (level - 1))],],
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-generic.metadata() is applicable for argument types: (tile-multiattribute-generic$_run_closure1) values: [tile-multiattribute-generic$_run_closure1@7a6d7e92]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing switch-activates-home-phrase-or-mode.groovy
DECLARED METHODS
getPref: 
installed: [this.subscribe(controlSwitch, switch, switchHandler)]
updated: [this.unsubscribe()][this.subscribe(controlSwitch, switch, switchHandler)]
switchHandler: [If ((evt.value == on) && (phrase_on || onMode)),[If phrase_on,,],[If onMode,,],,[If ((evt.value == off) && (phrase_off || offMode)),[If phrase_off,,],[If offMode,,],,],],
changeMode: [If (location.mode != newMode),[If location.modes?.find({ -> ... }),,],,],
textAppName: [(text = Switch Activates Home Phrase or Mode)]
textVersion: [(text = Version 1.0.1 (06/20/2015))]
textCopyright: [(text = Copyright © 2015 Michael Struck)]
textLicense: [(text = ((((((((((Licensed under the Apache License, Version 2.0 (the 'License');  + you may not use this file except in compliance with the License. ) + You may obtain a copy of the License at) + 

) +     http://www.apache.org/licenses/LICENSE-2.0) + 

) + Unless required by applicable law or agreed to in writing, software ) + distributed under the License is distributed on an 'AS IS' BASIS, ) + WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ) + See the License for the specific language governing permissions and ) + limitations under the License.))]
textHelp: [(text = ((Ties a Hello, Home phrase or mode to a switch's (virtual or real) on/off state. Perfect for use with IFTTT.  + Simple define a switch to be used, then tie the on/off state of the switch to a specific Hello, Home phrases or mode. ) + Connect the switch to an IFTTT action, and the Hello, Home phrase or mode will fire with the switch state change.))]
Starting Points: []
IT HAS STATE
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
Methods below
getpref
installed
updated
switchhandler
changemode
textappname
textversion
textcopyright
textlicense
texthelp
called cap-methods by app
called cap-props by app
switch
attribute uses through subscriptions
switch
cmd overpriv:[off, on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing zigbee-white-color-temperature-bulb.groovy
DECLARED METHODS
getMOVE_TO_COLOR_TEMPERATURE_COMMAND: 
getCOLOR_CONTROL_CLUSTER: 
getATTRIBUTE_COLOR_TEMPERATURE: 
parse: [(event = zigbee.getEvent(description))][If event,[If ((event.name == level) && (event.value == 0)),,[If (event.name == colorTemperature),,],],,[(cluster = zigbee.parse(description))][If ((cluster && (cluster.clusterId == 6)) && (cluster.command == 7)),[If (cluster.data[0] == 0),,],,],],
off: 
on: 
setLevel: 
ping: 
refresh: 
configure: 
setColorTemperature: [(value = (java.lang.Integer -> java.lang.Integer) value)][(tempInMired = java.lang.Math.round((1000000 / value)))][(finalHex = zigbee.swapEndianHex(zigbee.convertToHexString(tempInMired, 4)))][(cmds = [])][If ((device.getDataValue(manufacturer) == sengled) && (device.getDataValue(model) == Z01-A19NAE26)),,],
setGenericName: [If (value != null),[(genericName = White)][If (value < 3300),[(genericName = Soft White)],[If (value < 4150),[(genericName = Moonlight)],[If (value <= 5000),[(genericName = Cool White)],[If (value >= 5000),[(genericName = Daylight)],],],],],,],
installed: [If (((((device.getDataValue(manufacturer) == MRVL) && (device.getDataValue(model) == MZ100)) || (device.getDataValue(manufacturer) == OSRAM SYLVANIA)) || (device.getDataValue(manufacturer) == OSRAM)) || (device.getDataValue(manufacturer) == sengled)),[If ((device.currentState(level)?.value == null) || (device.currentState(level)?.value == 0)),,],,],
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: zigbee-white-color-temperature-bulb.metadata() is applicable for argument types: (zigbee-white-color-temperature-bulb$_run_closure1) values: [zigbee-white-color-temperature-bulb$_run_closure1@7eecb5b8]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing sylvania-ultra-iq.groovy
DECLARED METHODS
parse: [If description?.startsWith(catchall:),[(msg = zigbee.parse(description))],[(name = (description?.startsWith(on/off: )) ? switch : null)][(value = ((name == switch)) ? (description?.endsWith( 1)) ? on : off : null)][(result = this.createEvent([name:name, value:value]))]],
on: 
off: 
setLevel: [(cmds = [])][If (value == 0),,[If (device.latestValue(switch) == off),,],],[(level = this.hexString(java.lang.Math.round(((value * 255) / 100))))]
configure: 
hex: [(s = new java.math.BigInteger(java.lang.Math.round(value).toString()).toString(16))][While (s.size() < width),[(s = (0 + s))]]hex: [(s = new java.math.BigInteger(java.lang.Math.round(value).toString()).toString(16))][While (s.size() < width),[(s = (0 + s))]]
getEndpointId: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: sylvania-ultra-iq.metadata() is applicable for argument types: (sylvania-ultra-iq$_run_closure1) values: [sylvania-ultra-iq$_run_closure1@626abbd0]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing turn-on-only-if-i-arrive-after-sunset.groovy
DECLARED METHODS
installed: [this.subscribe(presence1, presence, presenceHandler)]
updated: [this.unsubscribe()][this.subscribe(presence1, presence, presenceHandler)]
presenceHandler: [(now = new java.util.Date())][(sunTime = this.getSunriseAndSunset())][(current = presence1.currentValue(presence))][(presenceValue = presence1.find({ -> ... }))][If (presenceValue && (now > sunTime.sunset)),,[If (presenceValue && (now < sunTime.sunset)),,],],
Starting Points: []
req caps: [capability.switch, capability.presencesensor]
req cap size: 2
requested commands:[off, on]
requested attrs:[presence, switch]
Methods below
installed
updated
presencehandler
called cap-methods by app
off
on
called cap-props by app
presence
attribute uses through subscriptions
presence
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing smartsense-garage-door-sensor-button.groovy
DECLARED METHODS
open: [If (device.currentValue(status) != open),,],
close: [If (device.currentValue(status) != closed),,],
parse: [(results = null)][If (this.isSupportedDescription(description) || description.startsWith(zone)),,[(results = this.parseMultiSensorMessage(description))]],
actuate: 
parseMultiSensorMessage: [(results = [])][If this.isAccelerationMessage(description),[(results = this.parseAccelerationMessage(description))],[If this.isContactMessage(description),[(results = this.parseContactMessage(description))],[If this.isRssiLqiMessage(description),[(results = this.parseRssiLqiMessage(description))],[If this.isOrientationMessage(description),[(results = this.parseOrientationMessage(description))],],],],],
parseAccelerationMessage: [(results = [])][(parts = description.split(,))]
parseContactMessage: [(results = [])][(parts = description.split(,))]
parseOrientationMessage: [(results = [])][(xyzResults = [x:0, y:0, z:0])][(parts = description.split(,))][(xyz = this.getXyzResult(xyzResults, description))][(a = xyz.value.split(,).collect({ -> ... }))][(absValueXY = java.lang.Math.max(java.lang.Math.abs(a[0]), java.lang.Math.abs(a[1])))][(absValueZ = java.lang.Math.abs(a[2]))][If ((absValueZ > 825) && (absValueXY < 175)),,[If ((absValueZ < 75) && (absValueXY > 825)),,],],
parseRssiLqiMessage: [(results = [])][(parts = description.split(,))]
getAccelerationResult: [(name = acceleration)][(value = (part.endsWith(1)) ? active : inactive)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]
getTempResult: [(name = temperature)][(temperatureScale = this.getTemperatureScale())][(value = zigbee.parseSmartThingsTemperatureValue(part, temp: , temperatureScale))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],[(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value°$temperatureScale)][(isStateChange = this.isTemperatureStateChange(device, name, value.toString()))]
getXyzResult: [(name = threeAxis)][(value = $results.x,$results.y,$results.z)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
getRssiResult: [(name = (lastHop) ? lastHopRssi : rssi)][(valueString = part.split(:)[1].trim())][(value = (java.lang.Integer.parseInt(valueString) - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]
getLqiResult: [(name = (lastHop) ? lastHopLqi : lqi)][(valueString = part.split(:)[1].trim())][(percentageOf = 255)][(value = java.lang.Math.round(((java.lang.Integer.parseInt(valueString) / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was: $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
isAccelerationMessage: [(description ==~ acceleration:.*rssi:.*lqi:.*)]
isContactMessage: [(description ==~ contactState:.*accelerationState:.*temp:.*battery:.*rssi:.*lqi:.*)]
isRssiLqiMessage: [(description ==~ lastHopRssi:.*lastHopLqi:.*rssi:.*lqi:.*)]
isOrientationMessage: [(description ==~ x:.*y:.*z:.*rssi:.*lqi:.*)]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-garage-door-sensor-button.metadata() is applicable for argument types: (smartsense-garage-door-sensor-button$_run_closure1) values: [smartsense-garage-door-sensor-button$_run_closure1@700fb871]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing plant-link.groovy
DECLARED METHODS
updated: 
parse: [(map = [:])][If description?.startsWith(read attr -),[(descMap = this.parseDescriptionAsMap(description))][If ((descMap.cluster == 0405) && (descMap.attrId == 0000)),[(map.name = humidity)][(map.value = this.calculateHumidity(descMap.value))],[If ((descMap.cluster == 0001) && (descMap.attrId == 0000)),[(map.name = battery)][(map.value = this.calculateBattery(descMap.value))],],],,],[(result = null)][If map,[(result = this.createEvent(map))],],
parseDescriptionAsMap: 
calculateHumidity: [(range = 576)][(percent = ((java.lang.Integer.parseInt(value, 16) / range) * 100))][(percent = java.lang.Math.max(0.0, java.lang.Math.min(percent, 100.0)))]
calculateBattery: [(min = 2300)][(percent = ((java.lang.Integer.parseInt(value, 16) - min) / 10))][(percent = java.lang.Math.max(0.0, java.lang.Math.min(percent, 100.0)))]
hex: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: plant-link.metadata() is applicable for argument types: (plant-link$_run_closure1) values: [plant-link$_run_closure1@7d322cad]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing particulate-detector.groovy
DECLARED METHODS
parse: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: particulate-detector.metadata() is applicable for argument types: (particulate-detector$_run_closure1) values: [particulate-detector$_run_closure1@20bd8be5]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartsense-multi.groovy
DECLARED METHODS
parse: [(results = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (this.isSupportedDescription(description) || description.startsWith(zone)),[(results = this.parseSingleMessage(description))],[If (description == updated),[(results = this.parseOtherMessage(description))],[(results = this.parseMultiSensorMessage(description))]],],
parseSingleMessage: [(name = this.parseName(description))][(value = this.parseValue(description))][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(handlerName = ((value == open)) ? opened : value)][(isStateChange = this.isStateChange(device, name, value))][(results = [])]
parseOtherMessage: [(name = null)][(value = description)][(linkText = this.getLinkText(device))][(descriptionText = description)][(handlerName = description)][(isStateChange = this.isStateChange(device, name, value))][(results = [name:name, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName, isStateChange:isStateChange, ... ])]
parseMultiSensorMessage: [(results = [])][If this.isAccelerationMessage(description),[(results = this.parseAccelerationMessage(description))],[If this.isContactMessage(description),[(results = this.parseContactMessage(description))],[If this.isRssiLqiMessage(description),[(results = this.parseRssiLqiMessage(description))],[If this.isOrientationMessage(description),[(results = this.parseOrientationMessage(description))],],],],],
parseAccelerationMessage: [(results = [])][(parts = description.split(,))]
parseContactMessage: [(results = [])][(parts = description.split(,))]
parseOrientationMessage: [(results = [])][(xyzResults = [x:0, y:0, z:0])][(parts = description.split(,))]
parseRssiLqiMessage: [(results = [])][(parts = description.split(,))]
getContactResult: [(name = contact)][(value = (part.endsWith(1)) ? open : closed)][(handlerName = ((value == open)) ? opened : value)][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $handlerName)][(isStateChange = this.isStateChange(device, name, value))][(results = [])]
getAccelerationResult: [(name = acceleration)][(value = (part.endsWith(1)) ? active : inactive)][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value)][(isStateChange = this.isStateChange(device, name, value))]
getTempResult: [(name = temperature)][(temperatureScale = this.getTemperatureScale())][(value = zigbee.parseSmartThingsTemperatureValue(part, temp: , temperatureScale))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],[(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value°$temperatureScale)][(isStateChange = this.isTemperatureStateChange(device, name, value.toString()))]
getXyzResult: [(name = threeAxis)][(value = $results.x,$results.y,$results.z)][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value)][(isStateChange = this.isStateChange(device, name, value))]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText Battery was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
getRssiResult: [(name = (lastHop) ? lastHopRssi : rssi)][(valueString = part.split(:)[1].trim())][(value = (java.lang.Integer.parseInt(valueString) - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value dBm)][If lastHop,[(descriptionText +=  on the last hop)],],[(isStateChange = this.isStateChange(device, name, value))]
getLqiResult: [(name = (lastHop) ? lastHopLqi : lqi)][(valueString = part.split(:)[1].trim())][(percentageOf = 255)][(value = java.lang.Math.round(((java.lang.Integer.parseInt(valueString) / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText Signal (LQI) was: $value$unit)][If lastHop,[(descriptionText +=  on the last hop)],],[(isStateChange = this.isStateChange(device, name, value))]
isAccelerationMessage: [(description ==~ acceleration:.*rssi:.*lqi:.*)]
isContactMessage: [(description ==~ contactState:.*accelerationState:.*temp:.*battery:.*rssi:.*lqi:.*)]
isRssiLqiMessage: [(description ==~ lastHopRssi:.*lastHopLqi:.*rssi:.*lqi:.*)]
isOrientationMessage: [(description ==~ x:.*y:.*z:.*rssi:.*lqi:.*)]
parseName: [If this.isSupportedDescription(description),,],
parseValue: [If this.isSupportedDescription(description),,],
parseDescriptionText: [If this.isSupportedDescription(description),,],[(value) ? $linkText was $((value == open)) ? opened : value : ]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-multi.metadata() is applicable for argument types: (smartsense-multi$_run_closure1) values: [smartsense-multi$_run_closure1@e3b3b2f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing undead-early-warning.groovy
DECLARED METHODS
installed: [this.subscribe(contacts, contact.open, contactOpenHandler)]
updated: [this.unsubscribe()][this.subscribe(contacts, contact.open, contactOpenHandler)]
contactOpenHandler: 
Starting Points: []
req caps: [capability.contactsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[contact, switch]
Methods below
installed
updated
contactopenhandler
called cap-methods by app
on
called cap-props by app
contact
attribute uses through subscriptions
contact
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing thing.groovy
DECLARED METHODS
parse: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: thing.metadata() is applicable for argument types: (thing$_run_closure1) values: [thing$_run_closure1@7fd7a283]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing virtual-thermostat.groovy
DECLARED METHODS
installed: [this.subscribe(sensor, temperature, temperatureHandler)][If motion,[this.subscribe(motion, motion, motionHandler)],],
updated: [this.unsubscribe()][this.subscribe(sensor, temperature, temperatureHandler)][If motion,[this.subscribe(motion, motion, motionHandler)],],
temperatureHandler: [(isActive = this.hasBeenRecentMotion())][If (isActive || emergencySetpoint),,],
motionHandler: [If (evt.value == active),[(lastTemp = sensor.currentTemperature)][If (lastTemp != null),,],,[If (evt.value == inactive),[(isActive = this.hasBeenRecentMotion())][If (isActive || emergencySetpoint),[(lastTemp = sensor.currentTemperature)][If (lastTemp != null),,],,],,],],
evaluate: [(threshold = 1.0)][If (mode == cool),[If ((currentTemp - desiredTemp) >= threshold),,[If ((desiredTemp - currentTemp) >= threshold),,],],,[If ((desiredTemp - currentTemp) >= threshold),,[If ((currentTemp - desiredTemp) >= threshold),,],],],
hasBeenRecentMotion: [(isActive = false)][If (motion && minutes),[(deltaMinutes = (java.lang.Long -> java.lang.Long) minutes)][If deltaMinutes,[(motionEvents = motion.eventsSince(new java.util.Date((this.now() - (60000 * deltaMinutes)))))][If motionEvents.find({ -> ... }),[(isActive = true)],],,],,[(isActive = true)]],
Starting Points: []
req caps: [capability.motionsensor, capability.temperaturemeasurement, capability.switch]
req cap size: 3
requested commands:[off, on]
requested attrs:[motion, temperature, switch]
Methods below
installed
updated
temperaturehandler
motionhandler
evaluate
hasbeenrecentmotion
called cap-methods by app
off
on
called cap-props by app
motion
temperature
switch
attribute uses through subscriptions
temperature
motion
switch
cmd overpriv:[]
attr overpriv:[]
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, ba155665-433d-4e20-9d12-efad7744c3d6]
[[capability.relativehumiditymeasurement]]
--app-start--
processing sleepy-time.groovy
DECLARED METHODS
selectPhrases: 
installed: [this.subscribe(jawbone, sleeping, jawboneHandler)]
updated: [this.unsubscribe()][this.subscribe(jawbone, sleeping, jawboneHandler)]
initialize: 
jawboneHandler: [If ((evt.value == sleeping) && sleepPhrase),,[If ((evt.value == not sleeping) && wakePhrase),,],],
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
--app-start--
processing on-off-button-tile.groovy
DECLARED METHODS
parse: 
on: 
off: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: on-off-button-tile.metadata() is applicable for argument types: (on-off-button-tile$_run_closure1) values: [on-off-button-tile$_run_closure1@2ca923bb]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing sprayer-controller-2.groovy
DECLARED METHODS
installed: [(startHour = startHour1)][(stopHour = stopHour1)][(startTime = minutes)][If (minutes == 1),[(startTime = ((((0 0  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 2),[(startTime = ((((0 0,30  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 3),[(startTime = ((((0 0,20,40  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 4),[(startTime = ((((0 0,15,30,45  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 5),[(startTime = ((((0 0,12,24,36,48  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 6),[(startTime = ((((0 0,10,20,30,40,50  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 12),[(startTime = ((((0 0,5,10,15,20,25,30,35,40,45,50,55  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 20),[(startTime = ((((0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 30),[(startTime = ((((0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58  + startHour) + -) + stopHour) +  * * ?))],[(startTime = ((((0 0  + startHour) + -) + stopHour) +  * * ?))]],],],],],],],],],[this.subscribe(valves1, switch.on, valveOnHandler, [filterEvents:false])]
updated: [this.unsubscribe()][(startHour = startHour1)][(stopHour = stopHour1)][(startTime = minutes)][If (minutes == 1),[(startTime = ((((0 0  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 2),[(startTime = ((((0 0,30  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 3),[(startTime = ((((0 0,20,40  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 4),[(startTime = ((((0 0,15,30,45  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 5),[(startTime = ((((0 0,12,24,36,48  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 6),[(startTime = ((((0 0,10,20,30,40,50  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 12),[(startTime = ((((0 0,5,10,15,20,25,30,35,40,45,50,55  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 20),[(startTime = ((((0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 30),[(startTime = ((((0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58  + startHour) + -) + stopHour) +  * * ?))],[(startTime = ((((0 0  + startHour) + -) + stopHour) +  * * ?))]],],],],],],],],],[this.subscribe(valves1, switch.on, valveOnHandler, [filterEvents:false])]
openValve: 
closeValve: 
valveOnHandler: [(delay = duration)]
setStartTime: [If (minutes == 1),[(startTime = 0 0 $startHour * * ?)],[If (minutes == 2),[(startTime = 0 0,30 $startHour * * ?)],[If (minutes == 3),[(startTime = 0 0,20,40 $startHour * * ?)],[If (minutes == 4),[(startTime = 0 0,15,30,45 $startHour * * ?)],[If (minutes == 5),[(startTime = 0 0,12,24,36,48 $startHour * * ?)],[If (minutes == 6),[(startTime = 0 0,10,20,30,40,50 $startHour * * ?)],[If (minutes == 12),[(startTime = 0 0,5,10,15,20,25,30,35,40,45,50,55 $startHour * * ?)],[If (minutes == 20),[(startTime = 0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57 $startHour * * ?)],[If (minutes == 30),[(startTime = 0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58 $startHour * * ?)],[(startTime = 0 0 $startHour * * ?)]],],],],],],],],],
Starting Points: []
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
Methods below
installed
updated
openvalve
closevalve
valveonhandler
setstarttime
called cap-methods by app
off
on
called cap-props by app
switch
attribute uses through subscriptions
switch
cmd overpriv:[]
attr overpriv:[]
--app-start--
processing smart-nightlight.groovy
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(motionSensor, motion, motionHandler)][If lightSensor,[this.subscribe(lightSensor, illuminance, illuminanceHandler, [filterEvents:false])],[this.subscribe(location, position, locationPositionChange)][this.subscribe(location, sunriseTime, sunriseSunsetTimeHandler)][this.subscribe(location, sunsetTime, sunriseSunsetTimeHandler)]],
locationPositionChange: 
sunriseSunsetTimeHandler: [(state.lastSunriseSunsetEvent = this.now())]
motionHandler: [If (evt.value == active),[If this.enabled(),[(state.lastStatus = on)],],[(state.motionStopTime = null)],[(state.motionStopTime = this.now())][If delayMinutes,,],],
illuminanceHandler: [(lastStatus = state.lastStatus)][If ((lastStatus != off) && (evt.integerValue > 50)),[(state.lastStatus = off)],[If state.motionStopTime,[If (lastStatus != off),[(elapsed = (this.now() - state.motionStopTime))][If (elapsed >= (((delayMinutes) ? delayMinutes : 0 * 60000) - 2000)),[(state.lastStatus = off)],],,],,[If ((lastStatus != on) && (evt.integerValue < 30)),[(state.lastStatus = on)],],],],
turnOffMotionAfterDelay: [log.trace(In turnOffMotionAfterDelay, state.motionStopTime = $state.motionStopTime, state.lastStatus = $state.lastStatus)][If (state.motionStopTime && (state.lastStatus != off)),[(elapsed = (this.now() - state.motionStopTime))][log.trace(elapsed = $elapsed)][If (elapsed >= (((delayMinutes) ? delayMinutes : 0 * 60000) - 2000)),[(state.lastStatus = off)],],,],
scheduleCheck: 
astroCheck: [(s = this.getSunriseAndSunset([zipCode:zipCode, sunriseOffset:sunriseOffset, sunsetOffset:sunsetOffset]))][(state.riseTime = s.sunrise.time)][(state.setTime = s.sunset.time)]
enabled: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If lightSensor,[(result = (lightSensor.currentIlluminance?.toInteger() < 30))],[(t = this.now())][(result = ((t < state.riseTime) || (t > state.setTime)))]],
getSunriseOffset: [(sunriseOffsetValue) ? ((sunriseOffsetDir == Before)) ? -$sunriseOffsetValue : sunriseOffsetValue : null]
getSunsetOffset: [(sunsetOffsetValue) ? ((sunsetOffsetDir == Before)) ? -$sunsetOffsetValue : sunsetOffsetValue : null]
Starting Points: []
IT HAS STATE
req caps: [capability.motionsensor, capability.illuminancemeasurement, capability.switch]
req cap size: 3
requested commands:[off, on]
requested attrs:[motion, illuminance, switch]
Methods below
installed
updated
initialize
locationpositionchange
sunrisesunsettimehandler
motionhandler
illuminancehandler
turnoffmotionafterdelay
schedulecheck
astrocheck
enabled
getsunriseoffset
getsunsetoffset
called cap-methods by app
off
on
called cap-props by app
motion
illuminance
attribute uses through subscriptions
motion
illuminance
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing quirky-wink-nimbus.groovy
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],
poll: 
refresh: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-nimbus.metadata() is applicable for argument types: (quirky-wink-nimbus$_run_closure1) values: [quirky-wink-nimbus$_run_closure1@102cec62]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-powerstrip.groovy
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],
on: 
off: 
poll: 
refresh: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-powerstrip.metadata() is applicable for argument types: (quirky-wink-powerstrip$_run_closure1) values: [quirky-wink-powerstrip$_run_closure1@15a04efb]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-slider.groovy
DECLARED METHODS
installed: 
parse: 
setLevel: 
setRangedLevel: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-slider.metadata() is applicable for argument types: (tile-basic-slider$_run_closure1) values: [tile-basic-slider$_run_closure1@6aa8e115]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing turn-it-on-when-it-opens.groovy
DECLARED METHODS
installed: [this.subscribe(contact1, contact.open, contactOpenHandler)]
updated: [this.unsubscribe()][this.subscribe(contact1, contact.open, contactOpenHandler)]
contactOpenHandler: 
Starting Points: []
req caps: [capability.contactsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[contact, switch]
Methods below
installed
updated
contactopenhandler
called cap-methods by app
on
called cap-props by app
contact
attribute uses through subscriptions
contact
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing simulated-refrigerator-temperature-control.groovy
DECLARED METHODS
installed: [this.sendEvent([name:temperature, value:((device.componentName == freezer)) ? 2 : 40])][this.sendEvent([name:coolingSetpoint, value:((device.componentName == freezer)) ? 2 : 40])]
updated: 
tempUp: [(value = (java.lang.Integer -> java.lang.Integer) device.currentValue(temperature))]
tempDown: [(value = (java.lang.Integer -> java.lang.Integer) device.currentValue(temperature))]
setpointUp: [(value = (java.lang.Integer -> java.lang.Integer) device.currentValue(coolingSetpoint))]
setpointDown: [(value = (java.lang.Integer -> java.lang.Integer) device.currentValue(coolingSetpoint))]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-refrigerator-temperature-control.metadata() is applicable for argument types: (simulated-refrigerator-temperature-control$_run_closure1) values: [simulated-refrigerator-temperature-control$_run_closure1@2e32ccc5]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-minimote.groovy
DECLARED METHODS
parse: 
push1: 
push2: 
push3: 
push4: 
hold1: 
hold2: 
hold3: 
hold4: 
push: 
hold: 
installed: 
updated: 
initialize: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-minimote.metadata() is applicable for argument types: (simulated-minimote$_run_closure1) values: [simulated-minimote$_run_closure1@4d518b32]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-spotter.groovy
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],
poll: 
refresh: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-spotter.metadata() is applicable for argument types: (quirky-wink-spotter$_run_closure1) values: [quirky-wink-spotter$_run_closure1@266374ef]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartweather-station-controller.groovy
DECLARED METHODS
installed: 
updated: 
initialize: 
scheduledEvent: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
--app-start--
processing wemo-bulb.groovy
DECLARED METHODS
parse: [If description?.startsWith(catchall:),[If description?.endsWith(0100),[(result = this.createEvent([name:switch, value:on]))],],[If description?.endsWith(0000),[(result = this.createEvent([name:switch, value:off]))],],,],[If description?.startsWith(read attr),[(i = java.lang.Math.round(((this.convertHexToInt(description[(-2..-1)]) / 256) * 100)))],],
on: 
off: 
refresh: 
setLevel: [(cmds = [])][If (value == 0),,[If (device.latestValue(switch) == off),,],],[(level = this.hexString(java.lang.Math.round(((value * 255) / 100))))]
configure: [(configCmds = [zcl global send-me-a-report 6 0 0x10 0 3600 {01}, delay 500, send 0x$device.deviceNetworkId 1 1, delay 1000, zcl global send-me-a-report 8 0 0x20 5 3600 {0010}, delay 200, send 0x$device.deviceNetworkId 1 1, delay 1500, zdo bind 0x$device.deviceNetworkId 1 1 6 {$device.zigbeeId} {}, delay 1000, zdo bind 0x$device.deviceNetworkId 1 1 8 {$device.zigbeeId} {}, delay 500])]
hex: [(s = new java.math.BigInteger(java.lang.Math.round(value).toString()).toString(16))][While (s.size() < width),[(s = (0 + s))]]hex: [(s = new java.math.BigInteger(java.lang.Math.round(value).toString()).toString(16))][While (s.size() < width),[(s = (0 + s))]]
convertHexToInt: 
swapEndianHex: 
reverseArray: [(i = 0)][(j = (array.length - 1))][(tmp = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While (j > i),[(tmp = array[j])][(array[j] = array[i])][(array[i] = tmp)]]reverseArray: [(i = 0)][(j = (array.length - 1))][(tmp = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While (j > i),[(tmp = array[j])][(array[j] = array[i])][(array[i] = tmp)]]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: wemo-bulb.metadata() is applicable for argument types: (wemo-bulb$_run_closure1) values: [wemo-bulb$_run_closure1@79c97cb]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing turn-it-on-for-5-minutes.groovy
DECLARED METHODS
installed: [this.subscribe(contact1, contact.open, contactOpenHandler)]
updated: [this.unsubscribe()][this.subscribe(contact1, contact.open, contactOpenHandler)]
contactOpenHandler: [(fiveMinuteDelay = (60 * 5))]
turnOffSwitch: 
Starting Points: []
req caps: [capability.contactsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[contact, switch]
Methods below
installed
updated
contactopenhandler
turnoffswitch
called cap-methods by app
off
on
called cap-props by app
contact
attribute uses through subscriptions
contact
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing smartpower-outlet-v1.groovy
DECLARED METHODS
parse: [If description?.startsWith(catchall: 0104 000A),,[(name = (description?.startsWith(on/off: )) ? switch : null)][(value = ((name == switch)) ? (description?.endsWith( 1)) ? on : off : null)][(result = this.createEvent([name:name, value:value]))]],
on: 
off: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: smartpower-outlet-v1.metadata() is applicable for argument types: (smartpower-outlet-v1$_run_closure1) values: [smartpower-outlet-v1$_run_closure1@14008db3]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-eggtray.groovy
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],
eggReport: 
poll: 
refresh: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-eggtray.metadata() is applicable for argument types: (quirky-wink-eggtray$_run_closure1) values: [quirky-wink-eggtray$_run_closure1@3e2059ae]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartsense-motion.groovy
DECLARED METHODS
parse: [(results = [:])][If (description.startsWith(zone) || this.isSupportedDescription(description)),[(results = this.parseBasicMessage(description))],[If this.isMotionStatusMessage(description),[(results = this.parseMotionStatusMessage(description))],],],
parseBasicMessage: [(name = this.parseName(description))][(results = [:])][If (name != null),[(value = this.parseValue(description))][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(handlerName = value)][(isStateChange = this.isStateChange(device, name, value))][(results = [name:name, value:value, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName, isStateChange:isStateChange, ... ])],],
parseName: [If this.isSupportedDescription(description),,],
parseValue: [(zs = zigbee.parseZoneStatus(description))][If zs,,],
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseDescriptionText: 
isMotionStatusMessage: [((description ==~ raw:.*dni:.*motion:.*battery:.*powerSource:.*rssi:.*lqi:.*) || (description ==~ raw:.*dni:.*motion:.*powerSource:.*battery:.*rssi:.*lqi:.*))]
parseMotionStatusMessage: [(results = [])][(parts = description.split(,))]
getMotionResult: [(name = motion)][(valueString = part.split(:)[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(value = ((valueInt == 0)) ? inactive : active)][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(isStateChange = this.isStateChange(device, name, value))]
getPowerSourceResult: [(name = powerSource)][(valueString = part.split(:)[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(value = ((valueInt == 0)) ? battery : powered)][(linkText = this.getLinkText(device))][(descriptionText = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (value == battery),[(descriptionText = $linkText is $value powered)],[(descriptionText = $linkText is plugged in)]],[(isStateChange = this.isStateChange(device, name, value))]
getBatteryResult: [(name = battery)][(valueString = part.split(:)[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][If (valueInt == 0),,],[(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText battery was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
getRssiResult: [(name = rssi)][(parts = part.split(:))][If (parts.size() != 2),,],[(valueString = parts[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(value = (valueInt - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]
getLqiResult: [(name = lqi)][(parts = part.split(:))][If (parts.size() != 2),,],[(valueString = parts[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(percentageOf = 255)][(value = java.lang.Math.round(((valueInt / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText Signal (LQI) was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-motion.metadata() is applicable for argument types: (smartsense-motion$_run_closure1) values: [smartsense-motion$_run_closure1@57576994]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tcp-bulb.groovy
DECLARED METHODS
parse: [(results = [])][If (description == updated),,],[If (description?.name && description?.value),,],
setBulbPower: [(state.bulbPower = value)]
on: [(levelSetting = ((java.lang.Float -> java.lang.Float) device.latestValue(level)) ? (java.lang.Float -> java.lang.Float) device.latestValue(level) : 1.0)][(bulbPowerMax = (java.lang.Float -> java.lang.Float) device.latestValue(setBulbPower))][(calculatedPower = (bulbPowerMax * (levelSetting / 100)))][If (device.latestValue(level) == null),,],
off: 
levelUp: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][(step = (float) state.stepsize)][(level += step)][If (level > 100),[(level = 100)],],
levelDown: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][(step = (float) state.stepsize)][(level -= step)][If (level < 1),[(level = 1)],],
setLevel: [(level = (java.lang.Integer -> java.lang.Integer) value)][If ((level > 0) && (level <= 100)),,],[(levelSetting = (float) level)][(bulbPowerMax = (float) device.latestValue(setBulbPower))][(calculatedPower = (bulbPowerMax * (levelSetting / 100)))]
poll: 
refresh: 
installed: 
updated: 
initialize: [If settings.stepsize,[(state.stepsize = 10)],[(state.stepsize = settings.stepsize)]],
uninstalled: 
Starting Points: []
IT HAS STATE
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: tcp-bulb.metadata() is applicable for argument types: (tcp-bulb$_run_closure1) values: [tcp-bulb$_run_closure1@1ae8bcbc]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartpower-outlet.groovy
DECLARED METHODS
parse: [(event = zigbee.getEvent(description))][If event,[If (event.name == power),[(value = ((java.lang.Integer -> java.lang.Integer) event.value / 10))][(event = this.createEvent([name:event.name, value:value, descriptionText:{{ device.displayName }} power is {{ value }} Watts, translatable:true]))],[If (event.name == switch),[(descriptionText = ((event.value == on)) ? {{ device.displayName }} is On : {{ device.displayName }} is Off)][(event = this.createEvent([name:event.name, value:event.value, descriptionText:descriptionText, translatable:true]))],],],,[(cluster = zigbee.parse(description))][If ((cluster && (cluster.clusterId == 6)) && (cluster.command == 7)),[If (cluster.data[0] == 0),[(event = this.createEvent([name:checkInterval, value:(60 * 12), displayed:false, data:[protocol:zigbee, hubHardwareId:device.hub.hardwareID]]))],[(event = null)]],,],],
off: 
on: 
ping: 
refresh: 
configure: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: smartpower-outlet.metadata() is applicable for argument types: (smartpower-outlet$_run_closure1) values: [smartpower-outlet$_run_closure1@2931522b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-thermostat.groovy
DECLARED METHODS
installed: 
configure: 
initialize: [(state.isHvacRunning = false)][(state.lastOperatingState = DEFAULT_OP_STATE)][(state.lastUserSetpointMode = DEFAULT_PREVIOUS_STATE)]
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],
ping: 
refresh: 
getThermostatMode: 
setThermostatMode: [If (value in SUPPORTED_MODES),[this.proposeSetpoints(this.getHeatingSetpoint(), this.getCoolingSetpoint(), state.lastUserSetpointMode)],],
cycleMode: [(nextMode = this.nextListElement(SUPPORTED_MODES, this.getThermostatMode()))]
isThermostatOff: [return (this.getThermostatMode() == MODE.OFF)]
getFanMode: 
setThermostatFanMode: [If (value in SUPPORTED_FAN_MODES),,],
cycleFanMode: [(nextMode = this.nextListElement(SUPPORTED_FAN_MODES, this.getFanMode()))]
no code yet for classclass org.codehaus.groovy.ast.stmt.ThrowStatement
no code yet for classclass org.codehaus.groovy.ast.stmt.ThrowStatement
nextListElement: [If (uniqueList != uniqueList.unique().asList()),,[If (currentElt in uniqueList),,],],[(listIdxMax = (uniqueList.size() - 1))][(currentEltIdx = uniqueList.indexOf(currentElt))][(nextEltIdx = ((currentEltIdx < listIdxMax)) ? (++currentEltIdx) : 0)][(nextElt = (java.lang.String -> java.lang.String) uniqueList[nextEltIdx])]
getOperatingState: [(operatingState = (device.currentValue(thermostatOperatingState)) ? device.currentValue(thermostatOperatingState) : OP_STATE.IDLE)]
setOperatingState: [If (operatingState in OP_STATE.values()),[If (operatingState != OP_STATE.IDLE),[(state.lastOperatingState = operatingState)],],,[log.warn('$operatingState' is not a supported operating state. Please set one of $OP_STATE.values().join(, ))]],
getThermostatSetpoint: [(ts = device.currentState(thermostatSetpoint))]
getHeatingSetpoint: [(hs = device.currentState(heatingSetpoint))]
setHeatingSetpoint: [(state.lastUserSetpointMode = SETPOINT_TYPE.HEATING)]
setHeatingSetpointInternal: 
heatUp: [(newHsp = (this.getHeatingSetpoint() + 1))][If (this.getThermostatMode() in (HEAT_ONLY_MODES + DUAL_SETPOINT_MODES)),,],
heatDown: [(newHsp = (this.getHeatingSetpoint() - 1))][If (this.getThermostatMode() in (HEAT_ONLY_MODES + DUAL_SETPOINT_MODES)),,],
getCoolingSetpoint: [(cs = device.currentState(coolingSetpoint))]
setCoolingSetpoint: [(state.lastUserSetpointMode = SETPOINT_TYPE.COOLING)]
setCoolingSetpointInternal: 
coolUp: [(newCsp = (this.getCoolingSetpoint() + 1))][If (this.getThermostatMode() in (COOL_ONLY_MODES + DUAL_SETPOINT_MODES)),,],
coolDown: [(newCsp = (this.getCoolingSetpoint() - 1))][If (this.getThermostatMode() in (COOL_ONLY_MODES + DUAL_SETPOINT_MODES)),,],
setpointUp: [(mode = this.getThermostatMode())][If (mode in COOL_ONLY_MODES),,[If (mode in (HEAT_ONLY_MODES + DUAL_SETPOINT_MODES)),,],],
setpointDown: [(mode = this.getThermostatMode())][If (mode in (COOL_ONLY_MODES + DUAL_SETPOINT_MODES)),,[If (mode in HEAT_ONLY_MODES),,],],
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
getTemperature: [(ts = device.currentState(temperature))][(currentTemp = DEFAULT_TEMPERATURE)]
setTemperature: 
tempUp: [(newTemp = (this.getTemperature()) ? (this.getTemperature() + 1) : DEFAULT_TEMPERATURE)]
tempDown: [(newTemp = (this.getTemperature()) ? (this.getTemperature() - 1) : DEFAULT_TEMPERATURE)]
setHumidityPercent: [(curHum = (java.lang.Integer -> java.lang.Integer) device.currentValue(humidity))][If (humidityValue != null),[(hum = this.boundInt(humidityValue, (0..100)))][If (hum != humidityValue),[(humidityValue = hum)],],,],
getHumidityPercent: [(hp = device.currentState(humidity))]
boundInt: [(value = java.lang.Math.max(theRange.getFrom(), java.lang.Math.min(theRange.getTo(), value)))]
proposeHeatSetpoint: 
proposeCoolSetpoint: 
proposeSetpoints: [(newHeatSetpoint = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(newCoolSetpoint = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(mode = this.getThermostatMode())][(proposedHeatSetpoint = (heatSetpoint) ? heatSetpoint : this.getHeatingSetpoint())][(proposedCoolSetpoint = (coolSetpoint) ? coolSetpoint : this.getCoolingSetpoint())][If (coolSetpoint == null),[(prioritySetpointType = SETPOINT_TYPE.HEATING)],[If (heatSetpoint == null),[(prioritySetpointType = SETPOINT_TYPE.COOLING)],[If (prioritySetpointType == null),[(prioritySetpointType = DEFAULT_SETPOINT_TYPE)],],],],[If (mode in HEAT_ONLY_MODES),[(newHeatSetpoint = this.boundInt(proposedHeatSetpoint, FULL_SETPOINT_RANGE))][If (newHeatSetpoint != proposedHeatSetpoint),,],,[If (mode in COOL_ONLY_MODES),[(newCoolSetpoint = this.boundInt(proposedCoolSetpoint, FULL_SETPOINT_RANGE))][If (newCoolSetpoint != proposedCoolSetpoint),,],,[If (mode in DUAL_SETPOINT_MODES),[If (prioritySetpointType == SETPOINT_TYPE.HEATING),[(newHeatSetpoint = this.boundInt(proposedHeatSetpoint, HEATING_SETPOINT_RANGE))][(customCoolingSetpointRange = ((newHeatSetpoint + AUTO_MODE_SETPOINT_SPREAD)..COOLING_SETPOINT_RANGE.getTo()))][(newCoolSetpoint = this.boundInt(proposedCoolSetpoint, customCoolingSetpointRange))],[If (prioritySetpointType == SETPOINT_TYPE.COOLING),[(newCoolSetpoint = this.boundInt(proposedCoolSetpoint, COOLING_SETPOINT_RANGE))][(customHeatingSetpointRange = (HEATING_SETPOINT_RANGE.getFrom()..(newCoolSetpoint - AUTO_MODE_SETPOINT_SPREAD)))][(newHeatSetpoint = this.boundInt(proposedHeatSetpoint, customHeatingSetpointRange))],],],,[If (mode == MODE.OFF),,],],],],[If (newHeatSetpoint != null),,],[If (newCoolSetpoint != null),,],
evaluateOperatingState: [(currentTemp = (overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value) ? overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value : (java.lang.Integer -> java.lang.Integer) this.getTemperature())][(heatingSetpoint = (overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value) ? overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value : (java.lang.Integer -> java.lang.Integer) this.getHeatingSetpoint())][(coolingSetpoint = (overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value) ? overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value : (java.lang.Integer -> java.lang.Integer) this.getCoolingSetpoint())][(tsMode = this.getThermostatMode())][(currentOperatingState = this.getOperatingState())][(isHeating = false)][(isCooling = false)][(isIdle = false)][If (tsMode in (HEAT_ONLY_MODES + DUAL_SETPOINT_MODES)),[If ((heatingSetpoint - currentTemp) >= THRESHOLD_DEGREES),[(isHeating = true)],],,],[If ((tsMode in (COOL_ONLY_MODES + DUAL_SETPOINT_MODES)) && isHeating),[If ((currentTemp - coolingSetpoint) >= THRESHOLD_DEGREES),[(isCooling = true)],],,],[If (isHeating || isCooling),,],
startSimHvac: [(operatingState = this.getOperatingState())][(isRunning = (state?.isHvacRunning) ? state?.isHvacRunning : false)][(shouldBeRunning = (operatingState in RUNNING_OP_STATES))][If (isRunning && shouldBeRunning),[(state.isHvacRunning = true)],[If isRunning,,[If shouldBeRunning,,],],],
runSimHvacCycle: [(operatingState = this.getOperatingState())][(currentTemp = this.getTemperature())][(heatSet = this.getHeatingSetpoint())][(coolSet = this.getCoolingSetpoint())][If ((operatingState == OP_STATE.HEATING) && ((heatSet - currentTemp) >= THRESHOLD_DEGREES)),,[If ((operatingState == OP_STATE.COOLING) && ((currentTemp - coolSet) >= THRESHOLD_DEGREES)),,[(state.isHvacRunning = false)]],],
done: 
Starting Points: []
IT HAS STATE
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-thermostat.metadata() is applicable for argument types: (simulated-thermostat$_run_closure1) values: [simulated-thermostat$_run_closure1@7b8b43c7]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smart-turn-it-on.groovy
DECLARED METHODS
installed: [If timeOne,,],
updated: [this.unsubscribe()][If timeOne,,],
turnOn: [(dayCheck = dayOne.contains(new java.util.Date().format(EEE)))][(dayTwo = new java.util.Date().format(EEE))][If dayCheck,[(presenceTwo = presenceOne.latestValue(presence).contains(present))][If presenceTwo,[(delay = (timeTwo * 60))],],,],
turnOff: 
Starting Points: []
req caps: [capability.switch, capability.presencesensor]
req cap size: 2
requested commands:[off, on]
requested attrs:[presence, switch]
Methods below
installed
updated
turnon
turnoff
called cap-methods by app
off
on
called cap-props by app
presence
attribute uses through subscriptions
presence
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing simulated-presence-sensor.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]
arrived: 
departed: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-presence-sensor.metadata() is applicable for argument types: (simulated-presence-sensor$_run_closure1) values: [simulated-presence-sensor$_run_closure1@5b67bb7e]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing three-axis-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: three-axis-capability.metadata() is applicable for argument types: (three-axis-capability$_run_closure1) values: [three-axis-capability$_run_closure1@455b6df1]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-water-sensor.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]
wet: 
dry: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-water-sensor.metadata() is applicable for argument types: (simulated-water-sensor$_run_closure1) values: [simulated-water-sensor$_run_closure1@63611043]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing switch-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]
on: 
off: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: switch-capability.metadata() is applicable for argument types: (switch-capability$_run_closure1) values: [switch-capability$_run_closure1@1e44b638]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing switch-level-capability.groovy
DECLARED METHODS
parse: [(pairs = description.split(,))][(result = [])]
on: 
off: 
setLevel: 
refresh: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: switch-level-capability.metadata() is applicable for argument types: (switch-level-capability$_run_closure1) values: [switch-level-capability$_run_closure1@42530531]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing turn-it-on-when-im-here.groovy
DECLARED METHODS
installed: [this.subscribe(presence1, presence, presenceHandler)]
updated: [this.unsubscribe()][this.subscribe(presence1, presence, presenceHandler)]
presenceHandler: [(current = presence1.currentValue(presence))][(presenceValue = presence1.find({ -> ... }))][If presenceValue,,],
Starting Points: []
req caps: [capability.switch, capability.presencesensor]
req cap size: 2
requested commands:[off, on]
requested attrs:[presence, switch]
Methods below
installed
updated
presencehandler
called cap-methods by app
off
on
called cap-props by app
presence
attribute uses through subscriptions
presence
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing tile-basic-presence.groovy
DECLARED METHODS
installed: 
parse: 
arrived: 
departed: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-presence.metadata() is applicable for argument types: (tile-basic-presence$_run_closure1) values: [tile-basic-presence$_run_closure1@1b75c2e3]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing thermostats.groovy
DECLARED METHODS
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [this.subscribe(smokeDevices, smoke.detected, eventHandler)][this.subscribe(smokeDevices, smoke.tested, eventHandler)][this.subscribe(smokeDevices, carbonMonoxide.detected, eventHandler)][this.subscribe(carbonMonoxideDevices, carbonMonoxide.detected, eventHandler)]
eventHandler: [If frequency,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],
sendMessage: [(msg = messageText)][(options = [:])][If messageText,[(msg = {{ triggerEvent.descriptionText }})][(options = [translatable:true, triggerEvent:evt])],],[If location.contactBookEnabled,,[If phone,[(options.phone = phone)][If (pushAndPhone != No),[(options.method = both)],[(options.method = phone)]],,[If (pushAndPhone != No),[(options.method = push)],[(options.method = none)]],],],[If frequency,[(state[evt.deviceId] = this.now())],],
Starting Points: []
req caps: [capability.smokedetector, capability.thermostat, capability.carbonmonoxidedetector]
req cap size: 3
requested commands:[heat, setheatingsetpoint, auto, cool, setcoolingsetpoint, fanon, setthermostatmode, emergencyheat, fancirculate, off, setthermostatfanmode, fanauto]
requested attrs:[coolingsetpoint, thermostatfanmode, thermostatmode, smoke, temperature, heatingsetpoint, thermostatoperatingstate, thermostatsetpoint, carbonmonoxide]
Methods below
installed
updated
subscribetoevents
eventhandler
sendmessage
called cap-methods by app
setthermostatmode
called cap-props by app
smoke
carbonmonoxide
attribute uses through subscriptions
smoke
carbonmonoxide
cmd overpriv:[heat, setheatingsetpoint, auto, cool, setcoolingsetpoint, fanon, emergencyheat, fancirculate, off, setthermostatfanmode, fanauto]
attr overpriv:[coolingsetpoint, thermostatfanmode, thermostatmode, temperature, heatingsetpoint, thermostatoperatingstate, thermostatsetpoint]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [26d69a34-ada2-42dc-9e45-445c78ae2619, 26d69a34-ada2-42dc-9e45-445c78ae2619, 8aa8a6b23f769c09013f769ed1c20012]
[[capability.battery, capability.polling]]
--app-start--
processing turn-off-with-motion.groovy
DECLARED METHODS
installed: [this.subscribe(motion1, motion, motionHandler)]
updated: [this.unsubscribe()][this.subscribe(motion1, motion, motionHandler)]
motionHandler: [If (evt.value == active),[(state.inactiveAt = null)],[If (evt.value == inactive),[If state.inactiveAt,[(state.inactiveAt = this.now())],],,],],
scheduleCheck: [If state.inactiveAt,[(elapsed = (this.now() - state.inactiveAt))][(threshold = ((1000 * 60) * minutes1))][If (elapsed >= threshold),[(state.inactiveAt = null)],],,],
Starting Points: []
IT HAS STATE
req caps: [capability.motionsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[motion, switch]
Methods below
installed
updated
motionhandler
schedulecheck
called cap-methods by app
off
on
called cap-props by app
motion
attribute uses through subscriptions
motion
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing water-sensor-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: water-sensor-capability.metadata() is applicable for argument types: (water-sensor-capability$_run_closure1) values: [water-sensor-capability$_run_closure1@5b6ec132]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-refrigerator-door.groovy
DECLARED METHODS
installed: 
open: 
close: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-refrigerator-door.metadata() is applicable for argument types: (simulated-refrigerator-door$_run_closure1) values: [simulated-refrigerator-door$_run_closure1@7a55af6b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-water-valve.groovy
DECLARED METHODS
installed: 
open: 
close: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-water-valve.metadata() is applicable for argument types: (simulated-water-valve$_run_closure1) values: [simulated-water-valve$_run_closure1@2f67b837]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-color-control.groovy
DECLARED METHODS
parse: 
setSaturation: 
setHue: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-color-control.metadata() is applicable for argument types: (simulated-color-control$_run_closure1) values: [simulated-color-control$_run_closure1@4ae9cfc1]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartsense-virtual-open-closed.groovy
DECLARED METHODS
parse: [(results = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (this.isSupportedDescription(description) || description.startsWith(zone)),,[(results = this.parseMultiSensorMessage(description))]],
parseMultiSensorMessage: [(results = [])][If this.isAccelerationMessage(description),[(results = this.parseAccelerationMessage(description))],[If this.isContactMessage(description),[(results = this.parseContactMessage(description))],[If this.isRssiLqiMessage(description),[(results = this.parseRssiLqiMessage(description))],[If this.isOrientationMessage(description),[(results = this.parseOrientationMessage(description))],],],],],
parseAccelerationMessage: [(results = [])][(parts = description.split(,))]
parseContactMessage: [(results = [])][(parts = description.split(,))]
parseOrientationMessage: [(results = [])][(xyzResults = [x:0, y:0, z:0])][(parts = description.split(,))][(xyz = this.getXyzResult(xyzResults, description))][(a = xyz.value.split(,).collect({ -> ... }))][(absValueXY = java.lang.Math.max(java.lang.Math.abs(a[0]), java.lang.Math.abs(a[1])))][(absValueZ = java.lang.Math.abs(a[2]))][If ((absValueZ > 825) && (absValueXY < 175)),,[If ((absValueZ < 75) && (absValueXY > 825)),,],],
parseRssiLqiMessage: [(results = [])][(parts = description.split(,))]
getAccelerationResult: [(name = acceleration)][(value = (part.endsWith(1)) ? active : inactive)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]
getTempResult: [(name = temperature)][(temperatureScale = this.getTemperatureScale())][(value = zigbee.parseSmartThingsTemperatureValue(part, temp: , temperatureScale))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],[(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value°$temperatureScale)][(isStateChange = this.isTemperatureStateChange(device, name, value.toString()))]
getXyzResult: [(name = threeAxis)][(value = $results.x,$results.y,$results.z)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
getRssiResult: [(name = (lastHop) ? lastHopRssi : rssi)][(valueString = part.split(:)[1].trim())][(value = (java.lang.Integer.parseInt(valueString) - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]
getLqiResult: [(name = (lastHop) ? lastHopLqi : lqi)][(valueString = part.split(:)[1].trim())][(percentageOf = 255)][(value = java.lang.Math.round(((java.lang.Integer.parseInt(valueString) / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was: $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
isAccelerationMessage: [(description ==~ acceleration:.*rssi:.*lqi:.*)]
isContactMessage: [(description ==~ contactState:.*accelerationState:.*temp:.*battery:.*rssi:.*lqi:.*)]
isRssiLqiMessage: [(description ==~ lastHopRssi:.*lastHopLqi:.*rssi:.*lqi:.*)]
isOrientationMessage: [(description ==~ x:.*y:.*z:.*rssi:.*lqi:.*)]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-virtual-open-closed.metadata() is applicable for argument types: (smartsense-virtual-open-closed$_run_closure1) values: [smartsense-virtual-open-closed$_run_closure1@3adcc812]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-contact-sensor.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]
open: 
close: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-contact-sensor.metadata() is applicable for argument types: (simulated-contact-sensor$_run_closure1) values: [simulated-contact-sensor$_run_closure1@4b23c30a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-switch.groovy
DECLARED METHODS
parse: 
on: 
off: 
onPhysical: 
offPhysical: 
getVersion: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-switch.metadata() is applicable for argument types: (simulated-switch$_run_closure1) values: [simulated-switch$_run_closure1@77128536]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing thermostat-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))][(map = this.createEvent([name:pair[0].trim(), value:pair[1].trim()]))][(result = [map])][If (map.isStateChange && (map.name in [heatingSetpoint, coolingSetpoint, thermostatMode])),[(map2 = [name:thermostatSetpoint, unit:F])][If (map.name == thermostatMode),[If (map.value == cool),[(map2.value = device.latestValue(coolingSetpoint))][log.info(THERMOSTAT, latest cooling setpoint = $map2.value)],[(map2.value = device.latestValue(heatingSetpoint))][log.info(THERMOSTAT, latest heating setpoint = $map2.value)]],,[(mode = device.latestValue(thermostatMode))][log.info(THERMOSTAT, latest mode = $mode)][If (((map.name == heatingSetpoint) && (mode == heat)) || ((map.name == coolingSetpoint) && (mode == cool))),[(map2.value = map.value)][(map2.unit = map.unit)],],],[If (map2.value != null),,],,],
setHeatingSetpoint: 
setCoolingSetpoint: 
setThermostatMode: 
setThermostatFanMode: 
off: 
heat: 
emergencyHeat: 
cool: 
fanOn: 
fanAuto: 
fanCirculate: 
poll: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: thermostat-capability.metadata() is applicable for argument types: (thermostat-capability$_run_closure1) values: [thermostat-capability$_run_closure1@41e68d87]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-garage-door-opener.groovy
DECLARED METHODS
parse: 
open: 
close: 
finishOpening: 
finishClosing: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-garage-door-opener.metadata() is applicable for argument types: (simulated-garage-door-opener$_run_closure1) values: [simulated-garage-door-opener$_run_closure1@d62fe5b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartsense-garage-door-multi.groovy
DECLARED METHODS
parse: [(results = [:])][If (this.isSupportedDescription(description) || description.startsWith(zone)),,[(results = this.parseMultiSensorMessage(description))]],
updated: [(threeAxis = device.currentState(threeAxis))][If threeAxis,[(xyz = threeAxis.xyzValue)][(value = ((java.lang.Math.round(xyz.z) > 925)) ? open : closed)],],
actuate: 
parseMultiSensorMessage: [(results = [])][If this.isAccelerationMessage(description),[(results = this.parseAccelerationMessage(description))],[If this.isContactMessage(description),[(results = this.parseContactMessage(description))],[If this.isRssiLqiMessage(description),[(results = this.parseRssiLqiMessage(description))],[If this.isOrientationMessage(description),[(results = this.parseOrientationMessage(description))],],],],],
parseAccelerationMessage: [(results = [])][(parts = description.split(,))]
parseContactMessage: [(results = [])][(parts = description.split(,))]
parseOrientationMessage: [(results = [])][(xyzResults = [x:0, y:0, z:0])][(parts = description.split(,))][(xyz = this.getXyzResult(xyzResults, description))][(a = xyz.value.split(,).collect({ -> ... }))][(absValueXY = java.lang.Math.max(java.lang.Math.abs(a[0]), java.lang.Math.abs(a[1])))][(absValueZ = java.lang.Math.abs(a[2]))][If ((absValueZ > 825) && (absValueXY < 175)),,[If ((absValueZ < 75) && (absValueXY > 825)),,],],
parseRssiLqiMessage: [(results = [])][(parts = description.split(,))]
getAccelerationResult: [(name = acceleration)][(value = (part.endsWith(1)) ? active : inactive)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]
getTempResult: [(name = temperature)][(temperatureScale = this.getTemperatureScale())][(value = zigbee.parseSmartThingsTemperatureValue(part, temp: , temperatureScale))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],[(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value°$temperatureScale)][(isStateChange = this.isTemperatureStateChange(device, name, value.toString()))]
getXyzResult: [(name = threeAxis)][(value = $results.x,$results.y,$results.z)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
getRssiResult: [(name = (lastHop) ? lastHopRssi : rssi)][(valueString = part.split(:)[1].trim())][(value = (java.lang.Integer.parseInt(valueString) - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]
getLqiResult: [(name = (lastHop) ? lastHopLqi : lqi)][(valueString = part.split(:)[1].trim())][(percentageOf = 255)][(value = java.lang.Math.round(((java.lang.Integer.parseInt(valueString) / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was: $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
isAccelerationMessage: [(description ==~ acceleration:.*rssi:.*lqi:.*)]
isContactMessage: [(description ==~ contactState:.*accelerationState:.*temp:.*battery:.*rssi:.*lqi:.*)]
isRssiLqiMessage: [(description ==~ lastHopRssi:.*lastHopLqi:.*rssi:.*lqi:.*)]
isOrientationMessage: [(description ==~ x:.*y:.*z:.*rssi:.*lqi:.*)]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-garage-door-multi.metadata() is applicable for argument types: (smartsense-garage-door-multi$_run_closure1) values: [smartsense-garage-door-multi$_run_closure1@6f63b475]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing zigbee-switch.groovy
DECLARED METHODS
parse: [(event = zigbee.getEvent(description))][If event,,],
off: 
on: 
ping: 
refresh: 
configure: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: zigbee-switch.metadata() is applicable for argument types: (zigbee-switch$_run_closure1) values: [zigbee-switch$_run_closure1@53941c2f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing switch-activates-home-phrase.groovy
DECLARED METHODS
getPref: 
installed: [this.subscribe(controlSwitch, switch, switchHandler)]
updated: [this.unsubscribe()][this.subscribe(controlSwitch, switch, switchHandler)]
switchHandler: [If (evt.value == on),,],
Starting Points: []
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
Methods below
getpref
installed
updated
switchhandler
called cap-methods by app
called cap-props by app
switch
attribute uses through subscriptions
switch
cmd overpriv:[off, on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing simulated-motion-sensor.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]
active: 
inactive: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-motion-sensor.metadata() is applicable for argument types: (simulated-motion-sensor$_run_closure1) values: [simulated-motion-sensor$_run_closure1@4ed5eb72]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-colorwheel.groovy
DECLARED METHODS
parse: 
setColor: [If value.hex,,],[If value.hue,,],[If value.saturation,,],
setSaturation: 
setHue: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-colorwheel.metadata() is applicable for argument types: (tile-basic-colorwheel$_run_closure1) values: [tile-basic-colorwheel$_run_closure1@19835e64]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-value.groovy
DECLARED METHODS
installed: 
parse: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-value.metadata() is applicable for argument types: (tile-basic-value$_run_closure1) values: [tile-basic-value$_run_closure1@535779e4]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartblock-chat-sender.groovy
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(location, modeChangeHandler)]
modeChangeHandler: [(newMode = evt.value)][If (modes && modes.contains(newMode)),[(message = (customMessage) ? customMessage : SmartThings mode has changed to: "$newMode")],],
chatMessageToMC: [(parent = app.getParent())][(url = $parent.getServerURL()/chat?message=$message.encodeAsURL())][If username,[(url += &username=$username.encodeAsURL())],],[this.httpPost(url, foo=bar, { java.lang.Object response -> ... })]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
--app-start--
processing tile-basic-carousel.groovy
DECLARED METHODS
installed: 
parse: 
evaluate: [(threshold = 1.0)][(current = device.currentValue(thermostatOperatingState))][(mode = device.currentValue(thermostatMode))][(heating = false)][(cooling = false)][(idle = false)][If (mode in [heat, emergency heat, auto]),[If ((heatingSetpoint - temp) >= threshold),[(heating = true)],[If ((temp - heatingSetpoint) >= threshold),[(idle = true)],],],,],[If (mode in [cool, auto]),[If ((temp - coolingSetpoint) >= threshold),[(cooling = true)],[If (((coolingSetpoint - temp) >= threshold) && heating),[(idle = true)],],],,],[If ((idle && heating) && cooling),,],
setHeatingSetpoint: 
setCoolingSetpoint: 
setThermostatMode: 
setThermostatFanMode: 
off: 
heat: 
auto: 
emergencyHeat: 
cool: 
fanOn: 
fanAuto: 
fanCirculate: 
tempUp: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue + 1) : 72)]
tempDown: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue - 1) : 72)]
setTemperature: [(ts = device.currentState(temperature))]
heatUp: [(ts = device.currentState(heatingSetpoint))][(value = (ts) ? (ts.integerValue + 1) : 68)]
heatDown: [(ts = device.currentState(heatingSetpoint))][(value = (ts) ? (ts.integerValue - 1) : 68)]
coolUp: [(ts = device.currentState(coolingSetpoint))][(value = (ts) ? (ts.integerValue + 1) : 76)]
coolDown: [(ts = device.currentState(coolingSetpoint))][(value = (ts) ? (ts.integerValue - 1) : 76)]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-carousel.metadata() is applicable for argument types: (tile-basic-carousel$_run_closure1) values: [tile-basic-carousel$_run_closure1@dbd8e44]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-standard.groovy
DECLARED METHODS
installed: 
parse: 
on: 
off: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-standard.metadata() is applicable for argument types: (tile-basic-standard$_run_closure1) values: [tile-basic-standard$_run_closure1@6e950bcf]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smart-light-timer-x-minutes-unless-already-on.groovy
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(switches, switch, switchChange)][this.subscribe(motions, motion, motionHandler)][this.subscribe(contacts, contact, contactHandler)][(state.myState = ready)]
switchChange: [If (evt.value == on),[If (state.myState == activating),[(state.myState = active)],[If (state.myState != active),[(state.myState = already on)],],],,[If ((state.myState == active) || (state.myState == activating)),,],[(state.myState = ready)]],
contactHandler: [If (evt.value == open),[If (state.myState == ready),[(state.inactiveAt = null)][(state.myState = activating)],],,[If (evt.value == closed),[If ((state.inactiveAt && (state.myState == active)) || (state.myState == activating)),,],,],],
motionHandler: [If (evt.value == active),[If (((state.myState == ready) || (state.myState == active)) || (state.myState == activating)),[(state.inactiveAt = null)][(state.myState = activating)],],,[If (evt.value == inactive),[If ((state.inactiveAt && (state.myState == active)) || (state.myState == activating)),,],,],],
setActiveAndSchedule: [(state.myState = active)][(state.inactiveAt = this.now())]
scheduleCheck: [If (state.myState != already on),[If (state.inactiveAt != null),[(elapsed = (this.now() - state.inactiveAt))][(threshold = ((1000 * 60) * minutes1))][If (elapsed >= threshold),[If (state.myState == active),,],[(state.inactiveAt = null)][(state.myState = ready)],],,],,],
Starting Points: []
IT HAS STATE
req caps: [capability.motionsensor, capability.contactsensor, capability.switch]
req cap size: 3
requested commands:[off, on]
requested attrs:[motion, contact, switch]
Methods below
installed
updated
initialize
switchchange
contacthandler
motionhandler
setactiveandschedule
schedulecheck
called cap-methods by app
off
on
called cap-props by app
motion
contact
switch
attribute uses through subscriptions
motion
switch
contact
cmd overpriv:[]
attr overpriv:[]
--app-start--
processing simulated-smoke-alarm.groovy
DECLARED METHODS
parse: 
smoke: 
test: 
clear: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-smoke-alarm.metadata() is applicable for argument types: (simulated-smoke-alarm$_run_closure1) values: [simulated-smoke-alarm$_run_closure1@691939c9]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing whole-house-fan.groovy
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [(state.fanRunning = false)][this.subscribe(outTemp, temperature, checkThings)][this.subscribe(inTemp, temperature, checkThings)][this.subscribe(thermostat, thermostatMode, checkThings)][this.subscribe(contacts, contact, checkThings)]
checkThings: [(outsideTemp = settings.outTemp.currentTemperature)][(insideTemp = settings.inTemp.currentTemperature)][(thermostatMode = settings.thermostat.currentThermostatMode)][(somethingOpen = ((settings.checkContacts == No) || settings.contacts?.find({ -> ... })))][(shouldRun = true)][If (thermostatMode != off),[(shouldRun = false)],],[If (insideTemp < outsideTemp),[(shouldRun = false)],],[If (insideTemp < settings.minTemp),[(shouldRun = false)],],[If somethingOpen,[(shouldRun = false)],],[If (shouldRun && state.fanRunning),[(state.fanRunning = true)],[If (shouldRun && state.fanRunning),[(state.fanRunning = false)],],],
Starting Points: []
IT HAS STATE
req caps: [capability.contactsensor, capability.switch, capability.temperaturemeasurement, capability.thermostat]
req cap size: 4
requested commands:[heat, setheatingsetpoint, auto, cool, setthermostatmode, off, setcoolingsetpoint, fanon, emergencyheat, fancirculate, setthermostatfanmode, on, fanauto]
requested attrs:[coolingsetpoint, thermostatfanmode, thermostatmode, contact, temperature, heatingsetpoint, thermostatoperatingstate, thermostatsetpoint, switch]
Methods below
installed
updated
initialize
checkthings
called cap-methods by app
off
on
called cap-props by app
temperature
thermostatmode
contact
attribute uses through subscriptions
temperature
thermostatmode
contact
cmd overpriv:[heat, setheatingsetpoint, auto, cool, setthermostatmode, setcoolingsetpoint, fanon, emergencyheat, fancirculate, setthermostatfanmode, fanauto]
attr overpriv:[coolingsetpoint, thermostatfanmode, heatingsetpoint, thermostatoperatingstate, thermostatsetpoint, switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [266374ae-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, ba155665-433d-4e20-9d12-efad7744c3d6, 0e7aa867-9aec-4a24-a372-69014bfa8c24]
[[capability.relativehumiditymeasurement]]
--app-start--
processing smart-block.groovy
DECLARED METHODS
parse: 
on: 
off: 
setLevel: [(signal = this.convertLevelToSignal((int) newLevel))]
sendSignalToMC: [(url = http://$state.serverIp:3333/block?x=$state.x&y=$state.y&z=$state.z&name=level&value=$newSignal)][this.httpPost(url, foo=bar, { java.lang.Object response -> ... })]
sendSwitchStateToMC: [(url = http://$state.serverIp:3333/block?x=$state.x&y=$state.y&z=$state.z&name=switch&value=$switchState)][this.httpPost(url, foo=bar, { java.lang.Object response -> ... })]
setCoordinates: [(state.x = x)][(state.y = y)][(state.z = z)]
getCoordinates: 
getCoordinate: [If [x, y, z].contains(axis),,],[return state.$axis]
isDestroyed: [state.destroyed]
setDestroyed: [(state.destroyed = isDestroyed)]
setWorldSeed: [(state.worldSeed = worldSeed)]
setDimensionName: [(state.dimensionName = dimensionName)]
setPlacedBy: [(state.placedBy = placedBy)]
setClosestPlayer: [(state.closestPlayer = closestPlayer)][(state.closestPlayerChanged = new java.util.Date())]
setSignalStrength: [(state.signalStrength = signalStrength)]
setLastNeighborChanged: [(state.neighborBlockId = blockId)][(state.neighborBlockName = blockName)]
setServerIp: [If ip,,],[(ip = ip.replace(https://, ))][(ip = ip.replace(http://, ))][(serverParts = ip.split(:))][If (serverParts.size() > 1),[(state.serverPort = serverParts[1])],],[If (serverParts.size() > 0),[(state.serverIp = serverParts[0])],],[If state.serverIp,[(state.blockServer = state.serverIp)],],[If state.serverPort,[(state.blockServer = $state.blockServer:$state.serverPort)],],[this.sendEvent([name:blockServer, value:$state.blockServer])]
calculateDNI: [$state.worldSeed|$state.dimensionName|$this.getCoordinates().encodeAsMD5()]
neighborBlockChange: [If data?.closestPlayer,,],[(signalStrength = (int) data?.signalStrength)][If data?.worldSeed,,],[If data?.dimensionName,,],[If data?.placedBy,,],
convertLevelToSignal: [If (level <= 0),,],[If (level >= 99),,],[(signal = (15 - ((99 - level) / 7)))]
convertSignalToLevel: [If (signal <= 0),,],[If (signal >= 15),,],[(level = (99 - ((15 - signal) * 7)))]
Starting Points: []
IT HAS STATE
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: smart-block.metadata() is applicable for argument types: (smart-block$_run_closure1) values: [smart-block$_run_closure1@32f232a5]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing temperature-sensor.groovy
DECLARED METHODS
parse: [(name = this.parseName(description))][(value = this.parseValue(description))][(unit = ((name == temperature)) ? this.getTemperatureScale() : ((name == humidity)) ? % : null)][(result = this.createEvent([name:name, value:value, unit:unit]))]
parseName: [If description?.startsWith(temperature: ),,[If description?.startsWith(humidity: ),,],],
parseValue: [If description?.startsWith(temperature: ),,[If description?.startsWith(humidity: ),[(pct = ((description - humidity: ) - %).trim())][If pct.isNumber(),,],,],],
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: temperature-sensor.metadata() is applicable for argument types: (temperature-sensor$_run_closure1) values: [temperature-sensor$_run_closure1@146587a2]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smart-home-ventilation.groovy
DECLARED METHODS
mainPage: 
installed: 
updated: [this.unsubscribe()]
init: [(midnightTime = this.timeToday(2000-01-01T00:01:00.999-0000, location.timeZone))][this.subscribe(location, mode, locationHandler)]
startProcess: [(state.dayCount = state.data.size())][If state.dayCount,[(state.counter = 0)],],
startDay: [(start = this.convertEpoch(state.data[state.counter].start))][(stop = this.convertEpoch(state.data[state.counter].stop))]
incDay: [If state.modeChange,,[(state.counter = (state.counter + 1))][If (state.counter < state.dayCount),,],],
locationHandler: [(result = false)][(state.modeChange = true)][If result,,],
midNight: 
turnOnSwitch: 
turnOffSwitch: 
schedDesc: [(title = )][(dayListClean = On )][(modeListClean = Scenario runs in )][If (dayList && (dayList.size() < 7)),[(dayListSize = dayList.size())][For dayList,[(dayListClean = ($dayListClean + $dayName))][(dayListSize = (dayListSize - 1))][If dayListSize,[(dayListClean = $dayListClean, )],],][(dayListSize = dayList.size())][For dayList,[(dayListClean = ($dayListClean + $dayName))][(dayListSize = (dayListSize - 1))][If dayListSize,[(dayListClean = $dayListClean, )],],],[(dayListClean = Every day)]],[If modeList,[(modeListSize = modeList.size())][(modePrefix = modes)][If (modeListSize == 1),[(modePrefix = mode)],],[For modeList,[(modeListClean = ($modeListClean + '$modeName'))][(modeListSize = (modeListSize - 1))][If modeListSize,[(modeListClean = $modeListClean, )],[(modeListClean = $modeListClean $modePrefix)]],][(modeListSize = modeList.size())][(modePrefix = modes)][If (modeListSize == 1),[(modePrefix = mode)],],[For modeList,[(modeListClean = ($modeListClean + '$modeName'))][(modeListSize = (modeListSize - 1))][If modeListSize,[(modeListClean = $modeListClean, )],[(modeListClean = $modeListClean $modePrefix)]],],[(modeListClean = $modeListCleanall modes)]],[If (on1 && off1),[(title += Schedule 1: $this.humanReadableTime(on1) to $this.humanReadableTime(off1))],],[If (on2 && off2),[(title += 
Schedule 2: $this.humanReadableTime(on2) to $this.humanReadableTime(off2))],],[If (on3 && off3),[(title += 
Schedule 3: $this.humanReadableTime(on3) to $this.humanReadableTime(off3))],],[If (on4 && off4),[(title += 
Schedule 4: $this.humanReadableTime(on4) to $this.humanReadableTime(off4))],],[If (((on1 || on2) || on3) || on4),[(title += 
$modeListClean)][(title += 
$dayListClean)],],[If (((on1 && on2) && on3) && on4),[(title = Click to configure scenario)],],
greyOut: [(result = ((((on1 || on2) || on3) || on4)) ? complete : )]
humanReadableTime: 
convertEpoch: 
getTitle: [(title = (txt) ? txt : Scenario $scenario)]
daysOk: [(result = true)][If dayList,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = dayList.contains(day))],],
timeOk: [If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting).time)][(stop = this.timeToday(ending).time)][If (((start < stop) && (start >= currTime)) && (stop >= currTime)),[(state.data << [start:start, stop:stop])],],,],
createDayArray: [(state.modeChange = false)][(state.data = [])][If (modeA && modeA.contains(location.mode)),[If this.daysOk(daysA),,],,],[If (modeB && modeB.contains(location.mode)),[If this.daysOk(daysB),,],,],[If (modeC && modeC.contains(location.mode)),[If this.daysOk(daysC),,],,],[If (modeD && modeD.contains(location.mode)),[If this.daysOk(daysD),,],,],[state.data.sort({ -> ... })]
textAppName: [(text = Smart Home Ventilation)]
textVersion: [(text = Version 2.1.2 (05/31/2015))]
textCopyright: [(text = Copyright © 2015 Michael Struck)]
textLicense: [(text = ((((((((((Licensed under the Apache License, Version 2.0 (the 'License');  + you may not use this file except in compliance with the License. ) + You may obtain a copy of the License at) + 

) +     http://www.apache.org/licenses/LICENSE-2.0) + 

) + Unless required by applicable law or agreed to in writing, software ) + distributed under the License is distributed on an 'AS IS' BASIS, ) + WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ) + See the License for the specific language governing permissions and ) + limitations under the License.))]
textHelp: [(text = ((((Within each scenario, choose a start and end time for the ventilation fan. You can have up to 4 different  + venting scenarios, and 4 schedules within each scenario. Each scenario can be restricted to specific modes or certain days of the week. It is recommended ) + that each scenario does not overlap and run in separate modes (i.e. Home, Out of town, etc). Also note that you should  ) + avoid scheduling the ventilation fan at exactly midnight; the app resets itself at that time. It is suggested to start any new schedule ) + at 12:15 am or later.))]
Starting Points: []
IT HAS STATE
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
Methods below
mainpage
installed
updated
init
startprocess
startday
incday
locationhandler
midnight
turnonswitch
turnoffswitch
scheddesc
greyout
humanreadabletime
convertepoch
gettitle
daysok
timeok
createdayarray
textappname
textversion
textcopyright
textlicense
texthelp
called cap-methods by app
off
on
called cap-props by app
switch
attribute uses through subscriptions
switch
cmd overpriv:[]
attr overpriv:[]
--app-start--
processing tile-multiattribute-thermostat.groovy
DECLARED METHODS
installed: 
parse: 
evaluate: [(threshold = 1.0)][(current = device.currentValue(thermostatOperatingState))][(mode = device.currentValue(thermostatMode))][(heating = false)][(cooling = false)][(idle = false)][If (mode in [heat, emergency heat, auto]),[If ((heatingSetpoint - temp) >= threshold),[(heating = true)],[If ((temp - heatingSetpoint) >= threshold),[(idle = true)],],],,],[If (mode in [cool, auto]),[If ((temp - coolingSetpoint) >= threshold),[(cooling = true)],[If (((coolingSetpoint - temp) >= threshold) && heating),[(idle = true)],],],,],[If (mode == off),[(idle = true)],],[If ((idle && heating) && cooling),,],
setHeatingSetpoint: 
setCoolingSetpoint: 
setThermostatMode: 
setThermostatFanMode: 
off: 
heat: 
auto: 
emergencyHeat: 
cool: 
fanOn: 
fanAuto: 
fanCirculate: 
poll: 
tempUp: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue + 1) : 72)]
tempDown: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue - 1) : 72)]
setTemperature: [(ts = device.currentState(temperature))]
heatUp: [(ts = device.currentState(heatingSetpoint))][(value = (ts) ? (ts.integerValue + 1) : 68)]
heatDown: [(ts = device.currentState(heatingSetpoint))][(value = (ts) ? (ts.integerValue - 1) : 68)]
coolUp: [(ts = device.currentState(coolingSetpoint))][(value = (ts) ? (ts.integerValue + 1) : 76)]
coolDown: [(ts = device.currentState(coolingSetpoint))][(value = (ts) ? (ts.integerValue - 1) : 76)]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-thermostat.metadata() is applicable for argument types: (tile-multiattribute-thermostat$_run_closure1) values: [tile-multiattribute-thermostat$_run_closure1@37c7595]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing the-flasher.groovy
DECLARED METHODS
installed: [this.subscribe()]
updated: [this.unsubscribe()][this.subscribe()]
subscribe: [If contact,[this.subscribe(contact, contact.open, contactOpenHandler)],],[If acceleration,[this.subscribe(acceleration, acceleration.active, accelerationActiveHandler)],],[If motion,[this.subscribe(motion, motion.active, motionActiveHandler)],],[If mySwitch,[this.subscribe(mySwitch, switch.on, switchOnHandler)],],[If myPresence,[this.subscribe(myPresence, presence, presenceHandler)],],
motionActiveHandler: 
contactOpenHandler: 
accelerationActiveHandler: 
switchOnHandler: 
presenceHandler: [If (evt.value == present),,[If (evt.value == not present),,],],
flashLights: [(doFlash = true)][(onFor = (onFor) ? onFor : 1000)][(offFor = (offFor) ? offFor : 1000)][(numFlashes = (numFlashes) ? numFlashes : 3)][If state.lastActivated,[(elapsed = (this.now() - state.lastActivated))][(sequenceTime = ((numFlashes + 1) * (onFor + offFor)))][(doFlash = (elapsed > sequenceTime))],],[If doFlash,[(state.lastActivated = this.now())][(initialActionOn = switches.collect({ -> ... }))][(delay = 0)],],
Starting Points: []
IT HAS STATE
req caps: [capability.motionsensor, capability.contactsensor, capability.switch, capability.accelerationsensor, capability.presencesensor]
req cap size: 5
requested commands:[off, on]
requested attrs:[acceleration, motion, presence, contact, switch]
Methods below
installed
updated
subscribe
motionactivehandler
contactopenhandler
accelerationactivehandler
switchonhandler
presencehandler
flashlights
called cap-methods by app
off
on
called cap-props by app
acceleration
motion
presence
contact
switch
attribute uses through subscriptions
acceleration
motion
presence
contact
switch
cmd overpriv:[]
attr overpriv:[]
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 266374ae-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, f730b653-b0b6-483e-8c84-977e240f5eb3, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.polling, capability.refresh]]
--app-start--
processing power-allowance.groovy
DECLARED METHODS
installed: [this.subscribe(theSwitch, switch.on, switchOnHandler, [filterEvents:false])]
updated: [this.unsubscribe()][this.subscribe(theSwitch, switch.on, switchOnHandler, [filterEvents:false])]
switchOnHandler: [(delay = (minutesLater * 60))]
turnOffSwitch: 
Starting Points: []
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
Methods below
installed
updated
switchonhandler
turnoffswitch
called cap-methods by app
off
called cap-props by app
switch
attribute uses through subscriptions
switch
cmd overpriv:[on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing switch-child-device.groovy
DECLARED METHODS
on: 
off: 
refresh: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: switch-child-device.metadata() is applicable for argument types: (switch-child-device$_run_closure1) values: [switch-child-device$_run_closure1@1d3ac898]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartblock-linker.groovy
DECLARED METHODS
linkerPage: 
installed: 
updated: [this.unsubscribe()]
initialize: [If blockUpdatesSwitch,[this.subscribe(linkedSmartBlock, level, updateSwitchLevel)][this.subscribe(linkedSmartBlock, switch, updateSwitchState)],],[If switchUpdatesBlock,[this.subscribe(linkedSwitch, level, updateBlockLevel)][this.subscribe(linkedSwitch, switch, updateBlockState)],],
updateSwitchLevel: [(level = (int) evt.value)]
updateBlockLevel: [(level = (int) evt.value)]
updateSwitchState: 
updateBlockState: 
getBlockId: 
getLinkerDescription: [(left = (linkedSmartBlock) ? $(linkedSmartBlock.label) ? linkedSmartBlock.label : linkedSmartBlock.name : )][(right = (linkedSwitch) ? $(linkedSwitch.label) ? linkedSwitch.label : linkedSwitch.name : )][(leftLink = (switchUpdatesBlock) ? < : )][(rightLink = (blockUpdatesSwitch) ? > : )][If ((leftLink == ) && (rightLink == )),,],
Starting Points: []
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
Methods below
linkerpage
installed
updated
initialize
updateswitchlevel
updateblocklevel
updateswitchstate
updateblockstate
getblockid
getlinkerdescription
Dynamic Method Invocation
type 2 command uses
setlevel
type 2 attr uses
level
called cap-methods by app
called cap-props by app
switch
attribute uses through subscriptions
level
switch
cmd overpriv:[off, on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing tile-multiattribute-mediaplayer.groovy
DECLARED METHODS
installed: [(state.tracks = [Gangnam Style (강남스타?)
PSY
Psy 6 (Six Rules), Part 1, Careless Whisper
Wham!
Make It Big, Never Gonna Give You Up
Rick Astley
Whenever You Need Somebody, Shake It Off
Taylor Swift
1989, Ironic
Alanis Morissette
Jagged Little Pill, Hotline Bling
Drake
Hotline Bling - Single])][(state.currentTrack = 0)]
parse: 
play: [this.sendEvent([name:trackDescription, value:state.tracks[state.currentTrack]])]
pause: [this.sendEvent([name:trackDescription, value:state.tracks[state.currentTrack]])]
stop: 
previousTrack: [(state.currentTrack = (state.currentTrack - 1))][If (state.currentTrack < 0),[(state.currentTrack = (state.tracks.size() - 1))],],[this.sendEvent([name:trackDescription, value:state.tracks[state.currentTrack]])]
nextTrack: [(state.currentTrack = (state.currentTrack + 1))][If (state.currentTrack == state.tracks.size()),[(state.currentTrack = 0)],],[this.sendEvent([name:trackDescription, value:state.tracks[state.currentTrack]])]
mute: 
unmute: 
setLevel: 
Starting Points: []
IT HAS STATE
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-mediaplayer.metadata() is applicable for argument types: (tile-multiattribute-mediaplayer$_run_closure1) values: [tile-multiattribute-mediaplayer$_run_closure1@1f6c9cd8]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing the-big-switch.groovy
DECLARED METHODS
installed: [this.subscribe(master, switch.on, onHandler)][this.subscribe(master, switch.off, offHandler)][this.subscribe(master, level, dimHandler)]
updated: [this.unsubscribe()][this.subscribe(master, switch.on, onHandler)][this.subscribe(master, switch.off, offHandler)][this.subscribe(master, level, dimHandler)]
logHandler: 
onHandler: 
offHandler: 
dimHandler: 
onSwitches: [If (switches && onSwitches),,[If switches,,],],
offSwitches: [If (switches && offSwitches),,[If switches,,],],
Starting Points: []
req caps: [capability.switchlevel, capability.switch]
req cap size: 2
requested commands:[setlevel, off, on]
requested attrs:[level, switch]
Methods below
installed
updated
loghandler
onhandler
offhandler
dimhandler
onswitches
offswitches
called cap-methods by app
setlevel
called cap-props by app
level
switch
attribute uses through subscriptions
level
switch
cmd overpriv:[off, on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing open-closed-sensor.groovy
DECLARED METHODS
parse: [(resMap = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If description.startsWith(zone),[(resMap = this.createEvent([name:contact, value:(zigbee.parseZoneStatus(description).isAlarm1Set()) ? open : closed]))],],
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: open-closed-sensor.metadata() is applicable for argument types: (open-closed-sensor$_run_closure1) values: [open-closed-sensor$_run_closure1@3243b914]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-porkfolio.groovy
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],
poll: 
refresh: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-porkfolio.metadata() is applicable for argument types: (quirky-wink-porkfolio$_run_closure1) values: [quirky-wink-porkfolio$_run_closure1@7ca33c24]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing pet-feeder-shield.groovy
DECLARED METHODS
parse: [(value = zigbee.parse(description)?.text)][(name = ((value && (value != ping))) ? response : null)][(result = this.createEvent([name:name, value:value]))]
feed: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: pet-feeder-shield.metadata() is applicable for argument types: (pet-feeder-shield$_run_closure1) values: [pet-feeder-shield$_run_closure1@5f6722d3]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-dimmable-bulb.groovy
DECLARED METHODS
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],
installed: 
updated: 
ping: 
refresh: 
configure: 
on: 
off: 
setLevel: [(levelEventMap = this.buildSetLevelEvent(value))][If (levelEventMap.value == 0),,],
setLevel: 
getSwitch: [(switchState = device.currentState(switch))]
getLevel: [(levelState = device.currentState(level))]
initialize: 
buildSetLevelEvent: [(intValue = (java.lang.Integer -> java.lang.Integer) value)][(newLevel = java.lang.Math.max(java.lang.Math.min(intValue, 99), 0))][(eventMap = [name:level, value:newLevel, unit:%])]
implicitOn: [If (device.currentValue(switch) != on),,],
turnOn: 
turnOff: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-dimmable-bulb.metadata() is applicable for argument types: (simulated-dimmable-bulb$_run_closure1) values: [simulated-dimmable-bulb$_run_closure1@674bd420]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing zooz-power-strip-outlet.groovy
DECLARED METHODS
on: 
off: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: zooz-power-strip-outlet.metadata() is applicable for argument types: (zooz-power-strip-outlet$_run_closure1) values: [zooz-power-strip-outlet$_run_closure1@158a3b2e]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartpower-dimming-outlet.groovy
DECLARED METHODS
parse: [(event = zigbee.getEvent(description))][If event,,[If (event.name == power),[(event.value = (event.value / 10))],],],
setLevel: 
off: 
on: 
refresh: 
configure: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: smartpower-dimming-outlet.metadata() is applicable for argument types: (smartpower-dimming-outlet$_run_closure1) values: [smartpower-dimming-outlet$_run_closure1@6f152006]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing switch-changes-mode.groovy
DECLARED METHODS
installed: [this.subscribe(controlSwitch, switch, switchHandler)]
updated: [this.unsubscribe()][this.subscribe(controlSwitch, switch, switchHandler)]
switchHandler: [If (evt.value == on),,],
changeMode: [If (newMode && (location.mode != newMode)),[If location.modes?.find({ -> ... }),,],,],
Starting Points: []
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
Methods below
installed
updated
switchhandler
changemode
called cap-methods by app
called cap-props by app
switch
attribute uses through subscriptions
switch
cmd overpriv:[off, on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing relative-humidity-measurement-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: relative-humidity-measurement-capability.metadata() is applicable for argument types: (relative-humidity-measurement-capability$_run_closure1) values: [relative-humidity-measurement-capability$_run_closure1@340da44c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing temperature-measurement-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: temperature-measurement-capability.metadata() is applicable for argument types: (temperature-measurement-capability$_run_closure1) values: [temperature-measurement-capability$_run_closure1@1dd6d4b7]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing sonos-remote-control.groovy
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(buttonDevice, button, buttonEvent)]
buttonEvent: [(buttonNumber = evt.data)][(value = evt.value)][(recentEvents = buttonDevice.eventsSince(new java.util.Date((this.now() - 2000))).findAll({ -> ... }))][If (recentEvents.size <= 1),,],
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
extractButtonNumber: [(buttonNumber = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
handleButton: 
togglePlayPause: [(currentStatus = sonos.currentValue(status))][If (currentStatus == playing),,],
adjustVolume: [(changeAmount = ((volumeOffset) ? volumeOffset : 5 * (doubleAmount) ? 2 : 1))][(currentVolume = sonos.currentValue(level))][If up,,],
Starting Points: []
req caps: [capability.musicplayer, capability.button]
req cap size: 2
requested commands:[play, playtrack, mute, playtext, nexttrack, restoretrack, pause, settrack, resumetrack, previoustrack, setlevel, stop, unmute]
requested attrs:[button, trackdescription, trackdata, mute, level, status]
Methods below
installed
updated
initialize
buttonevent
extractbuttonnumber
handlebutton
toggleplaypause
adjustvolume
called cap-methods by app
play
previoustrack
setlevel
nexttrack
pause
called cap-props by app
button
trackdescription
trackdata
mute
level
status
attribute uses through subscriptions
button
trackdescription
trackdata
mute
level
status
cmd overpriv:[playtrack, mute, playtext, restoretrack, settrack, resumetrack, stop, unmute]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [6d38663a-1703-46b6-9939-8c1fb9467cf9, ff20e87b-992b-42b0-9cd6-72b0030dedc3]
[[capability.switch, capability.refresh]]
--app-start--
processing presence-sensor-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: presence-sensor-capability.metadata() is applicable for argument types: (presence-sensor-capability$_run_closure1) values: [presence-sensor-capability$_run_closure1@7f6f61c8]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-alarm.groovy
DECLARED METHODS
strobe: 
siren: 
both: 
off: 
parse: [(pair = description.split(:))]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-alarm.metadata() is applicable for argument types: (simulated-alarm$_run_closure1) values: [simulated-alarm$_run_closure1@7e276594]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-temperature-sensor.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]
setLevel: 
up: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue + 1) : 72)]
down: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue - 1) : 72)]
setTemperature: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-temperature-sensor.metadata() is applicable for argument types: (simulated-temperature-sensor$_run_closure1) values: [simulated-temperature-sensor$_run_closure1@6b98a075]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-refrigerator.groovy
DECLARED METHODS
installed: [(state.counter = (state.counter) ? (state.counter + 1) : 1)][If (state.counter == 1),,],
doorOpen: 
doorClosed: [If childDevices.find({ -> ... }),,],
Starting Points: []
IT HAS STATE
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-refrigerator.metadata() is applicable for argument types: (simulated-refrigerator$_run_closure1) values: [simulated-refrigerator$_run_closure1@704f1591]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing hue-white-ambiance-bulb.groovy
DECLARED METHODS
initialize: 
installed: 
updated: 
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],
on: 
off: 
setLevel: [If (((percent != null) && (percent >= 0)) && (percent <= 100)),,],
setColorTemperature: [If value,,],
refresh: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: hue-white-ambiance-bulb.metadata() is applicable for argument types: (hue-white-ambiance-bulb$_run_closure1) values: [hue-white-ambiance-bulb$_run_closure1@315f43d5]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing bose-soundtouch-control.groovy
DECLARED METHODS
mainPage: 
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]
ifUnset: [If settings[name],,],
ifSet: [If settings[name],,],
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [log.trace(subscribeToEvents())][this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,,],
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],
modeChangeHandler: [If (evt.value in triggerModes),,],
scheduledTimeHandler: 
appTouchHandler: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
takeAction: [(options = [:])][If volume,[(options.delay = 1000)],],
frequencyKey: 
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],
getAllOk: 
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]
timeIntervalLabel: 
Starting Points: []
req caps: [capability.motionsensor, capability.musicplayer, capability.contactsensor, capability.switch, capability.button, capability.smokedetector, capability.watersensor, capability.accelerationsensor, capability.presencesensor]
req cap size: 9
requested commands:[play, playtrack, mute, playtext, nexttrack, restoretrack, pause, off, settrack, resumetrack, previoustrack, setlevel, stop, unmute, on]
requested attrs:[motion, level, smoke, trackdescription, mute, water, switch, button, acceleration, trackdata, contact, presence, status]
Methods below
mainpage
anythingset
ifunset
ifset
installed
updated
subscribetoevents
eventhandler
modechangehandler
scheduledtimehandler
apptouchhandler
takeaction
frequencykey
daystring
onceperdayok
getallok
getmodeok
getdaysok
gettimeok
hhmm
timeintervallabel
type 2 attr uses
carbonmonoxide
called cap-methods by app
play
nexttrack
pause
off
previoustrack
setlevel
on
called cap-props by app
motion
smoke
water
switch
button
acceleration
contact
presence
attribute uses through subscriptions
button
acceleration
motion
contact
smoke
presence
playpause
carbonmonoxide
water
switch
cmd overpriv:[playtrack, mute, playtext, restoretrack, settrack, resumetrack, stop, unmute]
attr overpriv:[level, trackdescription, mute, trackdata, status]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 6d38663a-1703-46b6-9939-8c1fb9467cf9, 266374ae-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, ff20e87b-992b-42b0-9cd6-72b0030dedc3, 26d69a34-ada2-42dc-9e45-445c78ae2619, 1e88cabe-5ba4-4647-9a23-0ad5b887f94b, f730b653-b0b6-483e-8c84-977e240f5eb3, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.refresh, capability.polling]]
--app-start--
processing hue-lux-bulb.groovy
DECLARED METHODS
initialize: 
installed: 
updated: 
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],
on: 
off: 
setLevel: [If (((percent != null) && (percent >= 0)) && (percent <= 100)),,],
refresh: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: hue-lux-bulb.metadata() is applicable for argument types: (hue-lux-bulb$_run_closure1) values: [hue-lux-bulb$_run_closure1@54d18072]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing cameras-on-when-im-away.groovy
DECLARED METHODS
installed: [this.subscribe(people, presence, presence)]
updated: [this.unsubscribe()][this.subscribe(people, presence, presence)]
presence: [If (evt.value == not present),[If this.everyoneIsAway(),,],,[If this.everyoneIsAway(),,],],
turnOff: 
turnOn: 
everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],]everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],]
Starting Points: []
req caps: [capability.switch, capability.presencesensor]
req cap size: 2
requested commands:[off, on]
requested attrs:[presence, switch]
Methods below
installed
updated
presence
turnoff
turnon
everyoneisaway
called cap-methods by app
off
on
called cap-props by app
presence
attribute uses through subscriptions
presence
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing lifx-white-bulb.groovy
DECLARED METHODS
initialize: 
installed: 
updated: 
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
setLevel: [If ((percentage < 1) && (percentage > 0)),[(percentage = 1)],],[If (percentage == 0),,],
setColorTemperature: 
on: 
off: 
refresh: [(resp = parent.apiGET(/lights/$this.selector()))][If (resp.status == 404),[(state.online = false)],[If (resp.status != 200),,],],[(data = resp.data[0])][If data.connected,,],
selector: [If device.deviceNetworkId.contains(:),,],
Starting Points: []
IT HAS STATE
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: lifx-white-bulb.metadata() is applicable for argument types: (lifx-white-bulb$_run_closure1) values: [lifx-white-bulb$_run_closure1@5a85c92]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing motion-detector.groovy
DECLARED METHODS
parse: [(name = null)][(value = description)][(descriptionText = null)][If zigbee.isZoneType19(description),[(name = motion)][(isActive = zigbee.translateStatusZoneType19(description))][(value = (isActive) ? active : inactive)][(descriptionText = (isActive) ? $device.displayName detected motion : $device.displayName motion has stopped)],],[(result = this.createEvent([name:name, value:value, descriptionText:descriptionText]))]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: motion-detector.metadata() is applicable for argument types: (motion-detector$_run_closure1) values: [motion-detector$_run_closure1@3d3ba765]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing nfc-tag-toggle.groovy
currentValue, arg not ConstantExpression
currentValue, arg not ConstantExpression
DECLARED METHODS
pageTwo: 
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(tag, nfcTouch, touchHandler)][this.subscribe(app, touchHandler)]
currentStatus: [(result = null)][If master,[(result = devices.find({ -> ... })?.currentValue(attribute))],[(map = [:])][(result = map.collect({ -> ... }).sort({ -> ... })[-1].key)]],
touchHandler: [If switch1,[(status = this.currentStatus(switch1, masterSwitch, switch))],],[If lock,[(status = this.currentStatus(lock, masterLock, lock))],],[If garageDoor,[(status = this.currentStatus(garageDoor, masterDoor, status))],],
Starting Points: []
req caps: [capability.touchsensor, capability.switch, capability.lock, capability.doorcontrol]
req cap size: 4
requested commands:[lock, unlock, close, off, open, on]
requested attrs:[lock, touch, door, switch]
Methods below
pagetwo
installed
updated
initialize
currentstatus
touchhandler
called cap-methods by app
lock
unlock
close
off
open
on
called cap-props by app
attribute uses through subscriptions
nfctouch
cmd overpriv:[]
attr overpriv:[lock, touch, door, switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, bdefadfd-d59f-4d54-82c2-5fbb3ac6965f, 548b3451-701a-4244-b66a-40d08564dc47]
[[capability.battery, capability.contactsensor, capability.polling, capability.refresh]]
--app-start--
processing jawbone-user.groovy
DECLARED METHODS
generateSleepingEvent: [(value = this.formatValue(sleeping))][(linkText = this.getLinkText(device))][(descriptionText = this.formatDescriptionText(linkText, sleeping))][(handlerName = this.getState(sleeping))][(results = [name:sleeping, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName])][(results2 = [name:button, value:held, unit:null, linkText:linkText, descriptionText:$linkText button was pressed, handlerName:buttonHandler, ... ])]
poll: [(results = parent.pollChild(this))]
setMemberId: [(state.jawboneMemberId = memberId)]
getMemberId: [return state.jawboneMemberId]
uninstalled: 
formatValue: [If sleeping,,],
formatDescriptionText: [If sleeping,,],
getState: [If sleeping,,],
Starting Points: []
IT HAS STATE
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: jawbone-user.metadata() is applicable for argument types: (jawbone-user$_run_closure1) values: [jawbone-user$_run_closure1@11981797]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing big-turn-on.groovy
DECLARED METHODS
installed: [this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
updated: [this.unsubscribe()][this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
changedLocationMode: 
appTouch: 
Starting Points: []
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
Methods below
installed
updated
changedlocationmode
apptouch
called cap-methods by app
on
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing hue-mood-lighting.groovy
DECLARED METHODS
mainPage: 
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]
ifUnset: [If settings[name],,],
ifSet: [If settings[name],,],
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,,],
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],
modeChangeHandler: [If (evt.value in triggerModes),,],
scheduledTimeHandler: 
appTouchHandler: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
takeAction: [If (frequency || oncePerDay),[(state[this.frequencyKey(evt)] = this.now())],],[(hueColor = 0)][(saturation = 100)]
frequencyKey: 
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],
oncePerDayOk: [(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result - $lastTime)]
getAllOk: 
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]
timeIntervalLabel: 
Starting Points: []
req caps: [capability.motionsensor, capability.contactsensor, capability.colorcontrol, capability.switch, capability.button, capability.smokedetector, capability.watersensor, capability.accelerationsensor, capability.presencesensor]
req cap size: 9
requested commands:[setsaturation, sethue, setcolor, off, on]
requested attrs:[saturation, button, acceleration, motion, color, contact, smoke, hue, presence, water, switch]
Methods below
mainpage
anythingset
ifunset
ifset
installed
updated
subscribetoevents
eventhandler
modechangehandler
scheduledtimehandler
apptouchhandler
takeaction
frequencykey
daystring
onceperdayok
getallok
getmodeok
getdaysok
gettimeok
hhmm
timeintervallabel
type 2 attr uses
level
carbonmonoxide
called cap-methods by app
setcolor
called cap-props by app
saturation
button
acceleration
motion
contact
smoke
hue
presence
water
switch
attribute uses through subscriptions
button
saturation
acceleration
motion
level
contact
smoke
hue
presence
carbonmonoxide
water
switch
cmd overpriv:[setsaturation, sethue, off, on]
attr overpriv:[color]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 266374ae-3292-11e2-9c79-22000a1dc790, 48b39485-7ebc-4c80-bf6e-9a653a2d1c95, 8a9d4b1e3b8af959013b8af9d183000e, ff20e87b-992b-42b0-9cd6-72b0030dedc3, 26d69a34-ada2-42dc-9e45-445c78ae2619, 1e88cabe-5ba4-4647-9a23-0ad5b887f94b, f730b653-b0b6-483e-8c84-977e240f5eb3, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.refresh, capability.polling]]
--app-start--
processing curling-iron.groovy
DECLARED METHODS
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [this.subscribe(motionSensors, motion.active, motionActive)][this.subscribe(motionSensors, motion.inactive, motionInactive)][this.subscribe(presenceSensors, presence.not present, notPresent)]
motionActive: [If this.anyHere(),,],
motionInactive: [If this.allQuiet(),,],
notPresent: [If this.anyHere(),,],
allQuiet: [(result = true)][For motionSensors,[If (it.currentMotion == active),[(result = false)][(result = false)],],]allQuiet: [(result = true)][For motionSensors,[If (it.currentMotion == active),[(result = false)][(result = false)],],]
anyHere: [(result = true)][For presenceSensors,[If (it.currentPresence == not present),[(result = false)][(result = false)],],]anyHere: [(result = true)][For presenceSensors,[If (it.currentPresence == not present),[(result = false)][(result = false)],],]
outletsOn: 
outletsOff: [(delay = (minutes * 60))]
scheduledTurnOff: 
Starting Points: []
req caps: [capability.motionsensor, capability.switch, capability.presencesensor]
req cap size: 3
requested commands:[off, on]
requested attrs:[motion, presence, switch]
Methods below
installed
updated
subscribetoevents
motionactive
motioninactive
notpresent
allquiet
anyhere
outletson
outletsoff
scheduledturnoff
called cap-methods by app
off
on
called cap-props by app
motion
presence
attribute uses through subscriptions
motion
presence
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing mood-cube.groovy
DECLARED METHODS
scenesPage: [(sceneId = this.getOrientation())]
scenePage: [(currentSceneId = this.getOrientation())][(sceneId = ((java.lang.Integer -> java.lang.Integer) params.sceneId) ? (java.lang.Integer -> java.lang.Integer) params.sceneId : state.lastDisplayedSceneId)][(state.lastDisplayedSceneId = sceneId)]
devicePage: [(sceneId = ((java.lang.Integer -> java.lang.Integer) params.sceneId) ? (java.lang.Integer -> java.lang.Integer) params.sceneId : state.lastDisplayedSceneId)]
saveStatesPage: 
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(cube, threeAxis, positionHandler)]
positionHandler: [(sceneId = this.getOrientation(evt.xyzValue))][If (sceneId != state.lastActiveSceneId),,],[(state.lastActiveSceneId = sceneId)]
sceneIsDefined: [(tgt = onoff_$sceneId.toString())][(settings.find({ -> ... }) != null)]
updateSetting: [(settings[name] = value)]
closestLevel: 
saveStates: [(sceneId = (java.lang.Integer -> java.lang.Integer) params.sceneId)]
restoreStates: 
switchLevel: [(percent = settings.level_$sceneId_$light.id)][If percent,,],
getDeviceCapabilities: [(caps = [:])][(state.lightCapabilities = caps)]
getLevels: [(levels = [])][For ((i = 0); (i <= 100); (i += 5)),]getLevels: [(levels = [])][For ((i = 0); (i <= 100); (i += 5)),]
getOrientation: [(threshold = 250)][(value = (xyz) ? xyz : cube.currentValue(threeAxis))][(x = ((java.lang.Math.abs(value.x) > threshold)) ? ((value.x > 0)) ? 1 : -1 : 0)][(y = ((java.lang.Math.abs(value.y) > threshold)) ? ((value.y > 0)) ? 1 : -1 : 0)][(z = ((java.lang.Math.abs(value.z) > threshold)) ? ((value.z > 0)) ? 1 : -1 : 0)][(orientation = 0)][If (z > 0),[If ((x == 0) && (y == 0)),[(orientation = 1)],],,[If (z < 0),[If ((x == 0) && (y == 0)),[(orientation = 2)],],,[If (x > 0),[If (y == 0),[(orientation = 3)],],,[If (x < 0),[If (y == 0),[(orientation = 4)],],,[If (y > 0),[(orientation = 5)],[If (y < 0),[(orientation = 6)],],],],],],],
sceneName: [(names = [UNDEFINED, One, Two, Three, Four, Five, Six])]
Starting Points: []
IT HAS STATE
req caps: [capability.threeaxis, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[threeaxis, switch]
Methods below
scenespage
scenepage
devicepage
savestatespage
installed
updated
initialize
positionhandler
sceneisdefined
updatesetting
closestlevel
savestates
restorestates
switchlevel
getdevicecapabilities
getlevels
getorientation
scenename
type 2 command uses
setlevel
setcolor
type 2 attr uses
saturation
hue
level
called cap-methods by app
off
on
called cap-props by app
threeaxis
switch
attribute uses through subscriptions
saturation
hue
level
threeaxis
switch
cmd overpriv:[]
attr overpriv:[]
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, 258ee648-d846-4702-bdfb-475a7ed047b4]
[[capability.battery, capability.contactsensor, capability.signalstrength, capability.accelerationsensor, capability.temperaturemeasurement]]
--app-start--
processing momentary-button-tile.groovy
DECLARED METHODS
parse: 
push: 
on: 
off: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: momentary-button-tile.metadata() is applicable for argument types: (momentary-button-tile$_run_closure1) values: [momentary-button-tile$_run_closure1@665df3c6]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing my-light-toggle.groovy
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(motionToggler, motion, toggleSwitches)]
toggleSwitches: [If ((evt.value == active) && (masterToggle.currentSwitch == off)),,[If ((evt.value == active) && (masterToggle.currentSwitch == on)),,],],
Starting Points: []
req caps: [capability.motionsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[motion, switch]
Methods below
installed
updated
initialize
toggleswitches
called cap-methods by app
off
on
called cap-props by app
motion
switch
attribute uses through subscriptions
motion
cmd overpriv:[]
attr overpriv:[]
--app-start--
processing netatmo-rain.groovy
DECLARED METHODS
parse: 
poll: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: netatmo-rain.metadata() is applicable for argument types: (netatmo-rain$_run_closure1) values: [netatmo-rain$_run_closure1@4a891c97]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing co2-vent.groovy
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [(state.active = false)][this.subscribe(sensor, carbonDioxide, handleLevel)]
handleLevel: [(co2 = sensor.currentValue(carbonDioxide).toInteger())][If ((co2 >= settings.level) && state.active),[(state.active = true)],[If ((co2 < settings.level) && state.active),[(state.active = false)],],],
Starting Points: []
IT HAS STATE
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
Methods below
installed
updated
initialize
handlelevel
called cap-methods by app
off
on
called cap-props by app
attribute uses through subscriptions
carbondioxide
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing notify-me-with-hue.groovy
DECLARED METHODS
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,,],
eventHandler: [If frequency,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],
modeChangeHandler: [If (evt.value in triggerModes),,],
scheduledTimeHandler: 
appTouchHandler: 
takeAction: [If frequency,[(state[evt.deviceId] = this.now())],],[(hueColor = 0)][If (color == Blue),[(hueColor = 70)],[If (color == Green),[(hueColor = 39)],[If (color == Yellow),[(hueColor = 25)],[If (color == Orange),[(hueColor = 10)],[If (color == Purple),[(hueColor = 75)],[If (color == Pink),[(hueColor = 83)],],],],],],],[(state.previous = [:])][(newValue = [hue:hueColor, saturation:100, level:((java.lang.Integer -> java.lang.Integer) lightLevel) ? (java.lang.Integer -> java.lang.Integer) lightLevel : 100])]
setTimer: [If duration,,[If (duration < 10),,],],
resetHue: 
Starting Points: []
IT HAS STATE
req caps: [capability.motionsensor, capability.colorcontrol, capability.contactsensor, capability.switch, capability.button, capability.smokedetector, capability.watersensor, capability.accelerationsensor, capability.presencesensor]
req cap size: 9
requested commands:[setsaturation, sethue, setcolor, off, on]
requested attrs:[saturation, button, acceleration, motion, color, contact, smoke, hue, presence, water, switch]
Methods below
installed
updated
subscribetoevents
eventhandler
modechangehandler
scheduledtimehandler
apptouchhandler
takeaction
settimer
resethue
type 2 attr uses
level
carbonmonoxide
called cap-methods by app
setcolor
called cap-props by app
saturation
button
acceleration
motion
color
contact
smoke
hue
presence
water
switch
attribute uses through subscriptions
motion
color
level
smoke
carbonmonoxide
water
switch
button
saturation
acceleration
contact
hue
presence
cmd overpriv:[setsaturation, sethue, off, on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 48b39485-7ebc-4c80-bf6e-9a653a2d1c95, 266374ae-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, ff20e87b-992b-42b0-9cd6-72b0030dedc3, 26d69a34-ada2-42dc-9e45-445c78ae2619, 1e88cabe-5ba4-4647-9a23-0ad5b887f94b, f730b653-b0b6-483e-8c84-977e240f5eb3, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.refresh, capability.polling]]
--app-start--
processing netatmo-outdoor-module.groovy
DECLARED METHODS
parse: 
poll: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: netatmo-outdoor-module.metadata() is applicable for argument types: (netatmo-outdoor-module$_run_closure1) values: [netatmo-outdoor-module$_run_closure1@201b6b6f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing light-follows-me.groovy
DECLARED METHODS
installed: [this.subscribe(motion1, motion, motionHandler)]
updated: [this.unsubscribe()][this.subscribe(motion1, motion, motionHandler)]
motionHandler: [If (evt.value == active),,[If (evt.value == inactive),,],],
scheduleCheck: [(motionState = motion1.currentState(motion))][If (motionState.value == inactive),[(elapsed = (this.now() - motionState.rawDateCreated.time))][(threshold = (((1000 * 60) * minutes1) - 1000))][If (elapsed >= threshold),,],,],
Starting Points: []
req caps: [capability.motionsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[motion, switch]
Methods below
installed
updated
motionhandler
schedulecheck
called cap-methods by app
off
on
called cap-props by app
motion
attribute uses through subscriptions
motion
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing illuminance-measurement-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: illuminance-measurement-capability.metadata() is applicable for argument types: (illuminance-measurement-capability$_run_closure1) values: [illuminance-measurement-capability$_run_closure1@2bb7bd00]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing lifx-color-bulb.groovy
DECLARED METHODS
initialize: 
installed: 
updated: 
setHue: 
setSaturation: 
setColor: [(attrs = [])][(events = [])]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
setLevel: [If ((percentage < 1) && (percentage > 0)),[(percentage = 1)],],[If (percentage == 0),,],
setColorTemperature: 
on: 
off: 
refresh: [(resp = parent.apiGET(/lights/$this.selector()))][If (resp.status == 404),[(state.online = false)],[If (resp.status != 200),,],],[(data = resp.data[0])][If data.connected,,],
selector: [If device.deviceNetworkId.contains(:),,],
Starting Points: []
IT HAS STATE
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: lifx-color-bulb.metadata() is applicable for argument types: (lifx-color-bulb$_run_closure1) values: [lifx-color-bulb$_run_closure1@3fffff43]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing centralite-thermostat.groovy
DECLARED METHODS
parse: [(result = [])][(descMap = zigbee.parseDescriptionAsMap(description))][(attrData = [[cluster:descMap.cluster, attrId:descMap.attrId, value:descMap.value]])]
getModeMap: 
getFanModeMap: 
refresh: 
getTemperature: [If (value != null),[(celsius = (java.lang.Integer.parseInt(value, 16) / 100))][If (this.getTemperatureScale() == C),,],,],
setHeatingSetpoint: [If (degrees != null),[(temperatureScale = this.getTemperatureScale())][(degreesInteger = java.lang.Math.round(degrees))][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))],],
setCoolingSetpoint: [If (degrees != null),[(degreesInteger = java.lang.Math.round(degrees))][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))],],
modes: 
setThermostatMode: [(currentMode = device.currentState(thermostatMode)?.value)][(modeOrder = this.modes())][(index = modeOrder.indexOf(currentMode))][(next = (((index >= 0) && (index < (modeOrder.size() - 1)))) ? modeOrder[(index + 1)] : modeOrder[0])]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
setThermostatFanMode: [(currentFanMode = device.currentState(thermostatFanMode)?.value)][(returnCommand = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)]
setThermostatMode: 
setThermostatFanMode: 
off: 
cool: 
heat: 
emergencyHeat: 
on: 
fanOn: 
auto: 
fanAuto: 
configure: 
hex: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: centralite-thermostat.metadata() is applicable for argument types: (centralite-thermostat$_run_closure1) values: [centralite-thermostat$_run_closure1@354fc8f0]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing notify-me-when.groovy
DECLARED METHODS
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [this.subscribe(button, button.pushed, eventHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)]
eventHandler: [If frequency,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],
sendMessage: [(msg = messageText)][(options = [:])][If messageText,[(msg = this.defaultText(evt))][(options = [translatable:true, triggerEvent:evt])],],[If location.contactBookEnabled,,[If phone,[(options.phone = phone)][If (pushAndPhone != No),[(options.method = both)],[(options.method = phone)]],,[If (pushAndPhone != No),[(options.method = push)],[(options.method = none)]],],],[If frequency,[(state[evt.deviceId] = this.now())],],
defaultText: [If (evt.name == presence),[If (evt.value == present),[If includeArticle,,],,[If includeArticle,,],],,],
getIncludeArticle: [(name = location.name.toLowerCase())][(segs = name.split( ))]
Starting Points: []
req caps: [capability.motionsensor, capability.contactsensor, capability.switch, capability.button, capability.smokedetector, capability.watersensor, capability.accelerationsensor, capability.presencesensor]
req cap size: 8
requested commands:[off, on]
requested attrs:[button, acceleration, motion, contact, smoke, presence, water, switch]
Methods below
installed
updated
subscribetoevents
eventhandler
sendmessage
defaulttext
getincludearticle
type 2 attr uses
carbonmonoxide
called cap-methods by app
called cap-props by app
button
acceleration
motion
contact
smoke
presence
water
switch
attribute uses through subscriptions
button
acceleration
motion
contact
smoke
presence
carbonmonoxide
water
switch
cmd overpriv:[off, on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 266374ae-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, ff20e87b-992b-42b0-9cd6-72b0030dedc3, 26d69a34-ada2-42dc-9e45-445c78ae2619, 1e88cabe-5ba4-4647-9a23-0ad5b887f94b, f730b653-b0b6-483e-8c84-977e240f5eb3, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.refresh, capability.switchlevel, capability.polling]]
--app-start--
processing motion-sensor-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: motion-sensor-capability.metadata() is applicable for argument types: (motion-sensor-capability$_run_closure1) values: [motion-sensor-capability$_run_closure1@192d74fb]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing brighten-dark-places.groovy
DECLARED METHODS
installed: [this.subscribe(contact1, contact.open, contactOpenHandler)]
updated: [this.unsubscribe()][this.subscribe(contact1, contact.open, contactOpenHandler)]
contactOpenHandler: [(lightSensorState = luminance1.currentIlluminance)][If ((lightSensorState != null) && (lightSensorState < 10)),,],
Starting Points: []
req caps: [capability.contactsensor, capability.illuminancemeasurement, capability.switch]
req cap size: 3
requested commands:[off, on]
requested attrs:[illuminance, contact, switch]
Methods below
installed
updated
contactopenhandler
called cap-methods by app
on
called cap-props by app
illuminance
contact
attribute uses through subscriptions
contact
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing light-sensor.groovy
DECLARED METHODS
parse: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If description?.startsWith(illuminance: ),[(raw = (description - illuminance: ))][If raw.isNumber(),[(result = this.createEvent([name:illuminance, value:java.lang.Math.round(zigbee.lux((java.lang.Integer -> java.lang.Integer) raw)).toString(), unit:lux]))],],,],
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: light-sensor.metadata() is applicable for argument types: (light-sensor$_run_closure1) values: [light-sensor$_run_closure1@285c08c8]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing energy-saver.groovy
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(meter, power, meterHandler)]
meterHandler: [(meterValue = (double) evt.value)][(thresholdValue = (int) threshold)][If (meterValue > thresholdValue),,],
Starting Points: []
req caps: [capability.powermeter, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[switch, power]
Methods below
installed
updated
initialize
meterhandler
called cap-methods by app
off
called cap-props by app
power
attribute uses through subscriptions
power
cmd overpriv:[on]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, b100c5ad-6d43-4adf-89f9-4109995e059d]
[[capability.refresh]]
--app-start--
processing keen-home-smart-vent.groovy
DECLARED METHODS
parse: [(map = [:])][If description?.startsWith(catchall:),[(map = this.parseCatchAllMessage(description))],[If description?.startsWith(read attr -),[(map = this.parseReportAttributeMessage(description))],[If (description?.startsWith(temperature: ) || description?.startsWith(humidity: )),[(map = this.parseCustomMessage(description))],[If description?.startsWith(on/off: ),[(map = this.parseOnOffMessage(description))],],],],],
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseCatchAllMessage: [(cluster = zigbee.parse(description))][If this.shouldProcessMessage(cluster),,],
shouldProcessMessage: [If ((((cluster.profileId != 260) || (cluster.command == 11)) || (cluster.command == 7)) || ((cluster.data.size() > 0) && (cluster.data.first() == 62))),,],
parseReportAttributeMessage: [(descMap = (description - read attr - ).split(,).inject([:], { java.lang.Object map, java.lang.Object param -> ... }))][If ((descMap.cluster == 0006) && (descMap.attrId == 0000)),,[If ((descMap.cluster == 0008) && (descMap.attrId == 0000)),,[If ((descMap.cluster == 0402) && (descMap.attrId == 0000)),[(value = this.convertTemperatureHex(descMap.value))],[If ((descMap.cluster == 0001) && (descMap.attrId == 0021)),,[If ((descMap.cluster == 0403) && (descMap.attrId == 0020)),,[If ((descMap.cluster == 0000) && (descMap.attrId == 0006)),,],],],],],],
parseCustomMessage: [(resultMap = [:])][If description?.startsWith(temperature: ),[(value = java.lang.Double.parseDouble(description.split(: )[1]))][(resultMap = this.makeTemperatureResult(this.convertTemperature(value)))],],
parseOnOffMessage: [(resultMap = [:])][If description?.startsWith(on/off: ),[(value = java.lang.Integer.parseInt((description - on/off: )))][(resultMap = this.makeOnOffResult(value))],],
makeOnOffResult: [(linkText = this.getLinkText(device))][(value = ((rawValue == 1)) ? on : off)]
makeLevelResult: [(linkText = this.getLinkText(device))][(value = java.lang.Integer.parseInt(rawValue, 16))][(rangeMax = 254)][If (value == 255),,],[(value = java.lang.Math.floor(((value / rangeMax) * 100)))]
makePressureResult: [(linkText = this.getLinkText(device))][(pascals = (rawValue / 10))][(result = [name:pressure, descriptionText:$linkText pressure is $pascalsPa, value:pascals])]
makeBatteryResult: [(linkText = this.getLinkText(device))]
makeTemperatureResult: [(linkText = this.getLinkText(device))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],
convertTemperatureHex: [(celsius = (java.lang.Integer.parseInt(value, 16).shortValue() / 100))]
convertTemperature: [If (this.getTemperatureScale() == C),,[(fahrenheit = (java.lang.Math.round((this.celsiusToFahrenheit(celsius) * 100)) / 100))]],
makeSerialResult: [(linkText = this.getLinkText(device))]
makeLevelCommand: [(rangeMax = 254)][(scaledLevel = java.lang.Math.round(((level * rangeMax) / 100)))][(hexLevel = new java.math.BigInteger(scaledLevel.toString()).toString(16).padLeft(2, 0))]
on: [(linkText = this.getLinkText(device))][If (device.currentValue(switch) == obstructed),,],
off: [(linkText = this.getLinkText(device))][If (device.currentValue(switch) == obstructed),,],
clearObstruction: [(linkText = this.getLinkText(device))]
setLevel: [(linkText = this.getLinkText(device))][(currentState = device.currentValue(switch))][If (currentState == obstructed),,],[If (value > 0),,],
getOnOff: [If (device.currentValue(switch) == obstructed),,],
getPressure: 
getLevel: [If (device.currentValue(switch) == obstructed),,],
getTemperature: 
getBattery: 
setZigBeeIdTile: [(linkText = this.getLinkText(device))]
refresh: 
ping: 
configure: [(configCmds = [zdo bind 0x$device.deviceNetworkId 1 1 0x0008 {$device.zigbeeId} {}, delay 500, zdo bind 0x$device.deviceNetworkId 1 1 0x0402 {$device.zigbeeId} {}, delay 500, zdo bind 0x$device.deviceNetworkId 1 1 0x0403 {$device.zigbeeId} {}, delay 500, zdo bind 0x$device.deviceNetworkId 1 1 0x0001 {$device.zigbeeId} {}, delay 500])]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: keen-home-smart-vent.metadata() is applicable for argument types: (keen-home-smart-vent$_run_closure1) values: [keen-home-smart-vent$_run_closure1@619bfe29]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing keep-me-cozy-ii.groovy
DECLARED METHODS
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [this.subscribe(location, changedLocationMode)][If sensor,[this.subscribe(sensor, temperature, temperatureHandler)][this.subscribe(thermostat, temperature, temperatureHandler)][this.subscribe(thermostat, thermostatMode, temperatureHandler)],],
changedLocationMode: 
temperatureHandler: 
evaluate: [If sensor,[(threshold = 1.0)][(tm = thermostat.currentThermostatMode)][(ct = thermostat.currentTemperature)][(currentTemp = sensor.currentTemperature)][If (tm in [cool, auto]),[If ((currentTemp - coolingSetpoint) >= threshold),,[If (((coolingSetpoint - currentTemp) >= threshold) && ((ct - thermostat.currentCoolingSetpoint) >= threshold)),,],],,],[If (tm in [heat, emergency heat, auto]),[If ((heatingSetpoint - currentTemp) >= threshold),,[If (((currentTemp - heatingSetpoint) >= threshold) && ((thermostat.currentHeatingSetpoint - ct) >= threshold)),,],],,],,],
coolingSetpointHandler: 
heatingSetpointHandler: 
Starting Points: []
req caps: [capability.thermostat, capability.temperaturemeasurement]
req cap size: 2
requested commands:[heat, setheatingsetpoint, auto, cool, setcoolingsetpoint, fanon, setthermostatmode, emergencyheat, fancirculate, off, setthermostatfanmode, fanauto]
requested attrs:[coolingsetpoint, thermostatfanmode, thermostatmode, temperature, heatingsetpoint, thermostatoperatingstate, thermostatsetpoint]
Methods below
installed
updated
subscribetoevents
changedlocationmode
temperaturehandler
evaluate
coolingsetpointhandler
heatingsetpointhandler
type 2 command uses
poll
called cap-methods by app
setcoolingsetpoint
setheatingsetpoint
called cap-props by app
temperature
coolingsetpoint
heatingsetpoint
thermostatmode
attribute uses through subscriptions
temperature
thermostatmode
cmd overpriv:[heat, auto, cool, fanon, setthermostatmode, emergencyheat, fancirculate, off, setthermostatfanmode, fanauto]
attr overpriv:[thermostatfanmode, thermostatoperatingstate, thermostatsetpoint]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8aa8a6b23f769c09013f769ed1c20012, ba155665-433d-4e20-9d12-efad7744c3d6]
[[capability.relativehumiditymeasurement]]
--app-start--
processing contact-sensor-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: contact-sensor-capability.metadata() is applicable for argument types: (contact-sensor-capability$_run_closure1) values: [contact-sensor-capability$_run_closure1@25748410]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing hue-bloom.groovy
DECLARED METHODS
initialize: 
installed: 
updated: 
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],
on: 
off: 
setLevel: [If this.verifyPercent(percent),,],
setSaturation: [If this.verifyPercent(percent),,],
setHue: [If this.verifyPercent(percent),,],
setColor: [(events = [])][(validValues = [:])][If this.verifyPercent(value.hue),[(validValues.hue = value.hue)],],[If this.verifyPercent(value.saturation),[(validValues.saturation = value.saturation)],],[If (value.hex != null),[If (value.hex ==~ ^\#([A-Fa-f0-9]){6}$),[(validValues.hex = value.hex)],],,],[If this.verifyPercent(value.level),[(validValues.level = value.level)],],[If ((value.switch == off) || ((value.level != null) && (value.level <= 0))),[(validValues.switch = off)],[(validValues.switch = on)]],[If validValues.isEmpty(),,],
reset: [(value = [hue:20, saturation:2])]
setAdjustedColor: [If value,[(adjusted = (value + [:]))][(adjusted.level = null)],],
refresh: 
verifyPercent: [If (percent == null),,[If ((percent >= 0) && (percent <= 100)),,],],
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: hue-bloom.metadata() is applicable for argument types: (hue-bloom$_run_closure1) values: [hue-bloom$_run_closure1@553f1d75]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing momentary-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]
push: 
off: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: momentary-capability.metadata() is applicable for argument types: (momentary-capability$_run_closure1) values: [momentary-capability$_run_closure1@5ed731d0]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing light-up-the-night.groovy
DECLARED METHODS
installed: [this.subscribe(lightSensor, illuminance, illuminanceHandler)]
updated: [this.unsubscribe()][this.subscribe(lightSensor, illuminance, illuminanceHandler)]
illuminanceHandler: [(lastStatus = state.lastStatus)][If ((lastStatus != on) && (evt.integerValue < 30)),[(state.lastStatus = on)],[If ((lastStatus != off) && (evt.integerValue > 50)),[(state.lastStatus = off)],],],
Starting Points: []
IT HAS STATE
req caps: [capability.illuminancemeasurement, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[illuminance, switch]
Methods below
installed
updated
illuminancehandler
called cap-methods by app
off
on
called cap-props by app
illuminance
attribute uses through subscriptions
illuminance
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing ecobee-thermostat.groovy
currentState, arg not ConstantExpression
currentState, arg not ConstantExpression
DECLARED METHODS
installed: 
ping: [(isAlive = ((device.currentValue(deviceAlive) == true)) ? true : false)][If isAlive,,],
parse: 
refresh: 
poll: 
generateEvent: [If results,[(linkText = this.getLinkText(device))][(supportedThermostatModes = [off])][(thermostatMode = null)][(locationScale = this.getTemperatureScale())][If (state.supportedThermostatModes != supportedThermostatModes),[(state.supportedThermostatModes = supportedThermostatModes)],],[If thermostatMode,[this.sendEvent([name:thermostatMode, value:thermostatMode, data:[supportedThermostatModes:state.supportedThermostatModes], linkText:linkText, ... ])],],,],
getThermostatDescriptionText: [If (name == temperature),,[If (name == heatingSetpoint),,[If (name == coolingSetpoint),,[If (name == thermostatMode),,[If (name == thermostatFanMode),,[If (name == humidity),,[return $name = $value]],],],],],],
setHeatingSetpoint: [If setpoint,[(state.heatingSetpoint = setpoint.toDouble())],],
setCoolingSetpoint: [If setpoint,[(state.coolingSetpoint = setpoint.toDouble())],],
updateSetpoints: [(deviceScale = F)][(data = [targetHeatingSetpoint:null, targetCoolingSetpoint:null])][(heatingSetpoint = this.getTempInLocalScale(heatingSetpoint))][(coolingSetpoint = this.getTempInLocalScale(coolingSetpoint))][If state.heatingSetpoint,[(data = this.enforceSetpointLimits(heatingSetpoint, [targetValue:state.heatingSetpoint, heatingSetpoint:heatingSetpoint, coolingSetpoint:coolingSetpoint]))],],[If state.coolingSetpoint,[(heatingSetpoint = (data.targetHeatingSetpoint) ? this.getTempInLocalScale(data.targetHeatingSetpoint, deviceScale) : heatingSetpoint)][(coolingSetpoint = (data.targetCoolingSetpoint) ? this.getTempInLocalScale(data.targetCoolingSetpoint, deviceScale) : coolingSetpoint)][(data = this.enforceSetpointLimits(coolingSetpoint, [targetValue:state.coolingSetpoint, heatingSetpoint:heatingSetpoint, coolingSetpoint:coolingSetpoint]))],],[(state.heatingSetpoint = null)][(state.coolingSetpoint = null)]
resumeProgram: [(deviceId = device.deviceNetworkId.split(\.).last())][If parent.resumeProgram(deviceId),,],
modes: [return state.supportedThermostatModes]
fanModes: 
switchMode: [(currentMode = device.currentValue(thermostatMode))][(modeOrder = this.modes())][If modeOrder,[(next = { -> ... })][(nextMode = next.call(currentMode))],],
switchToMode: [(deviceId = device.deviceNetworkId.split(\.).last())][If parent.setMode(((mode == emergency heat)) ? auxHeatOnly : mode, deviceId),,],
switchFanMode: [(currentFanMode = device.currentValue(thermostatFanMode))][(fanModeOrder = this.fanModes())][(next = { -> ... })]
switchToFanMode: [(heatingSetpoint = this.getTempInDeviceScale(heatingSetpoint))][(coolingSetpoint = this.getTempInDeviceScale(coolingSetpoint))][(deviceId = device.deviceNetworkId.split(\.).last())][(sendHoldType = (holdType) ? ((holdType == Temporary)) ? nextTransition : indefinite : indefinite)][If parent.setFanMode(heatingSetpoint, coolingSetpoint, deviceId, sendHoldType, fanMode),,],
getDataByName: 
setThermostatMode: [(supportedModes = this.modes())][If supportedModes,[(mode = mode.toLowerCase())][(modeIdx = supportedModes.indexOf(mode))][If (modeIdx < 0),,],[(mode = supportedModes[modeIdx])],],
setThermostatFanMode: [(mode = mode.toLowerCase())][(supportedFanModes = this.fanModes())][(modeIdx = supportedFanModes.indexOf(mode))][If (modeIdx < 0),,],[(mode = supportedFanModes[modeIdx])]
generateModeEvent: 
generateFanModeEvent: 
generateOperatingStateEvent: 
off: 
heat: 
emergencyHeat: 
cool: 
auto: 
fanOn: 
fanAuto: 
fanCirculate: 
generateSetpointEvent: [(mode = device.currentValue(thermostatMode))][(setpoint = this.getTempInLocalScale(heatingSetpoint))][(coolingSetpoint = this.getTempInLocalScale(coolingSetpoint))][If (mode == cool),[(setpoint = coolingSetpoint)],[If ((mode == auto) || (mode == off)),[(setpoint = this.roundC(((setpoint + coolingSetpoint) / 2)))],],],
raiseHeatingSetpoint: 
lowerHeatingSetpoint: 
raiseCoolSetpoint: 
lowerCoolSetpoint: 
alterSetpoint: [If (device.currentValue(thermostatMode) == off),,],[(locationScale = this.getTemperatureScale())][(deviceScale = F)][(heatingSetpoint = this.getTempInLocalScale(heatingSetpoint))][(coolingSetpoint = this.getTempInLocalScale(coolingSetpoint))][(targetValue = ((setpoint == heatingSetpoint)) ? heatingSetpoint : coolingSetpoint)][(delta = ((locationScale == F)) ? 1 : 0.5)][(targetValue += (raise) ? delta : delta)][(data = this.enforceSetpointLimits(setpoint, [targetValue:targetValue, heatingSetpoint:heatingSetpoint, coolingSetpoint:coolingSetpoint], raise))][If data.targetHeatingSetpoint,,],[If data.targetCoolingSetpoint,,],
enforceSetpointLimits: [(locationScale = this.getTemperatureScale())][(minSetpoint = ((setpoint == heatingSetpoint)) ? device.getDataValue(minHeatingSetpointFahrenheit) : device.getDataValue(minCoolingSetpointFahrenheit))][(maxSetpoint = ((setpoint == heatingSetpoint)) ? device.getDataValue(maxHeatingSetpointFahrenheit) : device.getDataValue(maxCoolingSetpointFahrenheit))][(minSetpoint = (minSetpoint) ? java.lang.Double.parseDouble(minSetpoint) : ((setpoint == heatingSetpoint)) ? 45 : 65)][(maxSetpoint = (maxSetpoint) ? java.lang.Double.parseDouble(maxSetpoint) : ((setpoint == heatingSetpoint)) ? 79 : 92)][(deadband = (deadbandSetting) ? deadbandSetting : 5)][(delta = ((locationScale == F)) ? 1 : 0.5)][(targetValue = this.getTempInDeviceScale(data.targetValue, locationScale))][(heatingSetpoint = this.getTempInDeviceScale(data.heatingSetpoint, locationScale))][(coolingSetpoint = this.getTempInDeviceScale(data.coolingSetpoint, locationScale))][If (targetValue > maxSetpoint),[(targetValue = maxSetpoint)],[If (targetValue < minSetpoint),[(targetValue = minSetpoint)],[If ((raise != null) && (((setpoint == heatingSetpoint) && (targetValue == heatingSetpoint)) || ((setpoint == coolingSetpoint) && (targetValue == coolingSetpoint)))),[(targetValue += (raise) ? delta : delta)],],],],[If (setpoint == heatingSetpoint),[(heatingSetpoint = targetValue)][(coolingSetpoint = (((heatingSetpoint + deadband) > coolingSetpoint)) ? (heatingSetpoint + deadband) : coolingSetpoint)],],[If (setpoint == coolingSetpoint),[(coolingSetpoint = targetValue)][(heatingSetpoint = (((coolingSetpoint - deadband) < heatingSetpoint)) ? (coolingSetpoint - deadband) : heatingSetpoint)],],
updateSetpoint: [(deviceId = device.deviceNetworkId.split(\.).last())][(sendHoldType = (holdType) ? ((holdType == Temporary)) ? nextTransition : indefinite : indefinite)][If parent.setHold(data.targetHeatingSetpoint, data.targetCoolingSetpoint, deviceId, sendHoldType),,],
generateStatusEvent: [(mode = device.currentValue(thermostatMode))][(heatingSetpoint = device.currentValue(heatingSetpoint))][(coolingSetpoint = device.currentValue(coolingSetpoint))][(temperature = device.currentValue(temperature))][(statusText = Right Now: Idle)][(operatingState = idle)][If ((mode == heat) || (mode == emergency heat)),[If (temperature < heatingSetpoint),[(statusText = Heating to $heatingSetpoint°$location.temperatureScale)][(operatingState = heating)],],,[If (mode == cool),[If (temperature > coolingSetpoint),[(statusText = Cooling to $coolingSetpoint°$location.temperatureScale)][(operatingState = cooling)],],,[If (mode == auto),[If (temperature < heatingSetpoint),[(statusText = Heating to $heatingSetpoint°$location.temperatureScale)][(operatingState = heating)],[If (temperature > coolingSetpoint),[(statusText = Cooling to $coolingSetpoint°$location.temperatureScale)][(operatingState = cooling)],],],,[If (mode == off),[(statusText = Right Now: Off)],[(statusText = ?)]],],],],
generateActivityFeedsEvent: 
getTempInLocalScale: [(temp = device.currentState(state))][(scaledTemp = this.convertTemperatureIfNeeded(temp.value.toBigDecimal(), temp.unit).toDouble())][return ((this.getTemperatureScale() == F)) ? scaledTemp.round(0).toInteger() : this.roundC(scaledTemp)]
getTempInLocalScale: [(scaledTemp = this.convertTemperatureIfNeeded(temp.toBigDecimal(), scale).toDouble())][return ((this.getTemperatureScale() == F)) ? scaledTemp.round(0).toInteger() : this.roundC(scaledTemp)]
getTempInDeviceScale: [(temp = device.currentState(state))][If ((temp && temp.value) && temp.unit),,],
getTempInDeviceScale: [If (temp && scale),[return ((F == scale)) ? temp : this.celsiusToFahrenheit(temp).toDouble().round(0).toInteger()],],
roundC: 
Starting Points: []
IT HAS STATE
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: ecobee-thermostat.metadata() is applicable for argument types: (ecobee-thermostat$_run_closure1) values: [ecobee-thermostat$_run_closure1@20b5f2ac]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing hue-bulb.groovy
DECLARED METHODS
initialize: 
installed: 
updated: 
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],
on: 
off: 
setLevel: [If this.verifyPercent(percent),,],
setSaturation: [If this.verifyPercent(percent),,],
setHue: [If this.verifyPercent(percent),,],
setColor: [(events = [])][(validValues = [:])][If this.verifyPercent(value.hue),[(validValues.hue = value.hue)],],[If this.verifyPercent(value.saturation),[(validValues.saturation = value.saturation)],],[If (value.hex != null),[If (value.hex ==~ ^\#([A-Fa-f0-9]){6}$),[(validValues.hex = value.hex)],],,],[If this.verifyPercent(value.level),[(validValues.level = value.level)],],[If ((value.switch == off) || ((value.level != null) && (value.level <= 0))),[(validValues.switch = off)],[(validValues.switch = on)]],[If validValues.isEmpty(),,],
reset: 
setAdjustedColor: [If value,[(adjusted = (value + [:]))][(adjusted.level = null)],],
setColorTemperature: [If value,,],
refresh: 
verifyPercent: [If (percent == null),,[If ((percent >= 0) && (percent <= 100)),,],],
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: hue-bulb.metadata() is applicable for argument types: (hue-bulb$_run_closure1) values: [hue-bulb$_run_closure1@665e9289]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing hub-ip-notifier.groovy
DECLARED METHODS
pageWithIp: [(currentIp = (state.localip) ? state.localip : unknown)][(registerDate = (state.lastRegister) ? state.lastRegister : null)]
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(hub, hubInfo, registrationHandler, [filterEvents:false])]
registrationHandler: [(hubInfo = evt.description.split(,).inject([:], { java.lang.Object map, java.lang.Object token -> ... }))][(state.localip = hubInfo.localip)][(state.lastRegister = new java.util.Date())]
Starting Points: []
IT HAS STATE
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
--app-start--
processing fidure-thermostat.groovy
DECLARED METHODS
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
getMin: 
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
getMax: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parse: [(result = [])][If description?.startsWith(read attr -),[(descMap = this.parseDescriptionAsMap(description))][For descMap.attrs,[(map = [:])][If (descMap.cluster == 0201),,[If (descMap.cluster == 0204),[If (atMap.attrId == 0001),[(map.name = lockLevel)][(map.value = this.getLockMap()[atMap.value])],],,],],[If map,[(result += this.createEvent(map))],],][(descMap = this.parseDescriptionAsMap(description))][For descMap.attrs,[(map = [:])][If (descMap.cluster == 0201),,[If (descMap.cluster == 0204),[If (atMap.attrId == 0001),[(map.name = lockLevel)][(map.value = this.getLockMap()[atMap.value])],],,],],[If map,[(result += this.createEvent(map))],],],],
parseDescriptionAsMap: [(map = (description - read attr - ).split(,).inject([:], { java.lang.Object map, java.lang.Object param -> ... }))][(attrId = map.get(attrId))][(encoding = map.get(encoding))][(value = map.get(value))][(result = map.get(result))][(list = [])][If (this.getDataLengthByType(map.get(encoding)) < map.get(value).length()),[(raw = map.get(raw))][(size = java.lang.Long.parseLong(( + map.get(size)), 16))][(index = 12)][(len = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While ((index - 12) < size),[(attrId = this.flipHexStringEndianness(raw[(index..(index + 3))]))][(index += 4)][If (result == success),[(index += 2)],],[(encoding = raw[(index..(index + 1))])][(index += 2)][(len = this.getDataLengthByType(encoding))][(value = this.flipHexStringEndianness(raw[(index..((index + len) - 1))]))][(index += len)][(list += [attrId:$attrId, encoding:$encoding, value:$value])]][(raw = map.get(raw))][(size = java.lang.Long.parseLong(( + map.get(size)), 16))][(index = 12)][(len = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While ((index - 12) < size),[(attrId = this.flipHexStringEndianness(raw[(index..(index + 3))]))][(index += 4)][If (result == success),[(index += 2)],],[(encoding = raw[(index..(index + 1))])][(index += 2)][(len = this.getDataLengthByType(encoding))][(value = this.flipHexStringEndianness(raw[(index..((index + len) - 1))]))][(index += len)][(list += [attrId:$attrId, encoding:$encoding, value:$value])]],[(list += [attrId:$attrId, encoding:$encoding, value:$value])]],[(map += [attrs:list])]
flipHexStringEndianness: [(s = s.reverse())][(sb = new java.lang.StringBuilder())][For ((i = 0); (i < (s.length() - 1)); (i += 2)),]flipHexStringEndianness: [(s = s.reverse())][(sb = new java.lang.StringBuilder())][For ((i = 0); (i < (s.length() - 1)); (i += 2)),]
getDataLengthByType: [(map = [08:1, 09:2, 0a:3, 0b:4, 0c:5, 0d:6, 0e:7, 0f:8, 10:1, 18:1, 19:2, 1a:3, 1b:4, 1c:5, 1d:6, 1e:7, 1f:8, 20:1, 21:2, 22:3, 23:4, ... ])]
getProgrammingMap: 
getModeMap: 
getFanModeMap: 
getHoldMap: 
updateSetpoint: [(cool = device.currentState(coolingSetpoint)?.value)][(heat = device.currentState(heatingSetpoint)?.value)][(runningMode = device.currentState(runningMode)?.value)][(mode = device.currentState(thermostatMode)?.value)][(value = --)][If ((heat == mode) && (heat != null)),[(value = heat)],[If ((cool == mode) && (cool != null)),[(value = cool)],[If (((auto == mode) && (runningMode == cool)) && (cool != null)),[(value = cool)],[If (((auto == mode) && (runningMode == heat)) && (heat != null)),[(value = heat)],],],],],
raiseSetpoint: 
lowerSetpoint: 
adjustSetpoint: [(runningMode = device.currentState(runningMode)?.value)][(mode = device.currentState(thermostatMode)?.value)][(modeData = 2)][If ((heat == mode) || (heat == runningMode)),[(modeData = 00)],[If ((cool == mode) || (cool == runningMode)),[(modeData = 01)],],],[(amountData = java.lang.String.format(%02X, value)[(-2..-1)])]
getDisplayTemperature: [(t = java.lang.Integer.parseInt($value, 16))][If (this.getTemperatureScale() == C),[(t = ((java.lang.Integer -> java.lang.Integer) ((t + 4) / 10) / 10))],[(t = ((java.lang.Integer -> java.lang.Integer) (10 * this.celsiusToFahrenheit((t / 100))) / 10))]],
updateHoldLabel: [(currentHold = (device?.currentState(setpointHold)?.value) ? device?.currentState(setpointHold)?.value : ...)][(holdExp = device?.currentState(holdExpiary)?.value)][(holdExp = (holdExp) ? holdExp : $new Date().getTime())][If (Hold == attr),[(currentHold = value)],],[If (HoldExp == attr),[(holdExp = value)],],[(past = (new java.util.Date(holdExp.toLong()).getTime() < new java.util.Date().getTime()))][If (HoldExp == attr),[If past,[(currentHold = On)],[(currentHold = Off)]],,],[(holdString = ((currentHold == On)) ? (past) ? Is On : Ends $this.compareWithNow(holdExp.toLong()) : ((currentHold == Off)) ?  is Off :  ...)]
getSetPointHoldDuration: [(holdTime = 0)][If settings.hold_time?.contains(Hours),[(holdTime = java.lang.Integer.parseInt(settings.hold_time[(0..1)].trim()))],[If settings.hold_time?.contains(Day),[(holdTime = (java.lang.Integer.parseInt(settings.hold_time[(0..1)].trim()) * 24))],],],[(currentHoldDuration = device.currentState(setpointHoldDuration)?.value)][If (java.lang.Short.parseShort((0 + (currentHoldDuration) ? currentHoldDuration : 0)) != (holdTime * 60)),,],
Hold: [(currentHold = device.currentState(setpointHold)?.value)][(next = ((currentHold == On)) ? 00 : 01)][(nextHold = this.getHoldMap()[next])]
compareWithNow: [(mins = (new java.util.Date(d).getTime() - new java.util.Date().getTime()))][(mins /= (1000 * 60))][(past = (mins < 0))][(ret = (past) ?  : in )][If past,[(mins *= -1)],],[(t = 0)][If (mins < 60),[(ret += (((java.lang.Integer -> java.lang.Integer) mins +  min) + ((mins > 1)) ? s : ))],[If (mins < 1440),[(t = ((java.lang.Integer -> java.lang.Integer) java.lang.Math.round(((14 + mins) / 30)) / 2))][(ret += ((t +  hr) + ((t > 1)) ? s : ))],[(t = ((java.lang.Integer -> java.lang.Integer) java.lang.Math.round(((359 + mins) / 720)) / 2))][(ret += ((t +  day) + ((t > 1)) ? s : ))]],],[(ret += (past) ?  ago : )]
convertToTime: [(time = (long) java.lang.Integer.parseInt($data, 16))][(time *= 1000)][(time += 946684800000)][(time -= (location.timeZone.getRawOffset() + location.timeZone.getDSTSavings()))][(d = new java.util.Date(time))]
Program: [(currentSched = device.currentState(prorgammingOperation)?.value)][(next = java.lang.Integer.parseInt((currentSched) ? currentSched : 00, 16))][If ((next & 1) == 1),[(next = (next & 254))],[(next = (next | 1))]],[(nextSched = this.getProgrammingMap()[(next & 1)])]
getThermostatOperatingState: [(m = [heating, cooling, fan, Heat2, Cool2, Fan2, Fan3])][(desc = idle)][(value = java.lang.Integer.parseInt(( + value), 16))][For (0..2),[If (value & (1 << i)),[(desc = m[i])],],]getThermostatOperatingState: [(m = [heating, cooling, fan, Heat2, Cool2, Fan2, Fan3])][(desc = idle)][(value = java.lang.Integer.parseInt(( + value), 16))][For (0..2),[If (value & (1 << i)),[(desc = m[i])],],]
checkLastTimeSync: [(lastSync = device.currentState(lastTimeSync)?.value)][If lastSync,[(lastSync = $new Date(0))],],[If (settings.sync_clock) ? settings.sync_clock : (false && (lastSync != new java.util.Date(0))),,],[(duration = (new java.util.Date().getTime() - new java.util.Date(lastSync).getTime()))][If (duration > 86400000),,],
readAttributesCommand: [(attrString = )][For attribList,[(attrString += (  + java.lang.String.format(%02X %02X, (val & 255), ((val >> 8) & 255))))]]readAttributesCommand: [(attrString = )][For attribList,[(attrString += (  + java.lang.String.format(%02X %02X, (val & 255), ((val >> 8) & 255))))]]
refresh: 
poll: 
getTemperature: [(celsius = (java.lang.Integer.parseInt($value, 16) / 100))][If (this.getTemperatureScale() == C),,],
setHeatingSetpoint: [(temperatureScale = this.getTemperatureScale())][(degreesInteger = (java.lang.Integer -> java.lang.Integer) degrees)][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))]
setCoolingSetpoint: [(degreesInteger = (java.lang.Integer -> java.lang.Integer) degrees)][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))]
modes: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
setThermostatFanMode: [(currentFanMode = device.currentState(thermostatFanMode)?.value)][(returnCommand = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)]
setThermostatMode: [(currentMode = device.currentState(thermostatMode)?.value)][(modeOrder = this.modes())][(index = modeOrder.indexOf(currentMode))][(next = (((index >= 0) && (index < (modeOrder.size() - 1)))) ? modeOrder[(index + 1)] : modeOrder[0])]
setThermostatMode: [(val = (this.getModeMap().find({ -> ... })?.key) ? this.getModeMap().find({ -> ... })?.key : 00)]
setThermostatFanMode: 
off: 
cool: 
heat: 
auto: 
on: 
fanOn: 
fanAuto: 
updated: [(lastSync = device.currentState(lastTimeSync)?.value)][If ((settings.sync_clock) ? settings.sync_clock : false == false),,],
getLockMap: 
lock: [(currentLock = device.currentState(lockLevel)?.value)][(val = this.getLockMap().find({ -> ... })?.key)][If (val == 00),[(val = this.getLockMap().find({ -> ... })?.key)],[(val = 00)]],
setThermostatTime: [If (settings.sync_clock) ? settings.sync_clock : false,,],[(date = new java.util.Date())][(zone = ((location.timeZone.getRawOffset() +  DST ) + location.timeZone.getDSTSavings()))][(millis = date.getTime())][(millis -= 946684800000)][(millis += (location.timeZone.getRawOffset() + location.timeZone.getDSTSavings()))][(millis /= 1000)][(s = java.lang.String.format(%08X, millis))][(data = (((((((  + s.substring(6, 8)) +  ) + s.substring(4, 6)) +  ) + s.substring(2, 4)) +  ) + s.substring(0, 2)))]
configure: 
hex: 
getEndpointId: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: fidure-thermostat.metadata() is applicable for argument types: (fidure-thermostat$_run_closure1) values: [fidure-thermostat$_run_closure1@58bf8650]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing darken-behind-me.groovy
DECLARED METHODS
installed: [this.subscribe(motion1, motion.inactive, motionInactiveHandler)]
updated: [this.unsubscribe()][this.subscribe(motion1, motion.inactive, motionInactiveHandler)]
motionInactiveHandler: 
Starting Points: []
req caps: [capability.motionsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[motion, switch]
Methods below
installed
updated
motioninactivehandler
called cap-methods by app
off
called cap-props by app
motion
attribute uses through subscriptions
motion
cmd overpriv:[on]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing coopboss-h3vx.groovy
DECLARED METHODS
parse: [(map = [:])][If description?.startsWith(catchall:),[(map = this.parseCatchAllMessage(description))],[If description?.startsWith(read attr -),[(map = this.parseReportAttributeMessage(description))],[If (description?.startsWith(temperature: ) || description?.startsWith(humidity: )),[(map = this.parseCustomMessage(description))],],],],
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseCatchAllMessage: [(resultMap = [:])][(cluster = zigbee.parse(description))][If (cluster.clusterId == 1026),,],[If ((cluster.clusterId == 257) && (cluster.command == 11)),,],
parseReportAttributeMessage: [(resultMap = [:])][(descMap = this.parseDescriptionAsMap(description))][If ((descMap.cluster == 0101) && (descMap.attrId == 0003)),[(resultMap.name = doorState)][If (descMap.value == 00),[(resultMap.value = unknown)],[If (descMap.value == 01),[(resultMap.value = closed)],[If (descMap.value == 02),[(resultMap.value = open)],[If (descMap.value == 03),[(resultMap.value = jammed)],[If (descMap.value == 04),[(resultMap.value = forced close)],[If (descMap.value == 05),[(resultMap.value = forced close)],[If (descMap.value == 06),[(resultMap.value = closing)],[If (descMap.value == 07),[(resultMap.value = opening)],[If (descMap.value == 08),[(resultMap.value = fault)],[(resultMap.value = unknown)]],],],],],],],],],[(resultMap.descriptionText = Door State Changed to $resultMap.value)],[If ((descMap.cluster == 0101) && (descMap.attrId == 0400)),[(resultMap.name = currentLightLevel)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.displayed = false)],[If ((descMap.cluster == 0101) && (descMap.attrId == 0401)),[(resultMap.name = closeLightLevel)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0402)),[(resultMap.name = openLightLevel)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0403)),[(resultMap.name = autoCloseEnable)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 0404)),[(resultMap.name = autoOpenEnable)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 0405)),[(resultMap.name = doorCurrent)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.value = (resultMap.value * 0.001))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0408)),[(resultMap.name = doorSensitivity)][(resultMap.value = (100 - java.lang.Integer.parseInt(descMap.value, 16)))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0409)),[(resultMap.name = baseDoorCurrent)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.value = (resultMap.value * 0.001))],[If ((descMap.cluster == 0101) && (descMap.attrId == 040a)),[(resultMap.name = doorVoltage)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.value = (resultMap.value * 0.001))],[If ((descMap.cluster == 0101) && (descMap.attrId == 040b)),[(resultMap.name = Aux1)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 040c)),[(resultMap.name = Aux2)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 040d)),[(resultMap.name = photoCalibration)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],[If ((descMap.cluster == 0101) && (descMap.attrId == 040e)),[(resultMap.name = baseCurrentNE)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],],],],],],],],],],],],],],],
parseCustomMessage: [(resultMap = [:])][If description?.startsWith(temperature: ),[(resultMap.name = temperature)][(rawT = (description - temperature: ).trim())][(resultMap.descriptionText = Temperature celsius value = $rawT)][(rawTint = java.lang.Float.parseFloat(rawT))][If (rawTint > 65),[(resultMap.name = null)][(resultMap.value = null)][(resultMap.descriptionText = Temperature celsius value = $rawT is invalid not updating)][log.warn(Invalid temperature value detected! rawT = $rawT, description = $description)],[If (rawT == -32768),[(resultMap.value = ERR)],[(resultMap.value = (java.lang.Float -> java.lang.Float) this.celsiusToFahrenheit(rawT.toFloat()))]],],,],[(resultMap.displayed = false)][log.info(Temperature reported = $resultMap.value)]
parseDescriptionAsMap: 
getFahrenheit: [(celsius = java.lang.Integer.parseInt(value, 16))]
callUpdateStatusTxt: [(cTemp = device.currentState(TempProb1)?.value)][(cLight = 0)][(testNull = device.currentState(currentLightLevel)?.value)][If (testNull != null),[(cLight = (int) device.currentState(currentLightLevel)?.value)],],
updateStatusTxt: [(cTmp = currentTemp)][(cLL = 10)][(oLL = 10)][(testNull = device.currentState(closeLightLevel)?.value)][If (testNull != null),[(cLL = (int) device.currentState(closeLightLevel)?.value)],],[(testNull = device.currentState(openLightLevel)?.value)][If (testNull != null),[(oLL = (int) device.currentState(openLightLevel)?.value)],],[(aOpnEn = device.currentState(autoOpenEnable)?.value)][(aClsEn = device.currentState(autoCloseEnable)?.value)][If (currentLight < cLL),[If (aOpnEn == on),,],,[If (aClsEn == on),,],],
on: 
off: 
close: 
open: 
Aux1On: 
Aux1Off: 
Aux2On: 
Aux2Off: 
openDoor: 
closeDoor: 
closeDoorHiI: 
autoOpenOn: 
autoOpenOff: 
autoCloseOn: 
autoCloseOff: 
setOpenLevelTo: [(cX = cValue)][(cmd = [])]
setCloseLevelTo: [(cX = cValue)][(cmd = [])]
setSensitivityLevel: [(cX = (100 - cValue))][(cmd = [])]
setNewBaseCurrent: [(cX = (int) cValue)][log.info(Setting new BaseCurrent to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]
setNewPhotoCalibration: [(cX = (int) cValue)][log.info(Setting new Photoresister calibration to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]
readNewPhotoCalibration: [(cmd = [])]
readBaseCurrentNE: [(cmd = [])]
setBaseCurrentNE: [(cX = (int) cValue)][log.info(Setting new base Current Never Exceed to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]
poll: [(cmd = [])]
updateTemp1: [(cmd = [])]
updateTemp2: [(cmd = [])]
updateSun: [(cmd = [])]
updateSensitivity: [(cmd = [])]
updateCloseLightLevel: [(cmd = [])]
updateOpenLightLevel: [(cmd = [])]
refresh: [(cmd = [])]
configure: [(cmd = [])]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: coopboss-h3vx.metadata() is applicable for argument types: (coopboss-h3vx$_run_closure1) values: [coopboss-h3vx$_run_closure1@1992eaf4]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing make-it-so.groovy
DECLARED METHODS
installed: [this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
updated: [this.unsubscribe()][this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
appTouch: 
changedLocationMode: 
restoreState: [(map = (state[mode]) ? state[mode] : [:])]
saveState: [(mode = currentMode)][(map = (state[mode]) ? state[mode] : [:])][(state[mode] = map)]
getCurrentMode: 
Starting Points: []
req caps: [capability.lock, capability.thermostat, capability.switch]
req cap size: 3
requested commands:[heat, setheatingsetpoint, auto, unlock, cool, setthermostatmode, off, setcoolingsetpoint, lock, fanon, emergencyheat, fancirculate, setthermostatfanmode, on, fanauto]
requested attrs:[coolingsetpoint, thermostatfanmode, thermostatmode, temperature, lock, heatingsetpoint, thermostatoperatingstate, thermostatsetpoint, switch]
Methods below
installed
updated
apptouch
changedlocationmode
restorestate
savestate
getcurrentmode
type 2 command uses
setlevel
type 2 attr uses
level
called cap-methods by app
setheatingsetpoint
unlock
setcoolingsetpoint
lock
off
on
called cap-props by app
coolingsetpoint
lock
heatingsetpoint
switch
attribute uses through subscriptions
cmd overpriv:[heat, auto, cool, setthermostatmode, fanon, emergencyheat, fancirculate, setthermostatfanmode, fanauto]
attr overpriv:[thermostatfanmode, thermostatmode, temperature, thermostatoperatingstate, thermostatsetpoint]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, bdefadfd-d59f-4d54-82c2-5fbb3ac6965f, 8aa8a6b23f769c09013f769ed1c20012]
[[capability.battery, capability.polling, capability.refresh]]
--app-start--
processing coffee-after-shower.groovy
DECLARED METHODS
installed: [this.subscribe(bathroom, humidity, coffeeMaker)]
updated: [this.unsubscribe()][this.subscribe(bathroom, humidity, coffeeMaker)]
coffeeMaker: [If (shower.value.toInteger() > relHum),,],
Starting Points: []
req caps: [capability.relativehumiditymeasurement, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[humidity, switch]
Methods below
installed
updated
coffeemaker
called cap-methods by app
on
called cap-props by app
humidity
attribute uses through subscriptions
humidity
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, ba155665-433d-4e20-9d12-efad7744c3d6]
[[capability.temperaturemeasurement]]
--app-start--
processing netatmo-additional-module.groovy
DECLARED METHODS
parse: 
poll: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: netatmo-additional-module.metadata() is applicable for argument types: (netatmo-additional-module$_run_closure1) values: [netatmo-additional-module$_run_closure1@7651218e]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing netatmo-basestation.groovy
DECLARED METHODS
parse: 
poll: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: netatmo-basestation.metadata() is applicable for argument types: (netatmo-basestation$_run_closure1) values: [netatmo-basestation$_run_closure1@7c351808]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing double-tap.groovy
DECLARED METHODS
installed: [this.subscribe(master, switch, switchHandler, [filterEvents:false])]
updated: [this.unsubscribe()][this.subscribe(master, switch, switchHandler, [filterEvents:false])]
switchHandler: [(recentStates = master.eventsSince(new java.util.Date((this.now() - 4000)), [all:true, max:10]).findAll({ -> ... }))][If evt.physical,[If ((evt.value == on) && this.lastTwoStatesWere(on, recentStates, evt)),,[If ((evt.value == off) && this.lastTwoStatesWere(off, recentStates, evt)),,],],,],
onSwitches: 
offSwitches: 
lastTwoStatesWere: [(result = false)][If states,[(onOff = states.findAll({ -> ... }))][If onOff[0].date.before(evt.date),[log.warn(Last state does not reflect current event, evt.date: $evt.dateCreated, state.date: $onOff[0].dateCreated)][(result = ((evt.value == value) && (onOff[0].value == value)))],[(result = (((onOff.size() > 1) && (onOff[0].value == value)) && (onOff[1].value == value)))]],,],
Starting Points: []
IT HAS STATE
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
Methods below
installed
updated
switchhandler
onswitches
offswitches
lasttwostateswere
called cap-methods by app
called cap-props by app
switch
attribute uses through subscriptions
switch
cmd overpriv:[off, on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing mobile-presence.groovy
DECLARED METHODS
parse: [(name = this.parseName(description))][(value = this.parseValue(description))][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(handlerName = this.getState(value))][(isStateChange = this.isStateChange(device, name, value))][(results = [translatable:true, name:name, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName, ... ])]
parseName: [If description?.startsWith(presence: ),,],
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseValue: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseDescriptionText: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
getState: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: mobile-presence.metadata() is applicable for argument types: (mobile-presence$_run_closure1) values: [mobile-presence$_run_closure1@4c168660]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing life360-user.groovy
DECLARED METHODS
generatePresenceEvent: [(value = this.formatValue(present))][(linkText = this.getLinkText(device))][(descriptionText = this.formatDescriptionText(linkText, present))][(handlerName = this.getState(present))][(results = [name:presence, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName])]
setMemberId: [(state.life360MemberId = memberId)]
getMemberId: [return state.life360MemberId]
formatValue: [If present,,],
formatDescriptionText: [If present,,],
getState: [If present,,],
Starting Points: []
IT HAS STATE
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: life360-user.metadata() is applicable for argument types: (life360-user$_run_closure1) values: [life360-user$_run_closure1@89c10b7]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing button-capability.groovy
DECLARED METHODS
parse: [(results = [])][If description.startsWith(Err),[(results = this.createEvent([descriptionText:description, displayed:true]))],[(cmd = zwave.parse(description, [43:1, 128:1, 132:1]))][If cmd,[(results += this.zwaveEvent(cmd))],],[If results,[(results = [descriptionText:cmd, displayed:false])],],],
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: button-capability.metadata() is applicable for argument types: (button-capability$_run_closure1) values: [button-capability$_run_closure1@64337702]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing good-night-house.groovy
DECLARED METHODS
installed: [this.subscribe(app, appTouch)]
updated: [this.unsubscribe()][this.subscribe(app, appTouch)]
appTouch: [If (location.mode != newMode),,],[(delay = (((waitfor != null) && (waitfor != ))) ? (waitfor * 1000) : 120000)]
Starting Points: []
req caps: [capability.lock, capability.switch]
req cap size: 2
requested commands:[lock, unlock, off, on]
requested attrs:[lock, switch]
Methods below
installed
updated
apptouch
called cap-methods by app
lock
off
on
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[unlock]
attr overpriv:[lock, switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, bdefadfd-d59f-4d54-82c2-5fbb3ac6965f]
[[capability.battery, capability.polling, capability.refresh]]
--app-start--
processing dry-the-wetspot.groovy
DECLARED METHODS
installed: [this.subscribe(sensor, water.dry, waterHandler)][this.subscribe(sensor, water.wet, waterHandler)]
updated: [this.unsubscribe()][this.subscribe(sensor, water.dry, waterHandler)][this.subscribe(sensor, water.wet, waterHandler)]
waterHandler: [If (evt.value == wet),,[If (evt.value == dry),,],],
Starting Points: []
req caps: [capability.switch, capability.watersensor]
req cap size: 2
requested commands:[off, on]
requested attrs:[water, switch]
Methods below
installed
updated
waterhandler
called cap-methods by app
off
on
called cap-props by app
water
attribute uses through subscriptions
water
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, 1e88cabe-5ba4-4647-9a23-0ad5b887f94b]
[[capability.battery]]
--app-start--
processing feed-my-pet.groovy
DECLARED METHODS
installed: 
updated: 
scheduleCheck: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
--app-start--
processing ecobee-sensor.groovy
DECLARED METHODS
refresh: 
poll: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: ecobee-sensor.metadata() is applicable for argument types: (ecobee-sensor$_run_closure1) values: [ecobee-sensor$_run_closure1@69c79f09]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing camera-power-scheduler.groovy
DECLARED METHODS
installed: 
updated: 
initialize: [If startTime,,],[If endTime,,],
turnOnCamera: 
turnOffCamera: 
Starting Points: []
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
Methods below
installed
updated
initialize
turnoncamera
turnoffcamera
called cap-methods by app
off
on
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing child-button.groovy
DECLARED METHODS
installed: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: child-button.metadata() is applicable for argument types: (child-button$_run_closure1) values: [child-button$_run_closure1@60bdf15d]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing harmony-activity.groovy
DECLARED METHODS
parse: 
on: 
off: 
huboff: 
alloff: 
refresh: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: harmony-activity.metadata() is applicable for argument types: (harmony-activity$_run_closure1) values: [harmony-activity$_run_closure1@37f21974]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing brighten-my-path.groovy
DECLARED METHODS
installed: [this.subscribe(motion1, motion.active, motionActiveHandler)]
updated: [this.unsubscribe()][this.subscribe(motion1, motion.active, motionActiveHandler)]
motionActiveHandler: 
Starting Points: []
req caps: [capability.motionsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[motion, switch]
Methods below
installed
updated
motionactivehandler
called cap-methods by app
on
called cap-props by app
motion
attribute uses through subscriptions
motion
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing lock-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]
lock: 
unlock: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: lock-capability.metadata() is applicable for argument types: (lock-capability$_run_closure1) values: [lock-capability$_run_closure1@3954d008]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing door-state-to-color-light-hue-bulb.groovy
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(doorSensor, doorState, coopDoorStateHandler)]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
coopDoorStateHandler: [(color = White)][(hueColor = 100)][(saturation = 100)][(hClr = [:])][(hClr.hex = #FFFFFF)]
Starting Points: []
req caps: [capability.colorcontrol, capability.doorcontrol]
req cap size: 2
requested commands:[setsaturation, sethue, setcolor, close, open]
requested attrs:[saturation, hue, door, color]
Methods below
installed
updated
initialize
coopdoorstatehandler
called cap-methods by app
setsaturation
setcolor
sethue
called cap-props by app
door
attribute uses through subscriptions
doorstate
cmd overpriv:[close, open]
attr overpriv:[saturation, hue, color]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [48b39485-7ebc-4c80-bf6e-9a653a2d1c95, 548b3451-701a-4244-b66a-40d08564dc47]
[[capability.switchlevel, capability.contactsensor, capability.switch, capability.refresh]]
--app-start--
processing gentle-wake-up-controller.groovy
DECLARED METHODS
parse: 
on: 
off: 
setTimeRemaining: 
start: 
stop: 
pause: 
cancel: 
startDimming: 
stopDimming: 
controllerEvent: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: gentle-wake-up-controller.metadata() is applicable for argument types: (gentle-wake-up-controller$_run_closure1) values: [gentle-wake-up-controller$_run_closure1@71104a4]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing color-coordinator.groovy
DECLARED METHODS
mainPage: 
installed: 
updated: [this.unsubscribe()]
init: [this.subscribe(master, switch, onOffHandler)][this.subscribe(master, level, colorHandler)][this.subscribe(master, hue, colorHandler)][this.subscribe(master, saturation, colorHandler)][this.subscribe(master, colorTemperature, tempHandler)]
onOffHandler: [If (slaves && master),[If slaves?.id.find({ -> ... }),[If (master?.currentValue(switch) == on),[If randomYes,,],,],,],,],
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
colorHandler: [If (slaves && master),[If (slaves?.id?.find({ -> ... }) && (master?.currentValue(switch) == on)),[(dimLevel = master?.currentValue(level))][(hueLevel = master?.currentValue(hue))][(saturationLevel = master.currentValue(saturation))][(newValue = [hue:hueLevel, saturation:saturationLevel, level:(java.lang.Integer -> java.lang.Integer) dimLevel])],],,],
getRandomColorMaster: [(hueLevel = java.lang.Math.floor((java.lang.Math.random() * 1000)))][(saturationLevel = java.lang.Math.floor((java.lang.Math.random() * 100)))][(dimLevel = master?.currentValue(level))][(newValue = [hue:hueLevel, saturation:saturationLevel, level:(java.lang.Integer -> java.lang.Integer) dimLevel])]
tempHandler: [If (slaves && master),[If (slaves?.id?.find({ -> ... }) && (master?.currentValue(switch) == on)),[If (evt.value != --),[(tempLevel = master.currentValue(colorTemperature))],],,],,],
textAppName: [(text = Color Coordinator)]
textVersion: [(text = Version 1.1.1 (12/13/2016))]
textCopyright: [(text = Copyright © 2016 Michael Struck)]
textLicense: [(text = ((((((((((Licensed under the Apache License, Version 2.0 (the 'License');  + you may not use this file except in compliance with the License. ) + You may obtain a copy of the License at) + 

) +     http://www.apache.org/licenses/LICENSE-2.0) + 

) + Unless required by applicable law or agreed to in writing, software ) + distributed under the License is distributed on an 'AS IS' BASIS, ) + WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ) + See the License for the specific language governing permissions and ) + limitations under the License.))]
textHelp: [(text = ((This application will allow you to control the settings of multiple colored lights with one control.  + Simply choose a master control light, and then choose the lights that will follow the settings of the master, ) + including on/off conditions, hue, saturation, level and color temperature. Also includes a random color feature.))]
Starting Points: []
req caps: [capability.colorcontrol]
req cap size: 1
requested commands:[sethue, setcolor, setsaturation]
requested attrs:[saturation, color, hue]
Methods below
mainpage
installed
updated
init
onoffhandler
colorhandler
getrandomcolormaster
temphandler
textappname
textversion
textcopyright
textlicense
texthelp
type 2 command uses
setcolortemperature
off
on
type 2 attr uses
colortemperature
level
switch
called cap-methods by app
setcolor
called cap-props by app
saturation
hue
attribute uses through subscriptions
saturation
hue
colortemperature
level
switch
cmd overpriv:[sethue, setsaturation]
attr overpriv:[color]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [48b39485-7ebc-4c80-bf6e-9a653a2d1c95]
[[capability.refresh]]
--app-start--
processing device-tile-controller.groovy
DECLARED METHODS
defaultPage: 
installed: 
uninstalled: 
updated: [this.unsubscribe()]
initializeDevices: 
labelMap: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
--app-start--
processing lights-off-when-closed.groovy
DECLARED METHODS
installed: [this.subscribe(contact1, contact.closed, contactClosedHandler)]
updated: [this.unsubscribe()][this.subscribe(contact1, contact.closed, contactClosedHandler)]
contactClosedHandler: 
Starting Points: []
req caps: [capability.contactsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[contact, switch]
Methods below
installed
updated
contactclosedhandler
called cap-methods by app
off
called cap-props by app
contact
attribute uses through subscriptions
contact
cmd overpriv:[on]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing every-element.groovy
DECLARED METHODS
firstPage: 
inputPage: 
inputBooleanPage: 
inputIconPage: 
inputImagePage: 
optionsGroup: [(group = [values:[], order:groups.size()])][(group.title = (title) ? title : )]
addValues: [(lastGroup = groups[-1])]
listToMap: 
addGroup: [If (values instanceof java.util.List),[(values = this.listToMap(values))],],
addGroup: 
inputSelectionPage: [(englishOptions = [One, Two, Three])][(spanishOptions = [Uno, Dos, Tres])][(groupedOptions = [])]
inputTextPage: 
inputTimePage: 
inputDevicePage: 
inputCapabilityPage: 
inputRoomPage: 
inputModePage: 
inputHubPage: 
inputContactBookPage: 
appPage: 
labelPage: 
modePage: 
paragraphPage: 
hrefPage: 
buttonsPage: 
imagePage: 
videoPage: 
flattenedPage: [(allSections = [])][(flattenedPage = this.dynamicPage([name:flattenedPage, title:All elements in one page!], { -> ... }))][(flattenedPage.sections = allSections)]
foo: 
installed: 
updated: [this.unsubscribe()]
initialize: 
Starting Points: []
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
Methods below
firstpage
inputpage
inputbooleanpage
inputiconpage
inputimagepage
optionsgroup
addvalues
listtomap
addgroup
addgroup
inputselectionpage
inputtextpage
inputtimepage
inputdevicepage
inputcapabilitypage
inputroompage
inputmodepage
inputhubpage
inputcontactbookpage
apppage
labelpage
modepage
paragraphpage
hrefpage
buttonspage
imagepage
videopage
flattenedpage
foo
installed
updated
initialize
called cap-methods by app
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[off, on]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e]
[[capability.switch]]
--app-start--
processing hall-light-welcome-home.groovy
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
init: [(state.lastClosed = this.now())][this.subscribe(people, presence.present, presence)][this.subscribe(sensors, contact.open, doorOpened)]
presence: [(delay = (contactDelay) ? contactDelay : 10)][(state.lastPresence = this.now())][If ((this.now() - (delay * 1000)) < state.lastContact),,],
doorOpened: [(delay = (presenceDelay) ? presenceDelay : 30)][(state.lastContact = this.now())][If ((this.now() - (delay * 1000)) < state.lastPresence),,],
Starting Points: []
IT HAS STATE
req caps: [capability.contactsensor, capability.switch, capability.presencesensor]
req cap size: 3
requested commands:[off, on]
requested attrs:[presence, contact, switch]
Methods below
installed
updated
init
presence
dooropened
called cap-methods by app
on
called cap-props by app
presence
contact
attribute uses through subscriptions
presence
contact
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing big-turn-off.groovy
DECLARED METHODS
installed: [this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
updated: [this.unsubscribe()][this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
changedLocationMode: 
appTouch: 
Starting Points: []
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
Methods below
installed
updated
changedlocationmode
apptouch
called cap-methods by app
off
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[on]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing let-there-be-light.groovy
DECLARED METHODS
installed: [this.subscribe(contact1, contact, contactHandler)]
updated: [this.unsubscribe()][this.subscribe(contact1, contact, contactHandler)]
contactHandler: [If (evt.value == open),,[If (evt.value == closed),,],],
Starting Points: []
req caps: [capability.contactsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[contact, switch]
Methods below
installed
updated
contacthandler
called cap-methods by app
off
on
called cap-props by app
contact
attribute uses through subscriptions
contact
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing door-shield.groovy
DECLARED METHODS
parse: [(value = zigbee.parse(description)?.text)][(name = ((value && (value != ping))) ? response : null)][(result = this.createEvent([name:name, value:value]))]
open: 
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: door-shield.metadata() is applicable for argument types: (door-shield$_run_closure1) values: [door-shield$_run_closure1@35d6ca49]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing bright-when-dark-and-or-bright-after-sunset.groovy
DECLARED METHODS
configurations: 
options: [If ((dark == true) && (sun == true)),,[If ((dark == true) && (sun == false)),,[If ((sun == true) && (dark == false)),,],],],
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(motionSensor, motion, motionHandler)][If ((((lights != null) && (lights != )) && (dimmers != null)) && (dimmers != )),[this.subscribe(lights, switch, lightsHandler)][this.subscribe(dimmers, switch, dimmersHandler)][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[this.subscribe(lightSensor, illuminance, illuminanceHandler, [filterEvents:false])],],[If (sun == true),[this.subscribe(location, position, locationPositionChange)][this.subscribe(location, sunriseTime, sunriseSunsetTimeHandler)][this.subscribe(location, sunsetTime, sunriseSunsetTimeHandler)],[If ((dark != true) && (sun != true)),,],],,[If ((lights != null) && (lights != )),[this.subscribe(lights, switch, lightsHandler)][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[this.subscribe(lightSensor, illuminance, illuminanceHandler, [filterEvents:false])],],[If (sun == true),[this.subscribe(location, position, locationPositionChange)][this.subscribe(location, sunriseTime, sunriseSunsetTimeHandler)][this.subscribe(location, sunsetTime, sunriseSunsetTimeHandler)],[If ((dark != true) && (sun != true)),,],],,[If ((dimmers != null) && (dimmers != )),[this.subscribe(dimmers, switch, dimmersHandler)][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[this.subscribe(lightSensor, illuminance, illuminanceHandler, [filterEvents:false])],],[If (sun == true),[this.subscribe(location, position, locationPositionChange)][this.subscribe(location, sunriseTime, sunriseSunsetTimeHandler)][this.subscribe(location, sunsetTime, sunriseSunsetTimeHandler)],[If ((dark != true) && (sun != true)),,],],,],],],[If ((lights != null) && (lights != )),[If lights.currentValue(switch).toString().contains(on),[(state.lightsState = on)],[If lights.currentValue(switch).toString().contains(off),[(state.lightsState = off)],],],,],[If ((dimmers != null) && (dimmers != )),[If dimmers.currentValue(switch).toString().contains(on),[(state.dimmersState = on)],[If dimmers.currentValue(switch).toString().contains(off),[(state.dimmersState = off)],],],,],
locationPositionChange: 
sunriseSunsetTimeHandler: [(state.lastSunriseSunsetEvent = this.now())]
motionHandler: [If (evt.value == active),[If ((dark == true) && (sun == true)),[If ((darkOk == true) && (sunOk == true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((darkOk == true) && (sunOk != true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((darkOk != true) && (sunOk == true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],],,[If ((dark == true) && (sun != true)),[If (darkOk == true),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],,[If ((dark != true) && (sun == true)),[If (sunOk == true),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],,[If ((dark != true) && (sun != true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],],],,[If (evt.value == inactive),[If ((state.lightsState != off) || (state.dimmersState != off)),[If delayMinutes,[(delay = (delayMinutes * 60))][If ((dark == true) && (sun == true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((dark == true) && (sun != true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((dark != true) && (sun == true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((dark != true) && (sun != true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],],],,],,[If ((state.lightsState == off) && (state.dimmersState == off)),,],],,],],
lightsHandler: [If (evt.value == on),[(state.lightsState = on)],[If (evt.value == off),[(state.lightsState = off)],],],
dimmersHandler: [If (evt.value == on),[(state.dimmersState = on)],[If (evt.value == off),[(state.dimmersState = off)],],],
illuminanceHandler: [If (evt.integerValue > 999),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If (evt.integerValue > (((luxLevel != null) && (luxLevel != ))) ? luxLevel : 50),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],
turnOnLights: [If allOk,[If (state.lightsState != on),[(state.lightsState = on)],],,],
turnOnDimmers: [If allOk,[If (state.dimmersState != on),[(state.dimmersState = on)],],,],
turnOffLights: [If allOk,[If (state.lightsState != off),[(state.lightsState = on)],],,],
turnOffDimmers: [If allOk,[If (state.dimmersState != off),[(state.dimmersState = off)],],,],
astroCheck: [(s = this.getSunriseAndSunset([zipCode:zipCode, sunriseOffset:sunriseOffset, sunsetOffset:sunsetOffset]))][(state.riseTime = s.sunrise.time)][(state.setTime = s.sunset.time)]
getDarkOk: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[(result = (lightSensor.currentIlluminance < (((luxLevel != null) && (luxLevel != ))) ? luxLevel : 50))],],[log.trace(darkOk = $result)]
getSunOk: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (sun == true),[(t = this.now())][(result = ((t < state.riseTime) || (t > state.setTime)))],],[log.trace(sunOk = $result)]
getSunriseOffset: [(sunriseOffsetValue) ? ((sunriseOffsetDir == Before)) ? -$sunriseOffsetValue : sunriseOffsetValue : null]
getSunsetOffset: [(sunsetOffsetValue) ? ((sunsetOffsetDir == Before)) ? -$sunsetOffsetValue : sunsetOffsetValue : null]
getAllOk: 
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting).time)][(stop = this.timeToday(ending).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]
hideOptionsSection: 
timeIntervalLabel: 
Starting Points: []
IT HAS STATE
req caps: [capability.motionsensor, capability.switchlevel, capability.illuminancemeasurement, capability.switch]
req cap size: 4
requested commands:[setlevel, off, on]
requested attrs:[motion, illuminance, level, switch]
Methods below
configurations
options
installed
updated
initialize
locationpositionchange
sunrisesunsettimehandler
motionhandler
lightshandler
dimmershandler
illuminancehandler
turnonlights
turnondimmers
turnofflights
turnoffdimmers
astrocheck
getdarkok
getsunok
getsunriseoffset
getsunsetoffset
getallok
getmodeok
getdaysok
gettimeok
hhmm
hideoptionssection
timeintervallabel
called cap-methods by app
setlevel
off
on
called cap-props by app
motion
illuminance
switch
attribute uses through subscriptions
motion
illuminance
switch
cmd overpriv:[]
attr overpriv:[level]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing lights-off-with-no-motion-and-presence.groovy
DECLARED METHODS
installed: [this.subscribe(motionSensor, motion, motionHandler)][this.subscribe(presenceSensors, presence, presenceHandler)]
updated: [this.unsubscribe()][this.subscribe(motionSensor, motion, motionHandler)][this.subscribe(presenceSensors, presence, presenceHandler)]
motionHandler: [If (evt.value == inactive),,],
presenceHandler: [If (evt.value == not present),,],
isActivePresence: [(noPresence = (presenceSensors.find({ -> ... }) == null))]
scheduleCheck: [(motionState = motionSensor.currentState(motion))][If (motionState.value == inactive),[(elapsed = (this.now() - motionState.rawDateCreated.time))][(threshold = (((1000 * 60) * delayMins) - 1000))][If (elapsed >= threshold),[If this.isActivePresence(),,],,],,],
Starting Points: []
req caps: [capability.motionsensor, capability.switch, capability.presencesensor]
req cap size: 3
requested commands:[off, on]
requested attrs:[motion, presence, switch]
Methods below
installed
updated
motionhandler
presencehandler
isactivepresence
schedulecheck
called cap-methods by app
off
called cap-props by app
motion
presence
attribute uses through subscriptions
motion
presence
cmd overpriv:[on]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing let-there-be-dark.groovy
DECLARED METHODS
installed: [this.subscribe(contact1, contact, contactHandler)]
updated: [this.unsubscribe()][this.subscribe(contact1, contact, contactHandler)]
contactHandler: [If (evt.value == open),[(state.wasOn = (switch1.currentValue(switch) == on))],],[If (evt.value == closed),[If state.wasOn,,],,],
Starting Points: []
IT HAS STATE
req caps: [capability.contactsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[contact, switch]
Methods below
installed
updated
contacthandler
called cap-methods by app
off
on
called cap-props by app
contact
switch
attribute uses through subscriptions
contact
switch
cmd overpriv:[]
attr overpriv:[]
--app-start--
processing goodnight-ubi.groovy
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(trigger, switch.on, switchOnHandler)]
switchOnHandler: [(timeDelay = (minutes * 60))][(phrase = )][If (phrase == ),[(phrase = The%20house%20is%20ready%20for%20night.)],[(phrase = ((You%20have%20left%20 + phrase) + open))]],[this.httpGet(https://portal.theubi.com/webapi/behaviour?access_token=$behaviorToken&variable=$phrase)][If (sayPhrase == Yes),,],
lightsOut: [If (theSwitches == ),,],
Starting Points: []
req caps: [capability.contactsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[contact, switch]
Methods below
installed
updated
initialize
switchonhandler
lightsout
called cap-methods by app
off
called cap-props by app
contact
switch
attribute uses through subscriptions
switch
cmd overpriv:[on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing keep-me-cozy.groovy
DECLARED METHODS
installed: [this.subscribe(thermostat, heatingSetpoint, heatingSetpointHandler)][this.subscribe(thermostat, coolingSetpoint, coolingSetpointHandler)][this.subscribe(thermostat, temperature, temperatureHandler)][this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
updated: [this.unsubscribe()][this.subscribe(thermostat, heatingSetpoint, heatingSetpointHandler)][this.subscribe(thermostat, coolingSetpoint, coolingSetpointHandler)][this.subscribe(thermostat, temperature, temperatureHandler)][this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
heatingSetpointHandler: 
coolingSetpointHandler: 
temperatureHandler: 
changedLocationMode: 
appTouch: 
event: 
Starting Points: []
req caps: [capability.thermostat]
req cap size: 1
requested commands:[heat, setheatingsetpoint, auto, cool, setcoolingsetpoint, fanon, setthermostatmode, emergencyheat, fancirculate, off, setthermostatfanmode, fanauto]
requested attrs:[coolingsetpoint, thermostatfanmode, thermostatmode, temperature, heatingsetpoint, thermostatoperatingstate, thermostatsetpoint]
Methods below
installed
updated
heatingsetpointhandler
coolingsetpointhandler
temperaturehandler
changedlocationmode
apptouch
event
type 2 command uses
poll
called cap-methods by app
setcoolingsetpoint
setheatingsetpoint
called cap-props by app
coolingsetpoint
temperature
heatingsetpoint
attribute uses through subscriptions
coolingsetpoint
temperature
heatingsetpoint
cmd overpriv:[heat, auto, cool, fanon, setthermostatmode, emergencyheat, fancirculate, off, setthermostatfanmode, fanauto]
attr overpriv:[thermostatfanmode, thermostatmode, thermostatoperatingstate, thermostatsetpoint]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing garage-door-opener.groovy
subscribeToCommand
subscribeToCommand
DECLARED METHODS
installed: [this.subscribe(app, appTouchHandler)][this.subscribeToCommand(switch1, on, onCommand)]
updated: [this.unsubscribe()][this.subscribe(app, appTouchHandler)][this.subscribeToCommand(switch1, on, onCommand)]
appTouch: 
onCommand: 
Starting Points: []
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
Methods below
installed
updated
apptouch
oncommand
called cap-methods by app
off
on
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
--app-start--
processing arduino-thingshield.groovy
DECLARED METHODS
parse: [(value = zigbee.parse(description)?.text)][(name = ((value && (value != ping))) ? response : null)][(result = this.createEvent([name:name, value:value]))]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: arduino-thingshield.metadata() is applicable for argument types: (arduino-thingshield$_run_closure1) values: [arduino-thingshield$_run_closure1@a50b09c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing alarm-capability.groovy
DECLARED METHODS
strobe: 
siren: 
both: 
off: 
parse: [(pair = description.split(:))]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: alarm-capability.metadata() is applicable for argument types: (alarm-capability$_run_closure1) values: [alarm-capability$_run_closure1@2755d705]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing acceleration-sensor-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
missing method: groovy.lang.MissingMethodException: No signature of method: acceleration-sensor-capability.metadata() is applicable for argument types: (acceleration-sensor-capability$_run_closure1) values: [acceleration-sensor-capability$_run_closure1@5cc5b667]
Possible solutions: metaClass(groovy.lang.Closure)
summary
cmd overpriv:35
attr overpriv:42
num reflection:1
total:53
type2 overprivilege total:21
samename_flags:0
type2 cmd/attr uses:11
numSendSms: 0
numOAuth: 0
numInternet: 1