
--app-start--
processing acceleration-sensor-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: acceleration-sensor-capability.metadata() is applicable for argument types: (acceleration-sensor-capability$_run_closure1) values: [acceleration-sensor-capability$_run_closure1@31fa1761]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing arduino-thingshield.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(value = zigbee.parse(description)?.text)][(name = ((value && (value != ping))) ? response : null)][(result = this.createEvent([name:name, value:value]))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: arduino-thingshield.metadata() is applicable for argument types: (arduino-thingshield$_run_closure1) values: [arduino-thingshield$_run_closure1@4310d43]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing big-turn-off.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
off
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[on]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
updated: [this.unsubscribe()][this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
changedLocationMode: 
appTouch: 
Starting Points: []
--app-start--
processing alarm-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
strobe: 
siren: 
both: 
off: 
parse: [(pair = description.split(:))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: alarm-capability.metadata() is applicable for argument types: (alarm-capability$_run_closure1) values: [alarm-capability$_run_closure1@76a4ebf2]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing bose-soundtouch-control.groovy
req caps: [capability.motionsensor, capability.musicplayer, capability.contactsensor, capability.switch, capability.button, capability.smokedetector, capability.watersensor, capability.accelerationsensor, capability.presencesensor]
req cap size: 9
requested commands:[play, playtrack, mute, playtext, nexttrack, restoretrack, pause, off, settrack, resumetrack, previoustrack, setlevel, stop, unmute, on]
requested attrs:[motion, level, smoke, trackdescription, mute, water, switch, button, acceleration, trackdata, contact, presence, status]
type 2 attr uses
carbonmonoxide
called cap-methods by app
play
nexttrack
pause
off
previoustrack
setlevel
on
called cap-props by app
motion
smoke
water
switch
button
acceleration
contact
presence
attribute uses through subscriptions
button
acceleration
motion
contact
smoke
presence
playpause
carbonmonoxide
water
switch
cmd overpriv:[playtrack, mute, playtext, restoretrack, settrack, resumetrack, stop, unmute]
attr overpriv:[level, trackdescription, mute, trackdata, status]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 6d38663a-1703-46b6-9939-8c1fb9467cf9, 266374ae-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, ff20e87b-992b-42b0-9cd6-72b0030dedc3, 26d69a34-ada2-42dc-9e45-445c78ae2619, 1e88cabe-5ba4-4647-9a23-0ad5b887f94b, f730b653-b0b6-483e-8c84-977e240f5eb3, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.refresh, capability.polling]]
DECLARED METHODS
mainPage: 
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],[return true],],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],[return true],],][return false]
ifUnset: [If settings[name],,],
ifSet: [If settings[name],,],
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [log.trace(subscribeToEvents())][this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,,],
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],
modeChangeHandler: [If (evt.value in triggerModes),,],
scheduledTimeHandler: 
appTouchHandler: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
takeAction: [(options = [:])][If volume,[(options.delay = 1000)],],
frequencyKey: [lastActionTimeStamp]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],[result]
getAllOk: [((modeOk && daysOk) && timeOk)]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)][result]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)][result]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)][result]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]
timeIntervalLabel: [((starting && ending)) ? ((this.hhmm(starting) + -) + this.hhmm(ending, h:mm a z)) : ]
Starting Points: []
--app-start--
processing big-turn-on.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
on
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
updated: [this.unsubscribe()][this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
changedLocationMode: 
appTouch: 
Starting Points: []
--app-start--
processing bright-when-dark-and-or-bright-after-sunset.groovy
req caps: [capability.motionsensor, capability.switchlevel, capability.illuminancemeasurement, capability.switch]
req cap size: 4
requested commands:[setlevel, off, on]
requested attrs:[motion, illuminance, level, switch]
called cap-methods by app
setlevel
off
on
called cap-props by app
motion
illuminance
switch
attribute uses through subscriptions
motion
illuminance
switch
cmd overpriv:[]
attr overpriv:[level]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
configurations: 
options: [If ((dark == true) && (sun == true)),,[If ((dark == true) && (sun == false)),,[If ((sun == true) && (dark == false)),,],],],
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(motionSensor, motion, motionHandler)][If ((((lights != null) && (lights != )) && (dimmers != null)) && (dimmers != )),[this.subscribe(lights, switch, lightsHandler)][this.subscribe(dimmers, switch, dimmersHandler)][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[this.subscribe(lightSensor, illuminance, illuminanceHandler, [filterEvents:false])],],[If (sun == true),[this.subscribe(location, position, locationPositionChange)][this.subscribe(location, sunriseTime, sunriseSunsetTimeHandler)][this.subscribe(location, sunsetTime, sunriseSunsetTimeHandler)],[If ((dark != true) && (sun != true)),,],],,[If ((lights != null) && (lights != )),[this.subscribe(lights, switch, lightsHandler)][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[this.subscribe(lightSensor, illuminance, illuminanceHandler, [filterEvents:false])],],[If (sun == true),[this.subscribe(location, position, locationPositionChange)][this.subscribe(location, sunriseTime, sunriseSunsetTimeHandler)][this.subscribe(location, sunsetTime, sunriseSunsetTimeHandler)],[If ((dark != true) && (sun != true)),,],],,[If ((dimmers != null) && (dimmers != )),[this.subscribe(dimmers, switch, dimmersHandler)][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[this.subscribe(lightSensor, illuminance, illuminanceHandler, [filterEvents:false])],],[If (sun == true),[this.subscribe(location, position, locationPositionChange)][this.subscribe(location, sunriseTime, sunriseSunsetTimeHandler)][this.subscribe(location, sunsetTime, sunriseSunsetTimeHandler)],[If ((dark != true) && (sun != true)),,],],,],],],[If ((lights != null) && (lights != )),[If lights.currentValue(switch).toString().contains(on),[(state.lightsState = on)],[If lights.currentValue(switch).toString().contains(off),[(state.lightsState = off)],],],,],[If ((dimmers != null) && (dimmers != )),[If dimmers.currentValue(switch).toString().contains(on),[(state.dimmersState = on)],[If dimmers.currentValue(switch).toString().contains(off),[(state.dimmersState = off)],],],,],
locationPositionChange: 
sunriseSunsetTimeHandler: [(state.lastSunriseSunsetEvent = this.now())]
motionHandler: [If (evt.value == active),[If ((dark == true) && (sun == true)),[If ((darkOk == true) && (sunOk == true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((darkOk == true) && (sunOk != true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((darkOk != true) && (sunOk == true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],],,[If ((dark == true) && (sun != true)),[If (darkOk == true),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],,[If ((dark != true) && (sun == true)),[If (sunOk == true),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],,[If ((dark != true) && (sun != true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],],],,[If (evt.value == inactive),[If ((state.lightsState != off) || (state.dimmersState != off)),[If delayMinutes,[(delay = (delayMinutes * 60))][If ((dark == true) && (sun == true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((dark == true) && (sun != true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((dark != true) && (sun == true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((dark != true) && (sun != true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],],],,],,[If ((state.lightsState == off) && (state.dimmersState == off)),,],],,],],
lightsHandler: [If (evt.value == on),[(state.lightsState = on)],[If (evt.value == off),[(state.lightsState = off)],],],
dimmersHandler: [If (evt.value == on),[(state.dimmersState = on)],[If (evt.value == off),[(state.dimmersState = off)],],],
illuminanceHandler: [If (evt.integerValue > 999),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If (evt.integerValue > (((luxLevel != null) && (luxLevel != ))) ? luxLevel : 50),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],
turnOnLights: [If allOk,[If (state.lightsState != on),[(state.lightsState = on)],],,],
turnOnDimmers: [If allOk,[If (state.dimmersState != on),[(state.dimmersState = on)],],,],
turnOffLights: [If allOk,[If (state.lightsState != off),[(state.lightsState = on)],],,],
turnOffDimmers: [If allOk,[If (state.dimmersState != off),[(state.dimmersState = off)],],,],
astroCheck: [(s = this.getSunriseAndSunset([zipCode:zipCode, sunriseOffset:sunriseOffset, sunsetOffset:sunsetOffset]))][(state.riseTime = s.sunrise.time)][(state.setTime = s.sunset.time)]
getDarkOk: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[(result = (lightSensor.currentIlluminance < (((luxLevel != null) && (luxLevel != ))) ? luxLevel : 50))],],[log.trace(darkOk = $result)][result]
getSunOk: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (sun == true),[(t = this.now())][(result = ((t < state.riseTime) || (t > state.setTime)))],],[log.trace(sunOk = $result)][result]
getSunriseOffset: [(sunriseOffsetValue) ? ((sunriseOffsetDir == Before)) ? -$sunriseOffsetValue : sunriseOffsetValue : null]
getSunsetOffset: [(sunsetOffsetValue) ? ((sunsetOffsetDir == Before)) ? -$sunsetOffsetValue : sunsetOffsetValue : null]
getAllOk: [((modeOk && daysOk) && timeOk)]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)][result]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)][result]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting).time)][(stop = this.timeToday(ending).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)][result]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]
hideOptionsSection: [((((starting || ending) || days) || modes)) ? false : true]
timeIntervalLabel: [((starting && ending)) ? ((this.hhmm(starting) + -) + this.hhmm(ending, h:mm a z)) : ]
Starting Points: []
IT HAS STATE
--app-start--
processing brighten-dark-places.groovy
req caps: [capability.contactsensor, capability.illuminancemeasurement, capability.switch]
req cap size: 3
requested commands:[off, on]
requested attrs:[illuminance, contact, switch]
called cap-methods by app
on
called cap-props by app
illuminance
contact
attribute uses through subscriptions
contact
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(contact1, contact.open, contactOpenHandler)]
updated: [this.unsubscribe()][this.subscribe(contact1, contact.open, contactOpenHandler)]
contactOpenHandler: [(lightSensorState = luminance1.currentIlluminance)][If ((lightSensorState != null) && (lightSensorState < 10)),,],
Starting Points: []
--app-start--
processing child-button.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: child-button.metadata() is applicable for argument types: (child-button$_run_closure1) values: [child-button$_run_closure1@24569dba]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing button-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(results = [])][If description.startsWith(Err),[(results = this.createEvent([descriptionText:description, displayed:true]))],[(cmd = zwave.parse(description, [43:1, 128:1, 132:1]))][If cmd,[(results += this.zwaveEvent(cmd))],],[If results,[(results = [descriptionText:cmd, displayed:false])],],],
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: button-capability.metadata() is applicable for argument types: (button-capability$_run_closure1) values: [button-capability$_run_closure1@359df09a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing centralite-thermostat.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(result = [])][(descMap = zigbee.parseDescriptionAsMap(description))][(attrData = [[cluster:descMap.cluster, attrId:descMap.attrId, value:descMap.value]])]
getModeMap: 
getFanModeMap: 
refresh: 
getTemperature: [If (value != null),[(celsius = (java.lang.Integer.parseInt(value, 16) / 100))][If (this.getTemperatureScale() == C),,],,],
setHeatingSetpoint: [If (degrees != null),[(temperatureScale = this.getTemperatureScale())][(degreesInteger = java.lang.Math.round(degrees))][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))],],
setCoolingSetpoint: [If (degrees != null),[(degreesInteger = java.lang.Math.round(degrees))][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))],],
modes: 
setThermostatMode: [(currentMode = device.currentState(thermostatMode)?.value)][(modeOrder = this.modes())][(index = modeOrder.indexOf(currentMode))][(next = (((index >= 0) && (index < (modeOrder.size() - 1)))) ? modeOrder[(index + 1)] : modeOrder[0])]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
setThermostatFanMode: [(currentFanMode = device.currentState(thermostatFanMode)?.value)][(returnCommand = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)]
setThermostatMode: 
setThermostatFanMode: 
off: 
cool: 
heat: 
emergencyHeat: 
on: 
fanOn: 
auto: 
fanAuto: 
configure: 
hex: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: centralite-thermostat.metadata() is applicable for argument types: (centralite-thermostat$_run_closure1) values: [centralite-thermostat$_run_closure1@4a8355dd]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing cameras-on-when-im-away.groovy
req caps: [capability.switch, capability.presencesensor]
req cap size: 2
requested commands:[off, on]
requested attrs:[presence, switch]
called cap-methods by app
off
on
called cap-props by app
presence
attribute uses through subscriptions
presence
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(people, presence, presence)]
updated: [this.unsubscribe()][this.subscribe(people, presence, presence)]
presence: [If (evt.value == not present),[If this.everyoneIsAway(),,],,[If this.everyoneIsAway(),,],],
turnOff: 
turnOn: 
everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],]everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],][return result]
Starting Points: []
--app-start--
processing camera-power-scheduler.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
off
on
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: 
updated: 
initialize: [If startTime,,],[If endTime,,],
turnOnCamera: 
turnOffCamera: 
Starting Points: []
--app-start--
processing brighten-my-path.groovy
req caps: [capability.motionsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[motion, switch]
called cap-methods by app
on
called cap-props by app
motion
attribute uses through subscriptions
motion
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(motion1, motion.active, motionActiveHandler)]
updated: [this.unsubscribe()][this.subscribe(motion1, motion.active, motionActiveHandler)]
motionActiveHandler: 
Starting Points: []
--app-start--
processing co2-vent.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
off
on
called cap-props by app
attribute uses through subscriptions
carbondioxide
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [(state.active = false)][this.subscribe(sensor, carbonDioxide, handleLevel)]
handleLevel: [(co2 = sensor.currentValue(carbonDioxide).toInteger())][If ((co2 >= settings.level) && state.active),[(switches.each({ -> ... }){ it.on() })][(state.active = true)],[If ((co2 < settings.level) && state.active),[(state.active = false)][(switches.each({ -> ... }){ it.off() })],],],
Starting Points: []
IT HAS STATE
--app-start--
processing coopboss-h3vx.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(map = [:])][If description?.startsWith(catchall:),[(map = this.parseCatchAllMessage(description))],[If description?.startsWith(read attr -),[(map = this.parseReportAttributeMessage(description))],[If (description?.startsWith(temperature: ) || description?.startsWith(humidity: )),[(map = this.parseCustomMessage(description))],],],],
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseCatchAllMessage: [(resultMap = [:])][(cluster = zigbee.parse(description))][If (cluster.clusterId == 1026),,],[If ((cluster.clusterId == 257) && (cluster.command == 11)),,],
parseReportAttributeMessage: [(resultMap = [:])][(descMap = this.parseDescriptionAsMap(description))][If ((descMap.cluster == 0101) && (descMap.attrId == 0003)),[(resultMap.name = doorState)][If (descMap.value == 00),[(resultMap.value = unknown)],[If (descMap.value == 01),[(resultMap.value = closed)],[If (descMap.value == 02),[(resultMap.value = open)],[If (descMap.value == 03),[(resultMap.value = jammed)],[If (descMap.value == 04),[(resultMap.value = forced close)],[If (descMap.value == 05),[(resultMap.value = forced close)],[If (descMap.value == 06),[(resultMap.value = closing)],[If (descMap.value == 07),[(resultMap.value = opening)],[If (descMap.value == 08),[(resultMap.value = fault)],[(resultMap.value = unknown)]],],],],],],],],],[(resultMap.descriptionText = Door State Changed to $resultMap.value)],[If ((descMap.cluster == 0101) && (descMap.attrId == 0400)),[(resultMap.name = currentLightLevel)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.displayed = false)],[If ((descMap.cluster == 0101) && (descMap.attrId == 0401)),[(resultMap.name = closeLightLevel)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0402)),[(resultMap.name = openLightLevel)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0403)),[(resultMap.name = autoCloseEnable)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 0404)),[(resultMap.name = autoOpenEnable)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 0405)),[(resultMap.name = doorCurrent)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.value = (resultMap.value * 0.001))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0408)),[(resultMap.name = doorSensitivity)][(resultMap.value = (100 - java.lang.Integer.parseInt(descMap.value, 16)))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0409)),[(resultMap.name = baseDoorCurrent)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.value = (resultMap.value * 0.001))],[If ((descMap.cluster == 0101) && (descMap.attrId == 040a)),[(resultMap.name = doorVoltage)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.value = (resultMap.value * 0.001))],[If ((descMap.cluster == 0101) && (descMap.attrId == 040b)),[(resultMap.name = Aux1)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 040c)),[(resultMap.name = Aux2)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 040d)),[(resultMap.name = photoCalibration)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],[If ((descMap.cluster == 0101) && (descMap.attrId == 040e)),[(resultMap.name = baseCurrentNE)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],],],],],],],],],],],],],],],
parseCustomMessage: [(resultMap = [:])][If description?.startsWith(temperature: ),[(resultMap.name = temperature)][(rawT = (description - temperature: ).trim())][(resultMap.descriptionText = Temperature celsius value = $rawT)][(rawTint = java.lang.Float.parseFloat(rawT))][If (rawTint > 65),[(resultMap.name = null)][(resultMap.value = null)][(resultMap.descriptionText = Temperature celsius value = $rawT is invalid not updating)][log.warn(Invalid temperature value detected! rawT = $rawT, description = $description)],[If (rawT == -32768),[(resultMap.value = ERR)],[(resultMap.value = (java.lang.Float -> java.lang.Float) this.celsiusToFahrenheit(rawT.toFloat()))]],],,],[(resultMap.displayed = false)][log.info(Temperature reported = $resultMap.value)]
parseDescriptionAsMap: 
getFahrenheit: [(celsius = java.lang.Integer.parseInt(value, 16))]
callUpdateStatusTxt: [(cTemp = device.currentState(TempProb1)?.value)][(cLight = 0)][(testNull = device.currentState(currentLightLevel)?.value)][If (testNull != null),[(cLight = (int) device.currentState(currentLightLevel)?.value)],],
updateStatusTxt: [(cTmp = currentTemp)][(cLL = 10)][(oLL = 10)][(testNull = device.currentState(closeLightLevel)?.value)][If (testNull != null),[(cLL = (int) device.currentState(closeLightLevel)?.value)],],[(testNull = device.currentState(openLightLevel)?.value)][If (testNull != null),[(oLL = (int) device.currentState(openLightLevel)?.value)],],[(aOpnEn = device.currentState(autoOpenEnable)?.value)][(aClsEn = device.currentState(autoCloseEnable)?.value)][If (currentLight < cLL),[If (aOpnEn == on),,],,[If (aClsEn == on),,],],
on: 
off: 
close: 
open: 
Aux1On: 
Aux1Off: 
Aux2On: 
Aux2Off: 
openDoor: 
closeDoor: 
closeDoorHiI: 
autoOpenOn: 
autoOpenOff: 
autoCloseOn: 
autoCloseOff: 
setOpenLevelTo: [(cX = cValue)][(cmd = [])]
setCloseLevelTo: [(cX = cValue)][(cmd = [])]
setSensitivityLevel: [(cX = (100 - cValue))][(cmd = [])]
setNewBaseCurrent: [(cX = (int) cValue)][log.info(Setting new BaseCurrent to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]
setNewPhotoCalibration: [(cX = (int) cValue)][log.info(Setting new Photoresister calibration to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]
readNewPhotoCalibration: [(cmd = [])]
readBaseCurrentNE: [(cmd = [])]
setBaseCurrentNE: [(cX = (int) cValue)][log.info(Setting new base Current Never Exceed to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]
poll: [(cmd = [])]
updateTemp1: [(cmd = [])]
updateTemp2: [(cmd = [])]
updateSun: [(cmd = [])]
updateSensitivity: [(cmd = [])]
updateCloseLightLevel: [(cmd = [])]
updateOpenLightLevel: [(cmd = [])]
refresh: [(cmd = [])]
configure: [(cmd = [])]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: coopboss-h3vx.metadata() is applicable for argument types: (coopboss-h3vx$_run_closure1) values: [coopboss-h3vx$_run_closure1@1b1cfb87]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing hue-white-ambiance-bulb.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
initialize: 
installed: 
updated: 
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],
on: 
off: 
setLevel: [If (((percent != null) && (percent >= 0)) && (percent <= 100)),,],
setColorTemperature: [If value,,],
refresh: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: hue-white-ambiance-bulb.metadata() is applicable for argument types: (hue-white-ambiance-bulb$_run_closure1) values: [hue-white-ambiance-bulb$_run_closure1@7eecb5b8]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing garage-door-opener.groovy
subscribeToCommand
subscribeToCommand
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
off
on
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(app, appTouchHandler)][this.subscribeToCommand(switch1, on, onCommand)]
updated: [this.unsubscribe()][this.subscribe(app, appTouchHandler)][this.subscribeToCommand(switch1, on, onCommand)]
appTouch: 
onCommand: 
Starting Points: []
--app-start--
processing energy-saver.groovy
req caps: [capability.powermeter, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[switch, power]
called cap-methods by app
off
called cap-props by app
power
attribute uses through subscriptions
power
cmd overpriv:[on]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, b100c5ad-6d43-4adf-89f9-4109995e059d]
[[capability.refresh]]
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(meter, power, meterHandler)]
meterHandler: [(meterValue = (double) evt.value)][(thresholdValue = (int) threshold)][If (meterValue > thresholdValue),,],
Starting Points: []
--app-start--
processing curling-iron.groovy
req caps: [capability.motionsensor, capability.switch, capability.presencesensor]
req cap size: 3
requested commands:[off, on]
requested attrs:[motion, presence, switch]
called cap-methods by app
off
on
called cap-props by app
motion
presence
attribute uses through subscriptions
motion
presence
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [this.subscribe(motionSensors, motion.active, motionActive)][this.subscribe(motionSensors, motion.inactive, motionInactive)][this.subscribe(presenceSensors, presence.not present, notPresent)]
motionActive: [If this.anyHere(),,],
motionInactive: [If this.allQuiet(),,],
notPresent: [If this.anyHere(),,],
allQuiet: [(result = true)][For motionSensors,[If (it.currentMotion == active),[(result = false)][(result = false)],],]allQuiet: [(result = true)][For motionSensors,[If (it.currentMotion == active),[(result = false)][(result = false)],],][return result]
anyHere: [(result = true)][For presenceSensors,[If (it.currentPresence == not present),[(result = false)][(result = false)],],]anyHere: [(result = true)][For presenceSensors,[If (it.currentPresence == not present),[(result = false)][(result = false)],],][return result]
outletsOn: 
outletsOff: [(delay = (minutes * 60))]
scheduledTurnOff: 
Starting Points: []
--app-start--
processing good-night-house.groovy
req caps: [capability.lock, capability.switch]
req cap size: 2
requested commands:[lock, unlock, off, on]
requested attrs:[lock, switch]
called cap-methods by app
lock
off
on
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[unlock]
attr overpriv:[lock, switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, bdefadfd-d59f-4d54-82c2-5fbb3ac6965f]
[[capability.battery, capability.polling, capability.refresh]]
DECLARED METHODS
installed: [this.subscribe(app, appTouch)]
updated: [this.unsubscribe()][this.subscribe(app, appTouch)]
appTouch: [If (location.mode != newMode),,],[(delay = (((waitfor != null) && (waitfor != ))) ? (waitfor * 1000) : 120000)]
Starting Points: []
--app-start--
processing every-element.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[off, on]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e]
[[capability.switch]]
DECLARED METHODS
firstPage: 
inputPage: 
inputBooleanPage: 
inputIconPage: 
inputImagePage: 
optionsGroup: [(group = [values:[], order:groups.size()])][(group.title = (title) ? title : )][(groups << group)][return groups]
addValues: [(lastGroup = groups[-1])][(lastGroup[values] << [key:key, value:value, order:lastGroup[values].size()])][return groups]
listToMap: 
addGroup: [If (values instanceof java.util.List),[(values = this.listToMap(values))],],[return groups]
addGroup: 
inputSelectionPage: [(englishOptions = [One, Two, Three])][(spanishOptions = [Uno, Dos, Tres])][(groupedOptions = [])]
inputTextPage: 
inputTimePage: 
inputDevicePage: 
inputCapabilityPage: 
inputRoomPage: 
inputModePage: 
inputHubPage: 
inputContactBookPage: 
appPage: 
labelPage: 
modePage: 
paragraphPage: 
hrefPage: 
buttonsPage: 
imagePage: 
videoPage: 
flattenedPage: [(allSections = [])][(this.firstPage().sections[0].body.each({ java.lang.Object hrefElement -> ... }){ <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })][(this.inputPage().sections.each({ java.lang.Object section -> ... }){ section.body.each({ java.lang.Object hrefElement -> ... }) })][(flattenedPage = this.dynamicPage([name:flattenedPage, title:All elements in one page!], { -> ... }))][(flattenedPage.sections = allSections)][return flattenedPage]
foo: 
installed: 
updated: [this.unsubscribe()]
initialize: 
Starting Points: []
--app-start--
processing feed-my-pet.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
updated: 
scheduleCheck: 
Starting Points: []
--app-start--
processing double-tap.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
called cap-props by app
switch
attribute uses through subscriptions
switch
cmd overpriv:[off, on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(master, switch, switchHandler, [filterEvents:false])]
updated: [this.unsubscribe()][this.subscribe(master, switch, switchHandler, [filterEvents:false])]
switchHandler: [(recentStates = master.eventsSince(new java.util.Date((this.now() - 4000)), [all:true, max:10]).findAll({ -> ... }))][If evt.physical,[If ((evt.value == on) && this.lastTwoStatesWere(on, recentStates, evt)),,[If ((evt.value == off) && this.lastTwoStatesWere(off, recentStates, evt)),,],],,],
onSwitches: [((switches + onSwitches).findAll({ -> ... }){ it })]
offSwitches: [((switches + offSwitches).findAll({ -> ... }){ it })]
lastTwoStatesWere: [(result = false)][If states,[(onOff = states.findAll({ -> ... }))][If onOff[0].date.before(evt.date),[log.warn(Last state does not reflect current event, evt.date: $evt.dateCreated, state.date: $onOff[0].dateCreated)][(result = ((evt.value == value) && (onOff[0].value == value)))],[(result = (((onOff.size() > 1) && (onOff[0].value == value)) && (onOff[1].value == value)))]],,],[result]
Starting Points: []
IT HAS STATE
--app-start--
processing device-tile-controller.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
defaultPage: 
installed: 
uninstalled: 
updated: [this.unsubscribe()]
initializeDevices: 
labelMap: 
Starting Points: []
--app-start--
processing ecobee-sensor.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
refresh: 
poll: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: ecobee-sensor.metadata() is applicable for argument types: (ecobee-sensor$_run_closure1) values: [ecobee-sensor$_run_closure1@1a5b6f42]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing fidure-thermostat.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
getMin: 
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
getMax: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parse: [(result = [])][If description?.startsWith(read attr -),[(descMap = this.parseDescriptionAsMap(description))][For descMap.attrs,[(map = [:])][If (descMap.cluster == 0201),,[If (descMap.cluster == 0204),[If (atMap.attrId == 0001),[(map.name = lockLevel)][(map.value = this.getLockMap()[atMap.value])],],,],],[If map,[(result += this.createEvent(map))],],][(descMap = this.parseDescriptionAsMap(description))][For descMap.attrs,[(map = [:])][If (descMap.cluster == 0201),,[If (descMap.cluster == 0204),[If (atMap.attrId == 0001),[(map.name = lockLevel)][(map.value = this.getLockMap()[atMap.value])],],,],],[If map,[(result += this.createEvent(map))],],],],
parseDescriptionAsMap: [(map = (description - read attr - ).split(,).inject([:], { java.lang.Object map, java.lang.Object param -> ... }))][(attrId = map.get(attrId))][(encoding = map.get(encoding))][(value = map.get(value))][(result = map.get(result))][(list = [])][If (this.getDataLengthByType(map.get(encoding)) < map.get(value).length()),[(raw = map.get(raw))][(size = java.lang.Long.parseLong(( + map.get(size)), 16))][(index = 12)][(len = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While ((index - 12) < size),[(attrId = this.flipHexStringEndianness(raw[(index..(index + 3))]))][(index += 4)][If (result == success),[(index += 2)],],[(encoding = raw[(index..(index + 1))])][(index += 2)][(len = this.getDataLengthByType(encoding))][(value = this.flipHexStringEndianness(raw[(index..((index + len) - 1))]))][(index += len)][(list += [attrId:$attrId, encoding:$encoding, value:$value])]][(raw = map.get(raw))][(size = java.lang.Long.parseLong(( + map.get(size)), 16))][(index = 12)][(len = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While ((index - 12) < size),[(attrId = this.flipHexStringEndianness(raw[(index..(index + 3))]))][(index += 4)][If (result == success),[(index += 2)],],[(encoding = raw[(index..(index + 1))])][(index += 2)][(len = this.getDataLengthByType(encoding))][(value = this.flipHexStringEndianness(raw[(index..((index + len) - 1))]))][(index += len)][(list += [attrId:$attrId, encoding:$encoding, value:$value])]],[(list += [attrId:$attrId, encoding:$encoding, value:$value])]],[(map += [attrs:list])]
flipHexStringEndianness: [(s = s.reverse())][(sb = new java.lang.StringBuilder())][For ((i = 0); (i < (s.length() - 1)); (i += 2)),]flipHexStringEndianness: [(s = s.reverse())][(sb = new java.lang.StringBuilder())][For ((i = 0); (i < (s.length() - 1)); (i += 2)),]
getDataLengthByType: [(map = [08:1, 09:2, 0a:3, 0b:4, 0c:5, 0d:6, 0e:7, 0f:8, 10:1, 18:1, 19:2, 1a:3, 1b:4, 1c:5, 1d:6, 1e:7, 1f:8, 20:1, 21:2, 22:3, 23:4, ... ])]
getProgrammingMap: 
getModeMap: 
getFanModeMap: 
getHoldMap: 
updateSetpoint: [(cool = device.currentState(coolingSetpoint)?.value)][(heat = device.currentState(heatingSetpoint)?.value)][(runningMode = device.currentState(runningMode)?.value)][(mode = device.currentState(thermostatMode)?.value)][(value = --)][If ((heat == mode) && (heat != null)),[(value = heat)],[If ((cool == mode) && (cool != null)),[(value = cool)],[If (((auto == mode) && (runningMode == cool)) && (cool != null)),[(value = cool)],[If (((auto == mode) && (runningMode == heat)) && (heat != null)),[(value = heat)],],],],],
raiseSetpoint: 
lowerSetpoint: 
adjustSetpoint: [(runningMode = device.currentState(runningMode)?.value)][(mode = device.currentState(thermostatMode)?.value)][(modeData = 2)][If ((heat == mode) || (heat == runningMode)),[(modeData = 00)],[If ((cool == mode) || (cool == runningMode)),[(modeData = 01)],],],[(amountData = java.lang.String.format(%02X, value)[(-2..-1)])]
getDisplayTemperature: [(t = java.lang.Integer.parseInt($value, 16))][If (this.getTemperatureScale() == C),[(t = ((java.lang.Integer -> java.lang.Integer) ((t + 4) / 10) / 10))],[(t = ((java.lang.Integer -> java.lang.Integer) (10 * this.celsiusToFahrenheit((t / 100))) / 10))]],
updateHoldLabel: [(currentHold = (device?.currentState(setpointHold)?.value) ? device?.currentState(setpointHold)?.value : ...)][(holdExp = device?.currentState(holdExpiary)?.value)][(holdExp = (holdExp) ? holdExp : $new Date().getTime())][If (Hold == attr),[(currentHold = value)],],[If (HoldExp == attr),[(holdExp = value)],],[(past = (new java.util.Date(holdExp.toLong()).getTime() < new java.util.Date().getTime()))][If (HoldExp == attr),[If past,[(currentHold = On)],[(currentHold = Off)]],,],[(holdString = ((currentHold == On)) ? (past) ? Is On : Ends $this.compareWithNow(holdExp.toLong()) : ((currentHold == Off)) ?  is Off :  ...)]
getSetPointHoldDuration: [(holdTime = 0)][If settings.hold_time?.contains(Hours),[(holdTime = java.lang.Integer.parseInt(settings.hold_time[(0..1)].trim()))],[If settings.hold_time?.contains(Day),[(holdTime = (java.lang.Integer.parseInt(settings.hold_time[(0..1)].trim()) * 24))],],],[(currentHoldDuration = device.currentState(setpointHoldDuration)?.value)][If (java.lang.Short.parseShort((0 + (currentHoldDuration) ? currentHoldDuration : 0)) != (holdTime * 60)),,],
Hold: [(currentHold = device.currentState(setpointHold)?.value)][(next = ((currentHold == On)) ? 00 : 01)][(nextHold = this.getHoldMap()[next])]
compareWithNow: [(mins = (new java.util.Date(d).getTime() - new java.util.Date().getTime()))][(mins /= (1000 * 60))][(past = (mins < 0))][(ret = (past) ?  : in )][If past,[(mins *= -1)],],[(t = 0)][If (mins < 60),[(ret += (((java.lang.Integer -> java.lang.Integer) mins +  min) + ((mins > 1)) ? s : ))],[If (mins < 1440),[(t = ((java.lang.Integer -> java.lang.Integer) java.lang.Math.round(((14 + mins) / 30)) / 2))][(ret += ((t +  hr) + ((t > 1)) ? s : ))],[(t = ((java.lang.Integer -> java.lang.Integer) java.lang.Math.round(((359 + mins) / 720)) / 2))][(ret += ((t +  day) + ((t > 1)) ? s : ))]],],[(ret += (past) ?  ago : )]
convertToTime: [(time = (long) java.lang.Integer.parseInt($data, 16))][(time *= 1000)][(time += 946684800000)][(time -= (location.timeZone.getRawOffset() + location.timeZone.getDSTSavings()))][(d = new java.util.Date(time))]
Program: [(currentSched = device.currentState(prorgammingOperation)?.value)][(next = java.lang.Integer.parseInt((currentSched) ? currentSched : 00, 16))][If ((next & 1) == 1),[(next = (next & 254))],[(next = (next | 1))]],[(nextSched = this.getProgrammingMap()[(next & 1)])]
getThermostatOperatingState: [(m = [heating, cooling, fan, Heat2, Cool2, Fan2, Fan3])][(desc = idle)][(value = java.lang.Integer.parseInt(( + value), 16))][For (0..2),[If (value & (1 << i)),[(desc = m[i])],],]getThermostatOperatingState: [(m = [heating, cooling, fan, Heat2, Cool2, Fan2, Fan3])][(desc = idle)][(value = java.lang.Integer.parseInt(( + value), 16))][For (0..2),[If (value & (1 << i)),[(desc = m[i])],],]
checkLastTimeSync: [(lastSync = device.currentState(lastTimeSync)?.value)][If lastSync,[(lastSync = $new Date(0))],],[If (settings.sync_clock) ? settings.sync_clock : (false && (lastSync != new java.util.Date(0))),,],[(duration = (new java.util.Date().getTime() - new java.util.Date(lastSync).getTime()))][If (duration > 86400000),,],
readAttributesCommand: [(attrString = )][For attribList,[(attrString += (  + java.lang.String.format(%02X %02X, (val & 255), ((val >> 8) & 255))))]]readAttributesCommand: [(attrString = )][For attribList,[(attrString += (  + java.lang.String.format(%02X %02X, (val & 255), ((val >> 8) & 255))))]]
refresh: 
poll: 
getTemperature: [(celsius = (java.lang.Integer.parseInt($value, 16) / 100))][If (this.getTemperatureScale() == C),,],
setHeatingSetpoint: [(temperatureScale = this.getTemperatureScale())][(degreesInteger = (java.lang.Integer -> java.lang.Integer) degrees)][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))]
setCoolingSetpoint: [(degreesInteger = (java.lang.Integer -> java.lang.Integer) degrees)][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))]
modes: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
setThermostatFanMode: [(currentFanMode = device.currentState(thermostatFanMode)?.value)][(returnCommand = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)]
setThermostatMode: [(currentMode = device.currentState(thermostatMode)?.value)][(modeOrder = this.modes())][(index = modeOrder.indexOf(currentMode))][(next = (((index >= 0) && (index < (modeOrder.size() - 1)))) ? modeOrder[(index + 1)] : modeOrder[0])]
setThermostatMode: [(val = (this.getModeMap().find({ -> ... })?.key) ? this.getModeMap().find({ -> ... })?.key : 00)]
setThermostatFanMode: 
off: 
cool: 
heat: 
auto: 
on: 
fanOn: 
fanAuto: 
updated: [(lastSync = device.currentState(lastTimeSync)?.value)][If ((settings.sync_clock) ? settings.sync_clock : false == false),,],
getLockMap: 
lock: [(currentLock = device.currentState(lockLevel)?.value)][(val = this.getLockMap().find({ -> ... })?.key)][If (val == 00),[(val = this.getLockMap().find({ -> ... })?.key)],[(val = 00)]],
setThermostatTime: [If (settings.sync_clock) ? settings.sync_clock : false,,],[(date = new java.util.Date())][(zone = ((location.timeZone.getRawOffset() +  DST ) + location.timeZone.getDSTSavings()))][(millis = date.getTime())][(millis -= 946684800000)][(millis += (location.timeZone.getRawOffset() + location.timeZone.getDSTSavings()))][(millis /= 1000)][(s = java.lang.String.format(%08X, millis))][(data = (((((((  + s.substring(6, 8)) +  ) + s.substring(4, 6)) +  ) + s.substring(2, 4)) +  ) + s.substring(0, 2)))]
configure: 
hex: 
getEndpointId: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: fidure-thermostat.metadata() is applicable for argument types: (fidure-thermostat$_run_closure1) values: [fidure-thermostat$_run_closure1@62656be4]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing hall-light-welcome-home.groovy
req caps: [capability.contactsensor, capability.switch, capability.presencesensor]
req cap size: 3
requested commands:[off, on]
requested attrs:[presence, contact, switch]
called cap-methods by app
on
called cap-props by app
presence
contact
attribute uses through subscriptions
presence
contact
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
init: [(state.lastClosed = this.now())][this.subscribe(people, presence.present, presence)][this.subscribe(sensors, contact.open, doorOpened)]
presence: [(delay = (contactDelay) ? contactDelay : 10)][(state.lastPresence = this.now())][If ((this.now() - (delay * 1000)) < state.lastContact),,],
doorOpened: [(delay = (presenceDelay) ? presenceDelay : 30)][(state.lastContact = this.now())][If ((this.now() - (delay * 1000)) < state.lastPresence),,],
Starting Points: []
IT HAS STATE
--app-start--
processing coffee-after-shower.groovy
req caps: [capability.relativehumiditymeasurement, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[humidity, switch]
called cap-methods by app
on
called cap-props by app
humidity
attribute uses through subscriptions
humidity
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, ba155665-433d-4e20-9d12-efad7744c3d6]
[[capability.temperaturemeasurement]]
DECLARED METHODS
installed: [this.subscribe(bathroom, humidity, coffeeMaker)]
updated: [this.unsubscribe()][this.subscribe(bathroom, humidity, coffeeMaker)]
coffeeMaker: [If (shower.value.toInteger() > relHum),,],
Starting Points: []
--app-start--
processing hue-bulb.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
initialize: 
installed: 
updated: 
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],
on: 
off: 
setLevel: [If this.verifyPercent(percent),,],
setSaturation: [If this.verifyPercent(percent),,],
setHue: [If this.verifyPercent(percent),,],
setColor: [(events = [])][(validValues = [:])][If this.verifyPercent(value.hue),[(validValues.hue = value.hue)],],[If this.verifyPercent(value.saturation),[(validValues.saturation = value.saturation)],],[If (value.hex != null),[If (value.hex ==~ ^\#([A-Fa-f0-9]){6}$),[(validValues.hex = value.hex)],],,],[If this.verifyPercent(value.level),[(validValues.level = value.level)],],[If ((value.switch == off) || ((value.level != null) && (value.level <= 0))),[(validValues.switch = off)],[(validValues.switch = on)]],[If validValues.isEmpty(),,],
reset: 
setAdjustedColor: [If value,[(adjusted = (value + [:]))][(adjusted.level = null)],],
setColorTemperature: [If value,,],
refresh: 
verifyPercent: [If (percent == null),,[If ((percent >= 0) && (percent <= 100)),,],],
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: hue-bulb.metadata() is applicable for argument types: (hue-bulb$_run_closure1) values: [hue-bulb$_run_closure1@456d6c1e]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing door-state-to-color-light-hue-bulb.groovy
req caps: [capability.colorcontrol, capability.doorcontrol]
req cap size: 2
requested commands:[setsaturation, sethue, setcolor, close, open]
requested attrs:[saturation, hue, door, color]
called cap-methods by app
setsaturation
setcolor
sethue
called cap-props by app
door
attribute uses through subscriptions
doorstate
cmd overpriv:[close, open]
attr overpriv:[saturation, hue, color]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [48b39485-7ebc-4c80-bf6e-9a653a2d1c95, 548b3451-701a-4244-b66a-40d08564dc47]
[[capability.switchlevel, capability.contactsensor, capability.switch, capability.refresh]]
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(doorSensor, doorState, coopDoorStateHandler)]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
coopDoorStateHandler: [(color = White)][(hueColor = 100)][(saturation = 100)][(hClr = [:])][(hClr.hex = #FFFFFF)]
Starting Points: []
--app-start--
processing hub-ip-notifier.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
pageWithIp: [(currentIp = (state.localip) ? state.localip : unknown)][(registerDate = (state.lastRegister) ? state.lastRegister : null)]
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(hub, hubInfo, registrationHandler, [filterEvents:false])]
registrationHandler: [(hubInfo = evt.description.split(,).inject([:], { java.lang.Object map, java.lang.Object token -> ... }))][(state.localip = hubInfo.localip)][(state.lastRegister = new java.util.Date())]
Starting Points: []
IT HAS STATE
--app-start--
processing contact-sensor-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: contact-sensor-capability.metadata() is applicable for argument types: (contact-sensor-capability$_run_closure1) values: [contact-sensor-capability$_run_closure1@24c22fe]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing gentle-wake-up-controller.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
on: 
off: 
setTimeRemaining: 
start: 
stop: 
pause: 
cancel: 
startDimming: 
stopDimming: 
controllerEvent: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: gentle-wake-up-controller.metadata() is applicable for argument types: (gentle-wake-up-controller$_run_closure1) values: [gentle-wake-up-controller$_run_closure1@44be0077]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing darken-behind-me.groovy
req caps: [capability.motionsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[motion, switch]
called cap-methods by app
off
called cap-props by app
motion
attribute uses through subscriptions
motion
cmd overpriv:[on]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(motion1, motion.inactive, motionInactiveHandler)]
updated: [this.unsubscribe()][this.subscribe(motion1, motion.inactive, motionInactiveHandler)]
motionInactiveHandler: 
Starting Points: []
--app-start--
processing hue-bloom.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
initialize: 
installed: 
updated: 
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],
on: 
off: 
setLevel: [If this.verifyPercent(percent),,],
setSaturation: [If this.verifyPercent(percent),,],
setHue: [If this.verifyPercent(percent),,],
setColor: [(events = [])][(validValues = [:])][If this.verifyPercent(value.hue),[(validValues.hue = value.hue)],],[If this.verifyPercent(value.saturation),[(validValues.saturation = value.saturation)],],[If (value.hex != null),[If (value.hex ==~ ^\#([A-Fa-f0-9]){6}$),[(validValues.hex = value.hex)],],,],[If this.verifyPercent(value.level),[(validValues.level = value.level)],],[If ((value.switch == off) || ((value.level != null) && (value.level <= 0))),[(validValues.switch = off)],[(validValues.switch = on)]],[If validValues.isEmpty(),,],
reset: [(value = [hue:20, saturation:2])]
setAdjustedColor: [If value,[(adjusted = (value + [:]))][(adjusted.level = null)],],
refresh: 
verifyPercent: [If (percent == null),,[If ((percent >= 0) && (percent <= 100)),,],],
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: hue-bloom.metadata() is applicable for argument types: (hue-bloom$_run_closure1) values: [hue-bloom$_run_closure1@f627d13]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing goodnight-ubi.groovy
req caps: [capability.contactsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[contact, switch]
called cap-methods by app
off
called cap-props by app
contact
switch
attribute uses through subscriptions
switch
cmd overpriv:[on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(trigger, switch.on, switchOnHandler)]
switchOnHandler: [(timeDelay = (minutes * 60))][(phrase = )][(doors.each({ java.lang.Object doorOpen -> ... }){ <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })][If (phrase == ),[(phrase = The%20house%20is%20ready%20for%20night.)],[(phrase = ((You%20have%20left%20 + phrase) + open))]],[this.httpGet(https://portal.theubi.com/webapi/behaviour?access_token=$behaviorToken&variable=$phrase)][If (sayPhrase == Yes),,],
lightsOut: [If (theSwitches == ),,],
Starting Points: []
--app-start--
processing ecobee-thermostat.groovy
currentState, arg not ConstantExpression
currentState, arg not ConstantExpression
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
ping: [(isAlive = ((device.currentValue(deviceAlive) == true)) ? true : false)][If isAlive,,],
parse: 
refresh: 
poll: 
generateEvent: [If results,[(linkText = this.getLinkText(device))][(supportedThermostatModes = [off])][(thermostatMode = null)][(locationScale = this.getTemperatureScale())][If (state.supportedThermostatModes != supportedThermostatModes),[(state.supportedThermostatModes = supportedThermostatModes)],],[If thermostatMode,[this.sendEvent([name:thermostatMode, value:thermostatMode, data:[supportedThermostatModes:state.supportedThermostatModes], linkText:linkText, ... ])],],,],
getThermostatDescriptionText: [If (name == temperature),,[If (name == heatingSetpoint),,[If (name == coolingSetpoint),,[If (name == thermostatMode),,[If (name == thermostatFanMode),,[If (name == humidity),,[return $name = $value]],],],],],],
setHeatingSetpoint: [If setpoint,[(state.heatingSetpoint = setpoint.toDouble())],],
setCoolingSetpoint: [If setpoint,[(state.coolingSetpoint = setpoint.toDouble())],],
updateSetpoints: [(deviceScale = F)][(data = [targetHeatingSetpoint:null, targetCoolingSetpoint:null])][(heatingSetpoint = this.getTempInLocalScale(heatingSetpoint))][(coolingSetpoint = this.getTempInLocalScale(coolingSetpoint))][If state.heatingSetpoint,[(data = this.enforceSetpointLimits(heatingSetpoint, [targetValue:state.heatingSetpoint, heatingSetpoint:heatingSetpoint, coolingSetpoint:coolingSetpoint]))],],[If state.coolingSetpoint,[(heatingSetpoint = (data.targetHeatingSetpoint) ? this.getTempInLocalScale(data.targetHeatingSetpoint, deviceScale) : heatingSetpoint)][(coolingSetpoint = (data.targetCoolingSetpoint) ? this.getTempInLocalScale(data.targetCoolingSetpoint, deviceScale) : coolingSetpoint)][(data = this.enforceSetpointLimits(coolingSetpoint, [targetValue:state.coolingSetpoint, heatingSetpoint:heatingSetpoint, coolingSetpoint:coolingSetpoint]))],],[(state.heatingSetpoint = null)][(state.coolingSetpoint = null)]
resumeProgram: [(deviceId = device.deviceNetworkId.split(\.).last())][If parent.resumeProgram(deviceId),,],
modes: [return state.supportedThermostatModes]
fanModes: 
switchMode: [(currentMode = device.currentValue(thermostatMode))][(modeOrder = this.modes())][If modeOrder,[(next = { -> ... })][(nextMode = next.call(currentMode))],],
switchToMode: [(deviceId = device.deviceNetworkId.split(\.).last())][If parent.setMode(((mode == emergency heat)) ? auxHeatOnly : mode, deviceId),,],
switchFanMode: [(currentFanMode = device.currentValue(thermostatFanMode))][(fanModeOrder = this.fanModes())][(next = { -> ... })]
switchToFanMode: [(heatingSetpoint = this.getTempInDeviceScale(heatingSetpoint))][(coolingSetpoint = this.getTempInDeviceScale(coolingSetpoint))][(deviceId = device.deviceNetworkId.split(\.).last())][(sendHoldType = (holdType) ? ((holdType == Temporary)) ? nextTransition : indefinite : indefinite)][If parent.setFanMode(heatingSetpoint, coolingSetpoint, deviceId, sendHoldType, fanMode),,],
getDataByName: 
setThermostatMode: [(supportedModes = this.modes())][If supportedModes,[(mode = mode.toLowerCase())][(modeIdx = supportedModes.indexOf(mode))][If (modeIdx < 0),,],[(mode = supportedModes[modeIdx])],],
setThermostatFanMode: [(mode = mode.toLowerCase())][(supportedFanModes = this.fanModes())][(modeIdx = supportedFanModes.indexOf(mode))][If (modeIdx < 0),,],[(mode = supportedFanModes[modeIdx])]
generateModeEvent: 
generateFanModeEvent: 
generateOperatingStateEvent: 
off: 
heat: 
emergencyHeat: 
cool: 
auto: 
fanOn: 
fanAuto: 
fanCirculate: 
generateSetpointEvent: [(mode = device.currentValue(thermostatMode))][(setpoint = this.getTempInLocalScale(heatingSetpoint))][(coolingSetpoint = this.getTempInLocalScale(coolingSetpoint))][If (mode == cool),[(setpoint = coolingSetpoint)],[If ((mode == auto) || (mode == off)),[(setpoint = this.roundC(((setpoint + coolingSetpoint) / 2)))],],],
raiseHeatingSetpoint: 
lowerHeatingSetpoint: 
raiseCoolSetpoint: 
lowerCoolSetpoint: 
alterSetpoint: [If (device.currentValue(thermostatMode) == off),,],[(locationScale = this.getTemperatureScale())][(deviceScale = F)][(heatingSetpoint = this.getTempInLocalScale(heatingSetpoint))][(coolingSetpoint = this.getTempInLocalScale(coolingSetpoint))][(targetValue = ((setpoint == heatingSetpoint)) ? heatingSetpoint : coolingSetpoint)][(delta = ((locationScale == F)) ? 1 : 0.5)][(targetValue += (raise) ? delta : delta)][(data = this.enforceSetpointLimits(setpoint, [targetValue:targetValue, heatingSetpoint:heatingSetpoint, coolingSetpoint:coolingSetpoint], raise))][If data.targetHeatingSetpoint,,],[If data.targetCoolingSetpoint,,],
enforceSetpointLimits: [(locationScale = this.getTemperatureScale())][(minSetpoint = ((setpoint == heatingSetpoint)) ? device.getDataValue(minHeatingSetpointFahrenheit) : device.getDataValue(minCoolingSetpointFahrenheit))][(maxSetpoint = ((setpoint == heatingSetpoint)) ? device.getDataValue(maxHeatingSetpointFahrenheit) : device.getDataValue(maxCoolingSetpointFahrenheit))][(minSetpoint = (minSetpoint) ? java.lang.Double.parseDouble(minSetpoint) : ((setpoint == heatingSetpoint)) ? 45 : 65)][(maxSetpoint = (maxSetpoint) ? java.lang.Double.parseDouble(maxSetpoint) : ((setpoint == heatingSetpoint)) ? 79 : 92)][(deadband = (deadbandSetting) ? deadbandSetting : 5)][(delta = ((locationScale == F)) ? 1 : 0.5)][(targetValue = this.getTempInDeviceScale(data.targetValue, locationScale))][(heatingSetpoint = this.getTempInDeviceScale(data.heatingSetpoint, locationScale))][(coolingSetpoint = this.getTempInDeviceScale(data.coolingSetpoint, locationScale))][If (targetValue > maxSetpoint),[(targetValue = maxSetpoint)],[If (targetValue < minSetpoint),[(targetValue = minSetpoint)],[If ((raise != null) && (((setpoint == heatingSetpoint) && (targetValue == heatingSetpoint)) || ((setpoint == coolingSetpoint) && (targetValue == coolingSetpoint)))),[(targetValue += (raise) ? delta : delta)],],],],[If (setpoint == heatingSetpoint),[(heatingSetpoint = targetValue)][(coolingSetpoint = (((heatingSetpoint + deadband) > coolingSetpoint)) ? (heatingSetpoint + deadband) : coolingSetpoint)],],[If (setpoint == coolingSetpoint),[(coolingSetpoint = targetValue)][(heatingSetpoint = (((coolingSetpoint - deadband) < heatingSetpoint)) ? (coolingSetpoint - deadband) : heatingSetpoint)],],
updateSetpoint: [(deviceId = device.deviceNetworkId.split(\.).last())][(sendHoldType = (holdType) ? ((holdType == Temporary)) ? nextTransition : indefinite : indefinite)][If parent.setHold(data.targetHeatingSetpoint, data.targetCoolingSetpoint, deviceId, sendHoldType),,],
generateStatusEvent: [(mode = device.currentValue(thermostatMode))][(heatingSetpoint = device.currentValue(heatingSetpoint))][(coolingSetpoint = device.currentValue(coolingSetpoint))][(temperature = device.currentValue(temperature))][(statusText = Right Now: Idle)][(operatingState = idle)][If ((mode == heat) || (mode == emergency heat)),[If (temperature < heatingSetpoint),[(statusText = Heating to $heatingSetpoint$location.temperatureScale)][(operatingState = heating)],],,[If (mode == cool),[If (temperature > coolingSetpoint),[(statusText = Cooling to $coolingSetpoint$location.temperatureScale)][(operatingState = cooling)],],,[If (mode == auto),[If (temperature < heatingSetpoint),[(statusText = Heating to $heatingSetpoint$location.temperatureScale)][(operatingState = heating)],[If (temperature > coolingSetpoint),[(statusText = Cooling to $coolingSetpoint$location.temperatureScale)][(operatingState = cooling)],],],,[If (mode == off),[(statusText = Right Now: Off)],[(statusText = ?)]],],],],
generateActivityFeedsEvent: 
getTempInLocalScale: [(temp = device.currentState(state))][(scaledTemp = this.convertTemperatureIfNeeded(temp.value.toBigDecimal(), temp.unit).toDouble())][return ((this.getTemperatureScale() == F)) ? scaledTemp.round(0).toInteger() : this.roundC(scaledTemp)]
getTempInLocalScale: [(scaledTemp = this.convertTemperatureIfNeeded(temp.toBigDecimal(), scale).toDouble())][return ((this.getTemperatureScale() == F)) ? scaledTemp.round(0).toInteger() : this.roundC(scaledTemp)]
getTempInDeviceScale: [(temp = device.currentState(state))][If ((temp && temp.value) && temp.unit),,],
getTempInDeviceScale: [If (temp && scale),[return ((F == scale)) ? temp : this.celsiusToFahrenheit(temp).toDouble().round(0).toInteger()],],
roundC: 
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: ecobee-thermostat.metadata() is applicable for argument types: (ecobee-thermostat$_run_closure1) values: [ecobee-thermostat$_run_closure1@2fba3fc4]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing color-coordinator.groovy
req caps: [capability.colorcontrol]
req cap size: 1
requested commands:[sethue, setcolor, setsaturation]
requested attrs:[saturation, color, hue]
type 2 command uses
setcolortemperature
off
on
type 2 attr uses
colortemperature
level
switch
called cap-methods by app
setcolor
called cap-props by app
saturation
hue
attribute uses through subscriptions
saturation
hue
colortemperature
level
switch
cmd overpriv:[sethue, setsaturation]
attr overpriv:[color]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [48b39485-7ebc-4c80-bf6e-9a653a2d1c95]
[[capability.refresh]]
DECLARED METHODS
mainPage: 
installed: 
updated: [this.unsubscribe()]
init: [this.subscribe(master, switch, onOffHandler)][this.subscribe(master, level, colorHandler)][this.subscribe(master, hue, colorHandler)][this.subscribe(master, saturation, colorHandler)][this.subscribe(master, colorTemperature, tempHandler)]
onOffHandler: [If (slaves && master),[If slaves?.id.find({ -> ... }),[If (master?.currentValue(switch) == on),[If randomYes,,],,],,],,],
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
colorHandler: [If (slaves && master),[If (slaves?.id?.find({ -> ... }) && (master?.currentValue(switch) == on)),[(dimLevel = master?.currentValue(level))][(hueLevel = master?.currentValue(hue))][(saturationLevel = master.currentValue(saturation))][(newValue = [hue:hueLevel, saturation:saturationLevel, level:(java.lang.Integer -> java.lang.Integer) dimLevel])],],,],
getRandomColorMaster: [(hueLevel = java.lang.Math.floor((java.lang.Math.random() * 1000)))][(saturationLevel = java.lang.Math.floor((java.lang.Math.random() * 100)))][(dimLevel = master?.currentValue(level))][(newValue = [hue:hueLevel, saturation:saturationLevel, level:(java.lang.Integer -> java.lang.Integer) dimLevel])]
tempHandler: [If (slaves && master),[If (slaves?.id?.find({ -> ... }) && (master?.currentValue(switch) == on)),[If (evt.value != --),[(tempLevel = master.currentValue(colorTemperature))],],,],,],
textAppName: [(text = Color Coordinator)]
textVersion: [(text = Version 1.1.1 (12/13/2016))]
textCopyright: [(text = Copyright  2016 Michael Struck)]
textLicense: [(text = ((((((((((Licensed under the Apache License, Version 2.0 (the 'License');  + you may not use this file except in compliance with the License. ) + You may obtain a copy of the License at) + 

) +     http://www.apache.org/licenses/LICENSE-2.0) + 

) + Unless required by applicable law or agreed to in writing, software ) + distributed under the License is distributed on an 'AS IS' BASIS, ) + WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ) + See the License for the specific language governing permissions and ) + limitations under the License.))]
textHelp: [(text = ((This application will allow you to control the settings of multiple colored lights with one control.  + Simply choose a master control light, and then choose the lights that will follow the settings of the master, ) + including on/off conditions, hue, saturation, level and color temperature. Also includes a random color feature.))]
Starting Points: []
--app-start--
processing door-shield.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(value = zigbee.parse(description)?.text)][(name = ((value && (value != ping))) ? response : null)][(result = this.createEvent([name:name, value:value]))]
open: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: door-shield.metadata() is applicable for argument types: (door-shield$_run_closure1) values: [door-shield$_run_closure1@5a37d3ed]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing dry-the-wetspot.groovy
req caps: [capability.switch, capability.watersensor]
req cap size: 2
requested commands:[off, on]
requested attrs:[water, switch]
called cap-methods by app
off
on
called cap-props by app
water
attribute uses through subscriptions
water
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, 1e88cabe-5ba4-4647-9a23-0ad5b887f94b]
[[capability.battery]]
DECLARED METHODS
installed: [this.subscribe(sensor, water.dry, waterHandler)][this.subscribe(sensor, water.wet, waterHandler)]
updated: [this.unsubscribe()][this.subscribe(sensor, water.dry, waterHandler)][this.subscribe(sensor, water.wet, waterHandler)]
waterHandler: [If (evt.value == wet),,[If (evt.value == dry),,],],
Starting Points: []
--app-start--
processing hue-lux-bulb.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
initialize: 
installed: 
updated: 
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],
on: 
off: 
setLevel: [If (((percent != null) && (percent >= 0)) && (percent <= 100)),,],
refresh: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: hue-lux-bulb.metadata() is applicable for argument types: (hue-lux-bulb$_run_closure1) values: [hue-lux-bulb$_run_closure1@389c4eb1]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing hue-mood-lighting.groovy
req caps: [capability.motionsensor, capability.contactsensor, capability.colorcontrol, capability.switch, capability.button, capability.smokedetector, capability.watersensor, capability.accelerationsensor, capability.presencesensor]
req cap size: 9
requested commands:[setsaturation, sethue, setcolor, off, on]
requested attrs:[saturation, button, acceleration, motion, color, contact, smoke, hue, presence, water, switch]
type 2 attr uses
level
carbonmonoxide
called cap-methods by app
setcolor
called cap-props by app
saturation
button
acceleration
motion
contact
smoke
hue
presence
water
switch
attribute uses through subscriptions
button
saturation
acceleration
motion
level
contact
smoke
hue
presence
carbonmonoxide
water
switch
cmd overpriv:[setsaturation, sethue, off, on]
attr overpriv:[color]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 266374ae-3292-11e2-9c79-22000a1dc790, 48b39485-7ebc-4c80-bf6e-9a653a2d1c95, 8a9d4b1e3b8af959013b8af9d183000e, ff20e87b-992b-42b0-9cd6-72b0030dedc3, 26d69a34-ada2-42dc-9e45-445c78ae2619, 1e88cabe-5ba4-4647-9a23-0ad5b887f94b, f730b653-b0b6-483e-8c84-977e240f5eb3, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.refresh, capability.polling]]
DECLARED METHODS
mainPage: 
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],[return true],],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],[return true],],][return false]
ifUnset: [If settings[name],,],
ifSet: [If settings[name],,],
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,,],
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],
modeChangeHandler: [If (evt.value in triggerModes),,],
scheduledTimeHandler: 
appTouchHandler: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
takeAction: [If (frequency || oncePerDay),[(state[this.frequencyKey(evt)] = this.now())],],[(hueColor = 0)][(saturation = 100)]
frequencyKey: [lastActionTimeStamp]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],
oncePerDayOk: [(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result - $lastTime)][result]
getAllOk: [((modeOk && daysOk) && timeOk)]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)][result]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)][result]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)][result]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]
timeIntervalLabel: [((starting && ending)) ? ((this.hhmm(starting) + -) + this.hhmm(ending, h:mm a z)) : ]
Starting Points: []
--app-start--
processing harmony-activity.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
on: 
off: 
huboff: 
alloff: 
refresh: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: harmony-activity.metadata() is applicable for argument types: (harmony-activity$_run_closure1) values: [harmony-activity$_run_closure1@6a47b187]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing keen-home-smart-vent.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(map = [:])][If description?.startsWith(catchall:),[(map = this.parseCatchAllMessage(description))],[If description?.startsWith(read attr -),[(map = this.parseReportAttributeMessage(description))],[If (description?.startsWith(temperature: ) || description?.startsWith(humidity: )),[(map = this.parseCustomMessage(description))],[If description?.startsWith(on/off: ),[(map = this.parseOnOffMessage(description))],],],],],
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseCatchAllMessage: [(cluster = zigbee.parse(description))][If this.shouldProcessMessage(cluster),,],
shouldProcessMessage: [If ((((cluster.profileId != 260) || (cluster.command == 11)) || (cluster.command == 7)) || ((cluster.data.size() > 0) && (cluster.data.first() == 62))),,],
parseReportAttributeMessage: [(descMap = (description - read attr - ).split(,).inject([:], { java.lang.Object map, java.lang.Object param -> ... }))][If ((descMap.cluster == 0006) && (descMap.attrId == 0000)),,[If ((descMap.cluster == 0008) && (descMap.attrId == 0000)),,[If ((descMap.cluster == 0402) && (descMap.attrId == 0000)),[(value = this.convertTemperatureHex(descMap.value))],[If ((descMap.cluster == 0001) && (descMap.attrId == 0021)),,[If ((descMap.cluster == 0403) && (descMap.attrId == 0020)),,[If ((descMap.cluster == 0000) && (descMap.attrId == 0006)),,],],],],],],
parseCustomMessage: [(resultMap = [:])][If description?.startsWith(temperature: ),[(value = java.lang.Double.parseDouble(description.split(: )[1]))][(resultMap = this.makeTemperatureResult(this.convertTemperature(value)))],],
parseOnOffMessage: [(resultMap = [:])][If description?.startsWith(on/off: ),[(value = java.lang.Integer.parseInt((description - on/off: )))][(resultMap = this.makeOnOffResult(value))],],
makeOnOffResult: [(linkText = this.getLinkText(device))][(value = ((rawValue == 1)) ? on : off)]
makeLevelResult: [(linkText = this.getLinkText(device))][(value = java.lang.Integer.parseInt(rawValue, 16))][(rangeMax = 254)][If (value == 255),,],[(value = java.lang.Math.floor(((value / rangeMax) * 100)))]
makePressureResult: [(linkText = this.getLinkText(device))][(pascals = (rawValue / 10))][(result = [name:pressure, descriptionText:$linkText pressure is $pascalsPa, value:pascals])]
makeBatteryResult: [(linkText = this.getLinkText(device))]
makeTemperatureResult: [(linkText = this.getLinkText(device))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],
convertTemperatureHex: [(celsius = (java.lang.Integer.parseInt(value, 16).shortValue() / 100))]
convertTemperature: [If (this.getTemperatureScale() == C),,[(fahrenheit = (java.lang.Math.round((this.celsiusToFahrenheit(celsius) * 100)) / 100))]],
makeSerialResult: [(linkText = this.getLinkText(device))]
makeLevelCommand: [(rangeMax = 254)][(scaledLevel = java.lang.Math.round(((level * rangeMax) / 100)))][(hexLevel = new java.math.BigInteger(scaledLevel.toString()).toString(16).padLeft(2, 0))]
on: [(linkText = this.getLinkText(device))][If (device.currentValue(switch) == obstructed),,],
off: [(linkText = this.getLinkText(device))][If (device.currentValue(switch) == obstructed),,],
clearObstruction: [(linkText = this.getLinkText(device))]
setLevel: [(linkText = this.getLinkText(device))][(currentState = device.currentValue(switch))][If (currentState == obstructed),,],[If (value > 0),,],
getOnOff: [If (device.currentValue(switch) == obstructed),,],
getPressure: 
getLevel: [If (device.currentValue(switch) == obstructed),,],
getTemperature: 
getBattery: 
setZigBeeIdTile: [(linkText = this.getLinkText(device))]
refresh: 
ping: 
configure: [(configCmds = [zdo bind 0x$device.deviceNetworkId 1 1 0x0008 {$device.zigbeeId} {}, delay 500, zdo bind 0x$device.deviceNetworkId 1 1 0x0402 {$device.zigbeeId} {}, delay 500, zdo bind 0x$device.deviceNetworkId 1 1 0x0403 {$device.zigbeeId} {}, delay 500, zdo bind 0x$device.deviceNetworkId 1 1 0x0001 {$device.zigbeeId} {}, delay 500])]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: keen-home-smart-vent.metadata() is applicable for argument types: (keen-home-smart-vent$_run_closure1) values: [keen-home-smart-vent$_run_closure1@28d18df5]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing lifx-white-bulb.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
initialize: 
installed: 
updated: 
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
setLevel: [If ((percentage < 1) && (percentage > 0)),[(percentage = 1)],],[If (percentage == 0),,],
setColorTemperature: 
on: 
off: 
refresh: [(resp = parent.apiGET(/lights/$this.selector()))][If (resp.status == 404),[(state.online = false)],[If (resp.status != 200),,],],[(data = resp.data[0])][If data.connected,,],
selector: [If device.deviceNetworkId.contains(:),,],
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: lifx-white-bulb.metadata() is applicable for argument types: (lifx-white-bulb$_run_closure1) values: [lifx-white-bulb$_run_closure1@6304101a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing let-there-be-dark.groovy
req caps: [capability.contactsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[contact, switch]
called cap-methods by app
off
on
called cap-props by app
contact
switch
attribute uses through subscriptions
contact
switch
cmd overpriv:[]
attr overpriv:[]
DECLARED METHODS
installed: [this.subscribe(contact1, contact, contactHandler)]
updated: [this.unsubscribe()][this.subscribe(contact1, contact, contactHandler)]
contactHandler: [If (evt.value == open),[(state.wasOn = (switch1.currentValue(switch) == on))],],[If (evt.value == closed),[If state.wasOn,,],,],
Starting Points: []
IT HAS STATE
--app-start--
processing jawbone-user.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
generateSleepingEvent: [(value = this.formatValue(sleeping))][(linkText = this.getLinkText(device))][(descriptionText = this.formatDescriptionText(linkText, sleeping))][(handlerName = this.getState(sleeping))][(results = [name:sleeping, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName])][(results2 = [name:button, value:held, unit:null, linkText:linkText, descriptionText:$linkText button was pressed, handlerName:buttonHandler, ... ])]
poll: [(results = parent.pollChild(this))]
setMemberId: [(state.jawboneMemberId = memberId)]
getMemberId: [return state.jawboneMemberId]
uninstalled: 
formatValue: [If sleeping,,],
formatDescriptionText: [If sleeping,,],
getState: [If sleeping,,],
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: jawbone-user.metadata() is applicable for argument types: (jawbone-user$_run_closure1) values: [jawbone-user$_run_closure1@40317ba2]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing let-there-be-light.groovy
req caps: [capability.contactsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[contact, switch]
called cap-methods by app
off
on
called cap-props by app
contact
attribute uses through subscriptions
contact
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(contact1, contact, contactHandler)]
updated: [this.unsubscribe()][this.subscribe(contact1, contact, contactHandler)]
contactHandler: [If (evt.value == open),,[If (evt.value == closed),,],],
Starting Points: []
--app-start--
processing illuminance-measurement-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: illuminance-measurement-capability.metadata() is applicable for argument types: (illuminance-measurement-capability$_run_closure1) values: [illuminance-measurement-capability$_run_closure1@18e36d14]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing keep-me-cozy.groovy
req caps: [capability.thermostat]
req cap size: 1
requested commands:[heat, setheatingsetpoint, auto, cool, setcoolingsetpoint, fanon, setthermostatmode, emergencyheat, fancirculate, off, setthermostatfanmode, fanauto]
requested attrs:[coolingsetpoint, thermostatfanmode, thermostatmode, temperature, heatingsetpoint, thermostatoperatingstate, thermostatsetpoint]
type 2 command uses
poll
called cap-methods by app
setcoolingsetpoint
setheatingsetpoint
called cap-props by app
coolingsetpoint
temperature
heatingsetpoint
attribute uses through subscriptions
coolingsetpoint
temperature
heatingsetpoint
cmd overpriv:[heat, auto, cool, fanon, setthermostatmode, emergencyheat, fancirculate, off, setthermostatfanmode, fanauto]
attr overpriv:[thermostatfanmode, thermostatmode, thermostatoperatingstate, thermostatsetpoint]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(thermostat, heatingSetpoint, heatingSetpointHandler)][this.subscribe(thermostat, coolingSetpoint, coolingSetpointHandler)][this.subscribe(thermostat, temperature, temperatureHandler)][this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
updated: [this.unsubscribe()][this.subscribe(thermostat, heatingSetpoint, heatingSetpointHandler)][this.subscribe(thermostat, coolingSetpoint, coolingSetpointHandler)][this.subscribe(thermostat, temperature, temperatureHandler)][this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
heatingSetpointHandler: 
coolingSetpointHandler: 
temperatureHandler: 
changedLocationMode: 
appTouch: 
event: 
Starting Points: []
--app-start--
processing life360-user.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
generatePresenceEvent: [(value = this.formatValue(present))][(linkText = this.getLinkText(device))][(descriptionText = this.formatDescriptionText(linkText, present))][(handlerName = this.getState(present))][(results = [name:presence, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName])]
setMemberId: [(state.life360MemberId = memberId)]
getMemberId: [return state.life360MemberId]
formatValue: [If present,,],
formatDescriptionText: [If present,,],
getState: [If present,,],
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: life360-user.metadata() is applicable for argument types: (life360-user$_run_closure1) values: [life360-user$_run_closure1@71e693fa]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing lifx-color-bulb.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
initialize: 
installed: 
updated: 
setHue: 
setSaturation: 
setColor: [(attrs = [])][(events = [])]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
setLevel: [If ((percentage < 1) && (percentage > 0)),[(percentage = 1)],],[If (percentage == 0),,],
setColorTemperature: 
on: 
off: 
refresh: [(resp = parent.apiGET(/lights/$this.selector()))][If (resp.status == 404),[(state.online = false)],[If (resp.status != 200),,],],[(data = resp.data[0])][If data.connected,,],
selector: [If device.deviceNetworkId.contains(:),,],
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: lifx-color-bulb.metadata() is applicable for argument types: (lifx-color-bulb$_run_closure1) values: [lifx-color-bulb$_run_closure1@25f4878b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing keep-me-cozy-ii.groovy
req caps: [capability.thermostat, capability.temperaturemeasurement]
req cap size: 2
requested commands:[heat, setheatingsetpoint, auto, cool, setcoolingsetpoint, fanon, setthermostatmode, emergencyheat, fancirculate, off, setthermostatfanmode, fanauto]
requested attrs:[coolingsetpoint, thermostatfanmode, thermostatmode, temperature, heatingsetpoint, thermostatoperatingstate, thermostatsetpoint]
type 2 command uses
poll
called cap-methods by app
setcoolingsetpoint
setheatingsetpoint
called cap-props by app
temperature
coolingsetpoint
heatingsetpoint
thermostatmode
attribute uses through subscriptions
temperature
thermostatmode
cmd overpriv:[heat, auto, cool, fanon, setthermostatmode, emergencyheat, fancirculate, off, setthermostatfanmode, fanauto]
attr overpriv:[thermostatfanmode, thermostatoperatingstate, thermostatsetpoint]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8aa8a6b23f769c09013f769ed1c20012, ba155665-433d-4e20-9d12-efad7744c3d6]
[[capability.relativehumiditymeasurement]]
DECLARED METHODS
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [this.subscribe(location, changedLocationMode)][If sensor,[this.subscribe(sensor, temperature, temperatureHandler)][this.subscribe(thermostat, temperature, temperatureHandler)][this.subscribe(thermostat, thermostatMode, temperatureHandler)],],
changedLocationMode: 
temperatureHandler: 
evaluate: [If sensor,[(threshold = 1.0)][(tm = thermostat.currentThermostatMode)][(ct = thermostat.currentTemperature)][(currentTemp = sensor.currentTemperature)][If (tm in [cool, auto]),[If ((currentTemp - coolingSetpoint) >= threshold),,[If (((coolingSetpoint - currentTemp) >= threshold) && ((ct - thermostat.currentCoolingSetpoint) >= threshold)),,],],,],[If (tm in [heat, emergency heat, auto]),[If ((heatingSetpoint - currentTemp) >= threshold),,[If (((currentTemp - heatingSetpoint) >= threshold) && ((thermostat.currentHeatingSetpoint - ct) >= threshold)),,],],,],,],
coolingSetpointHandler: 
heatingSetpointHandler: 
Starting Points: []
--app-start--
processing light-follows-me.groovy
req caps: [capability.motionsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[motion, switch]
called cap-methods by app
off
on
called cap-props by app
motion
attribute uses through subscriptions
motion
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(motion1, motion, motionHandler)]
updated: [this.unsubscribe()][this.subscribe(motion1, motion, motionHandler)]
motionHandler: [If (evt.value == active),,[If (evt.value == inactive),,],],
scheduleCheck: [(motionState = motion1.currentState(motion))][If (motionState.value == inactive),[(elapsed = (this.now() - motionState.rawDateCreated.time))][(threshold = (((1000 * 60) * minutes1) - 1000))][If (elapsed >= threshold),,],,],
Starting Points: []
--app-start--
processing light-sensor.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If description?.startsWith(illuminance: ),[(raw = (description - illuminance: ))][If raw.isNumber(),[(result = this.createEvent([name:illuminance, value:java.lang.Math.round(zigbee.lux((java.lang.Integer -> java.lang.Integer) raw)).toString(), unit:lux]))],],,],
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: light-sensor.metadata() is applicable for argument types: (light-sensor$_run_closure1) values: [light-sensor$_run_closure1@45a37759]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing light-up-the-night.groovy
req caps: [capability.illuminancemeasurement, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[illuminance, switch]
called cap-methods by app
off
on
called cap-props by app
illuminance
attribute uses through subscriptions
illuminance
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(lightSensor, illuminance, illuminanceHandler)]
updated: [this.unsubscribe()][this.subscribe(lightSensor, illuminance, illuminanceHandler)]
illuminanceHandler: [(lastStatus = state.lastStatus)][If ((lastStatus != on) && (evt.integerValue < 30)),[(state.lastStatus = on)],[If ((lastStatus != off) && (evt.integerValue > 50)),[(state.lastStatus = off)],],],
Starting Points: []
IT HAS STATE
--app-start--
processing momentary-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
push: 
off: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: momentary-capability.metadata() is applicable for argument types: (momentary-capability$_run_closure1) values: [momentary-capability$_run_closure1@50de186c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing netatmo-additional-module.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
poll: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: netatmo-additional-module.metadata() is applicable for argument types: (netatmo-additional-module$_run_closure1) values: [netatmo-additional-module$_run_closure1@5ef5c734]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing make-it-so.groovy
req caps: [capability.lock, capability.thermostat, capability.switch]
req cap size: 3
requested commands:[heat, setheatingsetpoint, auto, unlock, cool, setthermostatmode, off, setcoolingsetpoint, lock, fanon, emergencyheat, fancirculate, setthermostatfanmode, on, fanauto]
requested attrs:[coolingsetpoint, thermostatfanmode, thermostatmode, temperature, lock, heatingsetpoint, thermostatoperatingstate, thermostatsetpoint, switch]
type 2 command uses
setlevel
type 2 attr uses
level
called cap-methods by app
setheatingsetpoint
unlock
setcoolingsetpoint
lock
off
on
called cap-props by app
coolingsetpoint
lock
heatingsetpoint
switch
attribute uses through subscriptions
cmd overpriv:[heat, auto, cool, setthermostatmode, fanon, emergencyheat, fancirculate, setthermostatfanmode, fanauto]
attr overpriv:[thermostatfanmode, thermostatmode, temperature, thermostatoperatingstate, thermostatsetpoint]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, bdefadfd-d59f-4d54-82c2-5fbb3ac6965f, 8aa8a6b23f769c09013f769ed1c20012]
[[capability.battery, capability.polling, capability.refresh]]
DECLARED METHODS
installed: [this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
updated: [this.unsubscribe()][this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
appTouch: 
changedLocationMode: 
restoreState: [(map = (state[mode]) ? state[mode] : [:])][(switches?.each({ -> ... }){ (value = map[it.id]); <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })][(thermostats?.each({ -> ... }){ (value = map[it.id]); <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement>; <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })][(locks?.each({ -> ... }){ (value = map[it.id]); <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })]
saveState: [(mode = currentMode)][(map = (state[mode]) ? state[mode] : [:])][(switches?.each({ -> ... }){ (map[it.id] = [switch:it.currentSwitch, level:it.currentLevel]) })][(thermostats?.each({ -> ... }){ (map[it.id] = [coolingSetpoint:it.currentCoolingSetpoint, heatingSetpoint:it.currentHeatingSetpoint]) })][(locks?.each({ -> ... }){ (map[it.id] = [locked:(it.currentLock == locked)]) })][(state[mode] = map)]
getCurrentMode: [(location.mode) ? location.mode : _none_]
Starting Points: []
--app-start--
processing mobile-presence.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(name = this.parseName(description))][(value = this.parseValue(description))][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(handlerName = this.getState(value))][(isStateChange = this.isStateChange(device, name, value))][(results = [translatable:true, name:name, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName, ... ])]
parseName: [If description?.startsWith(presence: ),,],
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseValue: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseDescriptionText: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
getState: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: mobile-presence.metadata() is applicable for argument types: (mobile-presence$_run_closure1) values: [mobile-presence$_run_closure1@327bcebd]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing my-light-toggle.groovy
req caps: [capability.motionsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[motion, switch]
called cap-methods by app
off
on
called cap-props by app
motion
switch
attribute uses through subscriptions
motion
cmd overpriv:[]
attr overpriv:[]
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(motionToggler, motion, toggleSwitches)]
toggleSwitches: [If ((evt.value == active) && (masterToggle.currentSwitch == off)),,[If ((evt.value == active) && (masterToggle.currentSwitch == on)),,],],
Starting Points: []
--app-start--
processing momentary-button-tile.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
push: 
on: 
off: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: momentary-button-tile.metadata() is applicable for argument types: (momentary-button-tile$_run_closure1) values: [momentary-button-tile$_run_closure1@70f02c32]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing motion-sensor-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: motion-sensor-capability.metadata() is applicable for argument types: (motion-sensor-capability$_run_closure1) values: [motion-sensor-capability$_run_closure1@26ceffa8]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing lock-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
lock: 
unlock: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: lock-capability.metadata() is applicable for argument types: (lock-capability$_run_closure1) values: [lock-capability$_run_closure1@78641d23]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing mood-cube.groovy
req caps: [capability.threeaxis, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[threeaxis, switch]
type 2 command uses
setlevel
setcolor
type 2 attr uses
saturation
hue
level
called cap-methods by app
off
on
called cap-props by app
threeaxis
switch
attribute uses through subscriptions
saturation
hue
level
threeaxis
switch
cmd overpriv:[]
attr overpriv:[]
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, 258ee648-d846-4702-bdfb-475a7ed047b4]
[[capability.battery, capability.contactsensor, capability.signalstrength, capability.accelerationsensor, capability.temperaturemeasurement]]
DECLARED METHODS
scenesPage: [(sceneId = this.getOrientation())]
scenePage: [(currentSceneId = this.getOrientation())][(sceneId = ((java.lang.Integer -> java.lang.Integer) params.sceneId) ? (java.lang.Integer -> java.lang.Integer) params.sceneId : state.lastDisplayedSceneId)][(state.lastDisplayedSceneId = sceneId)]
devicePage: [(sceneId = ((java.lang.Integer -> java.lang.Integer) params.sceneId) ? (java.lang.Integer -> java.lang.Integer) params.sceneId : state.lastDisplayedSceneId)]
saveStatesPage: 
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(cube, threeAxis, positionHandler)]
positionHandler: [(sceneId = this.getOrientation(evt.xyzValue))][If (sceneId != state.lastActiveSceneId),,],[(state.lastActiveSceneId = sceneId)]
sceneIsDefined: [(tgt = onoff_$sceneId.toString())][(settings.find({ -> ... }) != null)]
updateSetting: [(settings[name] = value)]
closestLevel: [(level) ? $(Math.round((level / 5)) * 5)% : 0%]
saveStates: [(sceneId = (java.lang.Integer -> java.lang.Integer) params.sceneId)][(lights.each({ java.lang.Object light -> ... }){ (type = state.lightCapabilities[light.id]); this.updateSetting(onoff_$sceneId_$light.id, (light.currentValue(switch) == on)); <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })]
restoreStates: [(lights.each({ java.lang.Object light -> ... }){ (type = state.lightCapabilities[light.id]); (isOn = ((settings.onoff_$sceneId_$light.id == true)) ? true : false); log.debug($light.displayName is '$isOn'); <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement>; <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })]
switchLevel: [(percent = settings.level_$sceneId_$light.id)][If percent,,[null]],
getDeviceCapabilities: [(caps = [:])][(lights.each({ -> ... }){ <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })][(state.lightCapabilities = caps)]
getLevels: [(levels = [])][For ((i = 0); (i <= 100); (i += 5)),[(levels << $i%)]]getLevels: [(levels = [])][For ((i = 0); (i <= 100); (i += 5)),[(levels << $i%)]][levels]
getOrientation: [(threshold = 250)][(value = (xyz) ? xyz : cube.currentValue(threeAxis))][(x = ((java.lang.Math.abs(value.x) > threshold)) ? ((value.x > 0)) ? 1 : -1 : 0)][(y = ((java.lang.Math.abs(value.y) > threshold)) ? ((value.y > 0)) ? 1 : -1 : 0)][(z = ((java.lang.Math.abs(value.z) > threshold)) ? ((value.z > 0)) ? 1 : -1 : 0)][(orientation = 0)][If (z > 0),[If ((x == 0) && (y == 0)),[(orientation = 1)],],,[If (z < 0),[If ((x == 0) && (y == 0)),[(orientation = 2)],],,[If (x > 0),[If (y == 0),[(orientation = 3)],],,[If (x < 0),[If (y == 0),[(orientation = 4)],],,[If (y > 0),[(orientation = 5)],[If (y < 0),[(orientation = 6)],],],],],],],[orientation]
sceneName: [(names = [UNDEFINED, One, Two, Three, Four, Five, Six])][(settings.sceneName$num) ? settings.sceneName$num : Scene $names[num]]
Starting Points: []
IT HAS STATE
--app-start--
processing lights-off-with-no-motion-and-presence.groovy
req caps: [capability.motionsensor, capability.switch, capability.presencesensor]
req cap size: 3
requested commands:[off, on]
requested attrs:[motion, presence, switch]
called cap-methods by app
off
called cap-props by app
motion
presence
attribute uses through subscriptions
motion
presence
cmd overpriv:[on]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(motionSensor, motion, motionHandler)][this.subscribe(presenceSensors, presence, presenceHandler)]
updated: [this.unsubscribe()][this.subscribe(motionSensor, motion, motionHandler)][this.subscribe(presenceSensors, presence, presenceHandler)]
motionHandler: [If (evt.value == inactive),,],
presenceHandler: [If (evt.value == not present),,],
isActivePresence: [(noPresence = (presenceSensors.find({ -> ... }) == null))][noPresence]
scheduleCheck: [(motionState = motionSensor.currentState(motion))][If (motionState.value == inactive),[(elapsed = (this.now() - motionState.rawDateCreated.time))][(threshold = (((1000 * 60) * delayMins) - 1000))][If (elapsed >= threshold),[If this.isActivePresence(),,],,],,],
Starting Points: []
--app-start--
processing lights-off-when-closed.groovy
req caps: [capability.contactsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[contact, switch]
called cap-methods by app
off
called cap-props by app
contact
attribute uses through subscriptions
contact
cmd overpriv:[on]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(contact1, contact.closed, contactClosedHandler)]
updated: [this.unsubscribe()][this.subscribe(contact1, contact.closed, contactClosedHandler)]
contactClosedHandler: 
Starting Points: []
--app-start--
processing motion-detector.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(name = null)][(value = description)][(descriptionText = null)][If zigbee.isZoneType19(description),[(name = motion)][(isActive = zigbee.translateStatusZoneType19(description))][(value = (isActive) ? active : inactive)][(descriptionText = (isActive) ? $device.displayName detected motion : $device.displayName motion has stopped)],],[(result = this.createEvent([name:name, value:value, descriptionText:descriptionText]))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: motion-detector.metadata() is applicable for argument types: (motion-detector$_run_closure1) values: [motion-detector$_run_closure1@3899782c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing netatmo-basestation.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
poll: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: netatmo-basestation.metadata() is applicable for argument types: (netatmo-basestation$_run_closure1) values: [netatmo-basestation$_run_closure1@58326051]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing notify-me-with-hue.groovy
req caps: [capability.motionsensor, capability.colorcontrol, capability.contactsensor, capability.switch, capability.button, capability.smokedetector, capability.watersensor, capability.accelerationsensor, capability.presencesensor]
req cap size: 9
requested commands:[setsaturation, sethue, setcolor, off, on]
requested attrs:[saturation, button, acceleration, motion, color, contact, smoke, hue, presence, water, switch]
type 2 attr uses
level
carbonmonoxide
called cap-methods by app
setcolor
called cap-props by app
saturation
button
acceleration
motion
color
contact
smoke
hue
presence
water
switch
attribute uses through subscriptions
motion
color
level
smoke
carbonmonoxide
water
switch
button
saturation
acceleration
contact
hue
presence
cmd overpriv:[setsaturation, sethue, off, on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 48b39485-7ebc-4c80-bf6e-9a653a2d1c95, 266374ae-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, ff20e87b-992b-42b0-9cd6-72b0030dedc3, 26d69a34-ada2-42dc-9e45-445c78ae2619, 1e88cabe-5ba4-4647-9a23-0ad5b887f94b, f730b653-b0b6-483e-8c84-977e240f5eb3, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.refresh, capability.polling]]
DECLARED METHODS
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,,],
eventHandler: [If frequency,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],
modeChangeHandler: [If (evt.value in triggerModes),,],
scheduledTimeHandler: 
appTouchHandler: 
takeAction: [If frequency,[(state[evt.deviceId] = this.now())],],[(hueColor = 0)][If (color == Blue),[(hueColor = 70)],[If (color == Green),[(hueColor = 39)],[If (color == Yellow),[(hueColor = 25)],[If (color == Orange),[(hueColor = 10)],[If (color == Purple),[(hueColor = 75)],[If (color == Pink),[(hueColor = 83)],],],],],],],[(state.previous = [:])][(hues.each({ -> ... }){ (state.previous[it.id] = [switch:it.currentValue(switch), level:it.currentValue(level), hue:it.currentValue(hue), saturation:it.currentValue(saturation), ... ]) })][(newValue = [hue:hueColor, saturation:100, level:((java.lang.Integer -> java.lang.Integer) lightLevel) ? (java.lang.Integer -> java.lang.Integer) lightLevel : 100])]
setTimer: [If duration,,[If (duration < 10),,],],
resetHue: [(hues.each({ -> ... }){ it.setColor(state.previous[it.id]) })]
Starting Points: []
IT HAS STATE
--app-start--
processing notify-me-when.groovy
req caps: [capability.motionsensor, capability.contactsensor, capability.switch, capability.button, capability.smokedetector, capability.watersensor, capability.accelerationsensor, capability.presencesensor]
req cap size: 8
requested commands:[off, on]
requested attrs:[button, acceleration, motion, contact, smoke, presence, water, switch]
type 2 attr uses
carbonmonoxide
called cap-methods by app
called cap-props by app
button
acceleration
motion
contact
smoke
presence
water
switch
attribute uses through subscriptions
button
acceleration
motion
contact
smoke
presence
carbonmonoxide
water
switch
cmd overpriv:[off, on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 266374ae-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, ff20e87b-992b-42b0-9cd6-72b0030dedc3, 26d69a34-ada2-42dc-9e45-445c78ae2619, 1e88cabe-5ba4-4647-9a23-0ad5b887f94b, f730b653-b0b6-483e-8c84-977e240f5eb3, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.refresh, capability.switchlevel, capability.polling]]
DECLARED METHODS
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [this.subscribe(button, button.pushed, eventHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)]
eventHandler: [If frequency,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],
sendMessage: [(msg = messageText)][(options = [:])][If messageText,[(msg = this.defaultText(evt))][(options = [translatable:true, triggerEvent:evt])],],[If location.contactBookEnabled,,[If phone,[(options.phone = phone)][If (pushAndPhone != No),[(options.method = both)],[(options.method = phone)]],,[If (pushAndPhone != No),[(options.method = push)],[(options.method = none)]],],],[If frequency,[(state[evt.deviceId] = this.now())],],
defaultText: [If (evt.name == presence),[If (evt.value == present),[If includeArticle,[{{ triggerEvent.linkText }} has arrived at the {{ location.name }}],[{{ triggerEvent.linkText }} has arrived at {{ location.name }}]],,[If includeArticle,[{{ triggerEvent.linkText }} has left the {{ location.name }}],[{{ triggerEvent.linkText }} has left {{ location.name }}]],],,[{{ triggerEvent.descriptionText }}]],
getIncludeArticle: [(name = location.name.toLowerCase())][(segs = name.split( ))][([work, home].contains(name) || ((segs.size() > 1) && ([the, my, a, an].contains(segs[0]) || segs[0].endsWith('s))))]
Starting Points: []
--app-start--
processing plant-link.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
updated: 
parse: [(map = [:])][If description?.startsWith(read attr -),[(descMap = this.parseDescriptionAsMap(description))][If ((descMap.cluster == 0405) && (descMap.attrId == 0000)),[(map.name = humidity)][(map.value = this.calculateHumidity(descMap.value))],[If ((descMap.cluster == 0001) && (descMap.attrId == 0000)),[(map.name = battery)][(map.value = this.calculateBattery(descMap.value))],],],,],[(result = null)][If map,[(result = this.createEvent(map))],],
parseDescriptionAsMap: 
calculateHumidity: [(range = 576)][(percent = ((java.lang.Integer.parseInt(value, 16) / range) * 100))][(percent = java.lang.Math.max(0.0, java.lang.Math.min(percent, 100.0)))]
calculateBattery: [(min = 2300)][(percent = ((java.lang.Integer.parseInt(value, 16) - min) / 10))][(percent = java.lang.Math.max(0.0, java.lang.Math.min(percent, 100.0)))]
hex: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: plant-link.metadata() is applicable for argument types: (plant-link$_run_closure1) values: [plant-link$_run_closure1@49964d75]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing on-off-button-tile.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
on: 
off: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: on-off-button-tile.metadata() is applicable for argument types: (on-off-button-tile$_run_closure1) values: [on-off-button-tile$_run_closure1@13330ac6]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing once-a-day.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
off
on
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: 
updated: 
startTimerCallback: 
stopTimerCallback: 
Starting Points: []
--app-start--
processing particulate-detector.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: particulate-detector.metadata() is applicable for argument types: (particulate-detector$_run_closure1) values: [particulate-detector$_run_closure1@65a15628]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing netatmo-rain.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
poll: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: netatmo-rain.metadata() is applicable for argument types: (netatmo-rain$_run_closure1) values: [netatmo-rain$_run_closure1@3a4621bd]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing obything-music-connect.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
updated: 
initialize: [(parts = theAddr.split(:))][(iphex = this.convertIPtoHex(parts[0]))][(porthex = this.convertPortToHex(parts[1]))][(dni = $iphex:$porthex)][(hubNames = location.hubs*?.name.findAll({ -> ... }))][(d = this.addChildDevice(com.obycode, ObyThing Music, dni, theHub.id, [label:$app.label, name:ObyThing]))]
convertIPtoHex: [(hex = ipAddress.tokenize(.).collect({ -> ... }).join())]
convertPortToHex: [(hexport = port.toString().format(%04X, port.toInteger()))]
Starting Points: []
--app-start--
processing pet-feeder-shield.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(value = zigbee.parse(description)?.text)][(name = ((value && (value != ping))) ? response : null)][(result = this.createEvent([name:name, value:value]))]
feed: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: pet-feeder-shield.metadata() is applicable for argument types: (pet-feeder-shield$_run_closure1) values: [pet-feeder-shield$_run_closure1@7d1cfb8b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing netatmo-outdoor-module.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
poll: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: netatmo-outdoor-module.metadata() is applicable for argument types: (netatmo-outdoor-module$_run_closure1) values: [netatmo-outdoor-module$_run_closure1@53fd0d10]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing on-off-shield.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(value = zigbee.parse(description)?.text)][(name = ((value in [on, off])) ? switch : null)][(result = this.createEvent([name:name, value:value]))]
on: 
off: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: on-off-shield.metadata() is applicable for argument types: (on-off-shield$_run_closure1) values: [on-off-shield$_run_closure1@6138e79a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing open-closed-sensor.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(resMap = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If description.startsWith(zone),[(resMap = this.createEvent([name:contact, value:(zigbee.parseZoneStatus(description).isAlarm1Set()) ? open : closed]))],],
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: open-closed-sensor.metadata() is applicable for argument types: (open-closed-sensor$_run_closure1) values: [open-closed-sensor$_run_closure1@7776ab]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing nfc-tag-toggle.groovy
currentValue, arg not ConstantExpression
currentValue, arg not ConstantExpression
req caps: [capability.touchsensor, capability.switch, capability.lock, capability.doorcontrol]
req cap size: 4
requested commands:[lock, unlock, close, off, open, on]
requested attrs:[lock, touch, door, switch]
called cap-methods by app
lock
unlock
close
off
open
on
called cap-props by app
attribute uses through subscriptions
nfctouch
cmd overpriv:[]
attr overpriv:[lock, touch, door, switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, bdefadfd-d59f-4d54-82c2-5fbb3ac6965f, 548b3451-701a-4244-b66a-40d08564dc47]
[[capability.battery, capability.contactsensor, capability.polling, capability.refresh]]
DECLARED METHODS
pageTwo: 
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(tag, nfcTouch, touchHandler)][this.subscribe(app, touchHandler)]
currentStatus: [(result = null)][If master,[(result = devices.find({ -> ... })?.currentValue(attribute))],[(map = [:])][(devices.each({ -> ... }){ (value = it.currentValue(attribute)); (map[value] = ((map[value]) ? map[value] : 0 + 1)); log.trace($it.displayName: $value) })][(result = map.collect({ -> ... }).sort({ -> ... })[-1].key)]],[result]
touchHandler: [If switch1,[(status = this.currentStatus(switch1, masterSwitch, switch))][(switch1.each({ -> ... }){ <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })],],[If lock,[(status = this.currentStatus(lock, masterLock, lock))][(lock.each({ -> ... }){ <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })],],[If garageDoor,[(status = this.currentStatus(garageDoor, masterDoor, status))][(garageDoor.each({ -> ... }){ <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })],],
Starting Points: []
--app-start--
processing power-allowance.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
off
called cap-props by app
switch
attribute uses through subscriptions
switch
cmd overpriv:[on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(theSwitch, switch.on, switchOnHandler, [filterEvents:false])]
updated: [this.unsubscribe()][this.subscribe(theSwitch, switch.on, switchOnHandler, [filterEvents:false])]
switchOnHandler: [(delay = (minutesLater * 60))]
turnOffSwitch: 
Starting Points: []
--app-start--
processing relative-humidity-measurement-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: relative-humidity-measurement-capability.metadata() is applicable for argument types: (relative-humidity-measurement-capability$_run_closure1) values: [relative-humidity-measurement-capability$_run_closure1@1a6c1270]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-lock.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],
installed: 
updated: 
initialize: 
processPreferences: [(strBatteryLevel = $prefBatteryLevel)][(batteryLevel = (strBatteryLevel.isInteger()) ? strBatteryLevel.toInteger() : null)][If batteryLevel,,],[If prefJamNextOperation,,],[If prefJamImmediately,,],
refresh: 
ping: 
lock: [If (device.currentValue(doesNextOperationJam) == true),,],
unlock: [If (device.currentValue(doesNextOperationJam) == true),,],
jam: [If (device.currentValue(doesNextOperationJam) == true),,],
setJamNextOperation: 
clearJamNextOperation: 
setBatteryLevel: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-lock.metadata() is applicable for argument types: (simulated-lock$_run_closure1) values: [simulated-lock$_run_closure1@4f1bfe23]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-eggtray.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],
eggReport: 
poll: 
refresh: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-eggtray.metadata() is applicable for argument types: (quirky-wink-eggtray$_run_closure1) values: [quirky-wink-eggtray$_run_closure1@f316aeb]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-porkfolio.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],
poll: 
refresh: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-porkfolio.metadata() is applicable for argument types: (quirky-wink-porkfolio$_run_closure1) values: [quirky-wink-porkfolio$_run_closure1@79c7532f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-button.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
hold1: 
push1: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-button.metadata() is applicable for argument types: (simulated-button$_run_closure1) values: [simulated-button$_run_closure1@50468873]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-alarm.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
strobe: 
siren: 
both: 
off: 
parse: [(pair = description.split(:))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-alarm.metadata() is applicable for argument types: (simulated-alarm$_run_closure1) values: [simulated-alarm$_run_closure1@13d9b21f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-dimmable-bulb.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],
installed: 
updated: 
ping: 
refresh: 
configure: 
on: 
off: 
setLevel: [(levelEventMap = this.buildSetLevelEvent(value))][If (levelEventMap.value == 0),,],
setLevel: 
getSwitch: [(switchState = device.currentState(switch))]
getLevel: [(levelState = device.currentState(level))]
initialize: 
buildSetLevelEvent: [(intValue = (java.lang.Integer -> java.lang.Integer) value)][(newLevel = java.lang.Math.max(java.lang.Math.min(intValue, 99), 0))][(eventMap = [name:level, value:newLevel, unit:%])]
implicitOn: [If (device.currentValue(switch) != on),,],
turnOn: 
turnOff: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-dimmable-bulb.metadata() is applicable for argument types: (simulated-dimmable-bulb$_run_closure1) values: [simulated-dimmable-bulb$_run_closure1@635572a7]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-dimmer-switch.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],
installed: 
updated: 
refresh: 
configure: 
on: 
off: 
setLevel: [(levelEventMap = this.buildSetLevelEvent(value))][If (levelEventMap.value == 0),,],
setLevel: 
initialize: 
buildSetLevelEvent: [(intValue = (java.lang.Integer -> java.lang.Integer) value)][(newLevel = java.lang.Math.max(java.lang.Math.min(intValue, 99), 0))][(eventMap = [name:level, value:newLevel, unit:%])]
implicitOn: [If (device.currentValue(switch) != on),,],
turnOn: 
turnOff: 
onPhysical: 
offPhysical: 
setLevelPhysical: [(eventMap = this.buildSetLevelEvent(value))][If (eventMap.value == 0),[(eventMap.value = 1)],],[(eventMap.type = physical)]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-dimmer-switch.metadata() is applicable for argument types: (simulated-dimmer-switch$_run_closure1) values: [simulated-dimmer-switch$_run_closure1@6fe1b4fb]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-garage-door-opener.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
open: 
close: 
finishOpening: 
finishClosing: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-garage-door-opener.metadata() is applicable for argument types: (simulated-garage-door-opener$_run_closure1) values: [simulated-garage-door-opener$_run_closure1@1fdf1c5]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-nimbus.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],
poll: 
refresh: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-nimbus.metadata() is applicable for argument types: (quirky-wink-nimbus$_run_closure1) values: [quirky-wink-nimbus$_run_closure1@37091312]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-powerstrip.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],
on: 
off: 
poll: 
refresh: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-powerstrip.metadata() is applicable for argument types: (quirky-wink-powerstrip$_run_closure1) values: [quirky-wink-powerstrip$_run_closure1@77b14724]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-contact-sensor.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
open: 
close: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-contact-sensor.metadata() is applicable for argument types: (simulated-contact-sensor$_run_closure1) values: [simulated-contact-sensor$_run_closure1@1477089c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-color-control.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
setSaturation: 
setHue: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-color-control.metadata() is applicable for argument types: (simulated-color-control$_run_closure1) values: [simulated-color-control$_run_closure1@74960bfa]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-spotter.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],
poll: 
refresh: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-spotter.metadata() is applicable for argument types: (quirky-wink-spotter$_run_closure1) values: [quirky-wink-spotter$_run_closure1@5669c5fb]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing presence-sensor-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: presence-sensor-capability.metadata() is applicable for argument types: (presence-sensor-capability$_run_closure1) values: [presence-sensor-capability$_run_closure1@4dc8caa7]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-minimote.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
push1: 
push2: 
push3: 
push4: 
hold1: 
hold2: 
hold3: 
hold4: 
push: 
hold: 
installed: 
updated: 
initialize: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-minimote.metadata() is applicable for argument types: (simulated-minimote$_run_closure1) values: [simulated-minimote$_run_closure1@72c28d64]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-temperature-sensor.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
setLevel: 
up: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue + 1) : 72)]
down: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue - 1) : 72)]
setTemperature: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-temperature-sensor.metadata() is applicable for argument types: (simulated-temperature-sensor$_run_closure1) values: [simulated-temperature-sensor$_run_closure1@2d1dee39]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-refrigerator-temperature-control.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: [this.sendEvent([name:temperature, value:((device.componentName == freezer)) ? 2 : 40])][this.sendEvent([name:coolingSetpoint, value:((device.componentName == freezer)) ? 2 : 40])]
updated: 
tempUp: [(value = (java.lang.Integer -> java.lang.Integer) device.currentValue(temperature))]
tempDown: [(value = (java.lang.Integer -> java.lang.Integer) device.currentValue(temperature))]
setpointUp: [(value = (java.lang.Integer -> java.lang.Integer) device.currentValue(coolingSetpoint))]
setpointDown: [(value = (java.lang.Integer -> java.lang.Integer) device.currentValue(coolingSetpoint))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-refrigerator-temperature-control.metadata() is applicable for argument types: (simulated-refrigerator-temperature-control$_run_closure1) values: [simulated-refrigerator-temperature-control$_run_closure1@23fb172e]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-thermostat.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
configure: 
initialize: [(state.isHvacRunning = false)][(state.lastOperatingState = DEFAULT_OP_STATE)][(state.lastUserSetpointMode = DEFAULT_PREVIOUS_STATE)]
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],
ping: 
refresh: 
getThermostatMode: 
setThermostatMode: [If (value in SUPPORTED_MODES),[this.proposeSetpoints(this.getHeatingSetpoint(), this.getCoolingSetpoint(), state.lastUserSetpointMode)],],
cycleMode: [(nextMode = this.nextListElement(SUPPORTED_MODES, this.getThermostatMode()))]
isThermostatOff: [return (this.getThermostatMode() == MODE.OFF)]
getFanMode: 
setThermostatFanMode: [If (value in SUPPORTED_FAN_MODES),,],
cycleFanMode: [(nextMode = this.nextListElement(SUPPORTED_FAN_MODES, this.getFanMode()))]
no code yet for classclass org.codehaus.groovy.ast.stmt.ThrowStatement
no code yet for classclass org.codehaus.groovy.ast.stmt.ThrowStatement
nextListElement: [If (uniqueList != uniqueList.unique().asList()),,[If (currentElt in uniqueList),,],],[(listIdxMax = (uniqueList.size() - 1))][(currentEltIdx = uniqueList.indexOf(currentElt))][(nextEltIdx = ((currentEltIdx < listIdxMax)) ? (++currentEltIdx) : 0)][(nextElt = (java.lang.String -> java.lang.String) uniqueList[nextEltIdx])]
getOperatingState: [(operatingState = (device.currentValue(thermostatOperatingState)) ? device.currentValue(thermostatOperatingState) : OP_STATE.IDLE)]
setOperatingState: [If (operatingState in OP_STATE.values()),[If (operatingState != OP_STATE.IDLE),[(state.lastOperatingState = operatingState)],],,[log.warn('$operatingState' is not a supported operating state. Please set one of $OP_STATE.values().join(, ))]],
getThermostatSetpoint: [(ts = device.currentState(thermostatSetpoint))]
getHeatingSetpoint: [(hs = device.currentState(heatingSetpoint))]
setHeatingSetpoint: [(state.lastUserSetpointMode = SETPOINT_TYPE.HEATING)]
setHeatingSetpointInternal: 
heatUp: [(newHsp = (this.getHeatingSetpoint() + 1))][If (this.getThermostatMode() in (HEAT_ONLY_MODES + DUAL_SETPOINT_MODES)),,],
heatDown: [(newHsp = (this.getHeatingSetpoint() - 1))][If (this.getThermostatMode() in (HEAT_ONLY_MODES + DUAL_SETPOINT_MODES)),,],
getCoolingSetpoint: [(cs = device.currentState(coolingSetpoint))]
setCoolingSetpoint: [(state.lastUserSetpointMode = SETPOINT_TYPE.COOLING)]
setCoolingSetpointInternal: 
coolUp: [(newCsp = (this.getCoolingSetpoint() + 1))][If (this.getThermostatMode() in (COOL_ONLY_MODES + DUAL_SETPOINT_MODES)),,],
coolDown: [(newCsp = (this.getCoolingSetpoint() - 1))][If (this.getThermostatMode() in (COOL_ONLY_MODES + DUAL_SETPOINT_MODES)),,],
setpointUp: [(mode = this.getThermostatMode())][If (mode in COOL_ONLY_MODES),,[If (mode in (HEAT_ONLY_MODES + DUAL_SETPOINT_MODES)),,],],
setpointDown: [(mode = this.getThermostatMode())][If (mode in (COOL_ONLY_MODES + DUAL_SETPOINT_MODES)),,[If (mode in HEAT_ONLY_MODES),,],],
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
getTemperature: [(ts = device.currentState(temperature))][(currentTemp = DEFAULT_TEMPERATURE)]
setTemperature: 
tempUp: [(newTemp = (this.getTemperature()) ? (this.getTemperature() + 1) : DEFAULT_TEMPERATURE)]
tempDown: [(newTemp = (this.getTemperature()) ? (this.getTemperature() - 1) : DEFAULT_TEMPERATURE)]
setHumidityPercent: [(curHum = (java.lang.Integer -> java.lang.Integer) device.currentValue(humidity))][If (humidityValue != null),[(hum = this.boundInt(humidityValue, (0..100)))][If (hum != humidityValue),[(humidityValue = hum)],],,],
getHumidityPercent: [(hp = device.currentState(humidity))]
boundInt: [(value = java.lang.Math.max(theRange.getFrom(), java.lang.Math.min(theRange.getTo(), value)))]
proposeHeatSetpoint: 
proposeCoolSetpoint: 
proposeSetpoints: [(newHeatSetpoint = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(newCoolSetpoint = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(mode = this.getThermostatMode())][(proposedHeatSetpoint = (heatSetpoint) ? heatSetpoint : this.getHeatingSetpoint())][(proposedCoolSetpoint = (coolSetpoint) ? coolSetpoint : this.getCoolingSetpoint())][If (coolSetpoint == null),[(prioritySetpointType = SETPOINT_TYPE.HEATING)],[If (heatSetpoint == null),[(prioritySetpointType = SETPOINT_TYPE.COOLING)],[If (prioritySetpointType == null),[(prioritySetpointType = DEFAULT_SETPOINT_TYPE)],],],],[If (mode in HEAT_ONLY_MODES),[(newHeatSetpoint = this.boundInt(proposedHeatSetpoint, FULL_SETPOINT_RANGE))][If (newHeatSetpoint != proposedHeatSetpoint),,],,[If (mode in COOL_ONLY_MODES),[(newCoolSetpoint = this.boundInt(proposedCoolSetpoint, FULL_SETPOINT_RANGE))][If (newCoolSetpoint != proposedCoolSetpoint),,],,[If (mode in DUAL_SETPOINT_MODES),[If (prioritySetpointType == SETPOINT_TYPE.HEATING),[(newHeatSetpoint = this.boundInt(proposedHeatSetpoint, HEATING_SETPOINT_RANGE))][(customCoolingSetpointRange = ((newHeatSetpoint + AUTO_MODE_SETPOINT_SPREAD)..COOLING_SETPOINT_RANGE.getTo()))][(newCoolSetpoint = this.boundInt(proposedCoolSetpoint, customCoolingSetpointRange))],[If (prioritySetpointType == SETPOINT_TYPE.COOLING),[(newCoolSetpoint = this.boundInt(proposedCoolSetpoint, COOLING_SETPOINT_RANGE))][(customHeatingSetpointRange = (HEATING_SETPOINT_RANGE.getFrom()..(newCoolSetpoint - AUTO_MODE_SETPOINT_SPREAD)))][(newHeatSetpoint = this.boundInt(proposedHeatSetpoint, customHeatingSetpointRange))],],],,[If (mode == MODE.OFF),,],],],],[If (newHeatSetpoint != null),,],[If (newCoolSetpoint != null),,],
evaluateOperatingState: [(currentTemp = (overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value) ? overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value : (java.lang.Integer -> java.lang.Integer) this.getTemperature())][(heatingSetpoint = (overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value) ? overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value : (java.lang.Integer -> java.lang.Integer) this.getHeatingSetpoint())][(coolingSetpoint = (overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value) ? overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value : (java.lang.Integer -> java.lang.Integer) this.getCoolingSetpoint())][(tsMode = this.getThermostatMode())][(currentOperatingState = this.getOperatingState())][(isHeating = false)][(isCooling = false)][(isIdle = false)][If (tsMode in (HEAT_ONLY_MODES + DUAL_SETPOINT_MODES)),[If ((heatingSetpoint - currentTemp) >= THRESHOLD_DEGREES),[(isHeating = true)],],,],[If ((tsMode in (COOL_ONLY_MODES + DUAL_SETPOINT_MODES)) && isHeating),[If ((currentTemp - coolingSetpoint) >= THRESHOLD_DEGREES),[(isCooling = true)],],,],[If (isHeating || isCooling),,],
startSimHvac: [(operatingState = this.getOperatingState())][(isRunning = (state?.isHvacRunning) ? state?.isHvacRunning : false)][(shouldBeRunning = (operatingState in RUNNING_OP_STATES))][If (isRunning && shouldBeRunning),[(state.isHvacRunning = true)],[If isRunning,,[If shouldBeRunning,,],],],
runSimHvacCycle: [(operatingState = this.getOperatingState())][(currentTemp = this.getTemperature())][(heatSet = this.getHeatingSetpoint())][(coolSet = this.getCoolingSetpoint())][If ((operatingState == OP_STATE.HEATING) && ((heatSet - currentTemp) >= THRESHOLD_DEGREES)),,[If ((operatingState == OP_STATE.COOLING) && ((currentTemp - coolSet) >= THRESHOLD_DEGREES)),,[(state.isHvacRunning = false)]],],
done: 
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-thermostat.metadata() is applicable for argument types: (simulated-thermostat$_run_closure1) values: [simulated-thermostat$_run_closure1@2a5b3fee]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-switch.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
on: 
off: 
onPhysical: 
offPhysical: 
getVersion: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-switch.metadata() is applicable for argument types: (simulated-switch$_run_closure1) values: [simulated-switch$_run_closure1@5066d65f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-water-sensor.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
wet: 
dry: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-water-sensor.metadata() is applicable for argument types: (simulated-water-sensor$_run_closure1) values: [simulated-water-sensor$_run_closure1@20b12f8a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-water-valve.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
open: 
close: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-water-valve.metadata() is applicable for argument types: (simulated-water-valve$_run_closure1) values: [simulated-water-valve$_run_closure1@37ddb69a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-presence-sensor.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
arrived: 
departed: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-presence-sensor.metadata() is applicable for argument types: (simulated-presence-sensor$_run_closure1) values: [simulated-presence-sensor$_run_closure1@52d239ba]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-refrigerator.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: [(state.counter = (state.counter) ? (state.counter + 1) : 1)][If (state.counter == 1),,],
doorOpen: 
doorClosed: [If childDevices.find({ -> ... }),,],
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-refrigerator.metadata() is applicable for argument types: (simulated-refrigerator$_run_closure1) values: [simulated-refrigerator$_run_closure1@485e36bc]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-refrigerator-door.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
open: 
close: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-refrigerator-door.metadata() is applicable for argument types: (simulated-refrigerator-door$_run_closure1) values: [simulated-refrigerator-door$_run_closure1@54d18072]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-motion-sensor.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
active: 
inactive: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-motion-sensor.metadata() is applicable for argument types: (simulated-motion-sensor$_run_closure1) values: [simulated-motion-sensor$_run_closure1@4a11eb84]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-rgb-bulb.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],
installed: 
updated: 
ping: 
refresh: [(currentMode = device.currentValue(bulbMode))][If MODE.containsValue(currentMode),,],
configure: 
on: [this.simulateBulbState(state.lastMode)]
off: 
setLevel: [(boundedPercent = this.boundInt(levelPercent, PERCENT_RANGE))][(effectiveMode = device.currentValue(bulbMode))][If (boundedPercent > 0),,[(effectiveMode = MODE.OFF)]],
setSaturation: [(currentHue = device.currentValue(hue))]
setHue: [(currentSaturation = device.currentValue(saturation))]
setColor: [(boundedHue = this.boundInt(huePercent, PERCENT_RANGE))][(boundedSaturation = this.boundInt(saturationPercent, PERCENT_RANGE))][(logMsg = Executing 'setColor' from separate values hue: $boundedHue, saturation: $boundedSaturation)][If ((huePercent != boundedHue) || (saturationPercent != boundedSaturation)),[(logMsg +=  (pre-bounded values hue: $huePercent, saturation: $saturationPercent))],],[(colorHSMap = this.buildColorHSMap(hue, saturation))]
setColor: [If (hex == #000000),,[(hsvList = colorUtil.hexToHsv(hex))][(colorHSMap = this.buildColorHSMap(hsvList[0], hsvList[1]))]],
setColor: 
initialize: [(state.lastMode = MODE.COLOR)]
implicitOn: [If (device.currentValue(switch) != on),,],
turnOn: 
turnOff: 
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
buildColorHSMap: [(colorHSMap = [hue:0, saturation:0])]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
simulateBulbState: [(valueText = ---)][(hexColor = BLACK.rgb)][(colorIndicator = 0)]
flattenHueSat: [(flatHueSat = 0)][If (HUE_RANGE.contains(hue) && SAT_RANGE.contains(sat)),[(scaledHue = (hue * HUE_SCALE))][(flatHueSat = ((scaledHue + sat) + COLOR_OFFSET))],],
restoreHueSat: [(flatHueSat -= COLOR_OFFSET)][(sat = (flatHueSat % HUE_SCALE))][(hue = flatHueSat.intdiv(HUE_SCALE))]
done: 
boundInt: [(value = java.lang.Math.max(theRange.getFrom(), value))][(value = java.lang.Math.min(theRange.getTo(), value))]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-rgb-bulb.metadata() is applicable for argument types: (simulated-rgb-bulb$_run_closure1) values: [simulated-rgb-bulb$_run_closure1@25bc0606]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-smoke-alarm.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
smoke: 
test: 
clear: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-smoke-alarm.metadata() is applicable for argument types: (simulated-smoke-alarm$_run_closure1) values: [simulated-smoke-alarm$_run_closure1@13f17eb4]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smart-home-ventilation.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
off
on
called cap-props by app
switch
attribute uses through subscriptions
switch
cmd overpriv:[]
attr overpriv:[]
DECLARED METHODS
mainPage: 
installed: 
updated: [this.unsubscribe()]
init: [(midnightTime = this.timeToday(2000-01-01T00:01:00.999-0000, location.timeZone))][this.subscribe(location, mode, locationHandler)]
startProcess: [(state.dayCount = state.data.size())][If state.dayCount,[(state.counter = 0)],],
startDay: [(start = this.convertEpoch(state.data[state.counter].start))][(stop = this.convertEpoch(state.data[state.counter].stop))]
incDay: [If state.modeChange,,[(state.counter = (state.counter + 1))][If (state.counter < state.dayCount),,],],
locationHandler: [(result = false)][(state.modeChange = true)][(switches.each({ -> ... }){ <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })][If result,,],
midNight: 
turnOnSwitch: 
turnOffSwitch: [(switches.each({ -> ... }){ <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })]
schedDesc: [(title = )][(dayListClean = On )][(modeListClean = Scenario runs in )][If (dayList && (dayList.size() < 7)),[(dayListSize = dayList.size())][For dayList,[(dayListClean = ($dayListClean + $dayName))][(dayListSize = (dayListSize - 1))][If dayListSize,[(dayListClean = $dayListClean, )],],][(dayListSize = dayList.size())][For dayList,[(dayListClean = ($dayListClean + $dayName))][(dayListSize = (dayListSize - 1))][If dayListSize,[(dayListClean = $dayListClean, )],],],[(dayListClean = Every day)]],[If modeList,[(modeListSize = modeList.size())][(modePrefix = modes)][If (modeListSize == 1),[(modePrefix = mode)],],[For modeList,[(modeListClean = ($modeListClean + '$modeName'))][(modeListSize = (modeListSize - 1))][If modeListSize,[(modeListClean = $modeListClean, )],[(modeListClean = $modeListClean $modePrefix)]],][(modeListSize = modeList.size())][(modePrefix = modes)][If (modeListSize == 1),[(modePrefix = mode)],],[For modeList,[(modeListClean = ($modeListClean + '$modeName'))][(modeListSize = (modeListSize - 1))][If modeListSize,[(modeListClean = $modeListClean, )],[(modeListClean = $modeListClean $modePrefix)]],],[(modeListClean = $modeListCleanall modes)]],[If (on1 && off1),[(title += Schedule 1: $this.humanReadableTime(on1) to $this.humanReadableTime(off1))],],[If (on2 && off2),[(title += 
Schedule 2: $this.humanReadableTime(on2) to $this.humanReadableTime(off2))],],[If (on3 && off3),[(title += 
Schedule 3: $this.humanReadableTime(on3) to $this.humanReadableTime(off3))],],[If (on4 && off4),[(title += 
Schedule 4: $this.humanReadableTime(on4) to $this.humanReadableTime(off4))],],[If (((on1 || on2) || on3) || on4),[(title += 
$modeListClean)][(title += 
$dayListClean)],],[If (((on1 && on2) && on3) && on4),[(title = Click to configure scenario)],],[title]
greyOut: [(result = ((((on1 || on2) || on3) || on4)) ? complete : )]
humanReadableTime: 
convertEpoch: 
getTitle: [(title = (txt) ? txt : Scenario $scenario)]
daysOk: [(result = true)][If dayList,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = dayList.contains(day))],],[result]
timeOk: [If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting).time)][(stop = this.timeToday(ending).time)][If (((start < stop) && (start >= currTime)) && (stop >= currTime)),[(state.data << [start:start, stop:stop])],],,],
createDayArray: [(state.modeChange = false)][(state.data = [])][If (modeA && modeA.contains(location.mode)),[If this.daysOk(daysA),,],,],[If (modeB && modeB.contains(location.mode)),[If this.daysOk(daysB),,],,],[If (modeC && modeC.contains(location.mode)),[If this.daysOk(daysC),,],,],[If (modeD && modeD.contains(location.mode)),[If this.daysOk(daysD),,],,],[state.data.sort({ -> ... })]
textAppName: [(text = Smart Home Ventilation)]
textVersion: [(text = Version 2.1.2 (05/31/2015))]
textCopyright: [(text = Copyright  2015 Michael Struck)]
textLicense: [(text = ((((((((((Licensed under the Apache License, Version 2.0 (the 'License');  + you may not use this file except in compliance with the License. ) + You may obtain a copy of the License at) + 

) +     http://www.apache.org/licenses/LICENSE-2.0) + 

) + Unless required by applicable law or agreed to in writing, software ) + distributed under the License is distributed on an 'AS IS' BASIS, ) + WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ) + See the License for the specific language governing permissions and ) + limitations under the License.))]
textHelp: [(text = ((((Within each scenario, choose a start and end time for the ventilation fan. You can have up to 4 different  + venting scenarios, and 4 schedules within each scenario. Each scenario can be restricted to specific modes or certain days of the week. It is recommended ) + that each scenario does not overlap and run in separate modes (i.e. Home, Out of town, etc). Also note that you should  ) + avoid scheduling the ventilation fan at exactly midnight; the app resets itself at that time. It is suggested to start any new schedule ) + at 12:15 am or later.))]
Starting Points: []
IT HAS STATE
--app-start--
processing smartsense-garage-door-sensor-button.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
open: [If (device.currentValue(status) != open),,],
close: [If (device.currentValue(status) != closed),,],
parse: [(results = null)][If (this.isSupportedDescription(description) || description.startsWith(zone)),,[(results = this.parseMultiSensorMessage(description))]],
actuate: 
parseMultiSensorMessage: [(results = [])][If this.isAccelerationMessage(description),[(results = this.parseAccelerationMessage(description))],[If this.isContactMessage(description),[(results = this.parseContactMessage(description))],[If this.isRssiLqiMessage(description),[(results = this.parseRssiLqiMessage(description))],[If this.isOrientationMessage(description),[(results = this.parseOrientationMessage(description))],],],],],
parseAccelerationMessage: [(results = [])][(parts = description.split(,))]
parseContactMessage: [(results = [])][(parts = description.split(,))]
parseOrientationMessage: [(results = [])][(xyzResults = [x:0, y:0, z:0])][(parts = description.split(,))][(xyz = this.getXyzResult(xyzResults, description))][(a = xyz.value.split(,).collect({ -> ... }))][(absValueXY = java.lang.Math.max(java.lang.Math.abs(a[0]), java.lang.Math.abs(a[1])))][(absValueZ = java.lang.Math.abs(a[2]))][If ((absValueZ > 825) && (absValueXY < 175)),,[If ((absValueZ < 75) && (absValueXY > 825)),,],],
parseRssiLqiMessage: [(results = [])][(parts = description.split(,))]
getAccelerationResult: [(name = acceleration)][(value = (part.endsWith(1)) ? active : inactive)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]
getTempResult: [(name = temperature)][(temperatureScale = this.getTemperatureScale())][(value = zigbee.parseSmartThingsTemperatureValue(part, temp: , temperatureScale))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],[(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value$temperatureScale)][(isStateChange = this.isTemperatureStateChange(device, name, value.toString()))]
getXyzResult: [(name = threeAxis)][(value = $results.x,$results.y,$results.z)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
getRssiResult: [(name = (lastHop) ? lastHopRssi : rssi)][(valueString = part.split(:)[1].trim())][(value = (java.lang.Integer.parseInt(valueString) - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]
getLqiResult: [(name = (lastHop) ? lastHopLqi : lqi)][(valueString = part.split(:)[1].trim())][(percentageOf = 255)][(value = java.lang.Math.round(((java.lang.Integer.parseInt(valueString) / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was: $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
isAccelerationMessage: [(description ==~ acceleration:.*rssi:.*lqi:.*)]
isContactMessage: [(description ==~ contactState:.*accelerationState:.*temp:.*battery:.*rssi:.*lqi:.*)]
isRssiLqiMessage: [(description ==~ lastHopRssi:.*lastHopLqi:.*rssi:.*lqi:.*)]
isOrientationMessage: [(description ==~ x:.*y:.*z:.*rssi:.*lqi:.*)]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-garage-door-sensor-button.metadata() is applicable for argument types: (smartsense-garage-door-sensor-button$_run_closure1) values: [smartsense-garage-door-sensor-button$_run_closure1@5d2a4eed]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartblock-chat-sender.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(location, modeChangeHandler)]
modeChangeHandler: [(newMode = evt.value)][If (modes && modes.contains(newMode)),[(message = (customMessage) ? customMessage : SmartThings mode has changed to: "$newMode")],],
chatMessageToMC: [(parent = app.getParent())][(url = $parent.getServerURL()/chat?message=$message.encodeAsURL())][If username,[(url += &username=$username.encodeAsURL())],],[this.httpPost(url, foo=bar, { java.lang.Object response -> ... })]
Starting Points: []
--app-start--
processing smartsense-garage-door-multi.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(results = [:])][If (this.isSupportedDescription(description) || description.startsWith(zone)),,[(results = this.parseMultiSensorMessage(description))]],
updated: [(threeAxis = device.currentState(threeAxis))][If threeAxis,[(xyz = threeAxis.xyzValue)][(value = ((java.lang.Math.round(xyz.z) > 925)) ? open : closed)],],
actuate: 
parseMultiSensorMessage: [(results = [])][If this.isAccelerationMessage(description),[(results = this.parseAccelerationMessage(description))],[If this.isContactMessage(description),[(results = this.parseContactMessage(description))],[If this.isRssiLqiMessage(description),[(results = this.parseRssiLqiMessage(description))],[If this.isOrientationMessage(description),[(results = this.parseOrientationMessage(description))],],],],],
parseAccelerationMessage: [(results = [])][(parts = description.split(,))]
parseContactMessage: [(results = [])][(parts = description.split(,))]
parseOrientationMessage: [(results = [])][(xyzResults = [x:0, y:0, z:0])][(parts = description.split(,))][(xyz = this.getXyzResult(xyzResults, description))][(a = xyz.value.split(,).collect({ -> ... }))][(absValueXY = java.lang.Math.max(java.lang.Math.abs(a[0]), java.lang.Math.abs(a[1])))][(absValueZ = java.lang.Math.abs(a[2]))][If ((absValueZ > 825) && (absValueXY < 175)),,[If ((absValueZ < 75) && (absValueXY > 825)),,],],
parseRssiLqiMessage: [(results = [])][(parts = description.split(,))]
getAccelerationResult: [(name = acceleration)][(value = (part.endsWith(1)) ? active : inactive)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]
getTempResult: [(name = temperature)][(temperatureScale = this.getTemperatureScale())][(value = zigbee.parseSmartThingsTemperatureValue(part, temp: , temperatureScale))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],[(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value$temperatureScale)][(isStateChange = this.isTemperatureStateChange(device, name, value.toString()))]
getXyzResult: [(name = threeAxis)][(value = $results.x,$results.y,$results.z)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
getRssiResult: [(name = (lastHop) ? lastHopRssi : rssi)][(valueString = part.split(:)[1].trim())][(value = (java.lang.Integer.parseInt(valueString) - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]
getLqiResult: [(name = (lastHop) ? lastHopLqi : lqi)][(valueString = part.split(:)[1].trim())][(percentageOf = 255)][(value = java.lang.Math.round(((java.lang.Integer.parseInt(valueString) / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was: $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
isAccelerationMessage: [(description ==~ acceleration:.*rssi:.*lqi:.*)]
isContactMessage: [(description ==~ contactState:.*accelerationState:.*temp:.*battery:.*rssi:.*lqi:.*)]
isRssiLqiMessage: [(description ==~ lastHopRssi:.*lastHopLqi:.*rssi:.*lqi:.*)]
isOrientationMessage: [(description ==~ x:.*y:.*z:.*rssi:.*lqi:.*)]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-garage-door-multi.metadata() is applicable for argument types: (smartsense-garage-door-multi$_run_closure1) values: [smartsense-garage-door-multi$_run_closure1@1bb564e2]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing sleepy-time.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
selectPhrases: 
installed: [this.subscribe(jawbone, sleeping, jawboneHandler)]
updated: [this.unsubscribe()][this.subscribe(jawbone, sleeping, jawboneHandler)]
initialize: 
jawboneHandler: [If ((evt.value == sleeping) && sleepPhrase),,[If ((evt.value == not sleeping) && wakePhrase),,],],
Starting Points: []
--app-start--
processing smart-block.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
on: 
off: 
setLevel: [(signal = this.convertLevelToSignal((int) newLevel))]
sendSignalToMC: [(url = http://$state.serverIp:3333/block?x=$state.x&y=$state.y&z=$state.z&name=level&value=$newSignal)][this.httpPost(url, foo=bar, { java.lang.Object response -> ... })]
sendSwitchStateToMC: [(url = http://$state.serverIp:3333/block?x=$state.x&y=$state.y&z=$state.z&name=switch&value=$switchState)][this.httpPost(url, foo=bar, { java.lang.Object response -> ... })]
setCoordinates: [(state.x = x)][(state.y = y)][(state.z = z)]
getCoordinates: 
getCoordinate: [If [x, y, z].contains(axis),,],[return state.$axis]
isDestroyed: [state.destroyed]
setDestroyed: [(state.destroyed = isDestroyed)]
setWorldSeed: [(state.worldSeed = worldSeed)]
setDimensionName: [(state.dimensionName = dimensionName)]
setPlacedBy: [(state.placedBy = placedBy)]
setClosestPlayer: [(state.closestPlayer = closestPlayer)][(state.closestPlayerChanged = new java.util.Date())]
setSignalStrength: [(state.signalStrength = signalStrength)]
setLastNeighborChanged: [(state.neighborBlockId = blockId)][(state.neighborBlockName = blockName)]
setServerIp: [If ip,,],[(ip = ip.replace(https://, ))][(ip = ip.replace(http://, ))][(serverParts = ip.split(:))][If (serverParts.size() > 1),[(state.serverPort = serverParts[1])],],[If (serverParts.size() > 0),[(state.serverIp = serverParts[0])],],[If state.serverIp,[(state.blockServer = state.serverIp)],],[If state.serverPort,[(state.blockServer = $state.blockServer:$state.serverPort)],],[this.sendEvent([name:blockServer, value:$state.blockServer])]
calculateDNI: [$state.worldSeed|$state.dimensionName|$this.getCoordinates().encodeAsMD5()]
neighborBlockChange: [If data?.closestPlayer,,],[(signalStrength = (int) data?.signalStrength)][If data?.worldSeed,,],[If data?.dimensionName,,],[If data?.placedBy,,],
convertLevelToSignal: [If (level <= 0),,],[If (level >= 99),,],[(signal = (15 - ((99 - level) / 7)))]
convertSignalToLevel: [If (signal <= 0),,],[If (signal >= 15),,],[(level = (99 - ((15 - signal) * 7)))]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smart-block.metadata() is applicable for argument types: (smart-block$_run_closure1) values: [smart-block$_run_closure1@5c8eee0f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartpower-dimming-outlet.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(event = zigbee.getEvent(description))][If event,,[If (event.name == power),[(event.value = (event.value / 10))],],],
setLevel: 
off: 
on: 
refresh: 
configure: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: smartpower-dimming-outlet.metadata() is applicable for argument types: (smartpower-dimming-outlet$_run_closure1) values: [smartpower-dimming-outlet$_run_closure1@2262b621]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smart-nightlight.groovy
req caps: [capability.motionsensor, capability.illuminancemeasurement, capability.switch]
req cap size: 3
requested commands:[off, on]
requested attrs:[motion, illuminance, switch]
called cap-methods by app
off
on
called cap-props by app
motion
illuminance
attribute uses through subscriptions
motion
illuminance
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(motionSensor, motion, motionHandler)][If lightSensor,[this.subscribe(lightSensor, illuminance, illuminanceHandler, [filterEvents:false])],[this.subscribe(location, position, locationPositionChange)][this.subscribe(location, sunriseTime, sunriseSunsetTimeHandler)][this.subscribe(location, sunsetTime, sunriseSunsetTimeHandler)]],
locationPositionChange: 
sunriseSunsetTimeHandler: [(state.lastSunriseSunsetEvent = this.now())]
motionHandler: [If (evt.value == active),[If this.enabled(),[(state.lastStatus = on)],],[(state.motionStopTime = null)],[(state.motionStopTime = this.now())][If delayMinutes,,],],
illuminanceHandler: [(lastStatus = state.lastStatus)][If ((lastStatus != off) && (evt.integerValue > 50)),[(state.lastStatus = off)],[If state.motionStopTime,[If (lastStatus != off),[(elapsed = (this.now() - state.motionStopTime))][If (elapsed >= (((delayMinutes) ? delayMinutes : 0 * 60000) - 2000)),[(state.lastStatus = off)],],,],,[If ((lastStatus != on) && (evt.integerValue < 30)),[(state.lastStatus = on)],],],],
turnOffMotionAfterDelay: [log.trace(In turnOffMotionAfterDelay, state.motionStopTime = $state.motionStopTime, state.lastStatus = $state.lastStatus)][If (state.motionStopTime && (state.lastStatus != off)),[(elapsed = (this.now() - state.motionStopTime))][log.trace(elapsed = $elapsed)][If (elapsed >= (((delayMinutes) ? delayMinutes : 0 * 60000) - 2000)),[(state.lastStatus = off)],],,],
scheduleCheck: 
astroCheck: [(s = this.getSunriseAndSunset([zipCode:zipCode, sunriseOffset:sunriseOffset, sunsetOffset:sunsetOffset]))][(state.riseTime = s.sunrise.time)][(state.setTime = s.sunset.time)]
enabled: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If lightSensor,[(result = (lightSensor.currentIlluminance?.toInteger() < 30))],[(t = this.now())][(result = ((t < state.riseTime) || (t > state.setTime)))]],[result]
getSunriseOffset: [(sunriseOffsetValue) ? ((sunriseOffsetDir == Before)) ? -$sunriseOffsetValue : sunriseOffsetValue : null]
getSunsetOffset: [(sunsetOffsetValue) ? ((sunsetOffsetDir == Before)) ? -$sunsetOffsetValue : sunsetOffsetValue : null]
Starting Points: []
IT HAS STATE
--app-start--
processing smartblock-linker.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
Dynamic Method Invocation
type 2 command uses
setlevel
type 2 attr uses
level
called cap-methods by app
called cap-props by app
switch
attribute uses through subscriptions
level
switch
cmd overpriv:[off, on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
linkerPage: 
installed: 
updated: [this.unsubscribe()]
initialize: [If blockUpdatesSwitch,[this.subscribe(linkedSmartBlock, level, updateSwitchLevel)][this.subscribe(linkedSmartBlock, switch, updateSwitchState)],],[If switchUpdatesBlock,[this.subscribe(linkedSwitch, level, updateBlockLevel)][this.subscribe(linkedSwitch, switch, updateBlockState)],],
updateSwitchLevel: [(level = (int) evt.value)]
updateBlockLevel: [(level = (int) evt.value)]
updateSwitchState: 
updateBlockState: 
getBlockId: [return linkedSmartBlock.id]
getLinkerDescription: [(left = (linkedSmartBlock) ? $(linkedSmartBlock.label) ? linkedSmartBlock.label : linkedSmartBlock.name : )][(right = (linkedSwitch) ? $(linkedSwitch.label) ? linkedSwitch.label : linkedSwitch.name : )][(leftLink = (switchUpdatesBlock) ? < : )][(rightLink = (blockUpdatesSwitch) ? > : )][If ((leftLink == ) && (rightLink == )),[return null],],[$left $leftLink--$rightLink $right]
Starting Points: []
--app-start--
processing smartpower-outlet-v1.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [If description?.startsWith(catchall: 0104 000A),,[(name = (description?.startsWith(on/off: )) ? switch : null)][(value = ((name == switch)) ? (description?.endsWith( 1)) ? on : off : null)][(result = this.createEvent([name:name, value:value]))]],
on: 
off: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: smartpower-outlet-v1.metadata() is applicable for argument types: (smartpower-outlet-v1$_run_closure1) values: [smartpower-outlet-v1$_run_closure1@45c8d09f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smart-light-timer-x-minutes-unless-already-on.groovy
req caps: [capability.motionsensor, capability.contactsensor, capability.switch]
req cap size: 3
requested commands:[off, on]
requested attrs:[motion, contact, switch]
called cap-methods by app
off
on
called cap-props by app
motion
contact
switch
attribute uses through subscriptions
motion
switch
contact
cmd overpriv:[]
attr overpriv:[]
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(switches, switch, switchChange)][this.subscribe(motions, motion, motionHandler)][this.subscribe(contacts, contact, contactHandler)][(state.myState = ready)]
switchChange: [If (evt.value == on),[If (state.myState == activating),[(state.myState = active)],[If (state.myState != active),[(state.myState = already on)],],],,[If ((state.myState == active) || (state.myState == activating)),,],[(state.myState = ready)]],
contactHandler: [If (evt.value == open),[If (state.myState == ready),[(state.inactiveAt = null)][(state.myState = activating)],],,[If (evt.value == closed),[If ((state.inactiveAt && (state.myState == active)) || (state.myState == activating)),,],,],],
motionHandler: [If (evt.value == active),[If (((state.myState == ready) || (state.myState == active)) || (state.myState == activating)),[(state.inactiveAt = null)][(state.myState = activating)],],,[If (evt.value == inactive),[If ((state.inactiveAt && (state.myState == active)) || (state.myState == activating)),,],,],],
setActiveAndSchedule: [(state.myState = active)][(state.inactiveAt = this.now())]
scheduleCheck: [If (state.myState != already on),[If (state.inactiveAt != null),[(elapsed = (this.now() - state.inactiveAt))][(threshold = ((1000 * 60) * minutes1))][If (elapsed >= threshold),[If (state.myState == active),,],[(state.inactiveAt = null)][(state.myState = ready)],],,],,],
Starting Points: []
IT HAS STATE
--app-start--
processing smartsense-multi.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(results = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (this.isSupportedDescription(description) || description.startsWith(zone)),[(results = this.parseSingleMessage(description))],[If (description == updated),[(results = this.parseOtherMessage(description))],[(results = this.parseMultiSensorMessage(description))]],],
parseSingleMessage: [(name = this.parseName(description))][(value = this.parseValue(description))][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(handlerName = ((value == open)) ? opened : value)][(isStateChange = this.isStateChange(device, name, value))][(results = [])]
parseOtherMessage: [(name = null)][(value = description)][(linkText = this.getLinkText(device))][(descriptionText = description)][(handlerName = description)][(isStateChange = this.isStateChange(device, name, value))][(results = [name:name, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName, isStateChange:isStateChange, ... ])]
parseMultiSensorMessage: [(results = [])][If this.isAccelerationMessage(description),[(results = this.parseAccelerationMessage(description))],[If this.isContactMessage(description),[(results = this.parseContactMessage(description))],[If this.isRssiLqiMessage(description),[(results = this.parseRssiLqiMessage(description))],[If this.isOrientationMessage(description),[(results = this.parseOrientationMessage(description))],],],],],
parseAccelerationMessage: [(results = [])][(parts = description.split(,))]
parseContactMessage: [(results = [])][(parts = description.split(,))]
parseOrientationMessage: [(results = [])][(xyzResults = [x:0, y:0, z:0])][(parts = description.split(,))]
parseRssiLqiMessage: [(results = [])][(parts = description.split(,))]
getContactResult: [(name = contact)][(value = (part.endsWith(1)) ? open : closed)][(handlerName = ((value == open)) ? opened : value)][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $handlerName)][(isStateChange = this.isStateChange(device, name, value))][(results = [])]
getAccelerationResult: [(name = acceleration)][(value = (part.endsWith(1)) ? active : inactive)][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value)][(isStateChange = this.isStateChange(device, name, value))]
getTempResult: [(name = temperature)][(temperatureScale = this.getTemperatureScale())][(value = zigbee.parseSmartThingsTemperatureValue(part, temp: , temperatureScale))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],[(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value$temperatureScale)][(isStateChange = this.isTemperatureStateChange(device, name, value.toString()))]
getXyzResult: [(name = threeAxis)][(value = $results.x,$results.y,$results.z)][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value)][(isStateChange = this.isStateChange(device, name, value))]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText Battery was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
getRssiResult: [(name = (lastHop) ? lastHopRssi : rssi)][(valueString = part.split(:)[1].trim())][(value = (java.lang.Integer.parseInt(valueString) - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value dBm)][If lastHop,[(descriptionText +=  on the last hop)],],[(isStateChange = this.isStateChange(device, name, value))]
getLqiResult: [(name = (lastHop) ? lastHopLqi : lqi)][(valueString = part.split(:)[1].trim())][(percentageOf = 255)][(value = java.lang.Math.round(((java.lang.Integer.parseInt(valueString) / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText Signal (LQI) was: $value$unit)][If lastHop,[(descriptionText +=  on the last hop)],],[(isStateChange = this.isStateChange(device, name, value))]
isAccelerationMessage: [(description ==~ acceleration:.*rssi:.*lqi:.*)]
isContactMessage: [(description ==~ contactState:.*accelerationState:.*temp:.*battery:.*rssi:.*lqi:.*)]
isRssiLqiMessage: [(description ==~ lastHopRssi:.*lastHopLqi:.*rssi:.*lqi:.*)]
isOrientationMessage: [(description ==~ x:.*y:.*z:.*rssi:.*lqi:.*)]
parseName: [If this.isSupportedDescription(description),,],
parseValue: [If this.isSupportedDescription(description),,],
parseDescriptionText: [If this.isSupportedDescription(description),,],[(value) ? $linkText was $((value == open)) ? opened : value : ]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-multi.metadata() is applicable for argument types: (smartsense-multi$_run_closure1) values: [smartsense-multi$_run_closure1@75c9e76b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartsense-motion.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(results = [:])][If (description.startsWith(zone) || this.isSupportedDescription(description)),[(results = this.parseBasicMessage(description))],[If this.isMotionStatusMessage(description),[(results = this.parseMotionStatusMessage(description))],],],
parseBasicMessage: [(name = this.parseName(description))][(results = [:])][If (name != null),[(value = this.parseValue(description))][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(handlerName = value)][(isStateChange = this.isStateChange(device, name, value))][(results = [name:name, value:value, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName, isStateChange:isStateChange, ... ])],],
parseName: [If this.isSupportedDescription(description),,],
parseValue: [(zs = zigbee.parseZoneStatus(description))][If zs,,],
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseDescriptionText: 
isMotionStatusMessage: [((description ==~ raw:.*dni:.*motion:.*battery:.*powerSource:.*rssi:.*lqi:.*) || (description ==~ raw:.*dni:.*motion:.*powerSource:.*battery:.*rssi:.*lqi:.*))]
parseMotionStatusMessage: [(results = [])][(parts = description.split(,))]
getMotionResult: [(name = motion)][(valueString = part.split(:)[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(value = ((valueInt == 0)) ? inactive : active)][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(isStateChange = this.isStateChange(device, name, value))]
getPowerSourceResult: [(name = powerSource)][(valueString = part.split(:)[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(value = ((valueInt == 0)) ? battery : powered)][(linkText = this.getLinkText(device))][(descriptionText = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (value == battery),[(descriptionText = $linkText is $value powered)],[(descriptionText = $linkText is plugged in)]],[(isStateChange = this.isStateChange(device, name, value))]
getBatteryResult: [(name = battery)][(valueString = part.split(:)[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][If (valueInt == 0),,],[(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText battery was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
getRssiResult: [(name = rssi)][(parts = part.split(:))][If (parts.size() != 2),,],[(valueString = parts[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(value = (valueInt - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]
getLqiResult: [(name = lqi)][(parts = part.split(:))][If (parts.size() != 2),,],[(valueString = parts[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(percentageOf = 255)][(value = java.lang.Math.round(((valueInt / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText Signal (LQI) was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-motion.metadata() is applicable for argument types: (smartsense-motion$_run_closure1) values: [smartsense-motion$_run_closure1@a4b2d8f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smart-turn-it-on.groovy
req caps: [capability.switch, capability.presencesensor]
req cap size: 2
requested commands:[off, on]
requested attrs:[presence, switch]
called cap-methods by app
off
on
called cap-props by app
presence
attribute uses through subscriptions
presence
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [If timeOne,,],
updated: [this.unsubscribe()][If timeOne,,],
turnOn: [(dayCheck = dayOne.contains(new java.util.Date().format(EEE)))][(dayTwo = new java.util.Date().format(EEE))][If dayCheck,[(presenceTwo = presenceOne.latestValue(presence).contains(present))][If presenceTwo,[(delay = (timeTwo * 60))],],,],
turnOff: 
Starting Points: []
--app-start--
processing smartpower-outlet.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(event = zigbee.getEvent(description))][If event,[If (event.name == power),[(value = ((java.lang.Integer -> java.lang.Integer) event.value / 10))][(event = this.createEvent([name:event.name, value:value, descriptionText:{{ device.displayName }} power is {{ value }} Watts, translatable:true]))],[If (event.name == switch),[(descriptionText = ((event.value == on)) ? {{ device.displayName }} is On : {{ device.displayName }} is Off)][(event = this.createEvent([name:event.name, value:event.value, descriptionText:descriptionText, translatable:true]))],],],,[(cluster = zigbee.parse(description))][If ((cluster && (cluster.clusterId == 6)) && (cluster.command == 7)),[If (cluster.data[0] == 0),[(event = this.createEvent([name:checkInterval, value:(60 * 12), displayed:false, data:[protocol:zigbee, hubHardwareId:device.hub.hardwareID]]))],[(event = null)]],,],],
off: 
on: 
ping: 
refresh: 
configure: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: smartpower-outlet.metadata() is applicable for argument types: (smartpower-outlet$_run_closure1) values: [smartpower-outlet$_run_closure1@2b95e48b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartweather-station-controller.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
updated: 
initialize: 
scheduledEvent: 
Starting Points: []
--app-start--
processing speaker-control.groovy
req caps: [capability.motionsensor, capability.musicplayer, capability.contactsensor, capability.switch, capability.button, capability.smokedetector, capability.watersensor, capability.accelerationsensor, capability.presencesensor]
req cap size: 9
requested commands:[play, playtrack, mute, playtext, nexttrack, restoretrack, pause, off, settrack, resumetrack, previoustrack, setlevel, stop, unmute, on]
requested attrs:[motion, level, smoke, trackdescription, mute, water, switch, button, acceleration, trackdata, contact, presence, status]
type 2 attr uses
carbonmonoxide
called cap-methods by app
play
nexttrack
off
pause
previoustrack
setlevel
on
called cap-props by app
motion
smoke
water
switch
button
acceleration
contact
presence
status
attribute uses through subscriptions
button
acceleration
motion
contact
smoke
presence
carbonmonoxide
water
switch
status
cmd overpriv:[playtrack, mute, playtext, restoretrack, settrack, resumetrack, stop, unmute]
attr overpriv:[level, trackdescription, mute, trackdata]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 6d38663a-1703-46b6-9939-8c1fb9467cf9, 266374ae-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, ff20e87b-992b-42b0-9cd6-72b0030dedc3, 26d69a34-ada2-42dc-9e45-445c78ae2619, 1e88cabe-5ba4-4647-9a23-0ad5b887f94b, f730b653-b0b6-483e-8c84-977e240f5eb3, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.refresh, capability.polling]]
DECLARED METHODS
mainPage: 
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],[return true],],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],[return true],],][return false]
ifUnset: [If settings[name],,],
ifSet: [If settings[name],,],
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [log.trace(subscribeToEvents())][this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,,],
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],
modeChangeHandler: [If (evt.value in triggerModes),,],
scheduledTimeHandler: 
appTouchHandler: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
takeAction: [(options = [:])][If volume,[(options.delay = 1000)],],
frequencyKey: [lastActionTimeStamp]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],[result]
getAllOk: [((modeOk && daysOk) && timeOk)]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)][result]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)][result]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)][result]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]
timeIntervalLabel: [((starting && ending)) ? ((this.hhmm(starting) + -) + this.hhmm(ending, h:mm a z)) : ]
Starting Points: []
--app-start--
processing smartsense-virtual-open-closed.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(results = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (this.isSupportedDescription(description) || description.startsWith(zone)),,[(results = this.parseMultiSensorMessage(description))]],
parseMultiSensorMessage: [(results = [])][If this.isAccelerationMessage(description),[(results = this.parseAccelerationMessage(description))],[If this.isContactMessage(description),[(results = this.parseContactMessage(description))],[If this.isRssiLqiMessage(description),[(results = this.parseRssiLqiMessage(description))],[If this.isOrientationMessage(description),[(results = this.parseOrientationMessage(description))],],],],],
parseAccelerationMessage: [(results = [])][(parts = description.split(,))]
parseContactMessage: [(results = [])][(parts = description.split(,))]
parseOrientationMessage: [(results = [])][(xyzResults = [x:0, y:0, z:0])][(parts = description.split(,))][(xyz = this.getXyzResult(xyzResults, description))][(a = xyz.value.split(,).collect({ -> ... }))][(absValueXY = java.lang.Math.max(java.lang.Math.abs(a[0]), java.lang.Math.abs(a[1])))][(absValueZ = java.lang.Math.abs(a[2]))][If ((absValueZ > 825) && (absValueXY < 175)),,[If ((absValueZ < 75) && (absValueXY > 825)),,],],
parseRssiLqiMessage: [(results = [])][(parts = description.split(,))]
getAccelerationResult: [(name = acceleration)][(value = (part.endsWith(1)) ? active : inactive)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]
getTempResult: [(name = temperature)][(temperatureScale = this.getTemperatureScale())][(value = zigbee.parseSmartThingsTemperatureValue(part, temp: , temperatureScale))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],[(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value$temperatureScale)][(isStateChange = this.isTemperatureStateChange(device, name, value.toString()))]
getXyzResult: [(name = threeAxis)][(value = $results.x,$results.y,$results.z)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
getRssiResult: [(name = (lastHop) ? lastHopRssi : rssi)][(valueString = part.split(:)[1].trim())][(value = (java.lang.Integer.parseInt(valueString) - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]
getLqiResult: [(name = (lastHop) ? lastHopLqi : lqi)][(valueString = part.split(:)[1].trim())][(percentageOf = 255)][(value = java.lang.Math.round(((java.lang.Integer.parseInt(valueString) / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was: $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
isAccelerationMessage: [(description ==~ acceleration:.*rssi:.*lqi:.*)]
isContactMessage: [(description ==~ contactState:.*accelerationState:.*temp:.*battery:.*rssi:.*lqi:.*)]
isRssiLqiMessage: [(description ==~ lastHopRssi:.*lastHopLqi:.*rssi:.*lqi:.*)]
isOrientationMessage: [(description ==~ x:.*y:.*z:.*rssi:.*lqi:.*)]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-virtual-open-closed.metadata() is applicable for argument types: (smartsense-virtual-open-closed$_run_closure1) values: [smartsense-virtual-open-closed$_run_closure1@636e8cc]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing sonos-remote-control.groovy
req caps: [capability.musicplayer, capability.button]
req cap size: 2
requested commands:[play, playtrack, mute, playtext, nexttrack, restoretrack, pause, settrack, resumetrack, previoustrack, setlevel, stop, unmute]
requested attrs:[button, trackdescription, trackdata, mute, level, status]
called cap-methods by app
play
previoustrack
setlevel
nexttrack
pause
called cap-props by app
button
trackdescription
trackdata
mute
level
status
attribute uses through subscriptions
button
trackdescription
trackdata
mute
level
status
cmd overpriv:[playtrack, mute, playtext, restoretrack, settrack, resumetrack, stop, unmute]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [6d38663a-1703-46b6-9939-8c1fb9467cf9, ff20e87b-992b-42b0-9cd6-72b0030dedc3]
[[capability.switch, capability.refresh]]
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(buttonDevice, button, buttonEvent)]
buttonEvent: [(buttonNumber = evt.data)][(value = evt.value)][(recentEvents = buttonDevice.eventsSince(new java.util.Date((this.now() - 2000))).findAll({ -> ... }))][If (recentEvents.size <= 1),,],
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
extractButtonNumber: [(buttonNumber = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
handleButton: 
togglePlayPause: [(currentStatus = sonos.currentValue(status))][If (currentStatus == playing),[(options) ? sonos.pause(options) : sonos.pause()],[(options) ? sonos.play(options) : sonos.play()]],
adjustVolume: [(changeAmount = ((volumeOffset) ? volumeOffset : 5 * (doubleAmount) ? 2 : 1))][(currentVolume = sonos.currentValue(level))][If up,,],
Starting Points: []
--app-start--
processing the-flasher.groovy
req caps: [capability.motionsensor, capability.contactsensor, capability.switch, capability.accelerationsensor, capability.presencesensor]
req cap size: 5
requested commands:[off, on]
requested attrs:[acceleration, motion, presence, contact, switch]
called cap-methods by app
off
on
called cap-props by app
acceleration
motion
presence
contact
switch
attribute uses through subscriptions
acceleration
motion
presence
contact
switch
cmd overpriv:[]
attr overpriv:[]
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 266374ae-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, f730b653-b0b6-483e-8c84-977e240f5eb3, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.polling, capability.refresh]]
DECLARED METHODS
installed: [this.subscribe()]
updated: [this.unsubscribe()][this.subscribe()]
subscribe: [If contact,[this.subscribe(contact, contact.open, contactOpenHandler)],],[If acceleration,[this.subscribe(acceleration, acceleration.active, accelerationActiveHandler)],],[If motion,[this.subscribe(motion, motion.active, motionActiveHandler)],],[If mySwitch,[this.subscribe(mySwitch, switch.on, switchOnHandler)],],[If myPresence,[this.subscribe(myPresence, presence, presenceHandler)],],
motionActiveHandler: 
contactOpenHandler: 
accelerationActiveHandler: 
switchOnHandler: 
presenceHandler: [If (evt.value == present),,[If (evt.value == not present),,],],
flashLights: [(doFlash = true)][(onFor = (onFor) ? onFor : 1000)][(offFor = (offFor) ? offFor : 1000)][(numFlashes = (numFlashes) ? numFlashes : 3)][If state.lastActivated,[(elapsed = (this.now() - state.lastActivated))][(sequenceTime = ((numFlashes + 1) * (onFor + offFor)))][(doFlash = (elapsed > sequenceTime))],],[If doFlash,[(state.lastActivated = this.now())][(initialActionOn = switches.collect({ -> ... }))][(delay = 0)][(numFlashes.times({ -> ... }){ log.trace(Switch on after  $delay msec); switches.eachWithIndex({ java.lang.Object s, java.lang.Object i -> ... }); (delay += onFor); log.trace(Switch off after $delay msec); switches.eachWithIndex({ java.lang.Object s, java.lang.Object i -> ... }); (delay += offFor) })],],
Starting Points: []
IT HAS STATE
--app-start--
processing switch-activates-home-phrase-or-mode.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
called cap-props by app
switch
attribute uses through subscriptions
switch
cmd overpriv:[off, on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
getPref: 
installed: [this.subscribe(controlSwitch, switch, switchHandler)]
updated: [this.unsubscribe()][this.subscribe(controlSwitch, switch, switchHandler)]
switchHandler: [If ((evt.value == on) && (phrase_on || onMode)),[If phrase_on,,],[If onMode,,],,[If ((evt.value == off) && (phrase_off || offMode)),[If phrase_off,,],[If offMode,,],,],],
changeMode: [If (location.mode != newMode),[If location.modes?.find({ -> ... }),,],,],
textAppName: [(text = Switch Activates Home Phrase or Mode)]
textVersion: [(text = Version 1.0.1 (06/20/2015))]
textCopyright: [(text = Copyright  2015 Michael Struck)]
textLicense: [(text = ((((((((((Licensed under the Apache License, Version 2.0 (the 'License');  + you may not use this file except in compliance with the License. ) + You may obtain a copy of the License at) + 

) +     http://www.apache.org/licenses/LICENSE-2.0) + 

) + Unless required by applicable law or agreed to in writing, software ) + distributed under the License is distributed on an 'AS IS' BASIS, ) + WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ) + See the License for the specific language governing permissions and ) + limitations under the License.))]
textHelp: [(text = ((Ties a Hello, Home phrase or mode to a switch's (virtual or real) on/off state. Perfect for use with IFTTT.  + Simple define a switch to be used, then tie the on/off state of the switch to a specific Hello, Home phrases or mode. ) + Connect the switch to an IFTTT action, and the Hello, Home phrase or mode will fire with the switch state change.))]
Starting Points: []
IT HAS STATE
--app-start--
processing sylvania-ultra-iq.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [If description?.startsWith(catchall:),[(msg = zigbee.parse(description))],[(name = (description?.startsWith(on/off: )) ? switch : null)][(value = ((name == switch)) ? (description?.endsWith( 1)) ? on : off : null)][(result = this.createEvent([name:name, value:value]))]],
on: 
off: 
setLevel: [(cmds = [])][If (value == 0),,[If (device.latestValue(switch) == off),,],],[(level = this.hexString(java.lang.Math.round(((value * 255) / 100))))]
configure: 
hex: [(s = new java.math.BigInteger(java.lang.Math.round(value).toString()).toString(16))][While (s.size() < width),[(s = (0 + s))]]hex: [(s = new java.math.BigInteger(java.lang.Math.round(value).toString()).toString(16))][While (s.size() < width),[(s = (0 + s))]]
getEndpointId: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: sylvania-ultra-iq.metadata() is applicable for argument types: (sylvania-ultra-iq$_run_closure1) values: [sylvania-ultra-iq$_run_closure1@56ace400]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing switch-activates-home-phrase.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
called cap-props by app
switch
attribute uses through subscriptions
switch
cmd overpriv:[off, on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
getPref: 
installed: [this.subscribe(controlSwitch, switch, switchHandler)]
updated: [this.unsubscribe()][this.subscribe(controlSwitch, switch, switchHandler)]
switchHandler: [If (evt.value == on),,],
Starting Points: []
--app-start--
processing tcp-bulb.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(results = [])][If (description == updated),,],[If (description?.name && description?.value),,],
setBulbPower: [(state.bulbPower = value)]
on: [(levelSetting = ((java.lang.Float -> java.lang.Float) device.latestValue(level)) ? (java.lang.Float -> java.lang.Float) device.latestValue(level) : 1.0)][(bulbPowerMax = (java.lang.Float -> java.lang.Float) device.latestValue(setBulbPower))][(calculatedPower = (bulbPowerMax * (levelSetting / 100)))][If (device.latestValue(level) == null),,],
off: 
levelUp: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][(step = (float) state.stepsize)][(level += step)][If (level > 100),[(level = 100)],],
levelDown: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][(step = (float) state.stepsize)][(level -= step)][If (level < 1),[(level = 1)],],
setLevel: [(level = (java.lang.Integer -> java.lang.Integer) value)][If ((level > 0) && (level <= 100)),,],[(levelSetting = (float) level)][(bulbPowerMax = (float) device.latestValue(setBulbPower))][(calculatedPower = (bulbPowerMax * (levelSetting / 100)))]
poll: 
refresh: 
installed: 
updated: 
initialize: [If settings.stepsize,[(state.stepsize = 10)],[(state.stepsize = settings.stepsize)]],
uninstalled: 
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tcp-bulb.metadata() is applicable for argument types: (tcp-bulb$_run_closure1) values: [tcp-bulb$_run_closure1@7829b776]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing thermostat-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))][(map = this.createEvent([name:pair[0].trim(), value:pair[1].trim()]))][(result = [map])][If (map.isStateChange && (map.name in [heatingSetpoint, coolingSetpoint, thermostatMode])),[(map2 = [name:thermostatSetpoint, unit:F])][If (map.name == thermostatMode),[If (map.value == cool),[(map2.value = device.latestValue(coolingSetpoint))][log.info(THERMOSTAT, latest cooling setpoint = $map2.value)],[(map2.value = device.latestValue(heatingSetpoint))][log.info(THERMOSTAT, latest heating setpoint = $map2.value)]],,[(mode = device.latestValue(thermostatMode))][log.info(THERMOSTAT, latest mode = $mode)][If (((map.name == heatingSetpoint) && (mode == heat)) || ((map.name == coolingSetpoint) && (mode == cool))),[(map2.value = map.value)][(map2.unit = map.unit)],],],[If (map2.value != null),,],,],
setHeatingSetpoint: 
setCoolingSetpoint: 
setThermostatMode: 
setThermostatFanMode: 
off: 
heat: 
emergencyHeat: 
cool: 
fanOn: 
fanAuto: 
fanCirculate: 
poll: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: thermostat-capability.metadata() is applicable for argument types: (thermostat-capability$_run_closure1) values: [thermostat-capability$_run_closure1@2e54db99]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing three-axis-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: three-axis-capability.metadata() is applicable for argument types: (three-axis-capability$_run_closure1) values: [three-axis-capability$_run_closure1@6f603e89]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-carousel.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
parse: 
evaluate: [(threshold = 1.0)][(current = device.currentValue(thermostatOperatingState))][(mode = device.currentValue(thermostatMode))][(heating = false)][(cooling = false)][(idle = false)][If (mode in [heat, emergency heat, auto]),[If ((heatingSetpoint - temp) >= threshold),[(heating = true)],[If ((temp - heatingSetpoint) >= threshold),[(idle = true)],],],,],[If (mode in [cool, auto]),[If ((temp - coolingSetpoint) >= threshold),[(cooling = true)],[If (((coolingSetpoint - temp) >= threshold) && heating),[(idle = true)],],],,],[If ((idle && heating) && cooling),,],
setHeatingSetpoint: 
setCoolingSetpoint: 
setThermostatMode: 
setThermostatFanMode: 
off: 
heat: 
auto: 
emergencyHeat: 
cool: 
fanOn: 
fanAuto: 
fanCirculate: 
tempUp: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue + 1) : 72)]
tempDown: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue - 1) : 72)]
setTemperature: [(ts = device.currentState(temperature))]
heatUp: [(ts = device.currentState(heatingSetpoint))][(value = (ts) ? (ts.integerValue + 1) : 68)]
heatDown: [(ts = device.currentState(heatingSetpoint))][(value = (ts) ? (ts.integerValue - 1) : 68)]
coolUp: [(ts = device.currentState(coolingSetpoint))][(value = (ts) ? (ts.integerValue + 1) : 76)]
coolDown: [(ts = device.currentState(coolingSetpoint))][(value = (ts) ? (ts.integerValue - 1) : 76)]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-carousel.metadata() is applicable for argument types: (tile-basic-carousel$_run_closure1) values: [tile-basic-carousel$_run_closure1@376a312c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing switch-child-device.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
on: 
off: 
refresh: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: switch-child-device.metadata() is applicable for argument types: (switch-child-device$_run_closure1) values: [switch-child-device$_run_closure1@6731787b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing thermostats.groovy
req caps: [capability.smokedetector, capability.thermostat, capability.carbonmonoxidedetector]
req cap size: 3
requested commands:[heat, setheatingsetpoint, auto, cool, setcoolingsetpoint, fanon, setthermostatmode, emergencyheat, fancirculate, off, setthermostatfanmode, fanauto]
requested attrs:[coolingsetpoint, thermostatfanmode, thermostatmode, smoke, temperature, heatingsetpoint, thermostatoperatingstate, thermostatsetpoint, carbonmonoxide]
called cap-methods by app
setthermostatmode
called cap-props by app
smoke
carbonmonoxide
attribute uses through subscriptions
smoke
carbonmonoxide
cmd overpriv:[heat, setheatingsetpoint, auto, cool, setcoolingsetpoint, fanon, emergencyheat, fancirculate, off, setthermostatfanmode, fanauto]
attr overpriv:[coolingsetpoint, thermostatfanmode, thermostatmode, temperature, heatingsetpoint, thermostatoperatingstate, thermostatsetpoint]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [26d69a34-ada2-42dc-9e45-445c78ae2619, 26d69a34-ada2-42dc-9e45-445c78ae2619, 8aa8a6b23f769c09013f769ed1c20012]
[[capability.battery, capability.polling]]
DECLARED METHODS
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [this.subscribe(smokeDevices, smoke.detected, eventHandler)][this.subscribe(smokeDevices, smoke.tested, eventHandler)][this.subscribe(smokeDevices, carbonMonoxide.detected, eventHandler)][this.subscribe(carbonMonoxideDevices, carbonMonoxide.detected, eventHandler)]
eventHandler: [If frequency,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],
sendMessage: [(msg = messageText)][(options = [:])][If messageText,[(msg = {{ triggerEvent.descriptionText }})][(options = [translatable:true, triggerEvent:evt])],],[If location.contactBookEnabled,,[If phone,[(options.phone = phone)][If (pushAndPhone != No),[(options.method = both)],[(options.method = phone)]],,[If (pushAndPhone != No),[(options.method = push)],[(options.method = none)]],],],[If frequency,[(state[evt.deviceId] = this.now())],],
Starting Points: []
--app-start--
processing switch-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
on: 
off: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: switch-capability.metadata() is applicable for argument types: (switch-capability$_run_closure1) values: [switch-capability$_run_closure1@4bf3798b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing sprayer-controller-2.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
off
on
called cap-props by app
switch
attribute uses through subscriptions
switch
cmd overpriv:[]
attr overpriv:[]
DECLARED METHODS
installed: [(startHour = startHour1)][(stopHour = stopHour1)][(startTime = minutes)][If (minutes == 1),[(startTime = ((((0 0  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 2),[(startTime = ((((0 0,30  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 3),[(startTime = ((((0 0,20,40  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 4),[(startTime = ((((0 0,15,30,45  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 5),[(startTime = ((((0 0,12,24,36,48  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 6),[(startTime = ((((0 0,10,20,30,40,50  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 12),[(startTime = ((((0 0,5,10,15,20,25,30,35,40,45,50,55  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 20),[(startTime = ((((0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 30),[(startTime = ((((0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58  + startHour) + -) + stopHour) +  * * ?))],[(startTime = ((((0 0  + startHour) + -) + stopHour) +  * * ?))]],],],],],],],],],[this.subscribe(valves1, switch.on, valveOnHandler, [filterEvents:false])]
updated: [this.unsubscribe()][(startHour = startHour1)][(stopHour = stopHour1)][(startTime = minutes)][If (minutes == 1),[(startTime = ((((0 0  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 2),[(startTime = ((((0 0,30  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 3),[(startTime = ((((0 0,20,40  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 4),[(startTime = ((((0 0,15,30,45  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 5),[(startTime = ((((0 0,12,24,36,48  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 6),[(startTime = ((((0 0,10,20,30,40,50  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 12),[(startTime = ((((0 0,5,10,15,20,25,30,35,40,45,50,55  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 20),[(startTime = ((((0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 30),[(startTime = ((((0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58  + startHour) + -) + stopHour) +  * * ?))],[(startTime = ((((0 0  + startHour) + -) + stopHour) +  * * ?))]],],],],],],],],],[this.subscribe(valves1, switch.on, valveOnHandler, [filterEvents:false])]
openValve: 
closeValve: 
valveOnHandler: [(delay = duration)]
setStartTime: [If (minutes == 1),[(startTime = 0 0 $startHour * * ?)],[If (minutes == 2),[(startTime = 0 0,30 $startHour * * ?)],[If (minutes == 3),[(startTime = 0 0,20,40 $startHour * * ?)],[If (minutes == 4),[(startTime = 0 0,15,30,45 $startHour * * ?)],[If (minutes == 5),[(startTime = 0 0,12,24,36,48 $startHour * * ?)],[If (minutes == 6),[(startTime = 0 0,10,20,30,40,50 $startHour * * ?)],[If (minutes == 12),[(startTime = 0 0,5,10,15,20,25,30,35,40,45,50,55 $startHour * * ?)],[If (minutes == 20),[(startTime = 0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57 $startHour * * ?)],[If (minutes == 30),[(startTime = 0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58 $startHour * * ?)],[(startTime = 0 0 $startHour * * ?)]],],],],],],],],],
Starting Points: []
--app-start--
processing switch-changes-mode.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
called cap-props by app
switch
attribute uses through subscriptions
switch
cmd overpriv:[off, on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(controlSwitch, switch, switchHandler)]
updated: [this.unsubscribe()][this.subscribe(controlSwitch, switch, switchHandler)]
switchHandler: [If (evt.value == on),,],
changeMode: [If (newMode && (location.mode != newMode)),[If location.modes?.find({ -> ... }),,],,],
Starting Points: []
--app-start--
processing temperature-sensor.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(name = this.parseName(description))][(value = this.parseValue(description))][(unit = ((name == temperature)) ? this.getTemperatureScale() : ((name == humidity)) ? % : null)][(result = this.createEvent([name:name, value:value, unit:unit]))]
parseName: [If description?.startsWith(temperature: ),,[If description?.startsWith(humidity: ),,],],
parseValue: [If description?.startsWith(temperature: ),,[If description?.startsWith(humidity: ),[(pct = ((description - humidity: ) - %).trim())][If pct.isNumber(),,],,],],
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: temperature-sensor.metadata() is applicable for argument types: (temperature-sensor$_run_closure1) values: [temperature-sensor$_run_closure1@5049d8b2]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-colorwheel.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
setColor: [If value.hex,,],[If value.hue,,],[If value.saturation,,],
setSaturation: 
setHue: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-colorwheel.metadata() is applicable for argument types: (tile-basic-colorwheel$_run_closure1) values: [tile-basic-colorwheel$_run_closure1@267f474e]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing switch-level-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pairs = description.split(,))][(result = [])]
on: 
off: 
setLevel: 
refresh: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: switch-level-capability.metadata() is applicable for argument types: (switch-level-capability$_run_closure1) values: [switch-level-capability$_run_closure1@21005f6c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing thing.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: thing.metadata() is applicable for argument types: (thing$_run_closure1) values: [thing$_run_closure1@2a39fe6a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-slider.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
parse: 
setLevel: 
setRangedLevel: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-slider.metadata() is applicable for argument types: (tile-basic-slider$_run_closure1) values: [tile-basic-slider$_run_closure1@743cb8e0]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing temperature-measurement-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: temperature-measurement-capability.metadata() is applicable for argument types: (temperature-measurement-capability$_run_closure1) values: [temperature-measurement-capability$_run_closure1@77192705]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing the-big-switch.groovy
req caps: [capability.switchlevel, capability.switch]
req cap size: 2
requested commands:[setlevel, off, on]
requested attrs:[level, switch]
called cap-methods by app
setlevel
called cap-props by app
level
switch
attribute uses through subscriptions
level
switch
cmd overpriv:[off, on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(master, switch.on, onHandler)][this.subscribe(master, switch.off, offHandler)][this.subscribe(master, level, dimHandler)]
updated: [this.unsubscribe()][this.subscribe(master, switch.on, onHandler)][this.subscribe(master, switch.off, offHandler)][this.subscribe(master, level, dimHandler)]
logHandler: 
onHandler: 
offHandler: 
dimHandler: 
onSwitches: [If (switches && onSwitches),[(switches + onSwitches)],[If switches,[switches],[onSwitches]],],
offSwitches: [If (switches && offSwitches),[(switches + offSwitches)],[If switches,[switches],[offSwitches]],],
Starting Points: []
--app-start--
processing tile-basic-presence.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
parse: 
arrived: 
departed: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-presence.metadata() is applicable for argument types: (tile-basic-presence$_run_closure1) values: [tile-basic-presence$_run_closure1@41a90fa8]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-standard.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
parse: 
on: 
off: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-standard.metadata() is applicable for argument types: (tile-basic-standard$_run_closure1) values: [tile-basic-standard$_run_closure1@53ab0286]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-multiattribute-lighting.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],
on: 
off: 
nextLevel: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][If (level <= 100),[(level = (java.lang.Integer -> java.lang.Integer) java.lang.Math.min((25 * (java.lang.Math.round((level / 25)) + 1)), 100))],[(level = 25)]],
setLevel: [(power = (java.lang.Math.round((percent / 1.175)) * 0.1))]
setSaturation: 
setHue: 
setColor: [If value.hue,,],[If value.saturation,,],[If value.hex,,],[If value.level,,],[If value.switch,,],
reset: 
setAdjustedColor: [If value,[(adjusted = (value + [:]))][(adjusted.hue = this.adjustOutgoingHue(value.hue))][(adjusted.level = null)],],
refresh: 
adjustOutgoingHue: [(adjusted = percent)][If (percent > 31),[If (percent < 63.0),[(adjusted = (percent + ((7 * (percent - 30)) / 32)))],[If (percent < 73.0),[(adjusted = (69 + ((5 * (percent - 62)) / 10)))],[(adjusted = (percent + ((2 * (100 - percent)) / 28)))]],],,],
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-lighting.metadata() is applicable for argument types: (tile-multiattribute-lighting$_run_closure1) values: [tile-multiattribute-lighting$_run_closure1@3ebff828]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing undead-early-warning.groovy
req caps: [capability.contactsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[contact, switch]
called cap-methods by app
on
called cap-props by app
contact
attribute uses through subscriptions
contact
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(contacts, contact.open, contactOpenHandler)]
updated: [this.unsubscribe()][this.subscribe(contacts, contact.open, contactOpenHandler)]
contactOpenHandler: 
Starting Points: []
--app-start--
processing tile-multiattribute-mediaplayer.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: [(state.tracks = [Gangnam Style (?)
PSY
Psy 6 (Six Rules), Part 1, Careless Whisper
Wham!
Make It Big, Never Gonna Give You Up
Rick Astley
Whenever You Need Somebody, Shake It Off
Taylor Swift
1989, Ironic
Alanis Morissette
Jagged Little Pill, Hotline Bling
Drake
Hotline Bling - Single])][(state.currentTrack = 0)]
parse: 
play: [this.sendEvent([name:trackDescription, value:state.tracks[state.currentTrack]])]
pause: [this.sendEvent([name:trackDescription, value:state.tracks[state.currentTrack]])]
stop: 
previousTrack: [(state.currentTrack = (state.currentTrack - 1))][If (state.currentTrack < 0),[(state.currentTrack = (state.tracks.size() - 1))],],[this.sendEvent([name:trackDescription, value:state.tracks[state.currentTrack]])]
nextTrack: [(state.currentTrack = (state.currentTrack + 1))][If (state.currentTrack == state.tracks.size()),[(state.currentTrack = 0)],],[this.sendEvent([name:trackDescription, value:state.tracks[state.currentTrack]])]
mute: 
unmute: 
setLevel: 
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-mediaplayer.metadata() is applicable for argument types: (tile-multiattribute-mediaplayer$_run_closure1) values: [tile-multiattribute-mediaplayer$_run_closure1@3af17be2]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-multiattribute-thermostat.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
parse: 
evaluate: [(threshold = 1.0)][(current = device.currentValue(thermostatOperatingState))][(mode = device.currentValue(thermostatMode))][(heating = false)][(cooling = false)][(idle = false)][If (mode in [heat, emergency heat, auto]),[If ((heatingSetpoint - temp) >= threshold),[(heating = true)],[If ((temp - heatingSetpoint) >= threshold),[(idle = true)],],],,],[If (mode in [cool, auto]),[If ((temp - coolingSetpoint) >= threshold),[(cooling = true)],[If (((coolingSetpoint - temp) >= threshold) && heating),[(idle = true)],],],,],[If (mode == off),[(idle = true)],],[If ((idle && heating) && cooling),,],
setHeatingSetpoint: 
setCoolingSetpoint: 
setThermostatMode: 
setThermostatFanMode: 
off: 
heat: 
auto: 
emergencyHeat: 
cool: 
fanOn: 
fanAuto: 
fanCirculate: 
poll: 
tempUp: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue + 1) : 72)]
tempDown: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue - 1) : 72)]
setTemperature: [(ts = device.currentState(temperature))]
heatUp: [(ts = device.currentState(heatingSetpoint))][(value = (ts) ? (ts.integerValue + 1) : 68)]
heatDown: [(ts = device.currentState(heatingSetpoint))][(value = (ts) ? (ts.integerValue - 1) : 68)]
coolUp: [(ts = device.currentState(coolingSetpoint))][(value = (ts) ? (ts.integerValue + 1) : 76)]
coolDown: [(ts = device.currentState(coolingSetpoint))][(value = (ts) ? (ts.integerValue - 1) : 76)]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-thermostat.metadata() is applicable for argument types: (tile-multiattribute-thermostat$_run_closure1) values: [tile-multiattribute-thermostat$_run_closure1@7c041b41]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing turn-it-on-for-5-minutes.groovy
req caps: [capability.contactsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[contact, switch]
called cap-methods by app
off
on
called cap-props by app
contact
attribute uses through subscriptions
contact
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(contact1, contact.open, contactOpenHandler)]
updated: [this.unsubscribe()][this.subscribe(contact1, contact.open, contactOpenHandler)]
contactOpenHandler: [(fiveMinuteDelay = (60 * 5))]
turnOffSwitch: 
Starting Points: []
--app-start--
processing turn-it-on-when-im-here.groovy
req caps: [capability.switch, capability.presencesensor]
req cap size: 2
requested commands:[off, on]
requested attrs:[presence, switch]
called cap-methods by app
off
on
called cap-props by app
presence
attribute uses through subscriptions
presence
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(presence1, presence, presenceHandler)]
updated: [this.unsubscribe()][this.subscribe(presence1, presence, presenceHandler)]
presenceHandler: [(current = presence1.currentValue(presence))][(presenceValue = presence1.find({ -> ... }))][If presenceValue,,],
Starting Points: []
--app-start--
processing turn-off-with-motion.groovy
req caps: [capability.motionsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[motion, switch]
called cap-methods by app
off
on
called cap-props by app
motion
attribute uses through subscriptions
motion
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(motion1, motion, motionHandler)]
updated: [this.unsubscribe()][this.subscribe(motion1, motion, motionHandler)]
motionHandler: [If (evt.value == active),[(state.inactiveAt = null)],[If (evt.value == inactive),[If state.inactiveAt,[(state.inactiveAt = this.now())],],,],],
scheduleCheck: [If state.inactiveAt,[(elapsed = (this.now() - state.inactiveAt))][(threshold = ((1000 * 60) * minutes1))][If (elapsed >= threshold),[(state.inactiveAt = null)],],,],
Starting Points: []
IT HAS STATE
--app-start--
processing turn-it-on-when-it-opens.groovy
req caps: [capability.contactsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[contact, switch]
called cap-methods by app
on
called cap-props by app
contact
attribute uses through subscriptions
contact
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(contact1, contact.open, contactOpenHandler)]
updated: [this.unsubscribe()][this.subscribe(contact1, contact.open, contactOpenHandler)]
contactOpenHandler: 
Starting Points: []
--app-start--
processing tile-multiattribute-generic.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
parse: 
on: 
off: 
setLevel: 
randomizeLevel: [(level = java.lang.Math.round((java.lang.Math.random() * 100)))]
levelUp: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][If (level < 100),[(level = (level + 1))],],
levelDown: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][If (level > 0),[(level = (level - 1))],],
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-generic.metadata() is applicable for argument types: (tile-multiattribute-generic$_run_closure1) values: [tile-multiattribute-generic$_run_closure1@4b6166aa]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-value.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
parse: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-value.metadata() is applicable for argument types: (tile-basic-value$_run_closure1) values: [tile-basic-value$_run_closure1@66ea1466]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing turn-on-only-if-i-arrive-after-sunset.groovy
req caps: [capability.switch, capability.presencesensor]
req cap size: 2
requested commands:[off, on]
requested attrs:[presence, switch]
called cap-methods by app
off
on
called cap-props by app
presence
attribute uses through subscriptions
presence
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(presence1, presence, presenceHandler)]
updated: [this.unsubscribe()][this.subscribe(presence1, presence, presenceHandler)]
presenceHandler: [(now = new java.util.Date())][(sunTime = this.getSunriseAndSunset())][(current = presence1.currentValue(presence))][(presenceValue = presence1.find({ -> ... }))][If (presenceValue && (now > sunTime.sunset)),,[If (presenceValue && (now < sunTime.sunset)),,],],
Starting Points: []
--app-start--
processing unknown.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: unknown.metadata() is applicable for argument types: (unknown$_run_closure1) values: [unknown$_run_closure1@21694e53]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing whole-house-fan.groovy
req caps: [capability.contactsensor, capability.switch, capability.temperaturemeasurement, capability.thermostat]
req cap size: 4
requested commands:[heat, setheatingsetpoint, auto, cool, setthermostatmode, off, setcoolingsetpoint, fanon, emergencyheat, fancirculate, setthermostatfanmode, on, fanauto]
requested attrs:[coolingsetpoint, thermostatfanmode, thermostatmode, contact, temperature, heatingsetpoint, thermostatoperatingstate, thermostatsetpoint, switch]
called cap-methods by app
off
on
called cap-props by app
temperature
thermostatmode
contact
attribute uses through subscriptions
temperature
thermostatmode
contact
cmd overpriv:[heat, setheatingsetpoint, auto, cool, setthermostatmode, setcoolingsetpoint, fanon, emergencyheat, fancirculate, setthermostatfanmode, fanauto]
attr overpriv:[coolingsetpoint, thermostatfanmode, heatingsetpoint, thermostatoperatingstate, thermostatsetpoint, switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [266374ae-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, ba155665-433d-4e20-9d12-efad7744c3d6, 0e7aa867-9aec-4a24-a372-69014bfa8c24]
[[capability.relativehumiditymeasurement]]
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [(state.fanRunning = false)][this.subscribe(outTemp, temperature, checkThings)][this.subscribe(inTemp, temperature, checkThings)][this.subscribe(thermostat, thermostatMode, checkThings)][this.subscribe(contacts, contact, checkThings)]
checkThings: [(outsideTemp = settings.outTemp.currentTemperature)][(insideTemp = settings.inTemp.currentTemperature)][(thermostatMode = settings.thermostat.currentThermostatMode)][(somethingOpen = ((settings.checkContacts == No) || settings.contacts?.find({ -> ... })))][(shouldRun = true)][If (thermostatMode != off),[(shouldRun = false)],],[If (insideTemp < outsideTemp),[(shouldRun = false)],],[If (insideTemp < settings.minTemp),[(shouldRun = false)],],[If somethingOpen,[(shouldRun = false)],],[If (shouldRun && state.fanRunning),[(state.fanRunning = true)],[If (shouldRun && state.fanRunning),[(state.fanRunning = false)],],],
Starting Points: []
IT HAS STATE
--app-start--
processing virtual-thermostat.groovy
req caps: [capability.motionsensor, capability.temperaturemeasurement, capability.switch]
req cap size: 3
requested commands:[off, on]
requested attrs:[motion, temperature, switch]
called cap-methods by app
off
on
called cap-props by app
motion
temperature
switch
attribute uses through subscriptions
temperature
motion
switch
cmd overpriv:[]
attr overpriv:[]
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, ba155665-433d-4e20-9d12-efad7744c3d6]
[[capability.relativehumiditymeasurement]]
DECLARED METHODS
installed: [this.subscribe(sensor, temperature, temperatureHandler)][If motion,[this.subscribe(motion, motion, motionHandler)],],
updated: [this.unsubscribe()][this.subscribe(sensor, temperature, temperatureHandler)][If motion,[this.subscribe(motion, motion, motionHandler)],],
temperatureHandler: [(isActive = this.hasBeenRecentMotion())][If (isActive || emergencySetpoint),,],
motionHandler: [If (evt.value == active),[(lastTemp = sensor.currentTemperature)][If (lastTemp != null),,],,[If (evt.value == inactive),[(isActive = this.hasBeenRecentMotion())][If (isActive || emergencySetpoint),[(lastTemp = sensor.currentTemperature)][If (lastTemp != null),,],,],,],],
evaluate: [(threshold = 1.0)][If (mode == cool),[If ((currentTemp - desiredTemp) >= threshold),,[If ((desiredTemp - currentTemp) >= threshold),,],],,[If ((desiredTemp - currentTemp) >= threshold),,[If ((currentTemp - desiredTemp) >= threshold),,],],],
hasBeenRecentMotion: [(isActive = false)][If (motion && minutes),[(deltaMinutes = (java.lang.Long -> java.lang.Long) minutes)][If deltaMinutes,[(motionEvents = motion.eventsSince(new java.util.Date((this.now() - (60000 * deltaMinutes)))))][If motionEvents.find({ -> ... }),[(isActive = true)],],,],,[(isActive = true)]],[isActive]
Starting Points: []
--app-start--
processing water-sensor-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: water-sensor-capability.metadata() is applicable for argument types: (water-sensor-capability$_run_closure1) values: [water-sensor-capability$_run_closure1@455351c4]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing zigbee-white-color-temperature-bulb.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
getMOVE_TO_COLOR_TEMPERATURE_COMMAND: 
getCOLOR_CONTROL_CLUSTER: 
getATTRIBUTE_COLOR_TEMPERATURE: 
parse: [(event = zigbee.getEvent(description))][If event,[If ((event.name == level) && (event.value == 0)),,[If (event.name == colorTemperature),,],],,[(cluster = zigbee.parse(description))][If ((cluster && (cluster.clusterId == 6)) && (cluster.command == 7)),[If (cluster.data[0] == 0),,],,],],
off: 
on: 
setLevel: 
ping: 
refresh: 
configure: 
setColorTemperature: [(value = (java.lang.Integer -> java.lang.Integer) value)][(tempInMired = java.lang.Math.round((1000000 / value)))][(finalHex = zigbee.swapEndianHex(zigbee.convertToHexString(tempInMired, 4)))][(cmds = [])][If ((device.getDataValue(manufacturer) == sengled) && (device.getDataValue(model) == Z01-A19NAE26)),,],
setGenericName: [If (value != null),[(genericName = White)][If (value < 3300),[(genericName = Soft White)],[If (value < 4150),[(genericName = Moonlight)],[If (value <= 5000),[(genericName = Cool White)],[If (value >= 5000),[(genericName = Daylight)],],],],],,],
installed: [If (((((device.getDataValue(manufacturer) == MRVL) && (device.getDataValue(model) == MZ100)) || (device.getDataValue(manufacturer) == OSRAM SYLVANIA)) || (device.getDataValue(manufacturer) == OSRAM)) || (device.getDataValue(manufacturer) == sengled)),[If ((device.currentState(level)?.value == null) || (device.currentState(level)?.value == 0)),,],,],
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: zigbee-white-color-temperature-bulb.metadata() is applicable for argument types: (zigbee-white-color-temperature-bulb$_run_closure1) values: [zigbee-white-color-temperature-bulb$_run_closure1@61d9efe0]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing zooz-power-strip-outlet.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
on: 
off: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: zooz-power-strip-outlet.metadata() is applicable for argument types: (zooz-power-strip-outlet$_run_closure1) values: [zooz-power-strip-outlet$_run_closure1@5db99216]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing zigbee-switch.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(event = zigbee.getEvent(description))][If event,,],
off: 
on: 
ping: 
refresh: 
configure: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: zigbee-switch.metadata() is applicable for argument types: (zigbee-switch$_run_closure1) values: [zigbee-switch$_run_closure1@7e094740]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing wemo-bulb.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [If description?.startsWith(catchall:),[If description?.endsWith(0100),[(result = this.createEvent([name:switch, value:on]))],],[If description?.endsWith(0000),[(result = this.createEvent([name:switch, value:off]))],],,],[If description?.startsWith(read attr),[(i = java.lang.Math.round(((this.convertHexToInt(description[(-2..-1)]) / 256) * 100)))],],
on: 
off: 
refresh: 
setLevel: [(cmds = [])][If (value == 0),,[If (device.latestValue(switch) == off),,],],[(level = this.hexString(java.lang.Math.round(((value * 255) / 100))))]
configure: [(configCmds = [zcl global send-me-a-report 6 0 0x10 0 3600 {01}, delay 500, send 0x$device.deviceNetworkId 1 1, delay 1000, zcl global send-me-a-report 8 0 0x20 5 3600 {0010}, delay 200, send 0x$device.deviceNetworkId 1 1, delay 1500, zdo bind 0x$device.deviceNetworkId 1 1 6 {$device.zigbeeId} {}, delay 1000, zdo bind 0x$device.deviceNetworkId 1 1 8 {$device.zigbeeId} {}, delay 500])]
hex: [(s = new java.math.BigInteger(java.lang.Math.round(value).toString()).toString(16))][While (s.size() < width),[(s = (0 + s))]]hex: [(s = new java.math.BigInteger(java.lang.Math.round(value).toString()).toString(16))][While (s.size() < width),[(s = (0 + s))]]
convertHexToInt: 
swapEndianHex: 
reverseArray: [(i = 0)][(j = (array.length - 1))][(tmp = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While (j > i),[(tmp = array[j])][(array[j] = array[i])][(array[i] = tmp)]]reverseArray: [(i = 0)][(j = (array.length - 1))][(tmp = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While (j > i),[(tmp = array[j])][(array[j] = array[i])][(array[i] = tmp)]]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: wemo-bulb.metadata() is applicable for argument types: (wemo-bulb$_run_closure1) values: [wemo-bulb$_run_closure1@db44aa2]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing arrival-sensor-ha.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
updated: 
installed: 
configure: [(cmds = (zigbee.readAttribute(zigbee.POWER_CONFIGURATION_CLUSTER, 32) + zigbee.batteryConfig(20, 20, 1)))]
beep: 
parse: [(state.lastCheckin = this.now())][If description?.startsWith(read attr -),,],
handleReportAttributeMessage: [(descMap = zigbee.parseDescriptionAsMap(description))][If ((descMap.clusterInt == 1) && (descMap.attrInt == 32)),,],
handleBatteryEvent: [(descriptionText = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If ((volts == 0) || (volts == 255)),,[(batteryMap = [28:100, 27:100, 26:100, 25:90, 24:90, 23:70, 22:70, 21:50, 20:50, 19:30, 18:30, 17:15, 16:1, 15:0])][(minVolts = 15)][(maxVolts = 28)][If (volts < minVolts),[(volts = minVolts)],[If (volts > maxVolts),[(volts = maxVolts)],],],[(value = batteryMap[volts])][If (value != null),[(linkText = this.getLinkText(device))][(descriptionText = {{ linkText }} battery was {{ value }})][(eventMap = [name:battery, value:value, descriptionText:descriptionText, translatable:true])],],],
handlePresenceEvent: [(wasPresent = (device.currentState(presence)?.value == present))][If (wasPresent && present),,[If present,,],],[(linkText = this.getLinkText(device))][(descriptionText = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If present,[(descriptionText = {{ linkText }} has arrived)],[(descriptionText = {{ linkText }} has left)]],[(eventMap = [name:presence, value:(present) ? present : not present, linkText:linkText, descriptionText:descriptionText, translatable:true])]
startTimer: 
stopTimer: 
checkPresenceCallback: [(timeSinceLastCheckin = ((this.now() - state.lastCheckin) / 1000))][(theCheckInterval = ((checkInterval) ? (int) checkInterval : 2 * 60))][If (timeSinceLastCheckin >= theCheckInterval),,],
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: arrival-sensor-ha.metadata() is applicable for argument types: (arrival-sensor-ha$_run_closure1) values: [arrival-sensor-ha$_run_closure1@9573b3b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing door-lock-code-distress-message.groovy
req caps: [capability.lock]
req cap size: 1
requested commands:[lock, unlock]
requested attrs:[lock]
called cap-methods by app
called cap-props by app
lock
attribute uses through subscriptions
lock
cmd overpriv:[lock, unlock]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [bdefadfd-d59f-4d54-82c2-5fbb3ac6965f]
[[capability.battery, capability.polling, capability.refresh]]
DECLARED METHODS
installed: [this.subscribe(lock1, lock, checkCode)]
updated: [this.unsubscribe()][this.subscribe(lock1, lock, checkCode)]
checkCode: [If ((evt.value == unlocked) && evt.data),[(lockData = new groovy.json.JsonSlurper().parseText(evt.data))][If discoveryMode,,],[If ((lockData.usedCode == distressCode) && (discoveryMode == false)),,],,],
Starting Points: []
--app-start--
processing gentle-wake-up.groovy
req caps: [capability.musicplayer, capability.switchlevel, capability.switch, capability.sensor]
req cap size: 4
requested commands:[play, playtrack, mute, playtext, nexttrack, restoretrack, pause, off, settrack, resumetrack, previoustrack, setlevel, stop, unmute, on]
requested attrs:[trackdescription, trackdata, mute, level, status, switch]
Dynamic Method Invocation
Some app-defined methods have the same name as known IoT commands:
speak
stop
addChildDevice usage
type 2 command uses
setcolor
called cap-methods by app
playtrack
off
settrack
setlevel
called cap-props by app
trackdata
level
status
switch
attribute uses through subscriptions
level
trackdata
switch
cmd overpriv:[play, mute, playtext, nexttrack, restoretrack, pause, resumetrack, previoustrack, stop, unmute, on]
attr overpriv:[trackdescription, mute]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [6d38663a-1703-46b6-9939-8c1fb9467cf9, 5d3d201d-c4b4-4354-81e9-39d6d728e2c0, 8a9d4b1e3b8af959013b8af9d183000e, 26637648-3292-11e2-9c79-22000a1dc790]
[[capability.motionsensor, capability.refresh]]
DECLARED METHODS
rootPage: 
unsupportedDevicesPage: [(unsupportedDimmers = dimmers.findAll({ -> ... }))]
controllerExplanationPage: 
numbersPage: 
defaultStart: [If ((this.usesOldSettings() && direction) && (direction == Down)),[return 99],],[return 0]
defaultEnd: [If ((this.usesOldSettings() && direction) && (direction == Down)),[return 0],],[return 99]
startLevelLabel: [If this.usesOldSettings(),[If (direction && (direction == Down)),[return 99%],],[return 0%],],[return (this.hasStartLevel()) ? $startLevel% : Current Level]
endLevelLabel: [If this.usesOldSettings(),[If (direction && (direction == Down)),[return 0%],],[return 99%],],[return $endLevel%]
weekdays: [[Monday, Tuesday, Wednesday, Thursday, Friday]]
weekends: [[Saturday, Sunday]]
schedulingPage: 
completionPage: 
installed: 
updated: [(controller = this.getController())][If controller,[(controller.label = app.label)],],
initialize: [If startTime,,],[this.subscribe(app, appHandler)][this.subscribe(location, locationHandler)][If manualOverride,[this.subscribe(dimmers, switch.off, stopDimmersHandler)],],[If this.getAllChildDevices(),[(dni = $new Date().getTime())][(state.controllerDni = dni)],],
appHandler: [If (evt.value == touch),[If atomicState.running,,],,],
locationHandler: [If modeStart,[return null],],[(isSpecifiedMode = (evt.value == modeStart))][(modeStopIsTrue = (modeStop && (modeStop != false)))][If (isSpecifiedMode && this.canStartAutomatically()),,[If (isSpecifiedMode && modeStopIsTrue),,],],
stopDimmersHandler: [(percentComplete = this.completionPercentage())][If ((percentComplete > 2) && (percentComplete < 98)),[If (manualOverride == cancel),,[If (manualOverride == jumpTo),[(end = this.dynamicEndLevel())],],],,],
scheduledStart: [If this.canStartAutomatically(),,],
start: [(atomicState.running = true)][(atomicState.runCounter = 0)][(atomicState.start = new java.util.Date().getTime())]
stop: [(atomicState.running = false)][(atomicState.start = 0)][(atomicState.runCounter = 0)]
healthCheck: [If atomicState.running,[return null],],
sendStartEvent: [(eventData = [name:sessionStatus, value:running, descriptionText:$app.label has started dimming, displayed:true, linkText:app.label, isStateChange:true])][If (source == modeChange),[(eventData.descriptionText +=  because of a mode change)],[If (source == schedule),[(eventData.descriptionText +=  as scheduled)],[If (source == appTouch),[(eventData.descriptionText +=  because you pressed play on the app)],[If (source == controller),[(eventData.descriptionText +=  because you pressed play on the controller)],],],],],
sendStopEvent: [(eventData = [name:sessionStatus, value:stopped, descriptionText:$app.label has stopped dimming, displayed:true, linkText:app.label, isStateChange:true])][If (source == modeChange),[(eventData.descriptionText +=  because of a mode change)][(eventData.value += cancelled)],[If (source == schedule),[(eventData.descriptionText = $app.label has finished dimming)],[If (source == appTouch),[(eventData.descriptionText +=  because you pressed play on the app)][(eventData.value += cancelled)],[If (source == controller),[(eventData.descriptionText +=  because you pressed stop on the controller)][(eventData.value += cancelled)],[If (source == settingsChange),[(eventData.descriptionText +=  because the settings have changed)][(eventData.value += cancelled)],[If (source == manualOverride),[(eventData.descriptionText +=  because the dimmer was manually turned off)][(eventData.value += cancelled)],],],],],],],
sendTimeRemainingEvent: [(percentCompleteEventData = [name:percentComplete, value:(int) percentComplete, displayed:displayed, isStateChange:true])][(duration = this.sanitizeInt(duration, 30))][(timeRemaining = (duration - (duration * (percentComplete / 100))))][(timeRemainingEventData = [name:timeRemaining, value:this.displayableTime(timeRemaining), displayed:displayed, isStateChange:true])]
sendControllerEvent: [(controller = this.getController())][If controller,,],
getController: [(dni = state.controllerDni)][If dni,[return null],],[(controller = this.getChildDevice(dni))][If controller,[return null],],[return controller]
increment: [If atomicState.running,[return null],],[If (atomicState.runCounter == null),[(atomicState.runCounter = 1)],[(atomicState.runCounter = (atomicState.runCounter + 1))]],[(percentComplete = this.completionPercentage())][If (percentComplete > 99),[(percentComplete = 99)],],[If (atomicState.runCounter > 100),[(percentComplete = 100)],],[If (percentComplete < 99),[(runAgain = this.stepDuration())],[(completionDelay = this.completionDelaySeconds())][If completionDelay,,],],
updateDimmers: [(dimmers.each({ java.lang.Object dimmer -> ... }){ (nextLevel = this.dynamicLevel(dimmer, percentComplete)); <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })]
dynamicLevel: [(start = atomicState.startLevels[dimmer.id])][(end = this.dynamicEndLevel())][If percentComplete,[return start],],[(totalDiff = (end - start))][(actualPercentage = (percentComplete / 100))][(percentOfTotalDiff = (totalDiff * actualPercentage))][(int) (start + percentOfTotalDiff)]
completion: [If atomicState.running,[return null],],
handleCompletionSwitches: [(completionSwitches.each({ java.lang.Object completionSwitch -> ... }){ (isDimmer = this.hasSetLevelCommand(completionSwitch)); <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })]
handleCompletionMessaging: [If completionMessage,[If location.contactBookEnabled,,[If completionPhoneNumber,,],[If completionPush,,],],[If completionMusicPlayer,,],,],
handleCompletionModesAndPhrases: [If completionMode,,],[If completionPhrase,,],
speak: [(sound = this.textToSpeech(message))][(soundDuration = ((java.lang.Integer -> java.lang.Integer) sound.duration + 2))]
resumePlaying: [(sonos = completionMusicPlayer)][If sonos,[(currentTrack = sonos.currentState(trackData).jsonValue)][If (currentTrack.status == playing),,],,],
setLevelsInState: [(startLevels = [:])][(dimmers.each({ java.lang.Object dimmer -> ... }){ <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })][(atomicState.startLevels = startLevels)]
canStartAutomatically: [(today = new java.util.Date().format(EEEE))][If (days || days.contains(today)),[return true],],[return false]
completionPercentage: [If atomicState.running,[return null],],[(now = new java.util.Date().getTime())][(timeElapsed = (now - atomicState.start))][(totalRunTime = (this.totalRunTimeMillis()) ? this.totalRunTimeMillis() : 1)][(percentComplete = ((timeElapsed / totalRunTime) * 100))][return percentComplete]
totalRunTimeMillis: [(minutes = this.sanitizeInt(duration, 30))]
convertToMillis: [(seconds = (minutes * 60))][(millis = (seconds * 1000))][return millis]
timeRemaining: [(normalizedPercentComplete = (percentComplete / 100))][(duration = this.sanitizeInt(duration, 30))][(timeElapsed = (duration * normalizedPercentComplete))][(timeRemaining = (duration - timeElapsed))][return timeRemaining]
millisToEnd: 
displayableTime: [(timeString = $timeRemaining)][(parts = timeString.split(\.))][If parts.size(),[return 0:00],],[(minutes = parts[0])][If (parts.size() == 1),[return $minutes:00],],[(fraction = (double) 0.$parts[1])][(seconds = $(int) (60 * fraction).padLeft(2, 0))][return $minutes:$seconds]
jumpTo: [(millisToEnd = this.millisToEnd(percentComplete))][(endTime = (new java.util.Date().getTime() + millisToEnd))][(duration = this.sanitizeInt(duration, 30))][(durationMillis = this.convertToMillis(duration))][(shiftedStart = (endTime - durationMillis))][(atomicState.start = shiftedStart)]
dynamicEndLevel: [If this.usesOldSettings(),[If (direction && (direction == Down)),[return 0],],[return 99],],[return (int) endLevel]
getHue: [(start = (int) atomicState.startLevels[dimmer.id])][(end = this.dynamicEndLevel())][If (start > end),,],
getUpHue: 
getDownHue: 
getBlueHue: [If (level < 5),[return 72],],[If (level < 10),[return 71],],[If (level < 15),[return 70],],[If (level < 20),[return 69],],[If (level < 25),[return 68],],[If (level < 30),[return 67],],[If (level < 35),[return 66],],[If (level < 40),[return 65],],[If (level < 45),[return 64],],[If (level < 50),[return 63],],[If (level < 55),[return 62],],[If (level < 60),[return 61],],[If (level < 65),[return 60],],[If (level < 70),[return 59],],[If (level < 75),[return 58],],[If (level < 80),[return 57],],[If (level < 85),[return 56],],[If (level < 90),[return 55],],[If (level < 95),[return 54],],[If (level >= 95),[return 53],],
getRedHue: [If (level < 6),[return 1],],[If (level < 12),[return 2],],[If (level < 18),[return 3],],[If (level < 24),[return 4],],[If (level < 30),[return 5],],[If (level < 36),[return 6],],[If (level < 42),[return 7],],[If (level < 48),[return 8],],[If (level < 54),[return 9],],[If (level < 60),[return 10],],[If (level < 66),[return 11],],[If (level < 72),[return 12],],[If (level < 78),[return 13],],[If (level < 84),[return 14],],[If (level < 90),[return 15],],[If (level < 96),[return 16],],[If (level >= 96),[return 17],],
dimmersContainUnsupportedDevices: [(found = dimmers.find({ -> ... }))][return (found != null)]
hasSetLevelCommand: 
hasSetColorCommand: 
hasCommand: [return (device.supportedCommands.find({ -> ... }) != null)]
dimmersWithSetColorCommand: [(colorDimmers = [])][(dimmers.each({ java.lang.Object dimmer -> ... }){ <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })][return colorDimmers]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
sanitizeInt: 
completionDelaySeconds: [(completionDelayMinutes = this.sanitizeInt(completionDelay))][(completionDelaySeconds = (completionDelayMinutes * 60))][return (completionDelaySeconds) ? completionDelaySeconds : 0]
stepDuration: [(minutes = this.sanitizeInt(duration, 30))][(stepDuration = ((minutes * 60) / 100))][return (stepDuration) ? stepDuration : 1]
debug: 
smartThingsDateFormat: [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
humanReadableStartDate: 
fancyString: [(fancify = { java.lang.Object list -> ... })]
fancyDeviceString: 
deviceLabel: [return (device.label) ? device.label : device.name]
schedulingHrefDescription: [(descriptionParts = [])][If days,[If (days == this.weekdays()),[(descriptionParts << On weekdays,)],[If (days == this.weekends()),[(descriptionParts << On weekends,)],[(descriptionParts << On $this.fancyString(days),)]],],,],[(descriptionParts << $this.fancyDeviceString(dimmers) will start dimming)][If startTime,[(descriptionParts << at $this.humanReadableStartDate())],],[If modeStart,[If startTime,[(descriptionParts << or)],],[(descriptionParts << when $location.name enters '$modeStart' mode)],],[If (descriptionParts.size() <= 1),[return null],],
completionHrefDescription: [(descriptionParts = [])][(example = Switch1 will be turned on. Switch2, Switch3, and Switch4 will be dimmed to 50%. The message '<message>' will be spoken, sent as a text, and sent as a push notification. The mode will be changed to '<mode>'. The phrase '<phrase>' will be executed)][If completionSwitches,[(switchesList = [])][(dimmersList = [])][(completionSwitches.each({ -> ... }){ (isDimmer = (completionSwitchesLevel) ? this.hasSetLevelCommand(it) : false); <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement>; <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })][If switchesList,[(descriptionParts << $this.fancyString(switchesList) will be turned $(completionSwitchesState) ? completionSwitchesState : on.)],],[If dimmersList,[(descriptionParts << $this.fancyString(dimmersList) will be dimmed to $completionSwitchesLevel%.)],],,],[If (completionMessage && ((completionPhoneNumber || completionPush) || completionMusicPlayer)),[(messageParts = [])][If completionMusicPlayer,[(messageParts << spoken)],],[If completionPhoneNumber,[(messageParts << sent as a text)],],[If completionPush,[(messageParts << sent as a push notification)],],[(descriptionParts << The message '$completionMessage' will be $this.fancyString(messageParts).)],],[If completionMode,[(descriptionParts << The mode will be changed to '$completionMode'.)],],[If completionPhrase,[(descriptionParts << The phrase '$completionPhrase' will be executed.)],],
numbersPageHrefDescription: [(title = All dimmers will dim for $(duration) ? duration : 30 minutes from $this.startLevelLabel() to $this.endLevelLabel())][If colorize,[(colorDimmers = this.dimmersWithSetColorCommand())][If (colorDimmers == dimmers),[(title +=  and will gradually change color.)],[(title += .
$this.fancyDeviceString(colorDimmers) will gradually change color.)]],,],[return title]
hueSatToHex: [(convertedRGB = this.hslToRgb(h, s, 0.5))]
hslToRgb: [(r = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(g = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(b = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (s == 0),[(r = (g = (b = l)))],[(hue2rgb = { java.lang.Object p, java.lang.Object q, java.lang.Object t -> ... })][(q = ((l < 0.5)) ? (l * (1 + s)) : ((l + s) - (l * s)))][(p = ((2 * l) - q))][(r = hue2rgb.call(p, q, (h + (1 / 3))))][(g = hue2rgb.call(p, q, h))][(b = hue2rgb.call(p, q, (h - (1 / 3))))]],[return [(r * 255), (g * 255), (b * 255)]]
rgbToHex: [(toHex = { -> ... })][(rgbToHex = { java.lang.Object r, java.lang.Object g, java.lang.Object b -> ... })]
usesOldSettings: [this.hasEndLevel()]
hasStartLevel: [return ((startLevel != null) && (startLevel != ))]
hasEndLevel: [return ((endLevel != null) && (endLevel != ))]
Starting Points: []
IT HAS ATOMICSTATE
--app-start--
processing arrival-sensor.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
beep: 
installed: 
parse: [(results = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If this.isBatteryMessage(description),[(results = this.parseBatteryMessage(description))],[(results = this.parsePresenceMessage(description))]],
parsePresenceMessage: [(name = this.parseName(description))][(value = this.parseValue(description))][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(handlerName = this.getState(value))][(isStateChange = this.isStateChange(device, name, value))][(results = [name:name, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName, isStateChange:isStateChange, ... ])]
parseName: [If description?.startsWith(presence: ),,],
parseValue: [If description?.startsWith(presence: ),[If description?.endsWith(1),,[If description?.endsWith(0),,],],,],
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseDescriptionText: 
getState: [(state = value)][If (value == present),[(state = arrived)],[If (value == not present),[(state = left)],],],
isBatteryMessage: [(description ==~ .*battery:.*rssi:.*lqi:.*)]
parseBatteryMessage: [(results = [])][(parts = description.split(,))]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText battery was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
getRssiResult: [(name = rssi)][(parts = part.split(:))][If (parts.size() != 2),,],[(valueString = parts[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(value = (valueInt - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]
getLqiResult: [(name = lqi)][(parts = part.split(:))][If (parts.size() != 2),,],[(valueString = parts[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(percentageOf = 255)][(value = java.lang.Math.round(((valueInt / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText Signal (LQI) was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: arrival-sensor.metadata() is applicable for argument types: (arrival-sensor$_run_closure1) values: [arrival-sensor$_run_closure1@4b629f13]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing beacon-control.groovy
req caps: [capability.lock, capability.switch, capability.beacon]
req cap size: 3
requested commands:[lock, unlock, off, on]
requested attrs:[presence, lock, switch]
called cap-methods by app
lock
unlock
off
on
called cap-props by app
presence
attribute uses through subscriptions
presence
cmd overpriv:[]
attr overpriv:[lock, switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, bdefadfd-d59f-4d54-82c2-5fbb3ac6965f]
[[capability.battery, capability.polling, capability.refresh]]
DECLARED METHODS
mainPage: 
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(beacons, presence, beaconHandler)]
beaconHandler: [If allOk,[(data = new groovy.json.JsonSlurper().parseText(evt.data))][(beaconName = this.getBeaconName(evt))][(phoneName = this.getPhoneName(data))][If (phoneName != null),[(action = ((data.presence == 1)) ? arrived : left)][(msg = $phoneName has $action $((action == arrived)) ? at  : the $beaconName)][If (action == arrived),[(msg = this.arriveActions(msg))],[If (action == left),[(msg = this.departActions(msg))],],],[If (pushNotification || phone),[(options = [method:((pushNotification && phone)) ? both : (pushNotification) ? push : sms, phone:phone])],],,],,],
arriveActions: [If (((arrivalPhrase || arrivalOnSwitches) || arrivalOffSwitches) || arrivalLocks),[(msg += , so)],],[If arrivalPhrase,[(msg +=  $this.prefix(executed) $arrivalPhrase.)],],[If arrivalOnSwitches,[(msg +=  $this.prefix(turned) $this.list(arrivalOnSwitches) on.)],],[If arrivalOffSwitches,[(msg +=  $this.prefix(turned) $this.list(arrivalOffSwitches) off.)],],[If arrivalLocks,[(msg +=  $this.prefix(unlocked) $this.list(arrivalLocks).)],],[msg]
departActions: [If (((departPhrase || departOnSwitches) || departOffSwitches) || departLocks),[(msg += , so)],],[If departPhrase,[(msg +=  $this.prefix(executed) $departPhrase.)],],[If departOnSwitches,[(msg +=  $this.prefix(turned) $this.list(departOnSwitches) on.)],],[If departOffSwitches,[(msg +=  $this.prefix(turned) $this.list(departOffSwitches) off.)],],[If departLocks,[(msg +=  $this.prefix(locked) $this.list(departLocks).)],],[msg]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
prefix: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(index = ((settings.prefixIndex == null)) ? 0 : (settings.prefixIndex + 1))]
listPhrases: [location.helloHome.getPhrases().label]
executePhrase: [If phraseName,,],
getBeaconName: [(beaconName = beacons.find({ java.lang.Object b -> ... }))][return beaconName]
getPhoneName: [(phoneName = phones.find({ java.lang.Object phone -> ... }))][return phoneName]
hideOptionsSection: [((((starting || ending) || days) || modes)) ? false : true]
getAllOk: [((modeOk && daysOk) && timeOk)]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(<beacon-control> modeOk = $result)][result]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(<beacon-control> daysOk = $result)][result]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(<beacon-control> timeOk = $result)][result]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]
timeIntervalLabel: [((starting && ending)) ? ((this.hhmm(starting) + -) + this.hhmm(ending, h:mm a z)) : ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
list: 
Starting Points: []
--app-start--
processing beaconthing.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
installed: [(emptyList = [])][(json = new groovy.json.JsonBuilder(emptyList))]
setPresence: 
arrived: [(theList = device.latestValue(inRange))][(inRangeList = new groovy.json.JsonSlurper().parseText(theList))][If inRangeList.contains(id),,],[(inRangeList += id)][(json = new groovy.json.JsonBuilder(inRangeList))][(friendlyList = (Nearby:  + inRangeList.join(, )))][If (inRangeList.size() == 1),,],
left: [(theList = device.latestValue(inRange))][(inRangeList = new groovy.json.JsonSlurper().parseText(theList))][(inRangeList -= id)][(json = new groovy.json.JsonBuilder(inRangeList))][(friendlyList = (Nearby:  + inRangeList.join(, )))][If inRangeList.empty,[(friendlyList = No one is nearby)],],
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: beaconthing.metadata() is applicable for argument types: (beaconthing$_run_closure1) values: [beaconthing$_run_closure1@1df98368]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing button-controller.groovy
req caps: [capability.musicplayer, capability.switch, capability.alarm, capability.lock, capability.button]
req cap size: 5
requested commands:[play, siren, unlock, playtrack, mute, playtext, nexttrack, restoretrack, pause, off, settrack, resumetrack, both, previoustrack, setlevel, stop, strobe, lock, unmute, on]
requested attrs:[button, trackdata, level, alarm, trackdescription, lock, mute, status, switch]
called cap-methods by app
unlock
siren
off
lock
on
called cap-props by app
button
trackdata
level
alarm
trackdescription
lock
mute
status
switch
attribute uses through subscriptions
button
trackdata
numberofbuttons
level
alarm
trackdescription
lock
mute
switch
status
cmd overpriv:[play, playtrack, mute, playtext, nexttrack, restoretrack, pause, settrack, resumetrack, both, previoustrack, setlevel, stop, strobe, unmute]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [6d38663a-1703-46b6-9939-8c1fb9467cf9, 8a9d4b1e3b8af959013b8af9d183000e, c3a56dda-a2c9-40eb-96ad-a1397809b02e, bdefadfd-d59f-4d54-82c2-5fbb3ac6965f, ff20e87b-992b-42b0-9cd6-72b0030dedc3]
[[capability.battery, capability.refresh, capability.polling]]
DECLARED METHODS
selectButton: 
createPage: [If ((state.numButton == pageNum) || (pageNum == 8)),[(state.installCondition = true)],],[this.dynamicPage([name:configureButton$pageNum, title:Set up button $pageNum here, nextPage:configureButton$(pageNum + 1), install:state.installCondition, ... ], this.getButtonSections(pageNum))]
configureButton1: [(state.numButton = (buttonDevice.currentState(numberOfButtons)?.longValue) ? buttonDevice.currentState(numberOfButtons)?.longValue : 4)][(state.installCondition = false)]
configureButton2: 
configureButton3: 
configureButton4: 
configureButton5: 
configureButton6: 
configureButton7: 
configureButton8: 
getButtonSections: [return { -> ... }]
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(buttonDevice, button, buttonEvent)]
configured: [return ((((buttonDevice || this.buttonConfigured(1)) || this.buttonConfigured(2)) || this.buttonConfigured(3)) || this.buttonConfigured(4))]
buttonConfigured: [return (((((((settings[lights_$idx_pushed] || settings[locks_$idx_pushed]) || settings[sonos_$idx_pushed]) || settings[mode_$idx_pushed]) || settings[notifications_$idx_pushed]) || settings[sirens_$idx_pushed]) || settings[notifications_$idx_pushed]) || settings[phone_$idx_pushed])]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
buttonEvent: [If allOk,[(buttonNumber = evt.data)][(value = evt.value)][(recentEvents = buttonDevice.eventsSince(new java.util.Date((this.now() - 3000))).findAll({ -> ... }))][If (recentEvents.size <= 1),,],,],
executeHandlers: [(lights = this.find(lights, buttonNumber, value))][If (lights != null),,],[(locks = this.find(locks, buttonNumber, value))][If (locks != null),,],[(sonos = this.find(sonos, buttonNumber, value))][If (sonos != null),,],[(mode = this.find(mode, buttonNumber, value))][If (mode != null),,],[(phrase = this.find(phrase, buttonNumber, value))][If (phrase != null),,],[(textMessage = this.findMsg(textMessage, buttonNumber))][(notifications = this.find(notifications, buttonNumber, value))][If notifications?.toBoolean(),,],[(phone = this.find(phone, buttonNumber, value))][If (phone != null),,],[(sirens = this.find(sirens, buttonNumber, value))][If (sirens != null),,],
find: [(preferenceName = ((((type + _) + buttonNumber) + _) + value))][(pref = settings[preferenceName])][If (pref != null),,],[return pref]
findMsg: [(preferenceName = ((type + _) + buttonNumber))][(pref = settings[preferenceName])][If (pref != null),,],[return pref]
toggle: [If devices*.currentValue(switch).contains(on),,[If devices*.currentValue(switch).contains(off),,[If devices*.currentValue(lock).contains(locked),,[If devices*.currentValue(lock).contains(unlocked),,[If devices*.currentValue(alarm).contains(off),,],],],],],
changeMode: [If ((location.mode != mode) && location.modes?.find({ -> ... })),,],
getAllOk: [((modeOk && daysOk) && timeOk)]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)][result]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)][result]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location.timeZone).time)][(stop = this.timeToday(ending, location.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)][result]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]
hideOptionsSection: [((((starting || ending) || days) || modes)) ? false : true]
timeIntervalLabel: [((starting && ending)) ? ((this.hhmm(starting) + -) + this.hhmm(ending, h:mm a z)) : ]
Starting Points: []
IT HAS STATE
--app-start--
processing jenkins-notifier.groovy
req caps: [capability.colorcontrol, capability.switch]
req cap size: 2
requested commands:[setsaturation, sethue, setcolor, off, on]
requested attrs:[saturation, hue, color, switch]
called cap-methods by app
setcolor
off
on
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[setsaturation, sethue]
attr overpriv:[saturation, hue, color, switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [48b39485-7ebc-4c80-bf6e-9a653a2d1c95, 8a9d4b1e3b8af959013b8af9d183000e]
[[capability.switchlevel, capability.refresh]]
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
getHueColors: [return [Red:0, Green:39, Blue:70, Yellow:25, Orange:10, Purple:75, Pink:83]]
getSaturation: [return 100]
getMaxLevel: [return 100]
initialize: [(successColor = [switch:on, hue:this.getHueColors()[colorSuccess], saturation:this.getSaturation(), level:(lightLevelSuccess) ? lightLevelSuccess : this.getMaxLevel()])][(failColor = [switch:on, hue:this.getHueColors()[colorFail], saturation:this.getSaturation(), level:(lightLevelFail) ? lightLevelFail : this.getMaxLevel()])][(state.successColor = successColor)][(state.failColor = failColor)][(cron = * */$(refreshInterval) ? refreshInterval : 15 * * * ?)]
checkServer: [(successColor = state.successColor)][(failColor = state.failColor)][(basicCredentials = $jenkinsUsername:$jenkinsPassword)][(encodedCredentials = basicCredentials.encodeAsBase64().toString())][(basicAuth = Basic $encodedCredentials)][(head = [Authorization:basicAuth])][(host = (jenkinsUrl.contains(lastBuild/api/json)) ? jenkinsUrl : $jenkinsUrl/lastBuild/api/json)]
Starting Points: []
IT HAS STATE
--app-start--
processing shabbat-and-holiday-modes.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: 
poll: 
Hebcal_WebRequest: [(today = new java.util.Date().format(yyyy-MM-dd))][(zip = (java.lang.String -> java.lang.String) settings.zip)][(locale = this.getWeatherFeature(geolookup, zip))][(timezone = java.util.TimeZone.getTimeZone(locale.location.tz_long))][(hebcal_date = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(hebcal_category = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(hebcal_title = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(candlelighting = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(candlelightingLocalTime = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(havdalah = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(havdalahLocalTime = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pushMessage = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(testmessage = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(urlRequest = http://www.hebcal.com/hebcal/?v=1&cfg=json&nh=off&nx=off&year=now&month=now&mf=off&c=on&zip=$zipcode&m=$havdalahOffset&s=off&D=off&d=off&o=off&ss=off)][(hebcal = { java.lang.Object response -> ... })]
HebCal_GetTime12: [(returnTime = (((hebcal_title.split(:)[1] + :) + hebcal_title.split(:)[2]) +  ))]
HebCal_GetTime24: [(returnTime = hebcal_date.split(T)[1])][(returnTime = returnTime.split(-)[0])]
setChag: [If (location.mode != startMode),[If location.modes?.find({ -> ... }),[(dayofweek = new java.util.Date().format(EEE))][If (dayofweek == Fri),,],,],,],
endChag: [If (location.mode != endMode),[If location.modes?.find({ -> ... }),,],,],
sendMessage: [If (sendPushMessage != No),,],[If phone,,],
Starting Points: []
--app-start--
processing ready-for-rain.groovy
req caps: [capability.contactsensor]
req cap size: 1
requested commands:[]
requested attrs:[contact]
called cap-methods by app
called cap-props by app
contact
attribute uses through subscriptions
contact
cmd overpriv:[]
attr overpriv:[]
DECLARED METHODS
mainPage: 
installed: 
updated: [this.unsubscribe()]
init: [(state.lastMessage = 0)][(state.lastCheck = [time:0, result:false])][this.subscribe(sensors, contact.open, scheduleCheck)]
scheduleCheck: [(open = sensors.findAll({ -> ... }))][(plural = ((open.size() > 1)) ? are : is)][If (((this.now() - ((30 * 60) * 1000)) > state.lastCheck[time]) && open),[(response = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (location.channelName != samsungtv),[(response = this.getWeatherFeature(forecast, zipCode))],[(response = this.getWeatherFeature(forecast))]],[(weather = this.isStormy(response))][If weather,,],,[If ((((this.now() - ((30 * 60) * 1000)) <= state.lastCheck[time]) && state.lastCheck[result]) && open),[this.send($open.join(, ) $plural open and $state.lastCheck[result] coming.)],],],
send: [(delay = (((messageDelay != null) && (messageDelay != ))) ? ((messageDelay * 60) * 1000) : 0)][If ((this.now() - delay) > state.lastMessage),[(state.lastMessage = this.now())][If (sendPushMessage == Yes),,],[If phone,,],,],
isStormy: [(types = [rain, snow, showers, sprinkles, precipitation])][(forecast = json?.forecast?.txt_forecast?.forecastday?.first())][(result = false)][If forecast,[(text = forecast?.fcttext?.toLowerCase())][If text,[For ((i = 0); ((i < types.size()) && result); (i++)),[If text.contains(types[i]),[(result = types[i])],],][For ((i = 0); ((i < types.size()) && result); (i++)),[If text.contains(types[i]),[(result = types[i])],],],],,],[(state.lastCheck = [time:this.now(), result:result])][return result]
Starting Points: []
IT HAS STATE
--app-start--
processing lock-it-when-i-leave.groovy
req caps: [capability.lock, capability.presencesensor]
req cap size: 2
requested commands:[lock, unlock]
requested attrs:[presence, lock]
called cap-methods by app
lock
unlock
called cap-props by app
presence
lock
attribute uses through subscriptions
presence
cmd overpriv:[]
attr overpriv:[]
type2 overprivilege unused caps:
type2 driver combination: [bdefadfd-d59f-4d54-82c2-5fbb3ac6965f, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.polling, capability.refresh]]
DECLARED METHODS
installed: [this.subscribe(presence1, presence, presence)]
updated: [this.unsubscribe()][this.subscribe(presence1, presence, presence)]
presence: [If (evt.value == present),[If (unlock == Yes),[(anyLocked = (lock1.count({ -> ... }) != lock1.size()))][If anyLocked,,],,],,[(nobodyHome = (presence1.find({ -> ... }) == null))][If nobodyHome,[(anyUnlocked = (lock1.count({ -> ... }) != lock1.size()))][If anyUnlocked,,],,],],
sendMessage: [If location.contactBookEnabled,,[If (spam == Yes),,],],
Starting Points: []
--app-start--
processing simple-sync-trigger.groovy
req caps: [capability.motionsensor, capability.contactsensor, capability.switch, capability.button, capability.mediacontroller, capability.accelerationsensor, capability.presencesensor]
req cap size: 7
requested commands:[getcurrentactivity, startactivity, off, getallactivities, on]
requested attrs:[button, acceleration, motion, activities, contact, currentactivity, presence, switch]
Some app-defined methods have the same name as known IoT commands:
startactivity
called cap-methods by app
startactivity
getallactivities
called cap-props by app
button
acceleration
motion
activities
contact
presence
switch
attribute uses through subscriptions
button
acceleration
motion
activities
contact
presence
switch
cmd overpriv:[getcurrentactivity, off, on]
attr overpriv:[currentactivity]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 266374ae-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, ff20e87b-992b-42b0-9cd6-72b0030dedc3, a33780a2-68c1-465b-9c81-ca8081701b40, f730b653-b0b6-483e-8c84-977e240f5eb3, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.refresh, capability.switchlevel, capability.polling]]
DECLARED METHODS
agentSelection: [If agent,[(state.refreshCount = 0)],],
control: [(activities = agent.latestValue(activities))][If (activities || state.refreshCount),[(refreshCount = (state.refreshCount) ? 0 : (int) state.refreshCount)][(state.refreshCount = (refreshCount + 1))][(refreshInterval = ((refreshCount == 0)) ? 2 : 4)][If ((refreshCount % 5) == 0),,],,],
anythingSet: [For [motion, motionInactive, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, button1, triggerModes, timeOfDay],[If settings[name],[return true],],]anythingSet: [For [motion, motionInactive, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, button1, triggerModes, timeOfDay],[If settings[name],[return true],],][return false]
ifUnset: [If settings[name],,],
ifSet: [If settings[name],,],
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [log.trace(subscribeToEvents())][this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(motionInactive, motion.inactive, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,,],
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],
modeChangeHandler: [If (evt.value in triggerModes),,],
scheduledTimeHandler: 
appTouchHandler: 
startActivity: [If frequency,[(state.lastActionTimeStamp = this.now())],],
frequencyKey: [lastActionTimeStamp]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],[result]
getAllOk: [((modeOk && daysOk) && timeOk)]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)][result]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)][result]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting).time)][(stop = this.timeToday(ending).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)][result]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]
timeIntervalLabel: [((starting && ending)) ? ((this.hhmm(starting) + -) + this.hhmm(ending, h:mm a z)) : ]
Starting Points: []
IT HAS STATE
--app-start--
processing logitech-harmony-hub-c2c.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
initialize: 
installed: 
updated: 
startActivity: 
activityoff: 
alloff: 
poll: 
ping: 
refresh: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: logitech-harmony-hub-c2c.metadata() is applicable for argument types: (logitech-harmony-hub-c2c$_run_closure1) values: [logitech-harmony-hub-c2c$_run_closure1@4fbdc0f0]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing plantlink.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
updated: 
installed: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
setStatusIcon: [(status = )]
setPlantFuelLevel: 
setBatteryLevel: 
setInstallSmartApp: 
parse: [(description_map = this.parseDescriptionAsMap(description))][(event_name = )][(measurement_map = [type:link, signal:0x00, zigbeedeviceid:device.zigbeeId, created:(int) (new java.util.Date().time / 1000)])][If (description_map.cluster == 0001),[(event_name = battery_status)][(measurement_map[battery] = 0x$description_map.value)],[If (description_map.cluster == 0B04),[(measurement_map[moisture] = 0x$description_map.value)][(event_name = moisture_status)],],],[(json_builder = new groovy.json.JsonBuilder(measurement_map))][(result = this.createEvent([name:event_name, value:json_builder.toString()]))]
parseDescriptionAsMap: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: plantlink.metadata() is applicable for argument types: (plantlink$_run_closure1) values: [plantlink$_run_closure1@2449cff7]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing monitor-on-sense.groovy
req caps: [capability.switch, capability.accelerationsensor]
req cap size: 2
requested commands:[off, on]
requested attrs:[acceleration, switch]
called cap-methods by app
on
called cap-props by app
acceleration
attribute uses through subscriptions
acceleration
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, f730b653-b0b6-483e-8c84-977e240f5eb3]
[[capability.battery, capability.polling, capability.refresh]]
DECLARED METHODS
installed: [this.subscribe(accelerationSensor, acceleration.active, accelerationActiveHandler)]
updated: [this.unsubscribe()][this.subscribe(accelerationSensor, acceleration.active, accelerationActiveHandler)]
accelerationActiveHandler: 
Starting Points: []
--app-start--
processing mini-hue-controller.groovy
req caps: [capability.colorcontrol, capability.button]
req cap size: 2
requested commands:[sethue, setcolor, setsaturation]
requested attrs:[saturation, button, hue, color]
type 2 command uses
setlevel
off
on
type 2 attr uses
level
switch
called cap-methods by app
setcolor
called cap-props by app
saturation
button
hue
attribute uses through subscriptions
button
level
switch
cmd overpriv:[sethue, setsaturation]
attr overpriv:[color]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [48b39485-7ebc-4c80-bf6e-9a653a2d1c95, ff20e87b-992b-42b0-9cd6-72b0030dedc3]
[[capability.refresh]]
DECLARED METHODS
installed: [(state.colorIndex = -1)]
updated: [this.unsubscribe()]
initialize: [this.subscribe(controller, button, buttonHandler)]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
buttonHandler: 
toggleState: [If (currentSwitchState == on),,],
levelUp: [(level = java.lang.Math.min((currentSwitchLevel + 10), 100))]
levelDown: [(level = java.lang.Math.max((currentSwitchLevel - 10), 10))]
changeColor: [(colors = [[name:Soft White, hue:23, saturation:56], [name:Daylight, hue:53, saturation:91], [name:White, hue:52, saturation:19], [name:Warm White, hue:20, saturation:80], [name:Blue, hue:70, saturation:100], [name:Green, hue:39, saturation:100], [name:Yellow, hue:25, saturation:100], [name:Orange, hue:10, saturation:100], [name:Purple, hue:75, saturation:100], [name:Pink, hue:83, saturation:100], [name:Red, hue:100, saturation:100]])][(maxIndex = (colors.size() - 1))][If (state.colorIndex < maxIndex),[(state.colorIndex = (state.colorIndex + 1))],[(state.colorIndex = 0)]],[(color = colors[state.colorIndex])]
getCurrentSwitchState: [(on = 0)][(off = 0)][(bulbs.each({ -> ... }){ <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })][((on > off)) ? on : off]
getCurrentSwitchLevel: [(level = 0)][(bulbs.each({ -> ... }){ (level = java.lang.Math.max((it.currentValue(level)?.toInteger()) ? it.currentValue(level)?.toInteger() : 0, level)) })]
Starting Points: []
IT HAS STATE
--app-start--
processing single-button-controller.groovy
req caps: [capability.musicplayer, capability.lock, capability.switch]
req cap size: 3
requested commands:[play, unlock, playtrack, mute, playtext, nexttrack, restoretrack, pause, off, settrack, resumetrack, previoustrack, setlevel, stop, lock, unmute, on]
requested attrs:[trackdata, level, trackdescription, lock, mute, status, switch]
type 2 attr uses
button
called cap-methods by app
unlock
lock
off
on
called cap-props by app
trackdata
level
trackdescription
lock
mute
status
switch
attribute uses through subscriptions
button
trackdata
level
lock
trackdescription
mute
switch
status
cmd overpriv:[play, playtrack, mute, playtext, nexttrack, restoretrack, pause, settrack, resumetrack, previoustrack, setlevel, stop, unmute]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [6d38663a-1703-46b6-9939-8c1fb9467cf9, 8a9d4b1e3b8af959013b8af9d183000e, bdefadfd-d59f-4d54-82c2-5fbb3ac6965f]
[[capability.battery, capability.polling, capability.refresh]]
DECLARED METHODS
selectButton: 
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(buttonDevice, button, buttonEvent)]
configured: [return (buttonDevice || this.buttonConfigured(1))]
buttonConfigured: [return (((settings[lights_$idx_pushed] || settings[locks_$idx_pushed]) || settings[sonos_$idx_pushed]) || settings[mode_$idx_pushed])]
buttonEvent: [(buttonNumber = evt.data)][(value = evt.value)][(recentEvents = buttonDevice.eventsSince(new java.util.Date((this.now() - 3000))).findAll({ -> ... }))]
executeHandlers: [(lights = this.find(lights, buttonNumber, value))][If (lights != null),,],[(locks = this.find(locks, buttonNumber, value))][If (locks != null),,],[(sonos = this.find(sonos, buttonNumber, value))][If (sonos != null),,],[(mode = this.find(mode, buttonNumber, value))][If (mode != null),,],[(phrase = this.find(phrase, buttonNumber, value))][If (phrase != null),,],
find: [(preferenceName = ((((type + _) + buttonNumber) + _) + value))][(pref = settings[preferenceName])][If (pref != null),,],[return pref]
toggle: [If devices*.currentValue(switch).contains(on),,[If devices*.currentValue(switch).contains(off),,[If devices*.currentValue(lock).contains(locked),,[If devices*.currentValue(lock).contains(unlocked),,],],],],
changeMode: [If ((location.mode != mode) && location.modes?.find({ -> ... })),,],
Starting Points: []
--app-start--
processing talking-alarm-clock.groovy
req caps: [capability.musicplayer, capability.switchlevel, capability.switch, capability.relativehumiditymeasurement, capability.thermostat, capability.temperaturemeasurement]
req cap size: 6
requested commands:[play, heat, auto, nexttrack, restoretrack, resumetrack, setcoolingsetpoint, unmute, emergencyheat, fancirculate, on, setheatingsetpoint, cool, playtrack, mute, setthermostatmode, playtext, pause, off, settrack, previoustrack, setlevel, stop, fanon, setthermostatfanmode, fanauto]
requested attrs:[thermostatfanmode, level, trackdescription, thermostatoperatingstate, mute, thermostatsetpoint, switch, coolingsetpoint, trackdata, thermostatmode, temperature, humidity, heatingsetpoint, status]
called cap-methods by app
setcoolingsetpoint
on
setheatingsetpoint
playtrack
setlevel
called cap-props by app
trackdata
thermostatmode
temperature
humidity
attribute uses through subscriptions
humidity
trackdata
cmd overpriv:[play, heat, auto, nexttrack, restoretrack, resumetrack, unmute, emergencyheat, fancirculate, cool, mute, setthermostatmode, playtext, pause, off, settrack, previoustrack, stop, fanon, setthermostatfanmode, fanauto]
attr overpriv:[thermostatfanmode, level, trackdescription, thermostatoperatingstate, mute, thermostatsetpoint, switch, coolingsetpoint, heatingsetpoint, status]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [6d38663a-1703-46b6-9939-8c1fb9467cf9, 5d3d201d-c4b4-4354-81e9-39d6d728e2c0, 8a9d4b1e3b8af959013b8af9d183000e, ba155665-433d-4e20-9d12-efad7744c3d6, 0e7aa867-9aec-4a24-a372-69014bfa8c24, ba155665-433d-4e20-9d12-efad7744c3d6]
[[capability.refresh]]
DECLARED METHODS
pageMain: 
pageSetupScenarioA: 
pageWeatherSettingsA: 
pageSetupScenarioB: 
pageWeatherSettingsB: 
pageSetupScenarioC: 
pageWeatherSettingsC: 
pageSetupScenarioD: 
pageWeatherSettingsD: 
installed: 
updated: [this.unsubscribe()]
initialize: [If (A_alarmType == 1),,],[If (B_alarmType == 1),,],[If (C_alarmType == 1),,],[If (D_alarmType == 1),,],[If (alarmSummary && summarySonos),[this.subscribe(app, appTouchHandler)],],[If ((((ScenarioNameA && A_timeStart) && A_sonos) && A_alarmOn) && A_alarmType),[If A_musicTrack,,],,],[If ((((ScenarioNameB && B_timeStart) && B_sonos) && B_alarmOn) && B_alarmType),[If B_musicTrack,,],,],[If ((((ScenarioNameC && C_timeStart) && C_sonos) && C_alarmOn) && C_alarmType),[If C_musicTrack,,],,],[If ((((ScenarioNameD && D_timeStart) && D_sonos) && D_alarmOn) && D_alarmType),[If D_musicTrack,,],,],
alarm_A: [If ((A_mode || A_mode.contains(location.mode)) && this.getDayOk(A_day)),[If ((A_switches || A_dimmers) || A_thermostats),[(dimLevel = (java.lang.Integer -> java.lang.Integer) A_level)][If A_thermostats,[(thermostatState = A_thermostats.currentThermostatMode)][If (thermostatState == auto),,[If (thermostatState == heat),,],],,],,],[If A_phrase,,],[If (A_triggerMode && (location.mode != A_triggerMode)),[If location.modes?.find({ -> ... }),,],,],[If A_volume,,],[If ((A_alarmType == 2) || ((A_alarmType == 1) && (A_secondAlarm == 1))),[(state.fullMsgA = )][If A_wakeMsg,,],[If (((A_weatherReport || A_humidity) || A_includeTemp) || A_localTemp),,],[If (A_includeSunrise || A_includeSunset),,],[If (((A_switches || A_dimmers) || A_thermostats) && A_confirmSwitches),,],[If (A_phrase && A_confirmPhrase),,],[If (A_triggerMode && A_confirmMode),,],[(state.soundA = this.textToSpeech(state.fullMsgA, true))],],[If (A_alarmType == 1),[If ((A_secondAlarm == 1) && state.soundAlarmA),[A_sonos.playSoundAndTrack(state.soundAlarmA.uri, state.soundAlarmA.duration, state.soundA.uri)],],[If (((A_secondAlarm == 2) && state.selectedSongA) && state.soundAlarmA),[A_sonos.playSoundAndTrack(state.soundAlarmA.uri, state.soundAlarmA.duration, state.selectedSongA)],],[If A_secondAlarm,[A_sonos.playTrack(state.soundAlarmA.uri)],],,],[If (A_alarmType == 2),[If (A_secondAlarmMusic && state.selectedSongA),[A_sonos.playSoundAndTrack(state.soundA.uri, state.soundA.duration, state.selectedSongA)],[A_sonos.playTrack(state.soundA.uri)]],,],[If (A_alarmType == 3),[A_sonos.playTrack(state.selectedSongA)],],,],
alarm_B: [If ((B_mode || B_mode.contains(location.mode)) && this.getDayOk(B_day)),[If ((B_switches || B_dimmers) || B_thermostats),[(dimLevel = (java.lang.Integer -> java.lang.Integer) B_level)][If B_thermostats,[(thermostatState = B_thermostats.currentThermostatMode)][If (thermostatState == auto),,[If (thermostatState == heat),,],],,],,],[If B_phrase,,],[If (B_triggerMode && (location.mode != B_triggerMode)),[If location.modes?.find({ -> ... }),,],,],[If B_volume,,],[If ((B_alarmType == 2) || ((B_alarmType == 1) && (B_secondAlarm == 1))),[(state.fullMsgB = )][If B_wakeMsg,,],[If (((B_weatherReport || B_humidity) || B_includeTemp) || B_localTemp),,],[If (B_includeSunrise || B_includeSunset),,],[If (((B_switches || B_dimmers) || B_thermostats) && B_confirmSwitches),,],[If (B_phrase && B_confirmPhrase),,],[If (B_triggerMode && B_confirmMode),,],[(state.soundB = this.textToSpeech(state.fullMsgB, true))],],[If (B_alarmType == 1),[If ((B_secondAlarm == 1) && state.soundAlarmB),[B_sonos.playSoundAndTrack(state.soundAlarmB.uri, state.soundAlarmB.duration, state.soundB.uri)],],[If (((B_secondAlarm == 2) && state.selectedSongB) && state.soundAlarmB),[B_sonos.playSoundAndTrack(state.soundAlarmB.uri, state.soundAlarmB.duration, state.selectedSongB)],],[If B_secondAlarm,[B_sonos.playTrack(state.soundAlarmB.uri)],],,],[If (B_alarmType == 2),[If (B_secondAlarmMusic && state.selectedSongB),[B_sonos.playSoundAndTrack(state.soundB.uri, state.soundB.duration, state.selectedSongB)],[B_sonos.playTrack(state.soundB.uri)]],,],[If (B_alarmType == 3),[B_sonos.playTrack(state.selectedSongB)],],,],
alarm_C: [If ((C_mode || C_mode.contains(location.mode)) && this.getDayOk(C_day)),[If ((C_switches || C_dimmers) || C_thermostats),[(dimLevel = (java.lang.Integer -> java.lang.Integer) C_level)][If C_thermostats,[(thermostatState = C_thermostats.currentThermostatMode)][If (thermostatState == auto),,[If (thermostatState == heat),,],],,],,],[If C_phrase,,],[If (C_triggerMode && (location.mode != C_triggerMode)),[If location.modes?.find({ -> ... }),,],,],[If C_volume,,],[If ((C_alarmType == 2) || ((C_alarmType == 1) && (C_secondAlarm == 1))),[(state.fullMsgC = )][If C_wakeMsg,,],[If (((C_weatherReport || C_humidity) || C_includeTemp) || C_localTemp),,],[If (C_includeSunrise || C_includeSunset),,],[If (((C_switches || C_dimmers) || C_thermostats) && C_confirmSwitches),,],[If (C_phrase && C_confirmPhrase),,],[If (C_triggerMode && C_confirmMode),,],[(state.soundC = this.textToSpeech(state.fullMsgC, true))],],[If (C_alarmType == 1),[If ((C_secondAlarm == 1) && state.soundAlarmC),[C_sonos.playSoundAndTrack(state.soundAlarmC.uri, state.soundAlarmC.duration, state.soundC.uri)],],[If (((C_secondAlarm == 2) && state.selectedSongC) && state.soundAlarmC),[C_sonos.playSoundAndTrack(state.soundAlarmC.uri, state.soundAlarmC.duration, state.selectedSongC)],],[If C_secondAlarm,[C_sonos.playTrack(state.soundAlarmC.uri)],],,],[If (C_alarmType == 2),[If (C_secondAlarmMusic && state.selectedSongC),[C_sonos.playSoundAndTrack(state.soundC.uri, state.soundC.duration, state.selectedSongC)],[C_sonos.playTrack(state.soundC.uri)]],,],[If (C_alarmType == 3),[C_sonos.playTrack(state.selectedSongC)],],,],
alarm_D: [If ((D_mode || D_mode.contains(location.mode)) && this.getDayOk(D_day)),[If ((D_switches || D_dimmers) || D_thermostats),[(dimLevel = (java.lang.Integer -> java.lang.Integer) D_level)][If D_thermostats,[(thermostatState = D_thermostats.currentThermostatMode)][If (thermostatState == auto),,[If (thermostatState == heat),,],],,],,],[If D_phrase,,],[If (D_triggerMode && (location.mode != D_triggerMode)),[If location.modes?.find({ -> ... }),,],,],[If D_volume,,],[If ((D_alarmType == 2) || ((D_alarmType == 1) && (D_secondAlarm == 1))),[(state.fullMsgD = )][If D_wakeMsg,,],[If (((D_weatherReport || D_humidity) || D_includeTemp) || D_localTemp),,],[If (D_includeSunrise || D_includeSunset),,],[If (((D_switches || D_dimmers) || D_thermostats) && D_confirmSwitches),,],[If (D_phrase && D_confirmPhrase),,],[If (D_triggerMode && D_confirmMode),,],[(state.soundD = this.textToSpeech(state.fullMsgD, true))],],[If (D_alarmType == 1),[If ((D_secondAlarm == 1) && state.soundAlarmD),[D_sonos.playSoundAndTrack(state.soundAlarmD.uri, state.soundAlarmD.duration, state.soundD.uri)],],[If (((D_secondAlarm == 2) && state.selectedSongD) && state.soundAlarmD),[D_sonos.playSoundAndTrack(state.soundAlarmD.uri, state.soundAlarmD.duration, state.selectedSongD)],],[If D_secondAlarm,[D_sonos.playTrack(state.soundAlarmD.uri)],],,],[If (D_alarmType == 2),[If (D_secondAlarmMusic && state.selectedSongD),[D_sonos.playSoundAndTrack(state.soundD.uri, state.soundD.duration, state.selectedSongD)],[D_sonos.playTrack(state.soundD.uri)]],,],[If (D_alarmType == 3),[D_sonos.playTrack(state.selectedSongD)],],,],
appTouchHandler: [If (summaryMode || summaryMode.contains(location.mode)),[(state.summaryMsg = The following is a summary of the alarm settings. )][(summarySound = this.textToSpeech(state.summaryMsg, true))][If summaryVolume,,],,],
getSummary: [If (alarmOn && scenarioName),[(state.summaryMsg = $state.summaryMsg Alarm $num, $scenarioName, set for $this.parseDate(timeStart, , h:mm a), is enabled. )],[If ((summaryDisabled && alarmOn) && scenarioName),[(state.summaryMsg = $state.summaryMsg Alarm $num, $scenarioName, set for $this.parseDate(timeStart, , h:mm a), is disabled. )],[If (summaryDisabled && scenarioName),[(state.summaryMsg = $state.summaryMsg Alarm $num is not configured. )],],],],
getDesc: [(desc = Tap to set alarm)][If timeStart,[(desc = ((Alarm set to  + this.parseDate(timeStart, , h:mm a)) +  on $sonos))][(dayListSize = (day) ? day.size() : 7)][If (day && (dayListSize < 7)),[(desc = (desc +  on))][For day,[(desc = (desc +  $dayName))][(dayListSize = (dayListSize - 1))][If dayListSize,[(desc = $desc, )],],][(desc = (desc +  on))][For day,[(desc = (desc +  $dayName))][(dayListSize = (dayListSize - 1))][If dayListSize,[(desc = $desc, )],],],[(desc = (desc +  every day))]],[If mode,[(modeListSize = mode.size())][(modePrefix =  in the following modes: )][If (modeListSize == 1),[(modePrefix =  in the following mode: )],],[(desc = (desc + $modePrefix))][For mode,[(desc = (desc + '$modeName'))][(modeListSize = (modeListSize - 1))][If modeListSize,[(desc = $desc, )],[(desc = $desc)]],][(modeListSize = mode.size())][(modePrefix =  in the following modes: )][If (modeListSize == 1),[(modePrefix =  in the following mode: )],],[(desc = (desc + $modePrefix))][For mode,[(desc = (desc + '$modeName'))][(modeListSize = (modeListSize - 1))][If modeListSize,[(desc = $desc, )],[(desc = $desc)]],],[(desc = (desc +  in all modes))]],,],[desc]
greyOut: [(result = (((((scenario && sonos) && alarmTime) && alarmOn) && alarmType)) ? complete : )]
greyOut1: [(result = ((((((param1 || param2) || param3) || param4) || param5) || param6)) ? complete : )]
getWeatherDesc: [(title = ((((((param1 || param2) || param3) || param4) || param5) || param6)) ? Tap to edit weather reporting options : Tap to setup weather reporting options)]
greyOutOption: [(result = (param) ? complete : )]
getTitle: [(title = (scenario) ? scenario : Alarm $num not configured)]
dimmerDesc: [(desc = (dimmer) ? Tap to edit dimmer settings : Tap to set dimmer setting)]
thermostatDesc: [(tempText = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (heating || cooling),[If heating,[(tempText = $heating heat)],],[If cooling,[(tempText = $cooling cool)],],[If (heating && cooling),[(tempText = $heating heat / $cooling cool)],],,[(tempText = Tap to edit thermostat settings)]],[(desc = (thermostat) ? $tempText : Tap to set thermostat settings)][return desc]
getDayOk: [(result = true)][If dayList,[(result = dayList.contains(this.getDay()))],],[result]
getDay: [(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))]
parseDate: [(parseDate = )][If epoch,[(longDate = java.lang.Long.valueOf(epoch).longValue())][(parseDate = new java.util.Date(longDate).format(yyyy-MM-dd'T'HH:mm:ss.SSSZ, location.timeZone))],[(parseDate = date)]],
getSunriseSunset: [If (location.timeZone || zipCode),[(todayDate = new java.util.Date())][(s = this.getSunriseAndSunset([zipcode:zipCode, date:todayDate]))][(riseTime = this.parseDate(, s.sunrise.time, h:mm a))][(setTime = this.parseDate(, s.sunset.time, h:mm a))][(msg = )][(currTime = this.now())][(verb1 = ((currTime >= s.sunrise.time)) ? rose : will rise)][(verb2 = ((currTime >= s.sunset.time)) ? set : will set)][If (includeSunrise && includeSunset),[(msg = The sun $verb1 this morning at $riseTime and $verb2 at $setTime. )],[If (includeSunrise && includeSunset),[(msg = The sun $verb1 this morning at $riseTime. )],[If (includeSunrise && includeSunset),[(msg = The sun $verb2 tonight at $setTime. )],],],],,[(msg = Please set the location of your hub with the SmartThings mobile app, or enter a zip code to receive sunset and sunrise information. )]],
getGreeting: [(day = this.getDay())][(time = this.parseDate(, this.now(), h:mm a))][(month = this.parseDate(, this.now(), MMMM))][(year = this.parseDate(, this.now(), yyyy))][(dayNum = this.parseDate(, this.now(), dd))][(msg = msg.replace(%day%, day))][(msg = msg.replace(%date%, $month $dayNum, $year))][(msg = msg.replace(%time%, $time))][(msg = $msg )]
getWeatherReport: [If (location.timeZone || zipCode),[(isMetric = (location.temperatureScale == C))][(sb = new java.lang.StringBuilder())][If includeTemp,[(current = this.getWeatherFeature(conditions, zipCode))][If isMetric,[(sb << The current temperature is $Math.round(current.current_observation.temp_c) degrees. )],[(sb << The current temperature is $Math.round(current.current_observation.temp_f) degrees. )]],,],[If localTemp,[(sb << The local temperature is $Math.round(localTemp.currentTemperature) degrees. )],],[If humidity,[(sb << The local relative humidity is $humidity.currentValue(humidity)%. )],],[If weatherReport,[(weather = this.getWeatherFeature(forecast, zipCode))][(sb << Today's forecast is )][If isMetric,[(sb << weather.forecast.txt_forecast.forecastday[0].fcttext_metric)],[(sb << weather.forecast.txt_forecast.forecastday[0].fcttext)]],,],[(msg = sb.toString())][(msg = msg.replaceAll(([0-9]+)C, $1 degrees))][(msg = msg.replaceAll(([0-9]+)F, $1 degrees))],[(msg = Please set the location of your hub with the SmartThings mobile app, or enter a zip code to receive weather forecasts.)]],
getOnConfimation: [(msg = )][If ((switches || dimmers) && thermostats),[(msg = All switches)],],[If ((switches && dimmers) && thermostats),[(msg = All Thermostats)],],[If ((switches || dimmers) && thermostats),[(msg = All switches and thermostats)],],[(msg = $msg are now on and set. )]
getPhraseConfirmation: [(msg = The Smart Things Hello Home phrase, $phrase, has been activated. )]
getModeConfirmation: [(msg = The Smart Things mode is now being set to, $mode. )]
compileMsg: [If (scenario == 1),[(state.fullMsgA = (state.fullMsgA + $msg))],],[If (scenario == 2),[(state.fullMsgB = (state.fullMsgB + $msg))],],[If (scenario == 3),[(state.fullMsgC = (state.fullMsgC + $msg))],],[If (scenario == 4),[(state.fullMsgD = (state.fullMsgD + $msg))],],
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
alarmSoundUri: [(soundUri = )][(soundLength = )]
songOptions: [If sonos,[(options = new java.util.LinkedHashSet())][If (scenario == 1),[If state.selectedSongA?.station,[(options << state.selectedSongA.station)],[If state.selectedSongA?.description,[(options << state.selectedSongA.description)],],],,],[If (scenario == 2),[If state.selectedSongB?.station,[(options << state.selectedSongB.station)],[If state.selectedSongB?.description,[(options << state.selectedSongB.description)],],],,],[If (scenario == 3),[If state.selectedSongC?.station,[(options << state.selectedSongC.station)],[If state.selectedSongC?.description,[(options << state.selectedSongC.description)],],],,],[If (scenario == 4),[If state.selectedSongD?.station,[(options << state.selectedSongD.station)],[If state.selectedSongD?.description,[(options << state.selectedSongD.description)],],],,],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))][(java.util.List -> java.util.List <E extends java.lang.Object>) options.take(20)],],
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSong: 
textAppName: [(text = Talking Alarm Clock)]
textVersion: [(text = Version 1.4.5 (06/17/2015))]
textCopyright: [(text = Copyright  2015 Michael Struck)]
textLicense: [(text = ((((((((((Licensed under the Apache License, Version 2.0 (the 'License');  + you may not use this file except in compliance with the License. ) + You may obtain a copy of the License at) + 

) +     http://www.apache.org/licenses/LICENSE-2.0) + 

) + Unless required by applicable law or agreed to in writing, software ) + distributed under the License is distributed on an 'AS IS' BASIS, ) + WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ) + See the License for the specific language governing permissions and ) + limitations under the License.))]
textHelp: [(text = ((((((Within each alarm scenario, choose a Sonos speaker, an alarm time and alarm type along with  + switches, dimmers and thermostat to control when the alarm is triggered. Hello, Home phrases and modes can be triggered at alarm time. ) + You also have the option of setting up different alarm sounds, tracks and a personalized spoken greeting that can include a weather report. ) + Variables that can be used in the voice greeting include %day%, %time% and %date%.

) + From the main SmartApp convenience page, tapping the 'Talking Alarm Clock' icon (if enabled within the app) will ) + speak a summary of the alarms enabled or disabled without having to go into the application itself. This ) + functionality is optional and can be configured from the main setup page.))]
Starting Points: []
IT HAS STATE
--app-start--
processing thermostat-auto-off.groovy
req caps: [capability.contactsensor, capability.thermostat]
req cap size: 2
requested commands:[heat, setheatingsetpoint, auto, cool, setcoolingsetpoint, fanon, setthermostatmode, emergencyheat, fancirculate, off, setthermostatfanmode, fanauto]
requested attrs:[coolingsetpoint, thermostatfanmode, thermostatmode, contact, temperature, heatingsetpoint, thermostatoperatingstate, thermostatsetpoint]
called cap-methods by app
setthermostatmode
off
called cap-props by app
thermostatmode
contact
attribute uses through subscriptions
thermostatmode
contact
cmd overpriv:[heat, setheatingsetpoint, auto, cool, setcoolingsetpoint, fanon, emergencyheat, fancirculate, setthermostatfanmode, fanauto]
attr overpriv:[coolingsetpoint, thermostatfanmode, temperature, heatingsetpoint, thermostatoperatingstate, thermostatsetpoint]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [266374ae-3292-11e2-9c79-22000a1dc790, 8aa8a6b23f769c09013f769ed1c20012]
[[capability.polling]]
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [(state.changed = false)][this.subscribe(sensors, contact, sensorChange)]
sensorChange: [If ((evt.value == open) && state.changed),,[If ((evt.value == closed) && state.changed),[(isOpen = false)][For sensors,[If ((sensor.id != evt.deviceId) && (sensor.currentValue(contact) == open)),[(isOpen = true)],],][(isOpen = false)][For sensors,[If ((sensor.id != evt.deviceId) && (sensor.currentValue(contact) == open)),[(isOpen = true)],],][If isOpen,,],,],],
turnOff: [(state.thermostatMode = thermostat.currentValue(thermostatMode))][(state.changed = true)]
restore: [thermostat.setThermostatMode(state.thermostatMode)][(state.changed = false)]
Starting Points: []
IT HAS STATE
--app-start--
processing tile-multiattribute-videoplayer.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
parse: 
refresh: 
on: 
off: 
setProfile: 
setProfileHD: 
setProfileSDH: 
setProfileSDL: 
start: [(dataLiveVideo = [OutHomeURL:https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/bipbop_4x3_variant.m3u8, InHomeURL:https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/bipbop_4x3_variant.m3u8, ... ])][(event = [name:stream, value:groovy.json.JsonOutput.toJson(dataLiveVideo).toString(), data:groovy.json.JsonOutput.toJson(dataLiveVideo), ... ])]
stop: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-videoplayer.metadata() is applicable for argument types: (tile-multiattribute-videoplayer$_run_closure1) values: [tile-multiattribute-videoplayer$_run_closure1@66d23e4a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing spark.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
on: 
off: 
put: [(apiKey = fb91rfPFS84wmzH3)]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: spark.metadata() is applicable for argument types: (spark$_run_closure1) values: [spark$_run_closure1@72bca894]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing weather-windows.groovy
req caps: [capability.contactsensor, capability.temperaturemeasurement]
req cap size: 2
requested commands:[]
requested attrs:[temperature, contact]
called cap-methods by app
called cap-props by app
temperature
contact
attribute uses through subscriptions
temperature
contact
cmd overpriv:[]
attr overpriv:[]
type2 overprivilege unused caps:
type2 driver combination: [266374ae-3292-11e2-9c79-22000a1dc790, ba155665-433d-4e20-9d12-efad7744c3d6]
[[capability.relativehumiditymeasurement]]
DECLARED METHODS
installed: [this.subscribe(inTemp, temperature, temperatureHandler)]
updated: [this.unsubscribe()][this.subscribe(inTemp, temperature, temperatureHandler)]
temperatureHandler: [(currentOutTemp = null)][If outTemp,[(currentOutTemp = outTemp.latestValue(temperature))],[(currentOutTemp = this.weatherCheck())]],[(currentInTemp = evt.doubleValue)][(openWindows = sensors.findAll({ -> ... }))][(retryPeriodInMinutes = (retryPeriod) ? retryPeriod : 30)][(timeAgo = new java.util.Date((this.now() - ((1000 * 60) * retryPeriodInMinutes).toLong())))][(recentEvents = inTemp.eventsSince(timeAgo))][If ((currentInTemp > minTemp) && (currentInTemp < maxTemp)),,[If (currentInTemp > maxTemp),[(alreadyNotified = (recentEvents.count({ -> ... }) > 1))][If alreadyNotified,[If ((currentOutTemp < maxTemp) && openWindows),,[If ((currentOutTemp > maxTemp) && openWindows),,],],,],,[If (currentInTemp < minTemp),[(alreadyNotified = (recentEvents.count({ -> ... }) > 1))][If alreadyNotified,[If ((currentOutTemp > minTemp) && openWindows),,[If ((currentOutTemp < minTemp) && openWindows),,],],,],,],],],
weatherCheck: [(json = this.getWeatherFeature(conditions, zipCode))][(currentTemp = json?.current_observation?.temp_f)][If currentTemp,[return currentTemp],[return false]],
send: [If (sendPushMessage != No),,],[If phone1,,],
Starting Points: []
--app-start--
processing when-its-going-to-rain.groovy
req caps: [capability.contactsensor]
req cap size: 1
requested commands:[]
requested attrs:[contact]
called cap-methods by app
called cap-props by app
contact
attribute uses through subscriptions
contact
cmd overpriv:[]
attr overpriv:[]
DECLARED METHODS
installed: 
updated: 
scheduleCheck: [(response = this.getWeatherFeature(forecast, zipcode))][If this.isStormy(response),[(open = sensors.findAll({ -> ... }))][If open,[If location.contactBookEnabled,,],,],,],
isStormy: [(STORMY = [rain, snow, showers, sprinkles, precipitation])][(forecast = json?.forecast?.txt_forecast?.forecastday?.first())][If forecast,[(text = forecast?.fcttext?.toLowerCase())][If text,[(result = false)][For ((i = 0); ((i < STORMY.size()) && result); (i++)),[(result = text.contains(STORMY[i]))]][(result = false)][For ((i = 0); ((i < STORMY.size()) && result); (i++)),[(result = text.contains(STORMY[i]))]][return result],[return false]],,[return false]],
Starting Points: []
--app-start--
processing smartweather-station-tile.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: 
installed: 
uninstalled: 
poll: [(obs = this.get(conditions)?.current_observation)][If obs,[(weatherIcon = obs.icon_url.split(/)[-1].split(\.)[0])][If (this.getTemperatureScale() == C),,],[If (obs.local_tz_offset != device.currentValue(timeZoneOffset)),,],[(cityValue = $obs.display_location.city, $obs.display_location.state)][If (cityValue != device.currentValue(city)),,],[(a = this.get(astronomy)?.moon_phase)][(today = this.localDate(GMT$obs.local_tz_offset))][(ltf = new java.text.SimpleDateFormat(yyyy-MM-dd HH:mm))][(utf = new java.text.SimpleDateFormat(yyyy-MM-dd'T'HH:mm:ss.SSS'Z'))][(sunriseDate = ltf.parse($today $a.sunrise.hour:$a.sunrise.minute))][(sunsetDate = ltf.parse($today $a.sunset.hour:$a.sunset.minute))][(tf = new java.text.SimpleDateFormat(h:mm a))][(localSunrise = $tf.format(sunriseDate))][(localSunset = $tf.format(sunsetDate))][(f = this.get(forecast))][(f1 = f?.forecast?.simpleforecast?.forecastday)][If f1,[(icon = f1[0].icon_url.split(/)[-1].split(\.)[0])][(value = (java.lang.String -> java.lang.String) f1[0].pop)],],[(alerts = this.get(alerts)?.alerts)][(newKeys = (alerts?.collect({ -> ... })) ? alerts?.collect({ -> ... }) : [])][(oldKeys = device.currentState(alertKeys)?.jsonValue)][(noneString = no current weather alerts)][If (newKeys && (oldKeys == null)),,[If (newKeys != oldKeys),[If (oldKeys == null),[(oldKeys = [])],],[(newAlerts = false)][If (newAlerts && (device.currentValue(alert) != noneString)),,],,],],,],
refresh: 
configure: 
pad: [(n = ((size - s.size()) / 2))][If (n > 0),[(sb = )][(sb += s)],],
get: 
localDate: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))]
send: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
estimateLux: [(lux = 0)][(now = new java.util.Date().time)][If ((now > sunriseDate.time) && (now < sunsetDate.time)),,[(lux = 10)]],
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: smartweather-station-tile.metadata() is applicable for argument types: (smartweather-station-tile$_run_closure1) values: [smartweather-station-tile$_run_closure1@54e7391d]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing step-notifier.groovy
req caps: [capability.musicplayer, capability.colorcontrol, capability.switch]
req cap size: 3
requested commands:[play, setsaturation, playtrack, mute, playtext, nexttrack, restoretrack, pause, off, settrack, resumetrack, previoustrack, setlevel, stop, sethue, setcolor, unmute, on]
requested attrs:[saturation, trackdata, color, level, trackdescription, hue, mute, status, switch]
Dynamic Method Invocation
type 2 attr uses
goal
steps
called cap-methods by app
playtrack
off
setcolor
on
called cap-props by app
saturation
trackdata
level
hue
switch
attribute uses through subscriptions
saturation
trackdata
goal
level
hue
steps
switch
cmd overpriv:[play, setsaturation, mute, playtext, nexttrack, restoretrack, pause, settrack, resumetrack, previoustrack, setlevel, stop, sethue, unmute]
attr overpriv:[color, trackdescription, mute, status]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [6d38663a-1703-46b6-9939-8c1fb9467cf9, 48b39485-7ebc-4c80-bf6e-9a653a2d1c95, 8a9d4b1e3b8af959013b8af9d183000e]
[[capability.refresh]]
DECLARED METHODS
setupNotifications: 
chooseTrack: 
songOptions: [(options = new java.util.LinkedHashSet())][If state.selectedSong?.station,[(options << state.selectedSong.station)],[If state.selectedSong?.description,[(options << state.selectedSong.description)],],],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))][(java.util.List -> java.util.List <E extends java.lang.Object>) options.take(20)]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSong: 
installed: 
updated: [this.unsubscribe()]
initialize: [(state.lastSteps = 0)][(state.steps = jawbone.currentValue(steps).toInteger())][(state.goal = jawbone.currentValue(goal).toInteger())][this.subscribe(jawbone, goal, goalHandler)][this.subscribe(jawbone, steps, stepHandler)][If song,,],
goalHandler: [(goal = evt.value.toInteger())][(state.goal = goal)]
stepHandler: [(steps = evt.value.toInteger())][(state.lastSteps = state.steps)][(state.steps = steps)][(stepGoal = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (settings.thresholdType == Goal),[(stepGoal = state.goal)],[(stepGoal = settings.threshold)]],[If ((state.lastSteps < stepGoal) && (state.steps >= stepGoal)),[If (settings.notificationType != None),[If location.contactBookEnabled,,[(options = [method:settings.notificationType.toLowerCase(), phone:settings.phone])]],,],[If settings.sonos,,],[If settings.hues,,],[If settings.lights,,],,],
lightsNotification: [(state.previousLights = [:])][(lights.each({ -> ... }){ (state.previousLights[it.id] = it.currentValue(switch)) })][For (1..flashCount),]lightsNotification: [(state.previousLights = [:])][(lights.each({ -> ... }){ (state.previousLights[it.id] = it.currentValue(switch)) })][For (1..flashCount),][(lights.each({ -> ... }){ it.$state.previousLights[it.id]() })]
hueNotification: [(hueColor = 0)][If (color == Blue),[(hueColor = 70)],[If (color == Green),[(hueColor = 39)],[If (color == Yellow),[(hueColor = 25)],[If (color == Orange),[(hueColor = 10)],[If (color == Purple),[(hueColor = 75)],[If (color == Pink),[(hueColor = 83)],],],],],],],[(state.previousHue = [:])][(hues.each({ -> ... }){ (state.previousHue[it.id] = [switch:it.currentValue(switch), level:it.currentValue(level), hue:it.currentValue(hue), saturation:it.currentValue(saturation)]) })][(newValue = [hue:hueColor, saturation:100, level:((java.lang.Integer -> java.lang.Integer) lightLevel) ? (java.lang.Integer -> java.lang.Integer) lightLevel : 100])]
setTimer: 
resetHue: [(settings.hues.each({ -> ... }){ it.setColor(state.previousHue[it.id]) })]
sonosNotification: [If settings.song,[If settings.resumePlaying,[If settings.volume,[sonos.playTrackAndResume(state.selectedSong, settings.songDuration, settings.volume)],[sonos.playTrackAndResume(state.selectedSong, settings.songDuration)]],,[If settings.volume,[sonos.playTrackAtVolume(state.selectedSong, settings.volume)],[sonos.playTrack(state.selectedSong)]],],,],
Starting Points: []
IT HAS STATE
--app-start--
processing speaker-mood-music.groovy
req caps: [capability.motionsensor, capability.musicplayer, capability.contactsensor, capability.switch, capability.button, capability.smokedetector, capability.watersensor, capability.accelerationsensor, capability.presencesensor]
req cap size: 9
requested commands:[play, playtrack, mute, playtext, nexttrack, restoretrack, pause, off, settrack, resumetrack, previoustrack, setlevel, stop, unmute, on]
requested attrs:[motion, level, smoke, trackdescription, mute, water, switch, button, acceleration, trackdata, contact, presence, status]
type 2 attr uses
carbonmonoxide
called cap-methods by app
playtrack
setlevel
stop
called cap-props by app
motion
smoke
water
switch
button
acceleration
trackdata
contact
presence
attribute uses through subscriptions
button
acceleration
trackdata
motion
contact
smoke
presence
carbonmonoxide
water
switch
cmd overpriv:[play, mute, playtext, nexttrack, restoretrack, pause, off, settrack, resumetrack, previoustrack, unmute, on]
attr overpriv:[level, trackdescription, mute, status]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 6d38663a-1703-46b6-9939-8c1fb9467cf9, 266374ae-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, ff20e87b-992b-42b0-9cd6-72b0030dedc3, 26d69a34-ada2-42dc-9e45-445c78ae2619, 1e88cabe-5ba4-4647-9a23-0ad5b887f94b, f730b653-b0b6-483e-8c84-977e240f5eb3, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.refresh, capability.polling]]
DECLARED METHODS
songOptions: [(options = new java.util.LinkedHashSet())][If state.selectedSong?.station,[(options << state.selectedSong.station)],[If state.selectedSong?.description,[(options << state.selectedSong.description)],],],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))][(java.util.List -> java.util.List <E extends java.lang.Object>) options.take(20)]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSong: 
mainPage: 
chooseTrack: 
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes, timeOfDay],[If settings[name],[return true],],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes, timeOfDay],[If settings[name],[return true],],][return false]
ifUnset: [If settings[name],,],
ifSet: [If settings[name],,],
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [log.trace(subscribeToEvents())][this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,,],
eventHandler: [If allOk,[If frequency,[(lastTime = state[this.frequencyKey(evt)])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],
modeChangeHandler: [If (evt.value in triggerModes),,],
scheduledTimeHandler: 
appTouchHandler: 
takeAction: [log.info(Playing '$state.selectedSong)][If (volume != null),,],[sonos.playTrack(state.selectedSong)][If (frequency || oncePerDay),[(state[this.frequencyKey(evt)] = this.now())],],
frequencyKey: [lastActionTimeStamp]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],
oncePerDayOk: [(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)][result]
getAllOk: [((modeOk && daysOk) && timeOk)]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)][result]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)][result]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)][result]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]
timeIntervalLabel: [((starting && ending)) ? ((this.hhmm(starting) + -) + this.hhmm(ending, h:mm a z)) : ]
Starting Points: []
IT HAS STATE
--app-start--
processing wattvision.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
refresh: 
parse: 
setGraphUrl: 
addWattvisionData: [(data = this.parseJson(json.data.toString()))][(units = (json.units) ? json.units : watts)][If (data.size() > 0),[(latestData = data[-1])],],
sendPowerEvent: [(wattvisionDateFormat = parent.wattvisionDateFormat())][(eventData = [date:new java.util.Date().parse(wattvisionDateFormat, time), value:value, name:power, displayed:isLatest, isStateChange:isLatest, ... ])]
parseJson: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: wattvision.metadata() is applicable for argument types: (wattvision$_run_closure1) values: [wattvision$_run_closure1@74d7184a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing unlock-it-when-i-arrive.groovy
req caps: [capability.lock, capability.presencesensor]
req cap size: 2
requested commands:[lock, unlock]
requested attrs:[presence, lock]
called cap-methods by app
unlock
called cap-props by app
presence
lock
attribute uses through subscriptions
presence
cmd overpriv:[lock]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [bdefadfd-d59f-4d54-82c2-5fbb3ac6965f, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.polling, capability.refresh]]
DECLARED METHODS
installed: [this.subscribe(presence1, presence.present, presence)]
updated: [this.unsubscribe()][this.subscribe(presence1, presence.present, presence)]
presence: [(anyLocked = (lock1.count({ -> ... }) != lock1.size()))][If anyLocked,,],
Starting Points: []
--app-start--
processing smart-windows.groovy
req caps: [capability.contactsensor, capability.temperaturemeasurement]
req cap size: 2
requested commands:[]
requested attrs:[temperature, contact]
called cap-methods by app
called cap-props by app
temperature
contact
attribute uses through subscriptions
temperature
contact
cmd overpriv:[]
attr overpriv:[]
type2 overprivilege unused caps:
type2 driver combination: [266374ae-3292-11e2-9c79-22000a1dc790, ba155665-433d-4e20-9d12-efad7744c3d6]
[[capability.relativehumiditymeasurement]]
DECLARED METHODS
installed: [this.subscribe(inTemp, temperature, temperatureHandler)]
updated: [this.unsubscribe()][this.subscribe(inTemp, temperature, temperatureHandler)]
temperatureHandler: [(currentOutTemp = null)][If outTemp,[(currentOutTemp = outTemp.latestValue(temperature))],[(currentOutTemp = this.weatherCheck())]],[(currentInTemp = evt.doubleValue)][(openWindows = sensors.findAll({ -> ... }))][If retryPeriod,[(retryPeriod = 30)],],[(timeAgo = new java.util.Date((this.now() - ((1000 * 60) * retryPeriod).toLong())))][(recentEvents = inTemp.eventsSince(timeAgo))][If ((currentInTemp > minTemp) && (currentInTemp < maxTemp)),,[If (currentInTemp > maxTemp),[(alreadyNotified = (recentEvents.count({ -> ... }) > 1))][If alreadyNotified,[If ((currentOutTemp < maxTemp) && openWindows),,[If ((currentOutTemp > maxTemp) && openWindows),,],],,],,[If (currentInTemp < minTemp),[(alreadyNotified = (recentEvents.count({ -> ... }) > 1))][If alreadyNotified,[If ((currentOutTemp > minTemp) && openWindows),,[If ((currentOutTemp < minTemp) && openWindows),,],],,],,],],],
weatherCheck: [(json = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (location.channelName != samsungtv),[(json = this.getWeatherFeature(conditions, zipCode))],[(json = this.getWeatherFeature(conditions))]],[(currentTemp = json?.current_observation?.temp_f)][If currentTemp,[return currentTemp],[return false]],
send: [If (sendPushMessage != No),,],[If phone1,,],
Starting Points: []
--app-start--
processing speaker-weather-forecast.groovy
req caps: [capability.motionsensor, capability.musicplayer, capability.contactsensor, capability.switch, capability.button, capability.smokedetector, capability.watersensor, capability.accelerationsensor, capability.presencesensor]
req cap size: 9
requested commands:[play, playtrack, mute, playtext, nexttrack, restoretrack, pause, off, settrack, resumetrack, previoustrack, setlevel, stop, unmute, on]
requested attrs:[motion, level, smoke, trackdescription, mute, water, switch, button, acceleration, trackdata, contact, presence, status]
type 2 attr uses
carbonmonoxide
called cap-methods by app
playtrack
called cap-props by app
motion
smoke
water
switch
button
acceleration
trackdata
contact
presence
attribute uses through subscriptions
button
acceleration
trackdata
motion
contact
smoke
presence
carbonmonoxide
water
switch
cmd overpriv:[play, mute, playtext, nexttrack, restoretrack, pause, off, settrack, resumetrack, previoustrack, setlevel, stop, unmute, on]
attr overpriv:[level, trackdescription, mute, status]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 6d38663a-1703-46b6-9939-8c1fb9467cf9, 266374ae-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, ff20e87b-992b-42b0-9cd6-72b0030dedc3, 26d69a34-ada2-42dc-9e45-445c78ae2619, 1e88cabe-5ba4-4647-9a23-0ad5b887f94b, f730b653-b0b6-483e-8c84-977e240f5eb3, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.refresh, capability.switchlevel, capability.polling]]
DECLARED METHODS
mainPage: 
chooseTrack: 
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes],[If settings[name],[return true],],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes],[If settings[name],[return true],],][return false]
ifUnset: [If settings[name],,],
ifSet: [If settings[name],,],
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,,],[If song,,],
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],
modeChangeHandler: [If (evt.value in triggerModes),,],
scheduledTimeHandler: 
appTouchHandler: 
takeAction: [If song,[sonos.playSoundAndTrack(state.sound.uri, state.sound.duration, state.selectedSong, volume)],[If resumePlaying,[sonos.playTrackAndResume(state.sound.uri, state.sound.duration, volume)],[If volume,[sonos.playTrackAtVolume(state.sound.uri, volume)],[sonos.playTrack(state.sound.uri)]],],],[If (frequency || oncePerDay),[(state[this.frequencyKey(evt)] = this.now())],],
songOptions: [(options = new java.util.LinkedHashSet())][If state.selectedSong?.station,[(options << state.selectedSong.station)],[If state.selectedSong?.description,[(options << state.selectedSong.description)],],],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))][(java.util.List -> java.util.List <E extends java.lang.Object>) options.take(20)]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSong: 
frequencyKey: [lastActionTimeStamp]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],[result]
getAllOk: [((modeOk && daysOk) && timeOk)]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)][result]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)][result]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)][result]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]
getTimeLabel: [((starting && ending)) ? ((this.hhmm(starting) + -) + this.hhmm(ending, h:mm a z)) : ]
loadText: [If (location.timeZone || zipCode),[(weather = this.getWeatherFeature(forecast, zipCode))][(current = this.getWeatherFeature(conditions, zipCode))][(isMetric = (location.temperatureScale == C))][(delim = )][(sb = new java.lang.StringBuilder())][(this.list(forecastOptions).sort().each({ java.lang.Object opt -> ... }){ <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> })][(msg = sb.toString())][(msg = msg.replaceAll(([0-9]+)C, $1 degrees))][(state.sound = this.textToSpeech(msg, true))],[(state.sound = this.textToSpeech(Please set the location of your hub with the SmartThings mobile app, or enter a zip code to receive weather forecasts.))]],
list: [[s]]
list: [l]
Starting Points: []
IT HAS STATE
--app-start--
processing speaker-notify-with-sound.groovy
req caps: [capability.motionsensor, capability.musicplayer, capability.contactsensor, capability.switch, capability.button, capability.smokedetector, capability.watersensor, capability.accelerationsensor, capability.presencesensor]
req cap size: 9
requested commands:[play, playtrack, mute, playtext, nexttrack, restoretrack, pause, off, settrack, resumetrack, previoustrack, setlevel, stop, unmute, on]
requested attrs:[motion, level, smoke, trackdescription, mute, water, switch, button, acceleration, trackdata, contact, presence, status]
type 2 attr uses
carbonmonoxide
called cap-methods by app
called cap-props by app
motion
smoke
water
switch
button
acceleration
trackdata
contact
presence
attribute uses through subscriptions
button
acceleration
trackdata
motion
contact
smoke
presence
carbonmonoxide
water
switch
cmd overpriv:[play, playtrack, mute, playtext, nexttrack, restoretrack, pause, off, settrack, resumetrack, previoustrack, setlevel, stop, unmute, on]
attr overpriv:[level, trackdescription, mute, status]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 6d38663a-1703-46b6-9939-8c1fb9467cf9, 266374ae-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, ff20e87b-992b-42b0-9cd6-72b0030dedc3, 26d69a34-ada2-42dc-9e45-445c78ae2619, 1e88cabe-5ba4-4647-9a23-0ad5b887f94b, f730b653-b0b6-483e-8c84-977e240f5eb3, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.refresh, capability.switchlevel, capability.polling]]
DECLARED METHODS
mainPage: 
chooseTrack: 
songOptions: [(options = new java.util.LinkedHashSet())][If state.selectedSong?.station,[(options << state.selectedSong.station)],[If state.selectedSong?.description,[(options << state.selectedSong.description)],],],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))][(java.util.List -> java.util.List <E extends java.lang.Object>) options.take(20)]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSong: 
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes, timeOfDay],[If settings[name],[return true],],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes, timeOfDay],[If settings[name],[return true],],][return false]
ifUnset: [If settings[name],,],
ifSet: [If settings[name],,],
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,,],[If song,,],
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],
modeChangeHandler: [If (evt.value in triggerModes),,],
scheduledTimeHandler: 
appTouchHandler: 
takeAction: [If song,[sonos.playSoundAndTrack(state.sound.uri, state.sound.duration, state.selectedSong, volume)],[If resumePlaying,[sonos.playTrackAndResume(state.sound.uri, state.sound.duration, volume)],[sonos.playTrackAndRestore(state.sound.uri, state.sound.duration, volume)]],],[If (frequency || oncePerDay),[(state[this.frequencyKey(evt)] = this.now())],],
frequencyKey: [lastActionTimeStamp]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],[result]
getAllOk: [((modeOk && daysOk) && timeOk)]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)][result]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)][result]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)][result]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]
getTimeLabel: [((starting && ending)) ? ((this.hhmm(starting) + -) + this.hhmm(ending, h:mm a z)) : ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
loadText: 
Starting Points: []
IT HAS STATE
--app-start--
processing sonos-music-modes.groovy
req caps: [capability.musicplayer]
req cap size: 1
requested commands:[play, playtrack, mute, playtext, nexttrack, restoretrack, pause, settrack, resumetrack, previoustrack, setlevel, stop, unmute]
requested attrs:[trackdescription, trackdata, mute, level, status]
called cap-methods by app
playtrack
setlevel
stop
called cap-props by app
trackdata
attribute uses through subscriptions
trackdata
cmd overpriv:[play, mute, playtext, nexttrack, restoretrack, pause, settrack, resumetrack, previoustrack, unmute]
attr overpriv:[trackdescription, mute, level, status]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [6d38663a-1703-46b6-9939-8c1fb9467cf9]
[[capability.refresh, capability.switch]]
DECLARED METHODS
songOptions: [(options = new java.util.LinkedHashSet())][(options << STOP PLAYING)][If state.selectedSong?.station,[(options << state.selectedSong.station)],[If state.selectedSong?.description,[(options << state.selectedSong.description)],],],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))][(java.util.List -> java.util.List <E extends java.lang.Object>) options.take(20)]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSongs: 
mainPage: 
chooseTrack: 
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [log.trace(subscribeToEvents())][this.subscribe(location, modeChangeHandler)]
modeChangeHandler: [If allOk,[If frequency,[(lastTime = state[this.frequencyKey(evt)])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],
takeAction: [(name = mode_$evt.value.toString())][(selectedSong = state.selectedSongs.$name)][If (selectedSong == PAUSE),,[If (volume != null),,],],[If (frequency || oncePerDay),[(state[this.frequencyKey(evt)] = this.now())],],
frequencyKey: [lastActionTimeStamp]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],
oncePerDayOk: [(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)][result]
getAllOk: [((modeOk && daysOk) && timeOk)]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)][result]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)][result]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)][result]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]
timeIntervalLabel: [((starting && ending)) ? ((this.hhmm(starting) + -) + this.hhmm(ending, h:mm a z)) : ]
Starting Points: []
IT HAS STATE
summary
cmd overpriv:51
attr overpriv:55
num reflection:3
total:70
type2 overprivilege total:41
samename_flags:2
type2 cmd/attr uses:18
numSendSms: 7
numOAuth: 0
numInternet: 2