
--app-start--
processing acceleration-sensor-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(pair = description.split(:))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: acceleration-sensor-capability.metadata() is applicable for argument types: (acceleration-sensor-capability$_run_closure1) values: [acceleration-sensor-capability$_run_closure1@31fa1761]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing arduino-thingshield.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(value = zigbee.parse(description)?.text)][(name = ((value && (value != ping))) ? response : null)][(result = this.createEvent([name:name, value:value]))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: arduino-thingshield.metadata() is applicable for argument types: (arduino-thingshield$_run_closure1) values: [arduino-thingshield$_run_closure1@4310d43]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing big-turn-off.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
off
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[on]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
updated: [this.unsubscribe()][this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
changedLocationMode: 
appTouch: 
Starting Points: []
--app-start--
processing alarm-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
strobe: 
siren: 
both: 
off: 
parse: [(pair = description.split(:))]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: alarm-capability.metadata() is applicable for argument types: (alarm-capability$_run_closure1) values: [alarm-capability$_run_closure1@76a4ebf2]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing bose-soundtouch-control.groovy
req caps: [capability.motionsensor, capability.musicplayer, capability.contactsensor, capability.switch, capability.button, capability.smokedetector, capability.watersensor, capability.accelerationsensor, capability.presencesensor]
req cap size: 9
requested commands:[play, playtrack, mute, playtext, nexttrack, restoretrack, pause, off, settrack, resumetrack, previoustrack, setlevel, stop, unmute, on]
requested attrs:[motion, level, smoke, trackdescription, mute, water, switch, button, acceleration, trackdata, contact, presence, status]
type 2 attr uses
carbonmonoxide
called cap-methods by app
play
nexttrack
pause
off
previoustrack
setlevel
on
called cap-props by app
motion
smoke
water
switch
button
acceleration
contact
presence
attribute uses through subscriptions
button
acceleration
motion
contact
smoke
presence
playpause
carbonmonoxide
water
switch
cmd overpriv:[playtrack, mute, playtext, restoretrack, settrack, resumetrack, stop, unmute]
attr overpriv:[level, trackdescription, mute, trackdata, status]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [26637648-3292-11e2-9c79-22000a1dc790, 6d38663a-1703-46b6-9939-8c1fb9467cf9, 266374ae-3292-11e2-9c79-22000a1dc790, 8a9d4b1e3b8af959013b8af9d183000e, ff20e87b-992b-42b0-9cd6-72b0030dedc3, 26d69a34-ada2-42dc-9e45-445c78ae2619, 1e88cabe-5ba4-4647-9a23-0ad5b887f94b, f730b653-b0b6-483e-8c84-977e240f5eb3, 017a57fa-5f47-4faf-96b3-183eed48ec9e]
[[capability.battery, capability.refresh, capability.polling]]
DECLARED METHODS
mainPage: 
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],[return true],],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],[return true],],][return false]
ifUnset: [If settings[name],,],
ifSet: [If settings[name],,],
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [log.trace(subscribeToEvents())][this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,,],
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],
modeChangeHandler: [If (evt.value in triggerModes),,],
scheduledTimeHandler: 
appTouchHandler: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
takeAction: [(options = [:])][If volume,[(options.delay = 1000)],],
frequencyKey: [lastActionTimeStamp]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],[result]
getAllOk: [((modeOk && daysOk) && timeOk)]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)][result]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)][result]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)][result]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]
timeIntervalLabel: [((starting && ending)) ? ((this.hhmm(starting) + -) + this.hhmm(ending, h:mm a z)) : ]
Starting Points: []
--app-start--
processing big-turn-on.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
on
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
updated: [this.unsubscribe()][this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]
changedLocationMode: 
appTouch: 
Starting Points: []
--app-start--
processing bright-when-dark-and-or-bright-after-sunset.groovy
req caps: [capability.motionsensor, capability.switchlevel, capability.illuminancemeasurement, capability.switch]
req cap size: 4
requested commands:[setlevel, off, on]
requested attrs:[motion, illuminance, level, switch]
called cap-methods by app
setlevel
off
on
called cap-props by app
motion
illuminance
switch
attribute uses through subscriptions
motion
illuminance
switch
cmd overpriv:[]
attr overpriv:[level]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
configurations: 
options: [If ((dark == true) && (sun == true)),,[If ((dark == true) && (sun == false)),,[If ((sun == true) && (dark == false)),,],],],
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(motionSensor, motion, motionHandler)][If ((((lights != null) && (lights != )) && (dimmers != null)) && (dimmers != )),[this.subscribe(lights, switch, lightsHandler)][this.subscribe(dimmers, switch, dimmersHandler)][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[this.subscribe(lightSensor, illuminance, illuminanceHandler, [filterEvents:false])],],[If (sun == true),[this.subscribe(location, position, locationPositionChange)][this.subscribe(location, sunriseTime, sunriseSunsetTimeHandler)][this.subscribe(location, sunsetTime, sunriseSunsetTimeHandler)],[If ((dark != true) && (sun != true)),,],],,[If ((lights != null) && (lights != )),[this.subscribe(lights, switch, lightsHandler)][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[this.subscribe(lightSensor, illuminance, illuminanceHandler, [filterEvents:false])],],[If (sun == true),[this.subscribe(location, position, locationPositionChange)][this.subscribe(location, sunriseTime, sunriseSunsetTimeHandler)][this.subscribe(location, sunsetTime, sunriseSunsetTimeHandler)],[If ((dark != true) && (sun != true)),,],],,[If ((dimmers != null) && (dimmers != )),[this.subscribe(dimmers, switch, dimmersHandler)][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[this.subscribe(lightSensor, illuminance, illuminanceHandler, [filterEvents:false])],],[If (sun == true),[this.subscribe(location, position, locationPositionChange)][this.subscribe(location, sunriseTime, sunriseSunsetTimeHandler)][this.subscribe(location, sunsetTime, sunriseSunsetTimeHandler)],[If ((dark != true) && (sun != true)),,],],,],],],[If ((lights != null) && (lights != )),[If lights.currentValue(switch).toString().contains(on),[(state.lightsState = on)],[If lights.currentValue(switch).toString().contains(off),[(state.lightsState = off)],],],,],[If ((dimmers != null) && (dimmers != )),[If dimmers.currentValue(switch).toString().contains(on),[(state.dimmersState = on)],[If dimmers.currentValue(switch).toString().contains(off),[(state.dimmersState = off)],],],,],
locationPositionChange: 
sunriseSunsetTimeHandler: [(state.lastSunriseSunsetEvent = this.now())]
motionHandler: [If (evt.value == active),[If ((dark == true) && (sun == true)),[If ((darkOk == true) && (sunOk == true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((darkOk == true) && (sunOk != true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((darkOk != true) && (sunOk == true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],],,[If ((dark == true) && (sun != true)),[If (darkOk == true),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],,[If ((dark != true) && (sun == true)),[If (sunOk == true),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],,[If ((dark != true) && (sun != true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],],],,[If (evt.value == inactive),[If ((state.lightsState != off) || (state.dimmersState != off)),[If delayMinutes,[(delay = (delayMinutes * 60))][If ((dark == true) && (sun == true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((dark == true) && (sun != true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((dark != true) && (sun == true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((dark != true) && (sun != true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],],],,],,[If ((state.lightsState == off) && (state.dimmersState == off)),,],],,],],
lightsHandler: [If (evt.value == on),[(state.lightsState = on)],[If (evt.value == off),[(state.lightsState = off)],],],
dimmersHandler: [If (evt.value == on),[(state.dimmersState = on)],[If (evt.value == off),[(state.dimmersState = off)],],],
illuminanceHandler: [If (evt.integerValue > 999),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If (evt.integerValue > (((luxLevel != null) && (luxLevel != ))) ? luxLevel : 50),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],
turnOnLights: [If allOk,[If (state.lightsState != on),[(state.lightsState = on)],],,],
turnOnDimmers: [If allOk,[If (state.dimmersState != on),[(state.dimmersState = on)],],,],
turnOffLights: [If allOk,[If (state.lightsState != off),[(state.lightsState = on)],],,],
turnOffDimmers: [If allOk,[If (state.dimmersState != off),[(state.dimmersState = off)],],,],
astroCheck: [(s = this.getSunriseAndSunset([zipCode:zipCode, sunriseOffset:sunriseOffset, sunsetOffset:sunsetOffset]))][(state.riseTime = s.sunrise.time)][(state.setTime = s.sunset.time)]
getDarkOk: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[(result = (lightSensor.currentIlluminance < (((luxLevel != null) && (luxLevel != ))) ? luxLevel : 50))],],[log.trace(darkOk = $result)][result]
getSunOk: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (sun == true),[(t = this.now())][(result = ((t < state.riseTime) || (t > state.setTime)))],],[log.trace(sunOk = $result)][result]
getSunriseOffset: [(sunriseOffsetValue) ? ((sunriseOffsetDir == Before)) ? -$sunriseOffsetValue : sunriseOffsetValue : null]
getSunsetOffset: [(sunsetOffsetValue) ? ((sunsetOffsetDir == Before)) ? -$sunsetOffsetValue : sunsetOffsetValue : null]
getAllOk: [((modeOk && daysOk) && timeOk)]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)][result]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)][result]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting).time)][(stop = this.timeToday(ending).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)][result]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]
hideOptionsSection: [((((starting || ending) || days) || modes)) ? false : true]
timeIntervalLabel: [((starting && ending)) ? ((this.hhmm(starting) + -) + this.hhmm(ending, h:mm a z)) : ]
Starting Points: []
IT HAS STATE
--app-start--
processing brighten-dark-places.groovy
req caps: [capability.contactsensor, capability.illuminancemeasurement, capability.switch]
req cap size: 3
requested commands:[off, on]
requested attrs:[illuminance, contact, switch]
called cap-methods by app
on
called cap-props by app
illuminance
contact
attribute uses through subscriptions
contact
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(contact1, contact.open, contactOpenHandler)]
updated: [this.unsubscribe()][this.subscribe(contact1, contact.open, contactOpenHandler)]
contactOpenHandler: [(lightSensorState = luminance1.currentIlluminance)][If ((lightSensorState != null) && (lightSensorState < 10)),,],
Starting Points: []
--app-start--
processing child-button.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: child-button.metadata() is applicable for argument types: (child-button$_run_closure1) values: [child-button$_run_closure1@70ed52de]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing button-capability.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(results = [])][If description.startsWith(Err),[(results = this.createEvent([descriptionText:description, displayed:true]))],[(cmd = zwave.parse(description, [43:1, 128:1, 132:1]))][If cmd,[(results += this.zwaveEvent(cmd))],],[If results,[(results = [descriptionText:cmd, displayed:false])],],],
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: button-capability.metadata() is applicable for argument types: (button-capability$_run_closure1) values: [button-capability$_run_closure1@6d60fe40]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing centralite-thermostat.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(result = [])][(descMap = zigbee.parseDescriptionAsMap(description))][(attrData = [[cluster:descMap.cluster, attrId:descMap.attrId, value:descMap.value]])]
getModeMap: 
getFanModeMap: 
refresh: 
getTemperature: [If (value != null),[(celsius = (java.lang.Integer.parseInt(value, 16) / 100))][If (this.getTemperatureScale() == C),,],,],
setHeatingSetpoint: [If (degrees != null),[(temperatureScale = this.getTemperatureScale())][(degreesInteger = java.lang.Math.round(degrees))][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))],],
setCoolingSetpoint: [If (degrees != null),[(degreesInteger = java.lang.Math.round(degrees))][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))],],
modes: 
setThermostatMode: [(currentMode = device.currentState(thermostatMode)?.value)][(modeOrder = this.modes())][(index = modeOrder.indexOf(currentMode))][(next = (((index >= 0) && (index < (modeOrder.size() - 1)))) ? modeOrder[(index + 1)] : modeOrder[0])]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
setThermostatFanMode: [(currentFanMode = device.currentState(thermostatFanMode)?.value)][(returnCommand = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)]
setThermostatMode: 
setThermostatFanMode: 
off: 
cool: 
heat: 
emergencyHeat: 
on: 
fanOn: 
auto: 
fanAuto: 
configure: 
hex: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: centralite-thermostat.metadata() is applicable for argument types: (centralite-thermostat$_run_closure1) values: [centralite-thermostat$_run_closure1@536f2a7e]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing cameras-on-when-im-away.groovy
req caps: [capability.switch, capability.presencesensor]
req cap size: 2
requested commands:[off, on]
requested attrs:[presence, switch]
called cap-methods by app
off
on
called cap-props by app
presence
attribute uses through subscriptions
presence
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(people, presence, presence)]
updated: [this.unsubscribe()][this.subscribe(people, presence, presence)]
presence: [If (evt.value == not present),[If this.everyoneIsAway(),,],,[If this.everyoneIsAway(),,],],
turnOff: 
turnOn: 
everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],]everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],][return result]
Starting Points: []
--app-start--
processing camera-power-scheduler.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
off
on
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: 
updated: 
initialize: [If startTime,,],[If endTime,,],
turnOnCamera: 
turnOffCamera: 
Starting Points: []
--app-start--
processing brighten-my-path.groovy
req caps: [capability.motionsensor, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[motion, switch]
called cap-methods by app
on
called cap-props by app
motion
attribute uses through subscriptions
motion
cmd overpriv:[off]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(motion1, motion.active, motionActiveHandler)]
updated: [this.unsubscribe()][this.subscribe(motion1, motion.active, motionActiveHandler)]
motionActiveHandler: 
Starting Points: []
--app-start--
processing co2-vent.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
off
on
called cap-props by app
attribute uses through subscriptions
carbondioxide
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [(state.active = false)][this.subscribe(sensor, carbonDioxide, handleLevel)]
handleLevel: [(co2 = sensor.currentValue(carbonDioxide).toInteger())][If ((co2 >= settings.level) && state.active),[switches.each({ -> ... }){ it.on() }][(state.active = true)],[If ((co2 < settings.level) && state.active),[(state.active = false)][switches.each({ -> ... }){ it.off() }],],],
Starting Points: []
IT HAS STATE
--app-start--
processing coopboss-h3vx.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
parse: [(map = [:])][If description?.startsWith(catchall:),[(map = this.parseCatchAllMessage(description))],[If description?.startsWith(read attr -),[(map = this.parseReportAttributeMessage(description))],[If (description?.startsWith(temperature: ) || description?.startsWith(humidity: )),[(map = this.parseCustomMessage(description))],],],],
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseCatchAllMessage: [(resultMap = [:])][(cluster = zigbee.parse(description))][If (cluster.clusterId == 1026),,],[If ((cluster.clusterId == 257) && (cluster.command == 11)),,],
parseReportAttributeMessage: [(resultMap = [:])][(descMap = this.parseDescriptionAsMap(description))][If ((descMap.cluster == 0101) && (descMap.attrId == 0003)),[(resultMap.name = doorState)][If (descMap.value == 00),[(resultMap.value = unknown)],[If (descMap.value == 01),[(resultMap.value = closed)],[If (descMap.value == 02),[(resultMap.value = open)],[If (descMap.value == 03),[(resultMap.value = jammed)],[If (descMap.value == 04),[(resultMap.value = forced close)],[If (descMap.value == 05),[(resultMap.value = forced close)],[If (descMap.value == 06),[(resultMap.value = closing)],[If (descMap.value == 07),[(resultMap.value = opening)],[If (descMap.value == 08),[(resultMap.value = fault)],[(resultMap.value = unknown)]],],],],],],],],],[(resultMap.descriptionText = Door State Changed to $resultMap.value)],[If ((descMap.cluster == 0101) && (descMap.attrId == 0400)),[(resultMap.name = currentLightLevel)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.displayed = false)],[If ((descMap.cluster == 0101) && (descMap.attrId == 0401)),[(resultMap.name = closeLightLevel)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0402)),[(resultMap.name = openLightLevel)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0403)),[(resultMap.name = autoCloseEnable)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 0404)),[(resultMap.name = autoOpenEnable)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 0405)),[(resultMap.name = doorCurrent)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.value = (resultMap.value * 0.001))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0408)),[(resultMap.name = doorSensitivity)][(resultMap.value = (100 - java.lang.Integer.parseInt(descMap.value, 16)))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0409)),[(resultMap.name = baseDoorCurrent)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.value = (resultMap.value * 0.001))],[If ((descMap.cluster == 0101) && (descMap.attrId == 040a)),[(resultMap.name = doorVoltage)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.value = (resultMap.value * 0.001))],[If ((descMap.cluster == 0101) && (descMap.attrId == 040b)),[(resultMap.name = Aux1)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 040c)),[(resultMap.name = Aux2)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 040d)),[(resultMap.name = photoCalibration)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],[If ((descMap.cluster == 0101) && (descMap.attrId == 040e)),[(resultMap.name = baseCurrentNE)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],],],],],],],],],],],],],],],
parseCustomMessage: [(resultMap = [:])][If description?.startsWith(temperature: ),[(resultMap.name = temperature)][(rawT = (description - temperature: ).trim())][(resultMap.descriptionText = Temperature celsius value = $rawT)][(rawTint = java.lang.Float.parseFloat(rawT))][If (rawTint > 65),[(resultMap.name = null)][(resultMap.value = null)][(resultMap.descriptionText = Temperature celsius value = $rawT is invalid not updating)][log.warn(Invalid temperature value detected! rawT = $rawT, description = $description)],[If (rawT == -32768),[(resultMap.value = ERR)],[(resultMap.value = (java.lang.Float -> java.lang.Float) this.celsiusToFahrenheit(rawT.toFloat()))]],],,],[(resultMap.displayed = false)][log.info(Temperature reported = $resultMap.value)]
parseDescriptionAsMap: 
getFahrenheit: [(celsius = java.lang.Integer.parseInt(value, 16))]
callUpdateStatusTxt: [(cTemp = device.currentState(TempProb1)?.value)][(cLight = 0)][(testNull = device.currentState(currentLightLevel)?.value)][If (testNull != null),[(cLight = (int) device.currentState(currentLightLevel)?.value)],],
updateStatusTxt: [(cTmp = currentTemp)][(cLL = 10)][(oLL = 10)][(testNull = device.currentState(closeLightLevel)?.value)][If (testNull != null),[(cLL = (int) device.currentState(closeLightLevel)?.value)],],[(testNull = device.currentState(openLightLevel)?.value)][If (testNull != null),[(oLL = (int) device.currentState(openLightLevel)?.value)],],[(aOpnEn = device.currentState(autoOpenEnable)?.value)][(aClsEn = device.currentState(autoCloseEnable)?.value)][If (currentLight < cLL),[If (aOpnEn == on),,],,[If (aClsEn == on),,],],
on: 
off: 
close: 
open: 
Aux1On: 
Aux1Off: 
Aux2On: 
Aux2Off: 
openDoor: 
closeDoor: 
closeDoorHiI: 
autoOpenOn: 
autoOpenOff: 
autoCloseOn: 
autoCloseOff: 
setOpenLevelTo: [(cX = cValue)][(cmd = [])]
setCloseLevelTo: [(cX = cValue)][(cmd = [])]
setSensitivityLevel: [(cX = (100 - cValue))][(cmd = [])]
setNewBaseCurrent: [(cX = (int) cValue)][log.info(Setting new BaseCurrent to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]
setNewPhotoCalibration: [(cX = (int) cValue)][log.info(Setting new Photoresister calibration to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]
readNewPhotoCalibration: [(cmd = [])]
readBaseCurrentNE: [(cmd = [])]
setBaseCurrentNE: [(cX = (int) cValue)][log.info(Setting new base Current Never Exceed to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]
poll: [(cmd = [])]
updateTemp1: [(cmd = [])]
updateTemp2: [(cmd = [])]
updateSun: [(cmd = [])]
updateSensitivity: [(cmd = [])]
updateCloseLightLevel: [(cmd = [])]
updateOpenLightLevel: [(cmd = [])]
refresh: [(cmd = [])]
configure: [(cmd = [])]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: coopboss-h3vx.metadata() is applicable for argument types: (coopboss-h3vx$_run_closure1) values: [coopboss-h3vx$_run_closure1@1b1cfb87]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing hue-white-ambiance-bulb.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
initialize: 
installed: 
updated: 
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],
on: 
off: 
setLevel: [If (((percent != null) && (percent >= 0)) && (percent <= 100)),,],
setColorTemperature: [If value,,],
refresh: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: hue-white-ambiance-bulb.metadata() is applicable for argument types: (hue-white-ambiance-bulb$_run_closure1) values: [hue-white-ambiance-bulb$_run_closure1@7eecb5b8]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing garage-door-opener.groovy
subscribeToCommand
subscribeToCommand
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
off
on
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(app, appTouchHandler)][this.subscribeToCommand(switch1, on, onCommand)]
updated: [this.unsubscribe()][this.subscribe(app, appTouchHandler)][this.subscribeToCommand(switch1, on, onCommand)]
appTouch: 
onCommand: 
Starting Points: []
--app-start--
processing energy-saver.groovy
req caps: [capability.powermeter, capability.switch]
req cap size: 2
requested commands:[off, on]
requested attrs:[switch, power]
called cap-methods by app
off
called cap-props by app
power
attribute uses through subscriptions
power
cmd overpriv:[on]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, b100c5ad-6d43-4adf-89f9-4109995e059d]
[[capability.refresh]]
DECLARED METHODS
installed: 
updated: [this.unsubscribe()]
initialize: [this.subscribe(meter, power, meterHandler)]
meterHandler: [(meterValue = (double) evt.value)][(thresholdValue = (int) threshold)][If (meterValue > thresholdValue),,],
Starting Points: []
--app-start--
processing curling-iron.groovy
req caps: [capability.motionsensor, capability.switch, capability.presencesensor]
req cap size: 3
requested commands:[off, on]
requested attrs:[motion, presence, switch]
called cap-methods by app
off
on
called cap-props by app
motion
presence
attribute uses through subscriptions
motion
presence
cmd overpriv:[]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribeToEvents()]
updated: [this.unsubscribe()][this.subscribeToEvents()]
subscribeToEvents: [this.subscribe(motionSensors, motion.active, motionActive)][this.subscribe(motionSensors, motion.inactive, motionInactive)][this.subscribe(presenceSensors, presence.not present, notPresent)]
motionActive: [If this.anyHere(),,],
motionInactive: [If this.allQuiet(),,],
notPresent: [If this.anyHere(),,],
allQuiet: [(result = true)][For motionSensors,[If (it.currentMotion == active),[(result = false)][(result = false)],],]allQuiet: [(result = true)][For motionSensors,[If (it.currentMotion == active),[(result = false)][(result = false)],],][return result]
anyHere: [(result = true)][For presenceSensors,[If (it.currentPresence == not present),[(result = false)][(result = false)],],]anyHere: [(result = true)][For presenceSensors,[If (it.currentPresence == not present),[(result = false)][(result = false)],],][return result]
outletsOn: 
outletsOff: [(delay = (minutes * 60))]
scheduledTurnOff: 
Starting Points: []
--app-start--
processing good-night-house.groovy
req caps: [capability.lock, capability.switch]
req cap size: 2
requested commands:[lock, unlock, off, on]
requested attrs:[lock, switch]
called cap-methods by app
lock
off
on
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[unlock]
attr overpriv:[lock, switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e, bdefadfd-d59f-4d54-82c2-5fbb3ac6965f]
[[capability.battery, capability.polling, capability.refresh]]
DECLARED METHODS
installed: [this.subscribe(app, appTouch)]
updated: [this.unsubscribe()][this.subscribe(app, appTouch)]
appTouch: [If (location.mode != newMode),,],[(delay = (((waitfor != null) && (waitfor != ))) ? (waitfor * 1000) : 120000)]
Starting Points: []
--app-start--
processing every-element.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
called cap-props by app
attribute uses through subscriptions
cmd overpriv:[off, on]
attr overpriv:[switch]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
type2 overprivilege unused caps:
type2 driver combination: [8a9d4b1e3b8af959013b8af9d183000e]
[[capability.switch]]
DECLARED METHODS
firstPage: 
inputPage: 
inputBooleanPage: 
inputIconPage: 
inputImagePage: 
optionsGroup: [(group = [values:[], order:groups.size()])][(group.title = (title) ? title : )][(groups << group)][return groups]
addValues: [(lastGroup = groups[-1])][(lastGroup[values] << [key:key, value:value, order:lastGroup[values].size()])][return groups]
listToMap: 
addGroup: [If (values instanceof java.util.List),[(values = this.listToMap(values))],],[return groups]
addGroup: 
inputSelectionPage: [(englishOptions = [One, Two, Three])][(spanishOptions = [Uno, Dos, Tres])][(groupedOptions = [])]
inputTextPage: 
inputTimePage: 
inputDevicePage: 
inputCapabilityPage: 
inputRoomPage: 
inputModePage: 
inputHubPage: 
inputContactBookPage: 
appPage: 
labelPage: 
modePage: 
paragraphPage: 
hrefPage: 
buttonsPage: 
imagePage: 
videoPage: 
flattenedPage: [(allSections = [])][this.firstPage().sections[0].body.each({ java.lang.Object hrefElement -> ... }){ <not implemented yet for class: org.codehaus.groovy.ast.stmt.IfStatement> }][this.inputPage().sections.each({ java.lang.Object section -> ... }){ section.body.each({ java.lang.Object hrefElement -> ... }) }][(flattenedPage = this.dynamicPage([name:flattenedPage, title:All elements in one page!], { -> ... }))][(flattenedPage.sections = allSections)][return flattenedPage]
foo: 
installed: 
updated: [this.unsubscribe()]
initialize: 
Starting Points: []
--app-start--
processing feed-my-pet.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
installed: 
updated: 
scheduleCheck: 
Starting Points: []
--app-start--
processing double-tap.groovy
req caps: [capability.switch]
req cap size: 1
requested commands:[off, on]
requested attrs:[switch]
called cap-methods by app
called cap-props by app
switch
attribute uses through subscriptions
switch
cmd overpriv:[off, on]
attr overpriv:[]
^^^^^^^^-OVERPRIVILEGED-^^^^^^^
DECLARED METHODS
installed: [this.subscribe(master, switch, switchHandler, [filterEvents:false])]
updated: [this.unsubscribe()][this.subscribe(master, switch, switchHandler, [filterEvents:false])]
switchHandler: [(recentStates = master.eventsSince(new java.util.Date((this.now() - 4000)), [all:true, max:10]).findAll({ -> ... }))][If evt.physical,[If ((evt.value == on) && this.lastTwoStatesWere(on, recentStates, evt)),,[If ((evt.value == off) && this.lastTwoStatesWere(off, recentStates, evt)),,],],,],
onSwitches: [(switches + onSwitches).findAll({ -> ... }){ it }]
offSwitches: [(switches + offSwitches).findAll({ -> ... }){ it }]
lastTwoStatesWere: [(result = false)][If states,[(onOff = states.findAll({ -> ... }))][If onOff[0].date.before(evt.date),[log.warn(Last state does not reflect current event, evt.date: $evt.dateCreated, state.date: $onOff[0].dateCreated)][(result = ((evt.value == value) && (onOff[0].value == value)))],[(result = (((onOff.size() > 1) && (onOff[0].value == value)) && (onOff[1].value == value)))]],,],[result]
Starting Points: []
IT HAS STATE
--app-start--
processing device-tile-controller.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
defaultPage: 
installed: 
uninstalled: 
updated: [this.unsubscribe()]
initializeDevices: 
labelMap: 
Starting Points: []
--app-start--
processing ecobee-sensor.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
refresh: 
poll: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: ecobee-sensor.metadata() is applicable for argument types: (ecobee-sensor$_run_closure1) values: [ecobee-sensor$_run_closure1@1a5b6f42]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing fidure-thermostat.groovy
req caps: []
req cap size: 0
requested commands:[]
requested attrs:[]
DECLARED METHODS
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
getMin: 
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
getMax: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parse: [(result = [])][If description?.startsWith(read attr -),[(descMap = this.parseDescriptionAsMap(description))][For descMap.attrs,[(map = [:])][If (descMap.cluster == 0201),,[If (descMap.cluster == 0204),[If (atMap.attrId == 0001),[(map.name = lockLevel)][(map.value = this.getLockMap()[atMap.value])],],,],],[If map,[(result += this.createEvent(map))],],][(descMap = this.parseDescriptionAsMap(description))][For descMap.attrs,[(map = [:])][If (descMap.cluster == 0201),,[If (descMap.cluster == 0204),[If (atMap.attrId == 0001),[(map.name = lockLevel)][(map.value = this.getLockMap()[atMap.value])],],,],],[If map,[(result += this.createEvent(map))],],],],
parseDescriptionAsMap: [(map = (description - read attr - ).split(,).inject([:], { java.lang.Object map, java.lang.Object param -> ... }))][(attrId = map.get(attrId))][(encoding = map.get(encoding))][(value = map.get(value))][(result = map.get(result))][(list = [])][If (this.getDataLengthByType(map.get(encoding)) < map.get(value).length()),[(raw = map.get(raw))][(size = java.lang.Long.parseLong(( + map.get(size)), 16))][(index = 12)][(len = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While ((index - 12) < size),[(attrId = this.flipHexStringEndianness(raw[(index..(index + 3))]))][(index += 4)][If (result == success),[(index += 2)],],[(encoding = raw[(index..(index + 1))])][(index += 2)][(len = this.getDataLengthByType(encoding))][(value = this.flipHexStringEndianness(raw[(index..((index + len) - 1))]))][(index += len)][(list += [attrId:$attrId, encoding:$encoding, value:$value])]][(raw = map.get(raw))][(size = java.lang.Long.parseLong(( + map.get(size)), 16))][(index = 12)][(len = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While ((index - 12) < size),[(attrId = this.flipHexStringEndianness(raw[(index..(index + 3))]))][(index += 4)][If (result == success),[(index += 2)],],[(encoding = raw[(index..(index + 1))])][(index += 2)][(len = this.getDataLengthByType(encoding))][(value = this.flipHexStringEndianness(raw[(index..((index + len) - 1))]))][(index += len)][(list += [attrId:$attrId, encoding:$encoding, value:$value])]],[(list += [attrId:$attrId, encoding:$encoding, value:$value])]],[(map += [attrs:list])]
flipHexStringEndianness: [(s = s.reverse())][(sb = new java.lang.StringBuilder())][For ((i = 0); (i < (s.length() - 1)); (i += 2)),]flipHexStringEndianness: [(s = s.reverse())][(sb = new java.lang.StringBuilder())][For ((i = 0); (i < (s.length() - 1)); (i += 2)),]
getDataLengthByType: [(map = [08:1, 09:2, 0a:3, 0b:4, 0c:5, 0d:6, 0e:7, 0f:8, 10:1, 18:1, 19:2, 1a:3, 1b:4, 1c:5, 1d:6, 1e:7, 1f:8, 20:1, 21:2, 22:3, 23:4, ... ])]
getProgrammingMap: 
getModeMap: 
getFanModeMap: 
getHoldMap: 
updateSetpoint: [(cool = device.currentState(coolingSetpoint)?.value)][(heat = device.currentState(heatingSetpoint)?.value)][(runningMode = device.currentState(runningMode)?.value)][(mode = device.currentState(thermostatMode)?.value)][(value = --)][If ((heat == mode) && (heat != null)),[(value = heat)],[If ((cool == mode) && (cool != null)),[(value = cool)],[If (((auto == mode) && (runningMode == cool)) && (cool != null)),[(value = cool)],[If (((auto == mode) && (runningMode == heat)) && (heat != null)),[(value = heat)],],],],],
raiseSetpoint: 
lowerSetpoint: 
adjustSetpoint: [(runningMode = device.currentState(runningMode)?.value)][(mode = device.currentState(thermostatMode)?.value)][(modeData = 2)][If ((heat == mode) || (heat == runningMode)),[(modeData = 00)],[If ((cool == mode) || (cool == runningMode)),[(modeData = 01)],],],[(amountData = java.lang.String.format(%02X, value)[(-2..-1)])]
getDisplayTemperature: [(t = java.lang.Integer.parseInt($value, 16))][If (this.getTemperatureScale() == C),[(t = ((java.lang.Integer -> java.lang.Integer) ((t + 4) / 10) / 10))],[(t = ((java.lang.Integer -> java.lang.Integer) (10 * this.celsiusToFahrenheit((t / 100))) / 10))]],
updateHoldLabel: [(currentHold = (device?.currentState(setpointHold)?.value) ? device?.currentState(setpointHold)?.value : ...)][(holdExp = device?.currentState(holdExpiary)?.value)][(holdExp = (holdExp) ? holdExp : $new Date().getTime())][If (Hold == attr),[(currentHold = value)],],[If (HoldExp == attr),[(holdExp = value)],],[(past = (new java.util.Date(holdExp.toLong()).getTime() < new java.util.Date().getTime()))][If (HoldExp == attr),[If past,[(currentHold = On)],[(currentHold = Off)]],,],[(holdString = ((currentHold == On)) ? (past) ? Is On : Ends $this.compareWithNow(holdExp.toLong()) : ((currentHold == Off)) ?  is Off :  ...)]
getSetPointHoldDuration: [(holdTime = 0)][If settings.hold_time?.contains(Hours),[(holdTime = java.lang.Integer.parseInt(settings.hold_time[(0..1)].trim()))],[If settings.hold_time?.contains(Day),[(holdTime = (java.lang.Integer.parseInt(settings.hold_time[(0..1)].trim()) * 24))],],],[(currentHoldDuration = device.currentState(setpointHoldDuration)?.value)][If (java.lang.Short.parseShort((0 + (currentHoldDuration) ? currentHoldDuration : 0)) != (holdTime * 60)),,],
Hold: [(currentHold = device.currentState(setpointHold)?.value)][(next = ((currentHold == On)) ? 00 : 01)][(nextHold = this.getHoldMap()[next])]
compareWithNow: [(mins = (new java.util.Date(d).getTime() - new java.util.Date().getTime()))][(mins /= (1000 * 60))][(past = (mins < 0))][(ret = (past) ?  : in )][If past,[(mins *= -1)],],[(t = 0)][If (mins < 60),[(ret += (((java.lang.Integer -> java.lang.Integer) mins +  min) + ((mins > 1)) ? s : ))],[If (mins < 1440),[(t = ((java.lang.Integer -> java.lang.Integer) java.lang.Math.round(((14 + mins) / 30)) / 2))][(ret += ((t +  hr) + ((t > 1)) ? s : ))],[(t = ((java.lang.Integer -> java.lang.Integer) java.lang.Math.round(((359 + mins) / 720)) / 2))][(ret += ((t +  day) + ((t > 1)) ? s : ))]],],[(ret += (past) ?  ago : )]
convertToTime: [(time = (long) java.lang.Integer.parseInt($data, 16))][(time *= 1000)][(time += 946684800000)][(time -= (location.timeZone.getRawOffset() + location.timeZone.getDSTSavings()))][(d = new java.util.Date(time))]
Program: [(currentSched = device.currentState(prorgammingOperation)?.value)][(next = java.lang.Integer.parseInt((currentSched) ? currentSched : 00, 16))][If ((next & 1) == 1),[(next = (next & 254))],[(next = (next | 1))]],[(nextSched = this.getProgrammingMap()[(next & 1)])]
getThermostatOperatingState: [(m = [heating, cooling, fan, Heat2, Cool2, Fan2, Fan3])][(desc = idle)][(value = java.lang.Integer.parseInt(( + value), 16))][For (0..2),[If (value & (1 << i)),[(desc = m[i])],],]getThermostatOperatingState: [(m = [heating, cooling, fan, Heat2, Cool2, Fan2, Fan3])][(desc = idle)][(value = java.lang.Integer.parseInt(( + value), 16))][For (0..2),[If (value & (1 << i)),[(desc = m[i])],],]
checkLastTimeSync: [(lastSync = device.currentState(lastTimeSync)?.value)][If lastSync,[(lastSync = $new Date(0))],],[If (settings.sync_clock) ? settings.sync_clock : (false && (lastSync != new java.util.Date(0))),,],[(duration = (new java.util.Date().getTime() - new java.util.Date(lastSync).getTime()))][If (duration > 86400000),,],
readAttributesCommand: [(attrString = )][For attribList,[(attrString += (  + java.lang.String.format(%02X %02X, (val & 255), ((val >> 8) & 255))))]]readAttributesCommand: [(attrString = )][For attribList,[(attrString += (  + java.lang.String.format(%02X %02X, (val & 255), ((val >> 8) & 255))))]]
refresh: 
poll: 
getTemperature: [(celsius = (java.lang.Integer.parseInt($value, 16) / 100))][If (this.getTemperatureScale() == C),,],
setHeatingSetpoint: [(temperatureScale = this.getTemperatureScale())][(degreesInteger = (java.lang.Integer -> java.lang.Integer) degrees)][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))]
setCoolingSetpoint: [(degreesInteger = (java.lang.Integer -> java.lang.Integer) degrees)][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))]
modes: 
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
setThermostatFanMode: [(currentFanMode = device.currentState(thermostatFanMode)?.value)][(returnCommand = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)]
setThermostatMode: [(currentMode = device.currentState(thermostatMode)?.value)][(modeOrder = this.modes())][(index = modeOrder.indexOf(currentMode))][(next = (((index >= 0) && (index < (modeOrder.size() - 1)))) ? modeOrder[(index + 1)] : modeOrder[0])]
setThermostatMode: [(val = (this.getModeMap().find({ -> ... })?.key) ? this.getModeMap().find({ -> ... })?.key : 00)]
setThermostatFanMode: 
off: 
cool: 
heat: 
auto: 
on: 
fanOn: 
fanAuto: 
updated: [(lastSync = device.currentState(lastTimeSync)?.value)][If ((settings.sync_clock) ? settings.sync_clock : false == false),,],
getLockMap: 
lock: [(currentLock = device.currentState(lockLevel)?.value)][(val = this.getLockMap().find({ -> ... })?.key)][If (val == 00),[(val = this.getLockMap().find({ -> ... })?.key)],[(val = 00)]],
setThermostatTime: [If (settings.sync_clock) ? settings.sync_clock : false,,],[(date = new java.util.Date())][(zone = ((location.timeZone.getRawOffset() +  DST ) + location.timeZone.getDSTSavings()))][(millis = date.getTime())][(millis -= 946684800000)][(millis += (location.timeZone.getRawOffset() + location.timeZone.getDSTSavings()))][(millis /= 1000)][(s = java.lang.String.format(%08X, millis))][(data = (((((((  + s.substring(6, 8)) +  ) + s.substring(4, 6)) +  ) + s.substring(2, 4)) +  ) + s.substring(0, 2)))]
configure: 
hex: 
getEndpointId: 
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: fidure-thermostat.metadata() is applicable for argument types: (fidure-thermostat$_run_closure1) values: [fidure-thermostat$_run_closure1@62656be4]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing hall-light-welcome-home.groovy