
--app-start--
processing .app_test.swp
--app-start--
processing acceleration-sensor-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: acceleration-sensor-capability.metadata() is applicable for argument types: (acceleration-sensor-capability$_run_closure1) values: [acceleration-sensor-capability$_run_closure1@57d7f8ca]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing alarm-capability.groovy
DECLARED METHODS
strobe: ]
siren: ]
both: ]
off: ]
parse: [(pair = description.split(:))]]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: alarm-capability.metadata() is applicable for argument types: (alarm-capability$_run_closure1) values: [alarm-capability$_run_closure1@3232a28a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing app_test
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1e04fa0a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1af2d44a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@618425b5[org.codehaus.groovy.ast.expr.VariableExpression@58695725[variable: people], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@543588e6[variable: presence]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@f5acb9d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4fb3ee4e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5d7148e2[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@25fb8912[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7c24b813[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2c35e847[org.codehaus.groovy.ast.expr.VariableExpression@7bd4937b[variable: people], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@21e360a[variable: presence]]]]]]
presence: [If (evt.value == not present),[If (location.mode != newMode),[If this.everyoneIsAway(),[org.codehaus.groovy.ast.stmt.ExpressionStatement@306e95ec[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@52af26ee[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6fd83fc1[org.codehaus.groovy.ast.expr.BinaryExpression@4f2b503c[org.codehaus.groovy.ast.expr.MethodCallExpression@bae7dc0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[findFalseAlarmThreshold] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@209da20d[]]("*" at 73:37:  "*" )ConstantExpression[60]], ConstantExpression[takeAction], org.codehaus.groovy.ast.expr.MapExpression@e15b7e8[org.codehaus.groovy.ast.expr.MapEntryExpression@1b2abca6(key: ConstantExpression[overwrite], value: ConstantExpression[false])]]]]],],,],,],]
takeAction: [If this.everyoneIsAway(),[(threshold = (((1000 * 60) * this.findFalseAlarmThreshold()) - 1000))][(awayLongEnough = people.findAll({ java.lang.Object person -> ... }))][If (awayLongEnough.size() == people.size()),[(message = SmartThings changed your mode to '$newMode' because everyone left home)],],,],]
everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],]everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],]]
send: [If location.contactBookEnabled,,[If (sendPushMessage != No),,],[If phone,,],],]
findFalseAlarmThreshold: [(((falseAlarmThreshold != null) && (falseAlarmThreshold != ))) ? falseAlarmThreshold : 10]]
Starting Points: []
--app-start--
processing arduino-thingshield.groovy
DECLARED METHODS
parse: [(value = zigbee.parse(description)?.text)][(name = ((value && (value != ping))) ? response : null)][(result = this.createEvent([name:name, value:value]))]]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: arduino-thingshield.metadata() is applicable for argument types: (arduino-thingshield$_run_closure1) values: [arduino-thingshield$_run_closure1@1de5f259]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing arrival-sensor-ha.groovy
DECLARED METHODS
updated: ]
installed: ]
configure: [(cmds = (zigbee.readAttribute(zigbee.POWER_CONFIGURATION_CLUSTER, 32) + zigbee.batteryConfig(20, 20, 1)))]]
beep: ]
parse: [(state.lastCheckin = this.now())][If description?.startsWith(read attr -),,],]
handleReportAttributeMessage: [(descMap = zigbee.parseDescriptionAsMap(description))][If ((descMap.clusterInt == 1) && (descMap.attrInt == 32)),,],]
handleBatteryEvent: [(descriptionText = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If ((volts == 0) || (volts == 255)),,[(batteryMap = [28:100, 27:100, 26:100, 25:90, 24:90, 23:70, 22:70, 21:50, 20:50, 19:30, 18:30, 17:15, 16:1, 15:0])][(minVolts = 15)][(maxVolts = 28)][If (volts < minVolts),[(volts = minVolts)],[If (volts > maxVolts),[(volts = maxVolts)],],],[(value = batteryMap[volts])][If (value != null),[(linkText = this.getLinkText(device))][(descriptionText = {{ linkText }} battery was {{ value }})][(eventMap = [name:battery, value:value, descriptionText:descriptionText, translatable:true])][log.debug(Creating battery event for voltage=$(volts / 10)V: $linkText $eventMap.name is $eventMap.value%)],],],]
handlePresenceEvent: [(wasPresent = (device.currentState(presence)?.value == present))][If (wasPresent && present),,[If present,,],],[(linkText = this.getLinkText(device))][(descriptionText = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If present,[(descriptionText = {{ linkText }} has arrived)],[(descriptionText = {{ linkText }} has left)]],[(eventMap = [name:presence, value:(present) ? present : not present, linkText:linkText, descriptionText:descriptionText, translatable:true])]]
startTimer: ]
stopTimer: [org.codehaus.groovy.ast.stmt.ExpressionStatement@23c30a20[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1e1a0406[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3cebbb30[]]]]]
checkPresenceCallback: [(timeSinceLastCheckin = ((this.now() - state.lastCheckin) / 1000))][(theCheckInterval = ((checkInterval) ? (int) checkInterval : 2 * 60))][If (timeSinceLastCheckin >= theCheckInterval),,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: arrival-sensor-ha.metadata() is applicable for argument types: (arrival-sensor-ha$_run_closure1) values: [arrival-sensor-ha$_run_closure1@26e356f0]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing arrival-sensor.groovy
DECLARED METHODS
beep: ]
installed: ]
parse: [(results = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If this.isBatteryMessage(description),[(results = this.parseBatteryMessage(description))],[(results = this.parsePresenceMessage(description))]],]
parsePresenceMessage: [(name = this.parseName(description))][(value = this.parseValue(description))][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(handlerName = this.getState(value))][(isStateChange = this.isStateChange(device, name, value))][(results = [name:name, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName, isStateChange:isStateChange, ... ])]]
parseName: [If description?.startsWith(presence: ),,],]
parseValue: [If description?.startsWith(presence: ),[If description?.endsWith(1),,[If description?.endsWith(0),,],],,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseDescriptionText: ]
getState: [(state = value)][If (value == present),[(state = arrived)],[If (value == not present),[(state = left)],],],]
isBatteryMessage: [(description ==~ .*battery:.*rssi:.*lqi:.*)]]
parseBatteryMessage: [(results = [])][(parts = description.split(,))]]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText battery was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
getRssiResult: [(name = rssi)][(parts = part.split(:))][If (parts.size() != 2),,],[(valueString = parts[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(value = (valueInt - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]]
getLqiResult: [(name = lqi)][(parts = part.split(:))][If (parts.size() != 2),,],[(valueString = parts[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(percentageOf = 255)][(value = java.lang.Math.round(((valueInt / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText Signal (LQI) was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: arrival-sensor.metadata() is applicable for argument types: (arrival-sensor$_run_closure1) values: [arrival-sensor$_run_closure1@273e7444]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing auto-humidity-vent.groovy
DECLARED METHODS
installed: [(state.app_enabled = false)][(state.fan_control_enabled = false)][(state.fansOn = false)][(state.fansOnTime = this.now())][(state.fansLastRunTime = 0)]]
uninstalled: [(state.app_enabled = false)][(state.fan_control_enabled = false)]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@2d52216b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@242b836[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3f6f6701[]]]]]
initialize: [If settings.fan_control_enabled,[If (state.fan_control_enabled == false),,],[(state.fan_control_enabled = true)],[If (state.fan_control_enabled == true),,],[(state.fan_control_enabled = false)]],[If settings.app_enabled,[If (state.app_enabled == false),,],[org.codehaus.groovy.ast.stmt.ExpressionStatement@3527942a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@942a29c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1ed6388a[org.codehaus.groovy.ast.expr.VariableExpression@5a45133e[variable: humidity_sensor], ConstantExpression[humidity], ConstantExpression[handleThings]]]]][(state.app_enabled = true)],[If (state.app_enabled == true),,],[(state.app_enabled = false)]],]
handleThings: [If evt,,],[(h = (java.math.BigDecimal -> java.math.BigDecimal) 0.0)][If settings.app_enabled,[(h = settings.humidity_sensor.currentValue(humidity))],],[(activateFans = false)][(deactivateFans = false)][If settings.app_enabled,[If state.fansOn,[If (h > humidity_d),,[log.debug(Humidity sufficient to deactivate vent fans: $h <= $humidity_d)][(deactivateFans = true)]],,[If (h < humidity_a),,[log.debug(Humidity sufficient to activate vent fans: $h >= $humidity_a)][(activateFans = true)]],],,],[If activateFans,,],[If deactivateFans,,],]
set_fans: [If fan_state,[If (state.fansOn == false),[(state.fansOnTime = this.now())][If settings.fan_control_enabled,[If emeters,,],,],[(state.fansOn = true)],],,[If (state.fansOn == true),[(state.fansLastRunTime = (this.now() - state.fansOnTime))][(ms = new java.math.BigInteger(state.fansLastRunTime))][(seconds = (java.math.BigInteger -> java.math.BigInteger) (((java.math.BigInteger -> java.math.BigInteger) ms / 1000) % 60))][(minutes = (java.math.BigInteger -> java.math.BigInteger) (((java.math.BigInteger -> java.math.BigInteger) ms / (1000 * 60)) % 60))][(hours = (java.math.BigInteger -> java.math.BigInteger) (((java.math.BigInteger -> java.math.BigInteger) ms / ((1000 * 60) * 60)) % 24))][(days = (java.math.BigInteger -> java.math.BigInteger) ((java.math.BigInteger -> java.math.BigInteger) ms / (((1000 * 60) * 60) * 24)))][(sb = java.lang.String.format($app.label cycle: %d:%02d:%02d:%02d, days, hours, minutes, seconds))][If settings.fan_control_enabled,[If emeters,[(state.fansLastRunEnergy = emeters.currentValue(energy).sum())][(state.fansLastRunCost = ((state.fansLastRunEnergy * price_kwh) / 100.0))][this.send($app.label cycle: $state.fansLastRunEnergykWh @ $$state.fansLastRunCost)],],,],[(state.fansOn = false)][(state.fansHoldoff = this.now())],],],]
send: [If sendPushMessage,,],[If phone,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing beacon-control.groovy
DECLARED METHODS
mainPage: ]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5677323c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@18df8434[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@65c7a252[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4d154ccd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@229c6181[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4686afc2[org.codehaus.groovy.ast.expr.VariableExpression@1e0b4072[variable: beacons], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@791f145a[variable: beaconHandler]]]]]]
beaconHandler: [If allOk,[(data = new groovy.json.JsonSlurper().parseText(evt.data))][(beaconName = this.getBeaconName(evt))][(phoneName = this.getPhoneName(data))][If (phoneName != null),[(action = ((data.presence == 1)) ? arrived : left)][(msg = $phoneName has $action $((action == arrived)) ? at  : the $beaconName)][If (action == arrived),[(msg = this.arriveActions(msg))],[If (action == left),[(msg = this.departActions(msg))],],],[If (pushNotification || phone),[(options = [method:((pushNotification && phone)) ? both : (pushNotification) ? push : sms, phone:phone])],],,],,],]
arriveActions: [If (((arrivalPhrase || arrivalOnSwitches) || arrivalOffSwitches) || arrivalLocks),[(msg += , so)],],[If arrivalPhrase,[(msg +=  $this.prefix(executed) $arrivalPhrase.)],],[If arrivalOnSwitches,[(msg +=  $this.prefix(turned) $this.list(arrivalOnSwitches) on.)],],[If arrivalOffSwitches,[(msg +=  $this.prefix(turned) $this.list(arrivalOffSwitches) off.)],],[If arrivalLocks,[(msg +=  $this.prefix(unlocked) $this.list(arrivalLocks).)],],]
departActions: [If (((departPhrase || departOnSwitches) || departOffSwitches) || departLocks),[(msg += , so)],],[If departPhrase,[(msg +=  $this.prefix(executed) $departPhrase.)],],[If departOnSwitches,[(msg +=  $this.prefix(turned) $this.list(departOnSwitches) on.)],],[If departOffSwitches,[(msg +=  $this.prefix(turned) $this.list(departOffSwitches) off.)],],[If departLocks,[(msg +=  $this.prefix(locked) $this.list(departLocks).)],],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
prefix: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(index = ((settings.prefixIndex == null)) ? 0 : (settings.prefixIndex + 1))]]
listPhrases: ]
executePhrase: [If phraseName,,],]
getBeaconName: [(beaconName = beacons.find({ java.lang.Object b -> ... }))]]
getPhoneName: [(phoneName = phones.find({ java.lang.Object phone -> ... }))]]
hideOptionsSection: ]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(<beacon-control> modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(<beacon-control> daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(<beacon-control> timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
timeIntervalLabel: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
list: ]
Starting Points: []
IT HAS STATE
--app-start--
processing beaconthing.groovy
DECLARED METHODS
parse: ]
installed: [(emptyList = [])][(json = new groovy.json.JsonBuilder(emptyList))]]
setPresence: ]
arrived: [(theList = device.latestValue(inRange))][(inRangeList = new groovy.json.JsonSlurper().parseText(theList))][If inRangeList.contains(id),,],[(inRangeList += id)][(json = new groovy.json.JsonBuilder(inRangeList))][(friendlyList = (Nearby:  + inRangeList.join(, )))][If (inRangeList.size() == 1),,],]
left: [(theList = device.latestValue(inRange))][(inRangeList = new groovy.json.JsonSlurper().parseText(theList))][(inRangeList -= id)][(json = new groovy.json.JsonBuilder(inRangeList))][(friendlyList = (Nearby:  + inRangeList.join(, )))][If inRangeList.empty,[(friendlyList = No one is nearby)],],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: beaconthing.metadata() is applicable for argument types: (beaconthing$_run_closure1) values: [beaconthing$_run_closure1@5ab956d7]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing big-turn-off.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@2ddc9a9f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@298a5e20[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2a7f1f10[org.codehaus.groovy.ast.expr.VariableExpression@46cdf8bd[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@f0c8a99[variable: changedLocationMode]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@740cae06[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@26d9b808[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@f78a47e[org.codehaus.groovy.ast.expr.VariableExpression@644baf4a[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@7526515b[variable: appTouch]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1ed4ae0f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@54c5a2ff[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6d4d66d2[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2a265ea9[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@11392934[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6892b3b6[org.codehaus.groovy.ast.expr.VariableExpression@6e6f2380[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@76a4ebf2[variable: changedLocationMode]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2e8c1c9b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@53fe15ff[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@449a4f23[org.codehaus.groovy.ast.expr.VariableExpression@1530c739[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@5b1669c0[variable: appTouch]]]]]]
changedLocationMode: ]
appTouch: ]
Starting Points: []
IT HAS STATE
--app-start--
processing big-turn-on.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@173ed316[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@25ce9dc4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@74ea2410[org.codehaus.groovy.ast.expr.VariableExpression@17f62e33[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@76b1e9b8[variable: changedLocationMode]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2af004b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@248e319b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5d0bf09b[org.codehaus.groovy.ast.expr.VariableExpression@793f29ff[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@3e8c3cb[variable: appTouch]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@563f38c4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@543295b0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@54422e18[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@117159c0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3e27ba32[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7ef82753[org.codehaus.groovy.ast.expr.VariableExpression@3b0fe47a[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@202b0582[variable: changedLocationMode]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@235ecd9f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1ca3b418[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@58cbafc2[org.codehaus.groovy.ast.expr.VariableExpression@2034b64c[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@75d3a5e0[variable: appTouch]]]]]]
changedLocationMode: ]
appTouch: ]
Starting Points: []
IT HAS STATE
--app-start--
processing bon-voyage.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@548d708a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4b013c76[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@53fb3dab[org.codehaus.groovy.ast.expr.VariableExpression@cb0755b[variable: people], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@33065d67[variable: presence]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@712625fd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7bba5817[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@742ff096[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@75437611[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@350aac89[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1c5920df[org.codehaus.groovy.ast.expr.VariableExpression@17f9d882[variable: people], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@79e4c792[variable: presence]]]]]]
presence: [If (evt.value == not present),[If (location.mode != newMode),[If this.everyoneIsAway(),[org.codehaus.groovy.ast.stmt.ExpressionStatement@196a42c3[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4c60d6e9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@15043a2f[org.codehaus.groovy.ast.expr.BinaryExpression@4a83a74a[org.codehaus.groovy.ast.expr.MethodCallExpression@1349883[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[findFalseAlarmThreshold] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4b29d1d2[]]("*" at 73:37:  "*" )ConstantExpression[60]], ConstantExpression[takeAction], org.codehaus.groovy.ast.expr.MapExpression@7f485fda[org.codehaus.groovy.ast.expr.MapEntryExpression@28261e8e(key: ConstantExpression[overwrite], value: ConstantExpression[false])]]]]],],,],,],]
takeAction: [If this.everyoneIsAway(),[(threshold = (((1000 * 60) * this.findFalseAlarmThreshold()) - 1000))][(awayLongEnough = people.findAll({ java.lang.Object person -> ... }))][If (awayLongEnough.size() == people.size()),[(message = SmartThings changed your mode to '$newMode' because everyone left home)],],,],]
everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],]everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],]]
send: [If location.contactBookEnabled,,[If (sendPushMessage != No),,],[If phone,,],],]
findFalseAlarmThreshold: [(((falseAlarmThreshold != null) && (falseAlarmThreshold != ))) ? falseAlarmThreshold : 10]]
Starting Points: []
IT HAS STATE
--app-start--
processing bose-soundtouch-control.groovy
DECLARED METHODS
mainPage: ]
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]]
ifUnset: [If settings[name],,],]
ifSet: [If settings[name],,],]
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@33bc72d1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1a75e76a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5524cca1[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5032714f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@48bb62[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@353352b6[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4681c175[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@57a78e3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@402c4085[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6fa51cd4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2767e23c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@710c2b53[]]]]]
subscribeToEvents: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5386659f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@14028087[object: org.codehaus.groovy.ast.expr.VariableExpression@cecf639[variable: log] method: ConstantExpression[trace] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1caa0244[ConstantExpression[subscribeToEvents()]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7ce026d3[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7ce69770[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1750fbeb[org.codehaus.groovy.ast.expr.VariableExpression@5b247367[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@268f106e[variable: appTouchHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6e9a5ed8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7e057f43[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6c284af[org.codehaus.groovy.ast.expr.VariableExpression@5890e879[variable: contact], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@6440112d[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@31ea9581[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@231f98ef[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7c137fd5[org.codehaus.groovy.ast.expr.VariableExpression@183ec003[variable: contactClosed], ConstantExpression[contact.closed], org.codehaus.groovy.ast.expr.VariableExpression@7d9d0818[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@221a3fa4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@451001e5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2b40ff9c[org.codehaus.groovy.ast.expr.VariableExpression@3e08ff24[variable: acceleration], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@4d1c005e[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@8462f31[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@24569dba[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5ddeb7cb[org.codehaus.groovy.ast.expr.VariableExpression@70ed52de[variable: motion], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@496bc455[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@59402b8f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7188af83[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6be968ce[org.codehaus.groovy.ast.expr.VariableExpression@7c37508a[variable: mySwitch], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@247310d0[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1033576a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@303cf2ba[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@76494737[org.codehaus.groovy.ast.expr.VariableExpression@4a003cbe[variable: mySwitchOff], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@4082ba93[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@17fc391b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2b30a42c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@609e8838[org.codehaus.groovy.ast.expr.VariableExpression@359df09a[variable: arrivalPresence], ConstantExpression[presence.present], org.codehaus.groovy.ast.expr.VariableExpression@43df23d3[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6d60fe40[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@792b749c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@23e84203[org.codehaus.groovy.ast.expr.VariableExpression@19932c16[variable: departurePresence], ConstantExpression[presence.not present], org.codehaus.groovy.ast.expr.VariableExpression@73eb439a[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@514646ef[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@305ffe9e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@302c971f[org.codehaus.groovy.ast.expr.VariableExpression@1972e513[variable: smoke], ConstantExpression[smoke.detected], org.codehaus.groovy.ast.expr.VariableExpression@7ae0a9ec[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@35841320[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@61c4eee0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6f10d5b6[org.codehaus.groovy.ast.expr.VariableExpression@1040be71[variable: smoke], ConstantExpression[smoke.tested], org.codehaus.groovy.ast.expr.VariableExpression@548a24a[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@433defed[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2a693f59[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3f4faf53[org.codehaus.groovy.ast.expr.VariableExpression@7fd50002[variable: smoke], ConstantExpression[carbonMonoxide.detected], org.codehaus.groovy.ast.expr.VariableExpression@533bda92[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@304bb45b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@723ca036[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@25be7b63[org.codehaus.groovy.ast.expr.VariableExpression@28dcca0c[variable: water], ConstantExpression[water.wet], org.codehaus.groovy.ast.expr.VariableExpression@45d84a20[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@52f27fbd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4c163e3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4a8355dd[org.codehaus.groovy.ast.expr.VariableExpression@4d0d9fe7[variable: button1], ConstantExpression[button.pushed], org.codehaus.groovy.ast.expr.VariableExpression@c430e6c[variable: eventHandler]]]]][If triggerModes,[org.codehaus.groovy.ast.stmt.ExpressionStatement@312aa7c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@536f2a7e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@72bc6553[org.codehaus.groovy.ast.expr.VariableExpression@66982506[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@70cf32e3[variable: modeChangeHandler]]]]],],[If timeOfDay,[org.codehaus.groovy.ast.stmt.ExpressionStatement@5a59ca5e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4bdeaabb[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6c4906d3[org.codehaus.groovy.ast.expr.VariableExpression@65987993[variable: timeOfDay], org.codehaus.groovy.ast.expr.VariableExpression@71075444[variable: scheduledTimeHandler]]]]],],]
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],]
modeChangeHandler: [If (evt.value in triggerModes),,],]
scheduledTimeHandler: ]
appTouchHandler: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
takeAction: [(options = [:])][If volume,[(options.delay = 1000)],],]
frequencyKey: ]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],]
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
timeIntervalLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing bright-when-dark-and-or-bright-after-sunset.groovy
DECLARED METHODS
configurations: ]
options: [If ((dark == true) && (sun == true)),,[If ((dark == true) && (sun == false)),,[If ((sun == true) && (dark == false)),,],],],]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4201c465[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5b799640[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6cb107fd[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@710636b0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3de8f619[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2ab4bc72[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4e5ed836[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@eadd4fb[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@740fb309[org.codehaus.groovy.ast.expr.VariableExpression@7bd7d6d6[variable: motionSensor], ConstantExpression[motion], org.codehaus.groovy.ast.expr.VariableExpression@43f02ef2[variable: motionHandler]]]]][If ((((lights != null) && (lights != )) && (dimmers != null)) && (dimmers != )),[org.codehaus.groovy.ast.stmt.ExpressionStatement@239a307b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2a8448fa[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6f204a1a[org.codehaus.groovy.ast.expr.VariableExpression@2de56eb2[variable: lights], ConstantExpression[switch], org.codehaus.groovy.ast.expr.VariableExpression@5f8e8a9d[variable: lightsHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5745ca0e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3ad83a66[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3cce5371[org.codehaus.groovy.ast.expr.VariableExpression@17bffc17[variable: dimmers], ConstantExpression[switch], org.codehaus.groovy.ast.expr.VariableExpression@6e535154[variable: dimmersHandler]]]]][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[org.codehaus.groovy.ast.stmt.ExpressionStatement@15a34df2[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5b38c1ec[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@338fc1d8[org.codehaus.groovy.ast.expr.VariableExpression@4722ef0c[variable: lightSensor], ConstantExpression[illuminance], org.codehaus.groovy.ast.expr.VariableExpression@48e1f6c7[variable: illuminanceHandler], org.codehaus.groovy.ast.expr.MapExpression@55cb6996[org.codehaus.groovy.ast.expr.MapEntryExpression@1807e3f6(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]],],[If (sun == true),[org.codehaus.groovy.ast.stmt.ExpressionStatement@480d3575[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@f1da57d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@194fad1[org.codehaus.groovy.ast.expr.VariableExpression@26abb146[variable: location], ConstantExpression[position], org.codehaus.groovy.ast.expr.VariableExpression@72c8e7b[variable: locationPositionChange]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@65f8f5ae[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@431cd9b2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@38467116[org.codehaus.groovy.ast.expr.VariableExpression@5b7a7f33[variable: location], ConstantExpression[sunriseTime], org.codehaus.groovy.ast.expr.VariableExpression@790da477[variable: sunriseSunsetTimeHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5c7933ad[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@57bc27f5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5fb759d6[org.codehaus.groovy.ast.expr.VariableExpression@4b8d604b[variable: location], ConstantExpression[sunsetTime], org.codehaus.groovy.ast.expr.VariableExpression@5e7cd6cc[variable: sunriseSunsetTimeHandler]]]]],[If ((dark != true) && (sun != true)),,],],,[If ((lights != null) && (lights != )),[org.codehaus.groovy.ast.stmt.ExpressionStatement@68c9d179[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@d554c5f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2dfaea86[org.codehaus.groovy.ast.expr.VariableExpression@15888343[variable: lights], ConstantExpression[switch], org.codehaus.groovy.ast.expr.VariableExpression@33ecda92[variable: lightsHandler]]]]][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[org.codehaus.groovy.ast.stmt.ExpressionStatement@14fc5f04[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6e2829c7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3feb2dda[org.codehaus.groovy.ast.expr.VariableExpression@6a8658ff[variable: lightSensor], ConstantExpression[illuminance], org.codehaus.groovy.ast.expr.VariableExpression@1c742ed4[variable: illuminanceHandler], org.codehaus.groovy.ast.expr.MapExpression@333d4a8c[org.codehaus.groovy.ast.expr.MapEntryExpression@55de24cc(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]],],[If (sun == true),[org.codehaus.groovy.ast.stmt.ExpressionStatement@dc7df28[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@30f842ca[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@69c81773[org.codehaus.groovy.ast.expr.VariableExpression@4d14b6c2[variable: location], ConstantExpression[position], org.codehaus.groovy.ast.expr.VariableExpression@7e990ed7[variable: locationPositionChange]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@c05fddc[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@25df00a0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4d15107f[org.codehaus.groovy.ast.expr.VariableExpression@7b4c50bc[variable: location], ConstantExpression[sunriseTime], org.codehaus.groovy.ast.expr.VariableExpression@5884a914[variable: sunriseSunsetTimeHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@50378a4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@60f00693[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@79207381[org.codehaus.groovy.ast.expr.VariableExpression@491b9b8[variable: location], ConstantExpression[sunsetTime], org.codehaus.groovy.ast.expr.VariableExpression@1a4927d6[variable: sunriseSunsetTimeHandler]]]]],[If ((dark != true) && (sun != true)),,],],,[If ((dimmers != null) && (dimmers != )),[org.codehaus.groovy.ast.stmt.ExpressionStatement@7a6d7e92[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@aba625[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@97e93f1[org.codehaus.groovy.ast.expr.VariableExpression@5a5a729f[variable: dimmers], ConstantExpression[switch], org.codehaus.groovy.ast.expr.VariableExpression@4b520ea8[variable: dimmersHandler]]]]][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[org.codehaus.groovy.ast.stmt.ExpressionStatement@16150369[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6b09fb41[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@624ea235[org.codehaus.groovy.ast.expr.VariableExpression@3932c79a[variable: lightSensor], ConstantExpression[illuminance], org.codehaus.groovy.ast.expr.VariableExpression@782859e[variable: illuminanceHandler], org.codehaus.groovy.ast.expr.MapExpression@23f5b5dc[org.codehaus.groovy.ast.expr.MapEntryExpression@34bde49d(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]],],[If (sun == true),[org.codehaus.groovy.ast.stmt.ExpressionStatement@1b1cfb87[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@821330f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6f43c82[org.codehaus.groovy.ast.expr.VariableExpression@5db6b9cd[variable: location], ConstantExpression[position], org.codehaus.groovy.ast.expr.VariableExpression@210ab13f[variable: locationPositionChange]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@20b2475a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7857fe2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6f15d60e[org.codehaus.groovy.ast.expr.VariableExpression@1be2019a[variable: location], ConstantExpression[sunriseTime], org.codehaus.groovy.ast.expr.VariableExpression@29d80d2b[variable: sunriseSunsetTimeHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@58e1d9d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@446a1e84[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4f0f2942[org.codehaus.groovy.ast.expr.VariableExpression@2657d4dd[variable: location], ConstantExpression[sunsetTime], org.codehaus.groovy.ast.expr.VariableExpression@5340477f[variable: sunriseSunsetTimeHandler]]]]],[If ((dark != true) && (sun != true)),,],],,],],],[If ((lights != null) && (lights != )),[If lights.currentValue(switch).toString().contains(on),[(state.lightsState = on)][log.debug(Lights $state.lightsState.)],[If lights.currentValue(switch).toString().contains(off),[(state.lightsState = off)][log.debug(Lights $state.lightsState.)],],],,],[If ((dimmers != null) && (dimmers != )),[If dimmers.currentValue(switch).toString().contains(on),[(state.dimmersState = on)][log.debug(Dimmers $state.dimmersState.)],[If dimmers.currentValue(switch).toString().contains(off),[(state.dimmersState = off)][log.debug(Dimmers $state.dimmersState.)],],],,],]
locationPositionChange: ]
sunriseSunsetTimeHandler: [(state.lastSunriseSunsetEvent = this.now())]]
motionHandler: [If (evt.value == active),[org.codehaus.groovy.ast.stmt.ExpressionStatement@47caedad[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7139992f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@69504ae9[org.codehaus.groovy.ast.expr.VariableExpression@387a8303[variable: turnOffLights]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@28cda624[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1500b2f3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7eecb5b8[org.codehaus.groovy.ast.expr.VariableExpression@126253fd[variable: turnOffDimmers]]]]][If ((dark == true) && (sun == true)),[If ((darkOk == true) && (sunOk == true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((darkOk == true) && (sunOk != true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((darkOk != true) && (sunOk == true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],],,[If ((dark == true) && (sun != true)),[If (darkOk == true),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],,[If ((dark != true) && (sun == true)),[If (sunOk == true),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],,[If ((dark != true) && (sun != true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],],],,[If (evt.value == inactive),[org.codehaus.groovy.ast.stmt.ExpressionStatement@57db2b13[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@475c9c31[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5c86a017[org.codehaus.groovy.ast.expr.VariableExpression@5c7bfdc1[variable: turnOffLights]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5276d6ee[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@71687585[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1807f5a7[org.codehaus.groovy.ast.expr.VariableExpression@1b919693[variable: turnOffDimmers]]]]][If ((state.lightsState != off) || (state.dimmersState != off)),[If delayMinutes,[(delay = (delayMinutes * 60))][If ((dark == true) && (sun == true)),[If ((lights != null) && (lights != )),[org.codehaus.groovy.ast.stmt.ExpressionStatement@7fb4f2a9[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4dc27487[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6a4f1a55[org.codehaus.groovy.ast.expr.VariableExpression@7dfd3c81[variable: delay], org.codehaus.groovy.ast.expr.VariableExpression@2584b82d[variable: turnOffLights]]]]],],[If ((dimmers != null) && (dimmers != )),[org.codehaus.groovy.ast.stmt.ExpressionStatement@7bbc8656[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6933b6c6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7d3e8655[org.codehaus.groovy.ast.expr.VariableExpression@7dfb0c0f[variable: delay], org.codehaus.groovy.ast.expr.VariableExpression@626abbd0[variable: turnOffDimmers]]]]],],,[If ((dark == true) && (sun != true)),[If ((lights != null) && (lights != )),[org.codehaus.groovy.ast.stmt.ExpressionStatement@169bb4dd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1f9e9475[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3aa078fd[org.codehaus.groovy.ast.expr.VariableExpression@d23e042[variable: delay], org.codehaus.groovy.ast.expr.VariableExpression@46d59067[variable: turnOffLights]]]]],],[If ((dimmers != null) && (dimmers != )),[org.codehaus.groovy.ast.stmt.ExpressionStatement@2d0399f4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@14dd7b39[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@66ea810[org.codehaus.groovy.ast.expr.VariableExpression@6cd24612[variable: delay], org.codehaus.groovy.ast.expr.VariableExpression@5dafbe45[variable: turnOffDimmers]]]]],],,[If ((dark != true) && (sun == true)),[If ((lights != null) && (lights != )),[org.codehaus.groovy.ast.stmt.ExpressionStatement@2254127a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@51891008[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2f953efd[org.codehaus.groovy.ast.expr.VariableExpression@f68f0dc[variable: delay], org.codehaus.groovy.ast.expr.VariableExpression@d2de489[variable: turnOffLights]]]]],],[If ((dimmers != null) && (dimmers != )),[org.codehaus.groovy.ast.stmt.ExpressionStatement@14bdbc74[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@12591ac8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5a7fe64f[org.codehaus.groovy.ast.expr.VariableExpression@38145825[variable: delay], org.codehaus.groovy.ast.expr.VariableExpression@41330d4f[variable: turnOffDimmers]]]]],],,[If ((dark != true) && (sun != true)),[If ((lights != null) && (lights != )),[org.codehaus.groovy.ast.stmt.ExpressionStatement@1b66c0fb[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3e0e1046[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@24c1b2d2[org.codehaus.groovy.ast.expr.VariableExpression@7dc19a70[variable: delay], org.codehaus.groovy.ast.expr.VariableExpression@508dec2b[variable: turnOffLights]]]]],],[If ((dimmers != null) && (dimmers != )),[org.codehaus.groovy.ast.stmt.ExpressionStatement@1e4f4a5c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@37313c65[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@465232e9[org.codehaus.groovy.ast.expr.VariableExpression@798162bc[variable: delay], org.codehaus.groovy.ast.expr.VariableExpression@1df8da7a[variable: turnOffDimmers]]]]],],,],],],],,],,[If ((state.lightsState == off) && (state.dimmersState == off)),,],],,],],]
lightsHandler: [If (evt.value == on),[org.codehaus.groovy.ast.stmt.ExpressionStatement@23941fb4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7486b455[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@660acfb[org.codehaus.groovy.ast.expr.VariableExpression@5d908d47[variable: turnOffLights]]]]][(state.lightsState = on)],[If (evt.value == off),[org.codehaus.groovy.ast.stmt.ExpressionStatement@5efa40fe[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1f9f6368[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1c9b0314[org.codehaus.groovy.ast.expr.VariableExpression@45385f75[variable: turnOffLights]]]]][(state.lightsState = off)],],],]
dimmersHandler: [If (evt.value == on),[org.codehaus.groovy.ast.stmt.ExpressionStatement@49c90a9c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2d29b4ee[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@69ee81fc[org.codehaus.groovy.ast.expr.VariableExpression@6e2aa843[variable: turnOffDimmers]]]]][(state.dimmersState = on)],[If (evt.value == off),[org.codehaus.groovy.ast.stmt.ExpressionStatement@6f36c2f0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@f58853c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1224144a[org.codehaus.groovy.ast.expr.VariableExpression@29f7cefd[variable: turnOffDimmers]]]]][(state.dimmersState = off)],],],]
illuminanceHandler: [log.debug($evt.name: $evt.value, lastStatus lights: $state.lightsState, lastStatus dimmers: $state.dimmersState, motionStopTime: $state.motionStopTime)][org.codehaus.groovy.ast.stmt.ExpressionStatement@700fb871[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3b35a229[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@9816741[org.codehaus.groovy.ast.expr.VariableExpression@1e16c0aa[variable: turnOffLights]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@13d73f29[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@565f390[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7dc3712[org.codehaus.groovy.ast.expr.VariableExpression@2f67a4d3[variable: turnOffDimmers]]]]][If (evt.integerValue > 999),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If (evt.integerValue > (((luxLevel != null) && (luxLevel != ))) ? luxLevel : 50),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],]
turnOnLights: [If allOk,[If (state.lightsState != on),[(state.lightsState = on)],],,],]
turnOnDimmers: [If allOk,[If (state.dimmersState != on),[(state.dimmersState = on)],],,],]
turnOffLights: [If allOk,[If (state.lightsState != off),[(state.lightsState = on)],],,],]
turnOffDimmers: [If allOk,[If (state.dimmersState != off),[(state.dimmersState = off)],],,],]
astroCheck: [(s = this.getSunriseAndSunset([zipCode:zipCode, sunriseOffset:sunriseOffset, sunsetOffset:sunsetOffset]))][(state.riseTime = s.sunrise.time)][(state.setTime = s.sunset.time)][log.debug(Sunrise: $new Date(state.riseTime)($state.riseTime), Sunset: $new Date(state.setTime)($state.setTime))]]
getDarkOk: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[(result = (lightSensor.currentIlluminance < (((luxLevel != null) && (luxLevel != ))) ? luxLevel : 50))],],[log.trace(darkOk = $result)]]
getSunOk: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (sun == true),[(t = this.now())][(result = ((t < state.riseTime) || (t > state.setTime)))],],[log.trace(sunOk = $result)]]
getSunriseOffset: [(sunriseOffsetValue) ? ((sunriseOffsetDir == Before)) ? -$sunriseOffsetValue : sunriseOffsetValue : null]]
getSunsetOffset: [(sunsetOffsetValue) ? ((sunsetOffsetDir == Before)) ? -$sunsetOffsetValue : sunsetOffsetValue : null]]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting).time)][(stop = this.timeToday(ending).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
hideOptionsSection: ]
timeIntervalLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing brighten-dark-places.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4470fbd6[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@15d49048[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7098b907[org.codehaus.groovy.ast.expr.VariableExpression@503f91c3[variable: contact1], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@13526e59[variable: contactOpenHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@2235eaab[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@17503f6b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3bcd05cb[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3b6d844d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@36804139[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@20bd8be5[org.codehaus.groovy.ast.expr.VariableExpression@730d2164[variable: contact1], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@24959ca4[variable: contactOpenHandler]]]]]]
contactOpenHandler: [(lightSensorState = luminance1.currentIlluminance)][log.debug(SENSOR = $lightSensorState)][If ((lightSensorState != null) && (lightSensorState < 10)),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing brighten-my-path.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@e3b3b2f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@50f6ac94[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6cc4cdb9[org.codehaus.groovy.ast.expr.VariableExpression@28194a50[variable: motion1], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@7f2cfe3f[variable: motionActiveHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1a5b6f42[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5038d0b5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@32115b28[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2ad48653[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6bb4dd34[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7d9f158f[org.codehaus.groovy.ast.expr.VariableExpression@45efd90f[variable: motion1], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@4b8729ff[variable: motionActiveHandler]]]]]]
motionActiveHandler: ]
Starting Points: []
IT HAS STATE
--app-start--
processing button-capability.groovy
DECLARED METHODS
parse: [(results = [])][If description.startsWith(Err),[(results = this.createEvent([descriptionText:description, displayed:true]))],[(cmd = zwave.parse(description, [43:1, 128:1, 132:1]))][If cmd,[(results += this.zwaveEvent(cmd))],],[If results,[(results = [descriptionText:cmd, displayed:false])],],],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: button-capability.metadata() is applicable for argument types: (button-capability$_run_closure1) values: [button-capability$_run_closure1@4e0ae11f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing button-controller.groovy
DECLARED METHODS
selectButton: ]
createPage: [If ((state.numButton == pageNum) || (pageNum == 8)),[(state.installCondition = true)],],[this.dynamicPage([name:configureButton$pageNum, title:Set up button $pageNum here, nextPage:configureButton$(pageNum + 1), install:state.installCondition, ... ], this.getButtonSections(pageNum))]]
configureButton1: [(state.numButton = (buttonDevice.currentState(numberOfButtons)?.longValue) ? buttonDevice.currentState(numberOfButtons)?.longValue : 4)][log.debug(state variable numButton: $state.numButton)][(state.installCondition = false)]]
configureButton2: ]
configureButton3: ]
configureButton4: ]
configureButton5: ]
configureButton6: ]
configureButton7: ]
configureButton8: ]
getButtonSections: ]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@9cb8225[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@76b07f29[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@38af9828[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@376a0d86[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@62656be4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@17d919b6[org.codehaus.groovy.ast.expr.VariableExpression@53f3bdbd[variable: buttonDevice], ConstantExpression[button], org.codehaus.groovy.ast.expr.VariableExpression@34129c78[variable: buttonEvent]]]]]]
configured: ]
buttonConfigured: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
buttonEvent: [If allOk,[(buttonNumber = evt.data)][(value = evt.value)][log.debug(buttonEvent: $evt.name = $evt.value ($evt.data))][(recentEvents = buttonDevice.eventsSince(new java.util.Date((this.now() - 3000))).findAll({ -> ... }))][If (recentEvents.size <= 1),,],,],]
executeHandlers: [(lights = this.find(lights, buttonNumber, value))][If (lights != null),,],[(locks = this.find(locks, buttonNumber, value))][If (locks != null),,],[(sonos = this.find(sonos, buttonNumber, value))][If (sonos != null),,],[(mode = this.find(mode, buttonNumber, value))][If (mode != null),,],[(phrase = this.find(phrase, buttonNumber, value))][If (phrase != null),,],[(textMessage = this.findMsg(textMessage, buttonNumber))][(notifications = this.find(notifications, buttonNumber, value))][If notifications?.toBoolean(),,],[(phone = this.find(phone, buttonNumber, value))][If (phone != null),,],[(sirens = this.find(sirens, buttonNumber, value))][If (sirens != null),,],]
find: [(preferenceName = ((((type + _) + buttonNumber) + _) + value))][(pref = settings[preferenceName])][If (pref != null),,],]
findMsg: [(preferenceName = ((type + _) + buttonNumber))][(pref = settings[preferenceName])][If (pref != null),,],]
toggle: [log.debug(toggle: $devices = $devices*.currentValue(switch))][If devices*.currentValue(switch).contains(on),,[If devices*.currentValue(switch).contains(off),,[If devices*.currentValue(lock).contains(locked),,[If devices*.currentValue(lock).contains(unlocked),,[If devices*.currentValue(alarm).contains(off),,],],],],],]
changeMode: [log.debug(changeMode: $mode, location.mode = $location.mode, location.modes = $location.modes)][If ((location.mode != mode) && location.modes?.find({ -> ... })),,],]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location.timeZone).time)][(stop = this.timeToday(ending, location.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
hideOptionsSection: ]
timeIntervalLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing camera-power-scheduler.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@776a6d9b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@21d03963[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1f760b47[]]]]]
initialize: [If startTime,,],[If endTime,,],]
turnOnCamera: ]
turnOffCamera: ]
Starting Points: []
IT HAS STATE
--app-start--
processing cameras-on-when-im-away.groovy
DECLARED METHODS
installed: [log.debug(Current people = $people.collect({ -> ... }))][org.codehaus.groovy.ast.stmt.ExpressionStatement@2ca26d77[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4808bc9b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@70e38ce1[org.codehaus.groovy.ast.expr.VariableExpression@2ca923bb[variable: people], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@13df2a8c[variable: presence]]]]]]
updated: [log.debug(Current people = $people.collect({ -> ... }))][org.codehaus.groovy.ast.stmt.ExpressionStatement@1ebea008[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@72d6b3ba[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1787f2a0[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7de62196[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@163370c2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@51bf5add[org.codehaus.groovy.ast.expr.VariableExpression@7905a0b8[variable: people], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@35a3d49f[variable: presence]]]]]]
presence: [If (evt.value == not present),[If this.everyoneIsAway(),[org.codehaus.groovy.ast.stmt.ExpressionStatement@389b0789[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@13d9cbf5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@478db956[org.codehaus.groovy.ast.expr.BinaryExpression@6ca18a14[ConstantExpression[60]("*" at 60:21:  "*" )ConstantExpression[2]], ConstantExpression[turnOn]]]]],],,[If this.everyoneIsAway(),,],],]
turnOff: [org.codehaus.groovy.ast.stmt.ExpressionStatement@c667f46[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@51bd8b5c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7b50df34[ConstantExpression[turnOn]]]]]]
turnOn: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1b410b60[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2462cb01[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@19b843ba[ConstantExpression[turnOn]]]]]]
everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],]everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],]]
Starting Points: []
IT HAS STATE
--app-start--
processing carpool-notifier.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@471a9022[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@dc9876b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2f666ebb[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@19976a65[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@a1f72f5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4b2c5e02[org.codehaus.groovy.ast.expr.VariableExpression@57a3e26a[variable: driver], ConstantExpression[presence.present], org.codehaus.groovy.ast.expr.VariableExpression@75c56eb9[variable: presence]]]]]]
presence: [If ((evt.value == present) && this.riderIsHome()),,],]
riderIsHome: [If (rider.currentPresence != present),,],[(riderState = rider.currentState(presence))][If riderState,,],[(latestState = rider.latestState(presence))][(now = new java.util.Date())][(minusFive = new java.util.Date([minutes:(now.minutes - 5)]))][If (minusFive > latestState.date),,],]
sendText: [If location.contactBookEnabled,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing centralite-thermostat.groovy
DECLARED METHODS
parse: [(result = [])][(descMap = zigbee.parseDescriptionAsMap(description))][(attrData = [[cluster:descMap.cluster, attrId:descMap.attrId, value:descMap.value]])]]
getModeMap: ]
getFanModeMap: ]
refresh: ]
getTemperature: [If (value != null),[(celsius = (java.lang.Integer.parseInt(value, 16) / 100))][If (this.getTemperatureScale() == C),,],,],]
setHeatingSetpoint: [If (degrees != null),[(temperatureScale = this.getTemperatureScale())][(degreesInteger = java.lang.Math.round(degrees))][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))],],]
setCoolingSetpoint: [If (degrees != null),[(degreesInteger = java.lang.Math.round(degrees))][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))],],]
modes: ]
setThermostatMode: [(currentMode = device.currentState(thermostatMode)?.value)][(modeOrder = this.modes())][(index = modeOrder.indexOf(currentMode))][(next = (((index >= 0) && (index < (modeOrder.size() - 1)))) ? modeOrder[(index + 1)] : modeOrder[0])]]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
setThermostatFanMode: [(currentFanMode = device.currentState(thermostatFanMode)?.value)][(returnCommand = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)]]
setThermostatMode: ]
setThermostatFanMode: ]
off: ]
cool: ]
heat: ]
emergencyHeat: ]
on: ]
fanOn: ]
auto: ]
fanAuto: ]
configure: ]
hex: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: centralite-thermostat.metadata() is applicable for argument types: (centralite-thermostat$_run_closure1) values: [centralite-thermostat$_run_closure1@6f3187b0]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing child-button.groovy
DECLARED METHODS
installed: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: child-button.metadata() is applicable for argument types: (child-button$_run_closure1) values: [child-button$_run_closure1@3fce8fd9]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing close-the-valve.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@23202fce[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7b993c65[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@37911f88[org.codehaus.groovy.ast.expr.VariableExpression@6f1c29b7[variable: sensor], ConstantExpression[water], org.codehaus.groovy.ast.expr.VariableExpression@4d6025c5[variable: waterHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@7f284218[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@407a7f2a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4ea5b703[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2a7ed1f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3fa247d1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2cb2fc20[org.codehaus.groovy.ast.expr.VariableExpression@4f4c4b1a[variable: sensor], ConstantExpression[water], org.codehaus.groovy.ast.expr.VariableExpression@723e88f9[variable: waterHandler]]]]]]
waterHandler: [If (evt.value == wet),,],[If frequency,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],]
sendMessage: [(msg = (messageText) ? messageText : We closed the valve because moisture was detected)][If (phone || (pushAndPhone != No)),,],[If phone,,],[If frequency,[(state[evt.deviceId] = this.now())],],]
Starting Points: []
IT HAS STATE
--app-start--
processing co2-vent.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5f77d0f9[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@463fd068[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@895e367[]]]]]
initialize: [(state.active = false)][org.codehaus.groovy.ast.stmt.ExpressionStatement@1b266842[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7a3793c7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@42b3b079[org.codehaus.groovy.ast.expr.VariableExpression@651aed93[variable: sensor], ConstantExpression[carbonDioxide], ConstantExpression[handleLevel]]]]]]
handleLevel: [(co2 = sensor.currentValue(carbonDioxide).toInteger())][log.debug(CO2 Level: $co2 / $settings.level Active: $state.active)][If ((co2 >= settings.level) && state.active),[(state.active = true)],[If ((co2 < settings.level) && state.active),[(state.active = false)],],],]
Starting Points: []
IT HAS STATE
--app-start--
processing coffee-after-shower.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4c012563[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@14a50707[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4d518b32[org.codehaus.groovy.ast.expr.VariableExpression@4bd31064[variable: bathroom], ConstantExpression[humidity], org.codehaus.groovy.ast.expr.VariableExpression@e3c0e40[variable: coffeeMaker]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@329dbdbf[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7354b8c5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@20d7d6fb[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4ef782af[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@11d8ae8b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@479cbee5[org.codehaus.groovy.ast.expr.VariableExpression@59e2d8e3[variable: bathroom], ConstantExpression[humidity], org.codehaus.groovy.ast.expr.VariableExpression@2b72cb8a[variable: coffeeMaker]]]]]]
coffeeMaker: [If (shower.value.toInteger() > relHum),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing color-coordinator.groovy
DECLARED METHODS
mainPage: ]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@37fb0bed[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@a82c5f1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7b7fdc8[]]]]]
init: [org.codehaus.groovy.ast.stmt.ExpressionStatement@51c693d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6a57ae10[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@766653e6[org.codehaus.groovy.ast.expr.VariableExpression@4e07b95f[variable: master], ConstantExpression[switch], org.codehaus.groovy.ast.expr.VariableExpression@28b46423[variable: onOffHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7fc4780b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3b79fd76[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@48c76607[org.codehaus.groovy.ast.expr.VariableExpression@43599640[variable: master], ConstantExpression[level], org.codehaus.groovy.ast.expr.VariableExpression@1f81aa00[variable: colorHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6b6776cb[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1863d2fe[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1787bc24[org.codehaus.groovy.ast.expr.VariableExpression@544d57e[variable: master], ConstantExpression[hue], org.codehaus.groovy.ast.expr.VariableExpression@55c53a33[variable: colorHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@53b7f657[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@797b0699[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5a37d3ed[org.codehaus.groovy.ast.expr.VariableExpression@26df6e3a[variable: master], ConstantExpression[saturation], org.codehaus.groovy.ast.expr.VariableExpression@4a3631f8[variable: colorHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6b58b9e9[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@f14a7d4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@52e7a6b2[org.codehaus.groovy.ast.expr.VariableExpression@29a5f4e7[variable: master], ConstantExpression[colorTemperature], org.codehaus.groovy.ast.expr.VariableExpression@79c97cb[variable: tempHandler]]]]]]
onOffHandler: [If (slaves && master),[If slaves?.id.find({ -> ... }),[If (master?.currentValue(switch) == on),[If randomYes,,],,],,],,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
colorHandler: [If (slaves && master),[If (slaves?.id?.find({ -> ... }) && (master?.currentValue(switch) == on)),[(dimLevel = master?.currentValue(level))][(hueLevel = master?.currentValue(hue))][(saturationLevel = master.currentValue(saturation))][(newValue = [hue:hueLevel, saturation:saturationLevel, level:(java.lang.Integer -> java.lang.Integer) dimLevel])],],,],]
getRandomColorMaster: [(hueLevel = java.lang.Math.floor((java.lang.Math.random() * 1000)))][(saturationLevel = java.lang.Math.floor((java.lang.Math.random() * 100)))][(dimLevel = master?.currentValue(level))][(newValue = [hue:hueLevel, saturation:saturationLevel, level:(java.lang.Integer -> java.lang.Integer) dimLevel])]]
tempHandler: [If (slaves && master),[If (slaves?.id?.find({ -> ... }) && (master?.currentValue(switch) == on)),[If (evt.value != --),[(tempLevel = master.currentValue(colorTemperature))],],,],,],]
textAppName: [(text = Color Coordinator)]]
textVersion: [(text = Version 1.1.1 (12/13/2016))]]
textCopyright: [(text = Copyright  2016 Michael Struck)]]
textLicense: [(text = ((((((((((Licensed under the Apache License, Version 2.0 (the 'License');  + you may not use this file except in compliance with the License. ) + You may obtain a copy of the License at) + 

) +     http://www.apache.org/licenses/LICENSE-2.0) + 

) + Unless required by applicable law or agreed to in writing, software ) + distributed under the License is distributed on an 'AS IS' BASIS, ) + WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ) + See the License for the specific language governing permissions and ) + limitations under the License.))]]
textHelp: [(text = ((This application will allow you to control the settings of multiple colored lights with one control.  + Simply choose a master control light, and then choose the lights that will follow the settings of the master, ) + including on/off conditions, hue, saturation, level and color temperature. Also includes a random color feature.))]]
Starting Points: []
IT HAS STATE
--app-start--
processing contact-sensor-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: contact-sensor-capability.metadata() is applicable for argument types: (contact-sensor-capability$_run_closure1) values: [contact-sensor-capability$_run_closure1@34f6515b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing coopboss-h3vx.groovy
DECLARED METHODS
parse: [(map = [:])][If description?.startsWith(catchall:),[(map = this.parseCatchAllMessage(description))],[If description?.startsWith(read attr -),[(map = this.parseReportAttributeMessage(description))],[If (description?.startsWith(temperature: ) || description?.startsWith(humidity: )),[(map = this.parseCustomMessage(description))],],],],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseCatchAllMessage: [(resultMap = [:])][(cluster = zigbee.parse(description))][If (cluster.clusterId == 1026),,],[If ((cluster.clusterId == 257) && (cluster.command == 11)),,],]
parseReportAttributeMessage: [(resultMap = [:])][(descMap = this.parseDescriptionAsMap(description))][If ((descMap.cluster == 0101) && (descMap.attrId == 0003)),[(resultMap.name = doorState)][If (descMap.value == 00),[(resultMap.value = unknown)],[If (descMap.value == 01),[(resultMap.value = closed)],[If (descMap.value == 02),[(resultMap.value = open)],[If (descMap.value == 03),[(resultMap.value = jammed)],[If (descMap.value == 04),[(resultMap.value = forced close)],[If (descMap.value == 05),[(resultMap.value = forced close)],[If (descMap.value == 06),[(resultMap.value = closing)],[If (descMap.value == 07),[(resultMap.value = opening)],[If (descMap.value == 08),[(resultMap.value = fault)],[(resultMap.value = unknown)]],],],],],],],],],[(resultMap.descriptionText = Door State Changed to $resultMap.value)],[If ((descMap.cluster == 0101) && (descMap.attrId == 0400)),[(resultMap.name = currentLightLevel)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.displayed = false)],[If ((descMap.cluster == 0101) && (descMap.attrId == 0401)),[(resultMap.name = closeLightLevel)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0402)),[(resultMap.name = openLightLevel)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0403)),[(resultMap.name = autoCloseEnable)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 0404)),[(resultMap.name = autoOpenEnable)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 0405)),[(resultMap.name = doorCurrent)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.value = (resultMap.value * 0.001))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0408)),[(resultMap.name = doorSensitivity)][(resultMap.value = (100 - java.lang.Integer.parseInt(descMap.value, 16)))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0409)),[(resultMap.name = baseDoorCurrent)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.value = (resultMap.value * 0.001))],[If ((descMap.cluster == 0101) && (descMap.attrId == 040a)),[(resultMap.name = doorVoltage)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.value = (resultMap.value * 0.001))],[If ((descMap.cluster == 0101) && (descMap.attrId == 040b)),[(resultMap.name = Aux1)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 040c)),[(resultMap.name = Aux2)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 040d)),[(resultMap.name = photoCalibration)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],[If ((descMap.cluster == 0101) && (descMap.attrId == 040e)),[(resultMap.name = baseCurrentNE)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],],],],],],],],],],],],],],],]
parseCustomMessage: [(resultMap = [:])][If description?.startsWith(temperature: ),[(resultMap.name = temperature)][(rawT = (description - temperature: ).trim())][(resultMap.descriptionText = Temperature celsius value = $rawT)][(rawTint = java.lang.Float.parseFloat(rawT))][If (rawTint > 65),[(resultMap.name = null)][(resultMap.value = null)][(resultMap.descriptionText = Temperature celsius value = $rawT is invalid not updating)][log.warn(Invalid temperature value detected! rawT = $rawT, description = $description)],[If (rawT == -32768),[(resultMap.value = ERR)],[(resultMap.value = (java.lang.Float -> java.lang.Float) this.celsiusToFahrenheit(rawT.toFloat()))]],],,],[(resultMap.displayed = false)][log.info(Temperature reported = $resultMap.value)]]
parseDescriptionAsMap: ]
getFahrenheit: [(celsius = java.lang.Integer.parseInt(value, 16))]]
callUpdateStatusTxt: [(cTemp = device.currentState(TempProb1)?.value)][(cLight = 0)][(testNull = device.currentState(currentLightLevel)?.value)][If (testNull != null),[(cLight = (int) device.currentState(currentLightLevel)?.value)],],]
updateStatusTxt: [(cTmp = currentTemp)][(cLL = 10)][(oLL = 10)][(testNull = device.currentState(closeLightLevel)?.value)][If (testNull != null),[(cLL = (int) device.currentState(closeLightLevel)?.value)],],[(testNull = device.currentState(openLightLevel)?.value)][If (testNull != null),[(oLL = (int) device.currentState(openLightLevel)?.value)],],[(aOpnEn = device.currentState(autoOpenEnable)?.value)][(aClsEn = device.currentState(autoCloseEnable)?.value)][If (currentLight < cLL),[If (aOpnEn == on),,],,[If (aClsEn == on),,],],]
on: ]
off: ]
close: ]
open: ]
Aux1On: [log.debug(Sending Aux1 = on command)]]
Aux1Off: [log.debug(Sending Aux1 = off command)]]
Aux2On: [log.debug(Sending Aux2 = on command)]]
Aux2Off: [log.debug(Sending Aux2 = off command)]]
openDoor: ]
closeDoor: ]
closeDoorHiI: ]
autoOpenOn: ]
autoOpenOff: ]
autoCloseOn: ]
autoCloseOff: ]
setOpenLevelTo: [(cX = cValue)][log.debug(Setting Open Light Level to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]]
setCloseLevelTo: [(cX = cValue)][log.debug(Setting Close Light Level to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]]
setSensitivityLevel: [(cX = (100 - cValue))][log.debug(Setting Door sensitivity level to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]]
setNewBaseCurrent: [(cX = (int) cValue)][log.info(Setting new BaseCurrent to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]]
setNewPhotoCalibration: [(cX = (int) cValue)][log.info(Setting new Photoresister calibration to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]]
readNewPhotoCalibration: [(cmd = [])]]
readBaseCurrentNE: [(cmd = [])]]
setBaseCurrentNE: [(cX = (int) cValue)][log.info(Setting new base Current Never Exceed to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]]
poll: [(cmd = [])]]
updateTemp1: [(cmd = [])]]
updateTemp2: [(cmd = [])]]
updateSun: [(cmd = [])]]
updateSensitivity: [(cmd = [])]]
updateCloseLightLevel: [(cmd = [])]]
updateOpenLightLevel: [(cmd = [])]]
refresh: [(cmd = [])]]
configure: [(cmd = [])]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: coopboss-h3vx.metadata() is applicable for argument types: (coopboss-h3vx$_run_closure1) values: [coopboss-h3vx$_run_closure1@5495333e]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing curling-iron.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@57576994[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@616ac46a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@67b9b51a[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1205bd62[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7ef27d7f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@490caf5f[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6337c201[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5c669da8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@31920ade[]]]]]
subscribeToEvents: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1d483de4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4032d386[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@28d18df5[org.codehaus.groovy.ast.expr.VariableExpression@934b6cb[variable: motionSensors], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@55cf0d14[variable: motionActive]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3b74ac8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@27adc16e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@b83a9be[org.codehaus.groovy.ast.expr.VariableExpression@2609b277[variable: motionSensors], ConstantExpression[motion.inactive], org.codehaus.groovy.ast.expr.VariableExpression@1fd14d74[variable: motionInactive]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@563e4951[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4066c471[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2b175c00[org.codehaus.groovy.ast.expr.VariableExpression@3eb81efb[variable: presenceSensors], ConstantExpression[presence.not present], org.codehaus.groovy.ast.expr.VariableExpression@1ae8bcbc[variable: notPresent]]]]]]
motionActive: [If this.anyHere(),,],]
motionInactive: [If this.allQuiet(),,],]
notPresent: [If this.anyHere(),,],]
allQuiet: [(result = true)][For motionSensors,[If (it.currentMotion == active),[(result = false)][(result = false)],],]allQuiet: [(result = true)][For motionSensors,[If (it.currentMotion == active),[(result = false)][(result = false)],],]]
anyHere: [(result = true)][For presenceSensors,[If (it.currentPresence == not present),[(result = false)][(result = false)],],]anyHere: [(result = true)][For presenceSensors,[If (it.currentPresence == not present),[(result = false)][(result = false)],],]]
outletsOn: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6cdba6dc[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7d3d101b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@30c8681[ConstantExpression[scheduledTurnOff]]]]]]
outletsOff: [(delay = (minutes * 60))][org.codehaus.groovy.ast.stmt.ExpressionStatement@5cdec700[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6d026701[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@78aa1f72[org.codehaus.groovy.ast.expr.VariableExpression@1f75a668[variable: delay], ConstantExpression[scheduledTurnOff]]]]]]
scheduledTurnOff: [org.codehaus.groovy.ast.stmt.ExpressionStatement@35399441[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4b7dc788[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6304101a[ConstantExpression[scheduledTurnOff]]]]]]
Starting Points: [this.unschedule(scheduledTurnOff)]
IT HAS STATE
--app-start--
processing darken-behind-me.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@662706a7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@45a4b042[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@16b2bb0c[org.codehaus.groovy.ast.expr.VariableExpression@327af41b[variable: motion1], ConstantExpression[motion.inactive], org.codehaus.groovy.ast.expr.VariableExpression@6cb6decd[variable: motionInactiveHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@c7045b9[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@f99f5e0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6aa61224[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@30bce90b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3e6f3f28[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7e19ebf0[org.codehaus.groovy.ast.expr.VariableExpression@2474f125[variable: motion1], ConstantExpression[motion.inactive], org.codehaus.groovy.ast.expr.VariableExpression@7357a011[variable: motionInactiveHandler]]]]]]
motionInactiveHandler: ]
Starting Points: []
IT HAS STATE
--app-start--
processing device-tile-controller.groovy
DECLARED METHODS
defaultPage: ]
installed: ]
uninstalled: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@2ce6c6ec[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1bae316d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@147a5d08[]]]]]
initializeDevices: ]
labelMap: ]
Starting Points: []
IT HAS STATE
--app-start--
processing door-jammed-notification.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6bf08014[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5e3d57c7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@732d0d24[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1fb19a0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6ee4d9ab[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5a5338df[org.codehaus.groovy.ast.expr.VariableExpression@418c5a9c[variable: doorSensor], ConstantExpression[doorState], org.codehaus.groovy.ast.expr.VariableExpression@18e36d14[variable: coopDoorStateHandler]]]]]]
coopDoorStateHandler: [If (evt.value == jammed),[(msg = WARNING $doorSensor.displayName door is jammed and did not close!)][If location.contactBookEnabled,,[If phone,,],],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing door-knocker.groovy
DECLARED METHODS
mainPage: ]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@352c1b98[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@21129f1f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5a9f4771[]]]]]
init: [(state.lastClosed = 0)][org.codehaus.groovy.ast.stmt.ExpressionStatement@282cb7c7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7d898981[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@48d61b48[org.codehaus.groovy.ast.expr.VariableExpression@68d279ec[variable: knockSensor], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@258d79be[variable: handleEvent]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@14f9390f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6c0d7c83[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@176b75f7[org.codehaus.groovy.ast.expr.VariableExpression@5965be2d[variable: openSensor], ConstantExpression[contact.closed], org.codehaus.groovy.ast.expr.VariableExpression@409c54f[variable: doorClosed]]]]]]
doorClosed: [(state.lastClosed = this.now())]]
doorKnock: [If ((openSensor.latestValue(contact) == closed) && ((this.now() - (60 * 1000)) > state.lastClosed)),[(kSensor = (knockSensor.label) ? knockSensor.label : knockSensor.name)],],]
handleEvent: [(delay = (knockDelay) ? knockDelay : 5)][org.codehaus.groovy.ast.stmt.ExpressionStatement@3e74829[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4f6f416f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3b8f0a79[org.codehaus.groovy.ast.expr.VariableExpression@71e693fa[variable: delay], ConstantExpression[doorKnock]]]]]]
send: [If (sendPushMessage != No),,],[If phone,,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: door-knocker.include() is applicable for argument types: (java.lang.String) values: [localization]
Possible solutions: installed(), evaluate(java.lang.String)
--app-start--
processing door-lock-code-distress-message.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4196c360[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@41294f8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@225129c[org.codehaus.groovy.ast.expr.VariableExpression@20435c40[variable: lock1], ConstantExpression[lock], org.codehaus.groovy.ast.expr.VariableExpression@573906eb[variable: checkCode]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@479ceda0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6d07a63d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@571c5681[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@488d1cd7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@68dc098b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@38ba6ce3[org.codehaus.groovy.ast.expr.VariableExpression@d278d2b[variable: lock1], ConstantExpression[lock], org.codehaus.groovy.ast.expr.VariableExpression@2d6c53fc[variable: checkCode]]]]]]
checkCode: [If ((evt.value == unlocked) && evt.data),[(lockData = new groovy.json.JsonSlurper().parseText(evt.data))][If discoveryMode,,],[If ((lockData.usedCode == distressCode) && (discoveryMode == false)),,],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing door-shield.groovy
DECLARED METHODS
parse: [(value = zigbee.parse(description)?.text)][(name = ((value && (value != ping))) ? response : null)][(result = this.createEvent([name:name, value:value]))]]
open: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: door-shield.metadata() is applicable for argument types: (door-shield$_run_closure1) values: [door-shield$_run_closure1@5454d35e]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing door-state-to-color-light-hue-bulb.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1ab06251[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@41ab013[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@14bee915[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1115ec15[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@82ea68c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@59e505b2[org.codehaus.groovy.ast.expr.VariableExpression@3af0a9da[variable: doorSensor], ConstantExpression[doorState], org.codehaus.groovy.ast.expr.VariableExpression@43b9fd5[variable: coopDoorStateHandler]]]]]]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
coopDoorStateHandler: [(color = White)][(hueColor = 100)][(saturation = 100)][(hClr = [:])][(hClr.hex = #FFFFFF)]]
Starting Points: []
IT HAS STATE
--app-start--
processing double-tap.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1838ccb8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6c2ed0cd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7d9e8ef7[org.codehaus.groovy.ast.expr.VariableExpression@f107c50[variable: master], ConstantExpression[switch], org.codehaus.groovy.ast.expr.VariableExpression@51133c06[variable: switchHandler], org.codehaus.groovy.ast.expr.MapExpression@4b213651[org.codehaus.groovy.ast.expr.MapEntryExpression@4241e0f4(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4ebff610[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@60410cd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@44d52de2[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@95e33cc[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@38604b81[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1e44b638[org.codehaus.groovy.ast.expr.VariableExpression@7393222f[variable: master], ConstantExpression[switch], org.codehaus.groovy.ast.expr.VariableExpression@babafc2[variable: switchHandler], org.codehaus.groovy.ast.expr.MapExpression@31add175[org.codehaus.groovy.ast.expr.MapEntryExpression@ae3540e(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]]]
switchHandler: [(recentStates = master.eventsSince(new java.util.Date((this.now() - 4000)), [all:true, max:10]).findAll({ -> ... }))][If evt.physical,[If ((evt.value == on) && this.lastTwoStatesWere(on, recentStates, evt)),,[If ((evt.value == off) && this.lastTwoStatesWere(off, recentStates, evt)),,],],,],]
onSwitches: ]
offSwitches: ]
lastTwoStatesWere: [(result = false)][If states,[(onOff = states.findAll({ -> ... }))][If onOff[0].date.before(evt.date),[log.warn(Last state does not reflect current event, evt.date: $evt.dateCreated, state.date: $onOff[0].dateCreated)][(result = ((evt.value == value) && (onOff[0].value == value)))],[(result = (((onOff.size() > 1) && (onOff[0].value == value)) && (onOff[1].value == value)))]],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing dry-the-wetspot.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@7daa0fbd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@42530531[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5a3bc7ed[org.codehaus.groovy.ast.expr.VariableExpression@181e731e[variable: sensor], ConstantExpression[water.dry], org.codehaus.groovy.ast.expr.VariableExpression@35645047[variable: waterHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6f44a157[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6bc407fd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@291f18[org.codehaus.groovy.ast.expr.VariableExpression@17d88132[variable: sensor], ConstantExpression[water.wet], org.codehaus.groovy.ast.expr.VariableExpression@5ddcc487[variable: waterHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@16eccb2e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5ef5c734[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@d771cc9[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@36b4091c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4671115f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@36cda2c2[org.codehaus.groovy.ast.expr.VariableExpression@3697186[variable: sensor], ConstantExpression[water.dry], org.codehaus.groovy.ast.expr.VariableExpression@1583741e[variable: waterHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5b367418[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@36060e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@481ba2cf[org.codehaus.groovy.ast.expr.VariableExpression@46b61c56[variable: sensor], ConstantExpression[water.wet], org.codehaus.groovy.ast.expr.VariableExpression@2e48362c[variable: waterHandler]]]]]]
waterHandler: [If (evt.value == wet),,[If (evt.value == dry),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing ecobee-sensor.groovy
DECLARED METHODS
refresh: ]
poll: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: ecobee-sensor.metadata() is applicable for argument types: (ecobee-sensor$_run_closure1) values: [ecobee-sensor$_run_closure1@6239aba6]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing ecobee-thermostat.groovy
currentState, arg not ConstantExpression
currentState, arg not ConstantExpression
DECLARED METHODS
installed: ]
ping: [(isAlive = ((device.currentValue(deviceAlive) == true)) ? true : false)][If isAlive,,],]
parse: ]
refresh: ]
poll: ]
generateEvent: [If results,[(linkText = this.getLinkText(device))][(supportedThermostatModes = [off])][(thermostatMode = null)][(locationScale = this.getTemperatureScale())][If (state.supportedThermostatModes != supportedThermostatModes),[(state.supportedThermostatModes = supportedThermostatModes)],],[If thermostatMode,[this.sendEvent([name:thermostatMode, value:thermostatMode, data:[supportedThermostatModes:state.supportedThermostatModes], linkText:linkText, ... ])],],,],]
getThermostatDescriptionText: [If (name == temperature),,[If (name == heatingSetpoint),,[If (name == coolingSetpoint),,[If (name == thermostatMode),,[If (name == thermostatFanMode),,[If (name == humidity),,[return $name = $value]],],],],],],]
setHeatingSetpoint: [If setpoint,[(state.heatingSetpoint = setpoint.toDouble())][org.codehaus.groovy.ast.stmt.ExpressionStatement@30c93896[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@59a008ba[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@338c99c8[ConstantExpression[2], ConstantExpression[updateSetpoints], org.codehaus.groovy.ast.expr.MapExpression@21ba0741[org.codehaus.groovy.ast.expr.MapEntryExpression@58ce9668(key: ConstantExpression[overwrite], value: ConstantExpression[true])]]]]],],]
setCoolingSetpoint: [If setpoint,[(state.coolingSetpoint = setpoint.toDouble())][org.codehaus.groovy.ast.stmt.ExpressionStatement@172b013[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@56673b2c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2796aeae[ConstantExpression[2], ConstantExpression[updateSetpoints], org.codehaus.groovy.ast.expr.MapExpression@b4711e2[org.codehaus.groovy.ast.expr.MapEntryExpression@1fa1cab1(key: ConstantExpression[overwrite], value: ConstantExpression[true])]]]]],],]
updateSetpoints: [(deviceScale = F)][(data = [targetHeatingSetpoint:null, targetCoolingSetpoint:null])][(heatingSetpoint = this.getTempInLocalScale(heatingSetpoint))][(coolingSetpoint = this.getTempInLocalScale(coolingSetpoint))][If state.heatingSetpoint,[(data = this.enforceSetpointLimits(heatingSetpoint, [targetValue:state.heatingSetpoint, heatingSetpoint:heatingSetpoint, coolingSetpoint:coolingSetpoint]))],],[If state.coolingSetpoint,[(heatingSetpoint = (data.targetHeatingSetpoint) ? this.getTempInLocalScale(data.targetHeatingSetpoint, deviceScale) : heatingSetpoint)][(coolingSetpoint = (data.targetCoolingSetpoint) ? this.getTempInLocalScale(data.targetCoolingSetpoint, deviceScale) : coolingSetpoint)][(data = this.enforceSetpointLimits(coolingSetpoint, [targetValue:state.coolingSetpoint, heatingSetpoint:heatingSetpoint, coolingSetpoint:coolingSetpoint]))],],[(state.heatingSetpoint = null)][(state.coolingSetpoint = null)]]
resumeProgram: [org.codehaus.groovy.ast.stmt.ExpressionStatement@70f02c32[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@62010f5c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[sendEvent] arguments: org.codehaus.groovy.ast.expr.TupleExpression@51fadaff[org.codehaus.groovy.ast.expr.NamedArgumentListExpression@401f7633[org.codehaus.groovy.ast.expr.MapEntryExpression@31ff43be(key: ConstantExpression[name], value: ConstantExpression[thermostat]), org.codehaus.groovy.ast.expr.MapEntryExpression@5b6ec132(key: ConstantExpression[value], value: ConstantExpression[resuming schedule]), org.codehaus.groovy.ast.expr.MapEntryExpression@5c44c582(key: ConstantExpression[description], value: org.codehaus.groovy.ast.expr.VariableExpression@67d18ed7[variable: statusText]), org.codehaus.groovy.ast.expr.MapEntryExpression@2c78d320(key: ConstantExpression[displayed], value: ConstantExpression[false])]]]]][(deviceId = device.deviceNetworkId.split(\.).last())][If parent.resumeProgram(deviceId),,],[org.codehaus.groovy.ast.stmt.ExpressionStatement@132e0cc[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7b205dbd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@106cc338[ConstantExpression[5], ConstantExpression[refresh], org.codehaus.groovy.ast.expr.MapExpression@7a67e3c6[org.codehaus.groovy.ast.expr.MapEntryExpression@6cc558c6(key: ConstantExpression[overwrite], value: ConstantExpression[true])]]]]]]
modes: [return state.supportedThermostatModes]]
fanModes: ]
switchMode: [(currentMode = device.currentValue(thermostatMode))][(modeOrder = this.modes())][If modeOrder,[(next = { -> ... })][(nextMode = next.call(currentMode))],],]
switchToMode: [(deviceId = device.deviceNetworkId.split(\.).last())][If parent.setMode(((mode == emergency heat)) ? auxHeatOnly : mode, deviceId),,],[org.codehaus.groovy.ast.stmt.ExpressionStatement@15713d56[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@63f259c3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@26ceffa8[ConstantExpression[5], ConstantExpression[refresh], org.codehaus.groovy.ast.expr.MapExpression@600b90df[org.codehaus.groovy.ast.expr.MapEntryExpression@7c8c9a05(key: ConstantExpression[overwrite], value: ConstantExpression[true])]]]]]]
switchFanMode: [(currentFanMode = device.currentValue(thermostatFanMode))][(fanModeOrder = this.fanModes())][(next = { -> ... })]]
switchToFanMode: [(heatingSetpoint = this.getTempInDeviceScale(heatingSetpoint))][(coolingSetpoint = this.getTempInDeviceScale(coolingSetpoint))][(deviceId = device.deviceNetworkId.split(\.).last())][(sendHoldType = (holdType) ? ((holdType == Temporary)) ? nextTransition : indefinite : indefinite)][If parent.setFanMode(heatingSetpoint, coolingSetpoint, deviceId, sendHoldType, fanMode),,],[org.codehaus.groovy.ast.stmt.ExpressionStatement@d41f816[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5c2375a9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@60129b9a[ConstantExpression[5], ConstantExpression[refresh], org.codehaus.groovy.ast.expr.MapExpression@78d6692f[org.codehaus.groovy.ast.expr.MapEntryExpression@7a55af6b(key: ConstantExpression[overwrite], value: ConstantExpression[true])]]]]]]
getDataByName: ]
setThermostatMode: [(supportedModes = this.modes())][If supportedModes,[(mode = mode.toLowerCase())][(modeIdx = supportedModes.indexOf(mode))][If (modeIdx < 0),,],[(mode = supportedModes[modeIdx])],],]
setThermostatFanMode: [(mode = mode.toLowerCase())][(supportedFanModes = this.fanModes())][(modeIdx = supportedFanModes.indexOf(mode))][If (modeIdx < 0),,],[(mode = supportedFanModes[modeIdx])]]
generateModeEvent: ]
generateFanModeEvent: ]
generateOperatingStateEvent: ]
off: ]
heat: ]
emergencyHeat: ]
cool: ]
auto: ]
fanOn: ]
fanAuto: ]
fanCirculate: ]
generateSetpointEvent: [(mode = device.currentValue(thermostatMode))][(setpoint = this.getTempInLocalScale(heatingSetpoint))][(coolingSetpoint = this.getTempInLocalScale(coolingSetpoint))][If (mode == cool),[(setpoint = coolingSetpoint)],[If ((mode == auto) || (mode == off)),[(setpoint = this.roundC(((setpoint + coolingSetpoint) / 2)))],],],]
raiseHeatingSetpoint: ]
lowerHeatingSetpoint: ]
raiseCoolSetpoint: ]
lowerCoolSetpoint: ]
alterSetpoint: [If (device.currentValue(thermostatMode) == off),,],[(locationScale = this.getTemperatureScale())][(deviceScale = F)][(heatingSetpoint = this.getTempInLocalScale(heatingSetpoint))][(coolingSetpoint = this.getTempInLocalScale(coolingSetpoint))][(targetValue = ((setpoint == heatingSetpoint)) ? heatingSetpoint : coolingSetpoint)][(delta = ((locationScale == F)) ? 1 : 0.5)][(targetValue += (raise) ? delta : delta)][(data = this.enforceSetpointLimits(setpoint, [targetValue:targetValue, heatingSetpoint:heatingSetpoint, coolingSetpoint:coolingSetpoint], raise))][If data.targetHeatingSetpoint,,],[If data.targetCoolingSetpoint,,],[org.codehaus.groovy.ast.stmt.ExpressionStatement@3d9c13b5[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@492691d7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@27216cd[ConstantExpression[5], ConstantExpression[updateSetpoint], org.codehaus.groovy.ast.expr.MapExpression@558bdf1f[org.codehaus.groovy.ast.expr.MapEntryExpression@8576fa0(key: ConstantExpression[data], value: org.codehaus.groovy.ast.expr.VariableExpression@7582ff54[variable: data]), org.codehaus.groovy.ast.expr.MapEntryExpression@67545b57(key: ConstantExpression[overwrite], value: ConstantExpression[true])]]]]]]
enforceSetpointLimits: [(locationScale = this.getTemperatureScale())][(minSetpoint = ((setpoint == heatingSetpoint)) ? device.getDataValue(minHeatingSetpointFahrenheit) : device.getDataValue(minCoolingSetpointFahrenheit))][(maxSetpoint = ((setpoint == heatingSetpoint)) ? device.getDataValue(maxHeatingSetpointFahrenheit) : device.getDataValue(maxCoolingSetpointFahrenheit))][(minSetpoint = (minSetpoint) ? java.lang.Double.parseDouble(minSetpoint) : ((setpoint == heatingSetpoint)) ? 45 : 65)][(maxSetpoint = (maxSetpoint) ? java.lang.Double.parseDouble(maxSetpoint) : ((setpoint == heatingSetpoint)) ? 79 : 92)][(deadband = (deadbandSetting) ? deadbandSetting : 5)][(delta = ((locationScale == F)) ? 1 : 0.5)][(targetValue = this.getTempInDeviceScale(data.targetValue, locationScale))][(heatingSetpoint = this.getTempInDeviceScale(data.heatingSetpoint, locationScale))][(coolingSetpoint = this.getTempInDeviceScale(data.coolingSetpoint, locationScale))][If (targetValue > maxSetpoint),[(targetValue = maxSetpoint)],[If (targetValue < minSetpoint),[(targetValue = minSetpoint)],[If ((raise != null) && (((setpoint == heatingSetpoint) && (targetValue == heatingSetpoint)) || ((setpoint == coolingSetpoint) && (targetValue == coolingSetpoint)))),[(targetValue += (raise) ? delta : delta)],],],],[If (setpoint == heatingSetpoint),[(heatingSetpoint = targetValue)][(coolingSetpoint = (((heatingSetpoint + deadband) > coolingSetpoint)) ? (heatingSetpoint + deadband) : coolingSetpoint)],],[If (setpoint == coolingSetpoint),[(coolingSetpoint = targetValue)][(heatingSetpoint = (((coolingSetpoint - deadband) < heatingSetpoint)) ? (coolingSetpoint - deadband) : heatingSetpoint)],],]
updateSetpoint: [(deviceId = device.deviceNetworkId.split(\.).last())][(sendHoldType = (holdType) ? ((holdType == Temporary)) ? nextTransition : indefinite : indefinite)][If parent.setHold(data.targetHeatingSetpoint, data.targetCoolingSetpoint, deviceId, sendHoldType),,],[org.codehaus.groovy.ast.stmt.ExpressionStatement@6c2c1385[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5f354bcf[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3daf7722[ConstantExpression[5], ConstantExpression[refresh], org.codehaus.groovy.ast.expr.MapExpression@78641d23[org.codehaus.groovy.ast.expr.MapEntryExpression@74589991(key: ConstantExpression[overwrite], value: ConstantExpression[true])]]]]]]
generateStatusEvent: [(mode = device.currentValue(thermostatMode))][(heatingSetpoint = device.currentValue(heatingSetpoint))][(coolingSetpoint = device.currentValue(coolingSetpoint))][(temperature = device.currentValue(temperature))][(statusText = Right Now: Idle)][(operatingState = idle)][If ((mode == heat) || (mode == emergency heat)),[If (temperature < heatingSetpoint),[(statusText = Heating to $heatingSetpoint$location.temperatureScale)][(operatingState = heating)],],,[If (mode == cool),[If (temperature > coolingSetpoint),[(statusText = Cooling to $coolingSetpoint$location.temperatureScale)][(operatingState = cooling)],],,[If (mode == auto),[If (temperature < heatingSetpoint),[(statusText = Heating to $heatingSetpoint$location.temperatureScale)][(operatingState = heating)],[If (temperature > coolingSetpoint),[(statusText = Cooling to $coolingSetpoint$location.temperatureScale)][(operatingState = cooling)],],],,[If (mode == off),[(statusText = Right Now: Off)],[(statusText = ?)]],],],],]
generateActivityFeedsEvent: ]
getTempInLocalScale: [(temp = device.currentState(state))][(scaledTemp = this.convertTemperatureIfNeeded(temp.value.toBigDecimal(), temp.unit).toDouble())][return ((this.getTemperatureScale() == F)) ? scaledTemp.round(0).toInteger() : this.roundC(scaledTemp)]]
getTempInLocalScale: [(scaledTemp = this.convertTemperatureIfNeeded(temp.toBigDecimal(), scale).toDouble())][return ((this.getTemperatureScale() == F)) ? scaledTemp.round(0).toInteger() : this.roundC(scaledTemp)]]
getTempInDeviceScale: [(temp = device.currentState(state))][If ((temp && temp.value) && temp.unit),,],]
getTempInDeviceScale: [If (temp && scale),[return ((F == scale)) ? temp : this.celsiusToFahrenheit(temp).toDouble().round(0).toInteger()],],]
roundC: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: ecobee-thermostat.metadata() is applicable for argument types: (ecobee-thermostat$_run_closure1) values: [ecobee-thermostat$_run_closure1@1c93f6e1]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing elder-care-daily-routine.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@e383572[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5ddf0d24[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@363a52f[org.codehaus.groovy.ast.expr.VariableExpression@60856961[variable: time1], ConstantExpression[scheduleCheck]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@2fd953a6[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@a4add54[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@141e5bef[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5f9be66c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3abada5a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@66c61024[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@61fe30[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@c9d0d6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6ccdb29f[org.codehaus.groovy.ast.expr.VariableExpression@3adcc812[variable: time1], ConstantExpression[scheduleCheck]]]]]]
scheduleCheck: [If (this.noRecentContact() && this.noRecentMotion()),[(person = (person1) ? person1 : your elder)][(msg = Alert! There has been no activity at $person's place $timePhrase)][If location.contactBookEnabled,,[If phone1,,],],,],]
noRecentMotion: [If motion1,[(motionEvents = motion1.eventsSince(sinceTime))][If motionEvents.find({ -> ... }),,],,],]
noRecentContact: [If contact1,[(contactEvents = contact1.eventsSince(sinceTime))][If contactEvents.find({ -> ... }),,],,],]
getSinceTime: [If time0,,],]
getTimePhrase: [(interval = (this.now() - sinceTime.time))][If (interval < 3600000),,[If (interval < 7200000),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing elder-care-slip-fall.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@38089a5a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@30e868be[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@66c92293[]]]]]
initialize: [(state.active = 0)][org.codehaus.groovy.ast.stmt.ExpressionStatement@332796d3[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4f0100a7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3cdf2c61[org.codehaus.groovy.ast.expr.VariableExpression@13ad5cd3[variable: bedroomMotion], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@1c33c17b[variable: bedroomActive]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5bf0fe62[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1e097d59[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@673be18f[org.codehaus.groovy.ast.expr.VariableExpression@6581dc0a[variable: bathroomMotion], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@39de3d36[variable: bathroomActive]]]]]]
bedroomActive: [(start = this.timeToday(startTime, location?.timeZone))][(stop = this.timeToday(stopTime, location?.timeZone))][(now = new java.util.Date())][log.debug(bedroomActive, status: $state.ststus, start: $start, stop: $stop, now: $now)][If (state.status == waiting),[org.codehaus.groovy.ast.stmt.ExpressionStatement@6ce86ce1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@54e7df6a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3fed2870[ConstantExpression[sendMessage]]]]][(state.status = null)],[If (start.before(now) && stop.after(now)),[(state.status = pending)],],],]
bathroomActive: [log.debug(bathroomActive, status: $state.status)][If (state.status == pending),[(delay = (threshold.toInteger() * 60))][(state.status = waiting)][org.codehaus.groovy.ast.stmt.ExpressionStatement@77128536[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@58326051[object: org.codehaus.groovy.ast.expr.VariableExpression@32c4e8b2[variable: log] method: ConstantExpression[debug] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@64bce832[org.codehaus.groovy.ast.expr.GStringExpression@764faa6[strings: [ConstantExpression[runIn(], ConstantExpression[)]] values: [org.codehaus.groovy.ast.expr.VariableExpression@4c1f22f3[variable: delay]]]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@598bd2ba[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5a755cc1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7ae42ce3[org.codehaus.groovy.ast.expr.VariableExpression@4f5991f6[variable: delay], org.codehaus.groovy.ast.expr.VariableExpression@484094a5[variable: sendMessage]]]]],],]
sendMessage: [(msg = warnMessage)][If location.contactBookEnabled,,[If phone1,,],[If phone2,,],[If phone3,,],],[(state.status = null)]]
Starting Points: []
IT HAS STATE
--app-start--
processing energy-alerts.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@41e68d87[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@49ff7d8c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@29526c05[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@2ef14fe[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@77102b91[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@45312be2[org.codehaus.groovy.ast.expr.VariableExpression@7fb95505[variable: meter], ConstantExpression[power], org.codehaus.groovy.ast.expr.VariableExpression@58be6e8[variable: meterHandler]]]]]]
meterHandler: [(meterValue = (double) evt.value)][If atomicState.lastValue,[(atomicState.lastValue = meterValue)],],[(lastValue = (double) atomicState.lastValue)][(atomicState.lastValue = meterValue)][(dUnit = (evt.unit) ? evt.unit : Watts)][(aboveThresholdValue = (int) aboveThreshold)][If (meterValue > aboveThresholdValue),[If (lastValue < aboveThresholdValue),[(msg = $meter reported $evt.value $dUnit which is above your threshold of $aboveThreshold.)],],,],[(belowThresholdValue = (int) belowThreshold)][If (meterValue < belowThresholdValue),[If (lastValue > belowThresholdValue),[(msg = $meter reported $evt.value $dUnit which is below your threshold of $belowThreshold.)],],,],]
sendMessage: [If location.contactBookEnabled,,[If sms,,],[If pushNotification,,],],]
Starting Points: []
IT HAS ATOMICSTATE
--app-start--
processing energy-saver.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@466276d8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5ce8d869[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@27eedb64[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@64c63c79[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@31c7528f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2b76ff4e[org.codehaus.groovy.ast.expr.VariableExpression@7a1234bf[variable: meter], ConstantExpression[power], org.codehaus.groovy.ast.expr.VariableExpression@2f62ea70[variable: meterHandler]]]]]]
meterHandler: [(meterValue = (double) evt.value)][(thresholdValue = (int) threshold)][If (meterValue > thresholdValue),,],]
Starting Points: []
IT HAS ATOMICSTATE
--app-start--
processing enhanced-auto-lock-door.groovy
DECLARED METHODS
mainPage: ]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6f63b475[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@554e218[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1608bcbd[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5bf8fa12[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@29ca3d04[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@b2c5e07[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5812f68b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4426bff1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3c7c886c[org.codehaus.groovy.ast.expr.VariableExpression@55493582[variable: lock1], ConstantExpression[lock], org.codehaus.groovy.ast.expr.VariableExpression@1a20270e[variable: doorHandler], org.codehaus.groovy.ast.expr.MapExpression@6b88ca8c[org.codehaus.groovy.ast.expr.MapEntryExpression@336f1079(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2f16c6b3[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@34158c08[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@19e4fcac[org.codehaus.groovy.ast.expr.VariableExpression@52c3cb31[variable: lock1], ConstantExpression[unlock], org.codehaus.groovy.ast.expr.VariableExpression@4b79ac84[variable: doorHandler], org.codehaus.groovy.ast.expr.MapExpression@53941c2f[org.codehaus.groovy.ast.expr.MapEntryExpression@6dab9b6d(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@21fd5faa[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2766ca9d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5460cf3a[org.codehaus.groovy.ast.expr.VariableExpression@65a15628[variable: contact], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@2e6a5539[variable: doorHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3fc9504b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6d025197[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@27d4a09[org.codehaus.groovy.ast.expr.VariableExpression@7e4204e2[variable: contact], ConstantExpression[contact.closed], org.codehaus.groovy.ast.expr.VariableExpression@b7c4869[variable: doorHandler]]]]]]
lockDoor: [If location.contactBookEnabled,[If recipients,,],,],[If phoneNumber,,],]
unlockDoor: [If location.contactBookEnabled,[If recipients,,],,],[If phoneNumber,,],]
doorHandler: [If ((contact.latestValue(contact) == open) && (evt.value == locked)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@740d2e78[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1c481ff2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@72437d8d[org.codehaus.groovy.ast.expr.VariableExpression@1b955cac[variable: secondsLater], org.codehaus.groovy.ast.expr.VariableExpression@676cf48[variable: unlockDoor]]]]],[If ((contact.latestValue(contact) == open) && (evt.value == unlocked)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@5a1de7fb[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@335b5620[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@29a0cdb[org.codehaus.groovy.ast.expr.VariableExpression@32a68f4f[variable: unlockDoor]]]]],[If ((contact.latestValue(contact) == closed) && (evt.value == locked)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@73194df[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6eb2384f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3c9c0d96[org.codehaus.groovy.ast.expr.VariableExpression@3a4621bd[variable: lockDoor]]]]],[If ((contact.latestValue(contact) == closed) && (evt.value == unlocked)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@31dadd46[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4ed5eb72[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@12f9af83[org.codehaus.groovy.ast.expr.BinaryExpression@19b93fa8[org.codehaus.groovy.ast.expr.VariableExpression@7e6ef134[variable: minutesLater]("*" at 105:30:  "*" )ConstantExpression[60]], org.codehaus.groovy.ast.expr.VariableExpression@1f010bf0[variable: lockDoor]]]]],[If ((lock1.latestValue(lock) == unlocked) && (evt.value == open)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@40db2a24[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@10cf09e8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1921ad94[org.codehaus.groovy.ast.expr.VariableExpression@ee86bcb[variable: lockDoor]]]]],[If ((lock1.latestValue(lock) == unlocked) && (evt.value == closed)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@177bea38[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7f132176[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6bca7e0d[org.codehaus.groovy.ast.expr.BinaryExpression@2631f68c[org.codehaus.groovy.ast.expr.VariableExpression@6ed3f258[variable: minutesLater]("*" at 112:30:  "*" )ConstantExpression[60]], org.codehaus.groovy.ast.expr.VariableExpression@8ad6665[variable: lockDoor]]]]],[If location.contactBookEnabled,[If recipients,,],,],[If phoneNumber,,],],],],],],],]
Starting Points: [this.runIn(secondsLater, unlockDoor), this.unschedule(unlockDoor), this.unschedule(lockDoor), this.runIn((minutesLater * 60), lockDoor), this.unschedule(lockDoor), this.runIn((minutesLater * 60), lockDoor)]
IT HAS ATOMICSTATE
--app-start--
processing every-element.groovy
DECLARED METHODS
firstPage: ]
inputPage: ]
inputBooleanPage: ]
inputIconPage: ]
inputImagePage: ]
optionsGroup: [(group = [values:[], order:groups.size()])][(group.title = (title) ? title : )]]
addValues: [(lastGroup = groups[-1])]]
listToMap: ]
addGroup: [If (values instanceof java.util.List),[(values = this.listToMap(values))],],]
addGroup: ]
inputSelectionPage: [(englishOptions = [One, Two, Three])][(spanishOptions = [Uno, Dos, Tres])][(groupedOptions = [])]]
inputTextPage: ]
inputTimePage: ]
inputDevicePage: ]
inputCapabilityPage: ]
inputRoomPage: ]
inputModePage: ]
inputHubPage: ]
inputContactBookPage: ]
appPage: ]
labelPage: ]
modePage: ]
paragraphPage: ]
hrefPage: ]
buttonsPage: ]
imagePage: ]
videoPage: ]
flattenedPage: [(allSections = [])][(flattenedPage = this.dynamicPage([name:flattenedPage, title:All elements in one page!], { -> ... }))][(flattenedPage.sections = allSections)]]
foo: ]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@63787180[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7d1cfb8b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@48e92c5c[]]]]]
initialize: ]
Starting Points: []
IT HAS ATOMICSTATE
--app-start--
processing feed-my-pet.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1b7c473a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5e4bd84a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@648c94da[org.codehaus.groovy.ast.expr.VariableExpression@2a62b5bc[variable: time1], ConstantExpression[scheduleCheck]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@53de625d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@535779e4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@53fd0d10[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6c0d9d86[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4ce1d6d0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@24111ef1[org.codehaus.groovy.ast.expr.VariableExpression@1f3f02ee[variable: time1], ConstantExpression[scheduleCheck]]]]]]
scheduleCheck: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1fde5d22[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5dcb4f5f[object: org.codehaus.groovy.ast.expr.VariableExpression@71812481[variable: log] method: ConstantExpression[trace] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@16ce702d[ConstantExpression[scheduledFeeding]]]]]]
Starting Points: [log.trace(scheduledFeeding)]
IT HAS ATOMICSTATE
--app-start--
processing fidure-thermostat.groovy
DECLARED METHODS
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
getMin: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
getMax: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parse: [(result = [])][If description?.startsWith(read attr -),[(descMap = this.parseDescriptionAsMap(description))][For descMap.attrs,[(map = [:])][If (descMap.cluster == 0201),,[If (descMap.cluster == 0204),[If (atMap.attrId == 0001),[(map.name = lockLevel)][(map.value = this.getLockMap()[atMap.value])],],,],],[If map,[(result += this.createEvent(map))],],][(descMap = this.parseDescriptionAsMap(description))][For descMap.attrs,[(map = [:])][If (descMap.cluster == 0201),,[If (descMap.cluster == 0204),[If (atMap.attrId == 0001),[(map.name = lockLevel)][(map.value = this.getLockMap()[atMap.value])],],,],],[If map,[(result += this.createEvent(map))],],],],]
parseDescriptionAsMap: [(map = (description - read attr - ).split(,).inject([:], { java.lang.Object map, java.lang.Object param -> ... }))][(attrId = map.get(attrId))][(encoding = map.get(encoding))][(value = map.get(value))][(result = map.get(result))][(list = [])][If (this.getDataLengthByType(map.get(encoding)) < map.get(value).length()),[(raw = map.get(raw))][(size = java.lang.Long.parseLong(( + map.get(size)), 16))][(index = 12)][(len = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While ((index - 12) < size),[(attrId = this.flipHexStringEndianness(raw[(index..(index + 3))]))][(index += 4)][If (result == success),[(index += 2)],],[(encoding = raw[(index..(index + 1))])][(index += 2)][(len = this.getDataLengthByType(encoding))][(value = this.flipHexStringEndianness(raw[(index..((index + len) - 1))]))][(index += len)][(list += [attrId:$attrId, encoding:$encoding, value:$value])]][(raw = map.get(raw))][(size = java.lang.Long.parseLong(( + map.get(size)), 16))][(index = 12)][(len = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While ((index - 12) < size),[(attrId = this.flipHexStringEndianness(raw[(index..(index + 3))]))][(index += 4)][If (result == success),[(index += 2)],],[(encoding = raw[(index..(index + 1))])][(index += 2)][(len = this.getDataLengthByType(encoding))][(value = this.flipHexStringEndianness(raw[(index..((index + len) - 1))]))][(index += len)][(list += [attrId:$attrId, encoding:$encoding, value:$value])]],[(list += [attrId:$attrId, encoding:$encoding, value:$value])]],[(map += [attrs:list])]]
flipHexStringEndianness: [(s = s.reverse())][(sb = new java.lang.StringBuilder())][For ((i = 0); (i < (s.length() - 1)); (i += 2)),]flipHexStringEndianness: [(s = s.reverse())][(sb = new java.lang.StringBuilder())][For ((i = 0); (i < (s.length() - 1)); (i += 2)),]]
getDataLengthByType: [(map = [08:1, 09:2, 0a:3, 0b:4, 0c:5, 0d:6, 0e:7, 0f:8, 10:1, 18:1, 19:2, 1a:3, 1b:4, 1c:5, 1d:6, 1e:7, 1f:8, 20:1, 21:2, 22:3, 23:4, ... ])]]
getProgrammingMap: ]
getModeMap: ]
getFanModeMap: ]
getHoldMap: ]
updateSetpoint: [(cool = device.currentState(coolingSetpoint)?.value)][(heat = device.currentState(heatingSetpoint)?.value)][(runningMode = device.currentState(runningMode)?.value)][(mode = device.currentState(thermostatMode)?.value)][(value = --)][If ((heat == mode) && (heat != null)),[(value = heat)],[If ((cool == mode) && (cool != null)),[(value = cool)],[If (((auto == mode) && (runningMode == cool)) && (cool != null)),[(value = cool)],[If (((auto == mode) && (runningMode == heat)) && (heat != null)),[(value = heat)],],],],],]
raiseSetpoint: ]
lowerSetpoint: ]
adjustSetpoint: [(runningMode = device.currentState(runningMode)?.value)][(mode = device.currentState(thermostatMode)?.value)][(modeData = 2)][If ((heat == mode) || (heat == runningMode)),[(modeData = 00)],[If ((cool == mode) || (cool == runningMode)),[(modeData = 01)],],],[(amountData = java.lang.String.format(%02X, value)[(-2..-1)])]]
getDisplayTemperature: [(t = java.lang.Integer.parseInt($value, 16))][If (this.getTemperatureScale() == C),[(t = ((java.lang.Integer -> java.lang.Integer) ((t + 4) / 10) / 10))],[(t = ((java.lang.Integer -> java.lang.Integer) (10 * this.celsiusToFahrenheit((t / 100))) / 10))]],]
updateHoldLabel: [(currentHold = (device?.currentState(setpointHold)?.value) ? device?.currentState(setpointHold)?.value : ...)][(holdExp = device?.currentState(holdExpiary)?.value)][(holdExp = (holdExp) ? holdExp : $new Date().getTime())][If (Hold == attr),[(currentHold = value)],],[If (HoldExp == attr),[(holdExp = value)],],[(past = (new java.util.Date(holdExp.toLong()).getTime() < new java.util.Date().getTime()))][If (HoldExp == attr),[If past,[(currentHold = On)],[(currentHold = Off)]],,],[(holdString = ((currentHold == On)) ? (past) ? Is On : Ends $this.compareWithNow(holdExp.toLong()) : ((currentHold == Off)) ?  is Off :  ...)]]
getSetPointHoldDuration: [(holdTime = 0)][If settings.hold_time?.contains(Hours),[(holdTime = java.lang.Integer.parseInt(settings.hold_time[(0..1)].trim()))],[If settings.hold_time?.contains(Day),[(holdTime = (java.lang.Integer.parseInt(settings.hold_time[(0..1)].trim()) * 24))],],],[(currentHoldDuration = device.currentState(setpointHoldDuration)?.value)][If (java.lang.Short.parseShort((0 + (currentHoldDuration) ? currentHoldDuration : 0)) != (holdTime * 60)),,],]
Hold: [(currentHold = device.currentState(setpointHold)?.value)][(next = ((currentHold == On)) ? 00 : 01)][(nextHold = this.getHoldMap()[next])]]
compareWithNow: [(mins = (new java.util.Date(d).getTime() - new java.util.Date().getTime()))][(mins /= (1000 * 60))][(past = (mins < 0))][(ret = (past) ?  : in )][If past,[(mins *= -1)],],[(t = 0)][If (mins < 60),[(ret += (((java.lang.Integer -> java.lang.Integer) mins +  min) + ((mins > 1)) ? s : ))],[If (mins < 1440),[(t = ((java.lang.Integer -> java.lang.Integer) java.lang.Math.round(((14 + mins) / 30)) / 2))][(ret += ((t +  hr) + ((t > 1)) ? s : ))],[(t = ((java.lang.Integer -> java.lang.Integer) java.lang.Math.round(((359 + mins) / 720)) / 2))][(ret += ((t +  day) + ((t > 1)) ? s : ))]],],[(ret += (past) ?  ago : )]]
convertToTime: [(time = (long) java.lang.Integer.parseInt($data, 16))][(time *= 1000)][(time += 946684800000)][(time -= (location.timeZone.getRawOffset() + location.timeZone.getDSTSavings()))][(d = new java.util.Date(time))]]
Program: [(currentSched = device.currentState(prorgammingOperation)?.value)][(next = java.lang.Integer.parseInt((currentSched) ? currentSched : 00, 16))][If ((next & 1) == 1),[(next = (next & 254))],[(next = (next | 1))]],[(nextSched = this.getProgrammingMap()[(next & 1)])]]
getThermostatOperatingState: [(m = [heating, cooling, fan, Heat2, Cool2, Fan2, Fan3])][(desc = idle)][(value = java.lang.Integer.parseInt(( + value), 16))][For (0..2),[If (value & (1 << i)),[(desc = m[i])],],]getThermostatOperatingState: [(m = [heating, cooling, fan, Heat2, Cool2, Fan2, Fan3])][(desc = idle)][(value = java.lang.Integer.parseInt(( + value), 16))][For (0..2),[If (value & (1 << i)),[(desc = m[i])],],]]
checkLastTimeSync: [(lastSync = device.currentState(lastTimeSync)?.value)][If lastSync,[(lastSync = $new Date(0))],],[If (settings.sync_clock) ? settings.sync_clock : (false && (lastSync != new java.util.Date(0))),,],[(duration = (new java.util.Date().getTime() - new java.util.Date(lastSync).getTime()))][If (duration > 86400000),,],]
readAttributesCommand: [(attrString = )][For attribList,[(attrString += (  + java.lang.String.format(%02X %02X, (val & 255), ((val >> 8) & 255))))]]readAttributesCommand: [(attrString = )][For attribList,[(attrString += (  + java.lang.String.format(%02X %02X, (val & 255), ((val >> 8) & 255))))]]]
refresh: ]
poll: ]
getTemperature: [(celsius = (java.lang.Integer.parseInt($value, 16) / 100))][If (this.getTemperatureScale() == C),,],]
setHeatingSetpoint: [(temperatureScale = this.getTemperatureScale())][(degreesInteger = (java.lang.Integer -> java.lang.Integer) degrees)][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))]]
setCoolingSetpoint: [(degreesInteger = (java.lang.Integer -> java.lang.Integer) degrees)][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))]]
modes: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
setThermostatFanMode: [(currentFanMode = device.currentState(thermostatFanMode)?.value)][(returnCommand = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)]]
setThermostatMode: [(currentMode = device.currentState(thermostatMode)?.value)][(modeOrder = this.modes())][(index = modeOrder.indexOf(currentMode))][(next = (((index >= 0) && (index < (modeOrder.size() - 1)))) ? modeOrder[(index + 1)] : modeOrder[0])]]
setThermostatMode: [(val = (this.getModeMap().find({ -> ... })?.key) ? this.getModeMap().find({ -> ... })?.key : 00)]]
setThermostatFanMode: ]
off: ]
cool: ]
heat: ]
auto: ]
on: ]
fanOn: ]
fanAuto: ]
updated: [(lastSync = device.currentState(lastTimeSync)?.value)][If ((settings.sync_clock) ? settings.sync_clock : false == false),,],]
getLockMap: ]
lock: [(currentLock = device.currentState(lockLevel)?.value)][(val = this.getLockMap().find({ -> ... })?.key)][If (val == 00),[(val = this.getLockMap().find({ -> ... })?.key)],[(val = 00)]],]
setThermostatTime: [If (settings.sync_clock) ? settings.sync_clock : false,,],[(date = new java.util.Date())][(zone = ((location.timeZone.getRawOffset() +  DST ) + location.timeZone.getDSTSavings()))][(millis = date.getTime())][(millis -= 946684800000)][(millis += (location.timeZone.getRawOffset() + location.timeZone.getDSTSavings()))][(millis /= 1000)][(s = java.lang.String.format(%08X, millis))][(data = (((((((  + s.substring(6, 8)) +  ) + s.substring(4, 6)) +  ) + s.substring(2, 4)) +  ) + s.substring(0, 2)))]]
configure: ]
hex: ]
getEndpointId: ]
Starting Points: []
IT HAS ATOMICSTATE
missing method: groovy.lang.MissingMethodException: No signature of method: fidure-thermostat.metadata() is applicable for argument types: (fidure-thermostat$_run_closure1) values: [fidure-thermostat$_run_closure1@294a6b8e]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing flood-alert.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6fb365ed[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6e950bcf[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@16414e40[org.codehaus.groovy.ast.expr.VariableExpression@74bada02[variable: alarm], ConstantExpression[water.wet], org.codehaus.groovy.ast.expr.VariableExpression@525575[variable: waterWetHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@46dffdc3[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5a709816[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@78383390[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6ad3381f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@53dbe163[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@db57326[org.codehaus.groovy.ast.expr.VariableExpression@34a875b3[variable: alarm], ConstantExpression[water.wet], org.codehaus.groovy.ast.expr.VariableExpression@4748a0f9[variable: waterWetHandler]]]]]]
waterWetHandler: [(deltaSeconds = 60)][(timeAgo = new java.util.Date((this.now() - (1000 * deltaSeconds))))][(recentEvents = alarm.eventsSince(timeAgo))][(alreadySentSms = (recentEvents.count({ -> ... }) > 1))][If alreadySentSms,,[(msg = $alarm.displayName is wet!)][If location.contactBookEnabled,,[If phone,,],],],]
Starting Points: []
IT HAS ATOMICSTATE
--app-start--
processing forgiving-security.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@31bcf236[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4b3ed2f0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4fad9bb2[]]]]]
init: [(state.lastTrigger = this.now())][(state.deviceTriggers = [])][org.codehaus.groovy.ast.stmt.ExpressionStatement@517d4a0d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7862f56[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3a12c404[org.codehaus.groovy.ast.expr.VariableExpression@1941a8ff[variable: contacts], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@22d7b4f8[variable: triggerAlarm]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@149dd36b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@38831718[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2c1156a7[org.codehaus.groovy.ast.expr.VariableExpression@33fe57a9[variable: motions], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@4982cc36[variable: triggerAlarm]]]]]]
triggerAlarm: [(presenceDelay = (presenceDelay) ? presenceDelay : 15)][If ((this.now() - (presenceDelay * 1000)) > state.lastTrigger),[(state.deviceTriggers = [])],],[state.deviceTriggers.add(evt.displayName)][(state.triggerMode = location.mode)][(state.lastTrigger = this.now())][org.codehaus.groovy.ast.stmt.ExpressionStatement@691939c9[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4f1bfe23[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@e19bb76[org.codehaus.groovy.ast.expr.VariableExpression@512535ff[variable: presenceDelay], ConstantExpression[fireAlarm]]]]]]
fireAlarm: [If (state.deviceTriggers.size() > 0),[(devices = state.deviceTriggers.unique().join(, ))][If (location.mode == state.triggerMode),,],,],[(state.deviceTriggers = [])]]
send: [(delay = (((messageDelay != null) && (messageDelay != ))) ? ((messageDelay * 60) * 1000) : 0)][If ((this.now() - delay) > state.lastMessage),[(state.lastMessage = this.now())][If (sendPushMessage == Yes),,],[If phone,,],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing garage-door-monitor.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@41d426b5[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@8dbfffb[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@f316aeb[org.codehaus.groovy.ast.expr.VariableExpression@6aa3a905[variable: multisensor], ConstantExpression[acceleration], org.codehaus.groovy.ast.expr.VariableExpression@a22cb6a[variable: accelerationHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5dd1c9f2[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@59b38691[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2e2ff723[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@324a0017[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6187d1f5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2445445a[org.codehaus.groovy.ast.expr.VariableExpression@7502291e[variable: multisensor], ConstantExpression[acceleration], org.codehaus.groovy.ast.expr.VariableExpression@17aad511[variable: accelerationHandler]]]]]]
accelerationHandler: [(latestThreeAxisState = multisensor.threeAxisState)][If latestThreeAxisState,[(isOpen = (java.lang.Math.abs(latestThreeAxisState.xyzValue.z) > 250))][(isNotScheduled = (state.status != scheduled))][If isOpen,,],[If (isOpen && isNotScheduled),[org.codehaus.groovy.ast.stmt.ExpressionStatement@487db668[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@46944ca9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@22bac7bc[org.codehaus.groovy.ast.expr.BinaryExpression@63798ca7[org.codehaus.groovy.ast.expr.VariableExpression@4612b856[variable: maxOpenTime]("*" at 64:22:  "*" )ConstantExpression[60]], org.codehaus.groovy.ast.expr.VariableExpression@22875539[variable: takeAction], org.codehaus.groovy.ast.expr.MapExpression@5674e1f2[org.codehaus.groovy.ast.expr.MapEntryExpression@79c7532f(key: ConstantExpression[overwrite], value: ConstantExpression[false])]]]]][(state.status = scheduled)],],,],]
takeAction: [If (state.status == scheduled),[(deltaMillis = ((1000 * 60) * maxOpenTime))][(timeAgo = new java.util.Date((this.now() - deltaMillis)))][(openTooLong = (multisensor.threeAxisState.dateCreated.toSystemDate() < timeAgo))][(recentTexts = state.smsHistory.find({ -> ... }))][If recentTexts,,],[org.codehaus.groovy.ast.stmt.ExpressionStatement@2a448449[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@32f232a5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@43f82e78[org.codehaus.groovy.ast.expr.BinaryExpression@e54303[org.codehaus.groovy.ast.expr.VariableExpression@e8df99a[variable: maxOpenTime]("*" at 86:21:  "*" )ConstantExpression[60]], org.codehaus.groovy.ast.expr.VariableExpression@2dc995f4[variable: takeAction], org.codehaus.groovy.ast.expr.MapExpression@2f40e5db[org.codehaus.groovy.ast.expr.MapEntryExpression@517566b(key: ConstantExpression[overwrite], value: ConstantExpression[false])]]]]],[org.codehaus.groovy.ast.stmt.ExpressionStatement@64b73e7a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@530712d[object: org.codehaus.groovy.ast.expr.VariableExpression@2df6226d[variable: log] method: ConstantExpression[trace] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@12ed9db6[ConstantExpression[Status is no longer scheduled. Not sending text.]]]]]],]
sendTextMessage: [(openMinutes = (maxOpenTime * (state.smsHistory?.size()) ? state.smsHistory?.size() : 1))][(msg = Your $(multisensor.label) ? multisensor.label : multisensor.name has been open for more than $openMinutes minutes!)][If location.contactBookEnabled,,[If phone,,],],]
updateSmsHistory: [If state.smsHistory,[(state.smsHistory = [])],],[If (state.smsHistory.size() > 9),[(state.smsHistory = state.smsHistory[(-9..-1)])],],[(state.smsHistory << [sentDate:new java.util.Date().toSystemFormat()])]]
clearSmsHistory: [(state.smsHistory = null)]]
clearStatus: [(state.status = null)]]
Starting Points: []
IT HAS STATE
--app-start--
processing garage-door-opener.groovy
subscribeToCommand
subscribeToCommand
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@b1712f3[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6986bbaf[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4879dfad[org.codehaus.groovy.ast.expr.VariableExpression@4758820d[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@74eb909f[variable: appTouchHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@28ec166e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2eee3069[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToCommand] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2da59753[org.codehaus.groovy.ast.expr.VariableExpression@5629510[variable: switch1], ConstantExpression[on], org.codehaus.groovy.ast.expr.VariableExpression@4df5bcb4[variable: onCommand]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@12c7a01b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@13d9b21f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2826f61[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@62727399[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4d9ac0b4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@130dca52[org.codehaus.groovy.ast.expr.VariableExpression@2654635[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@737a135b[variable: appTouchHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@687ef2e0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@15dcfae7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToCommand] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3da05287[org.codehaus.groovy.ast.expr.VariableExpression@1e636ea3[variable: switch1], ConstantExpression[on], org.codehaus.groovy.ast.expr.VariableExpression@115667d[variable: onCommand]]]]]]
appTouch: ]
onCommand: ]
Starting Points: []
IT HAS STATE
--app-start--
processing gentle-wake-up-controller.groovy
DECLARED METHODS
parse: ]
on: ]
off: ]
setTimeRemaining: ]
start: ]
stop: ]
pause: ]
cancel: ]
startDimming: ]
stopDimming: ]
controllerEvent: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: gentle-wake-up-controller.metadata() is applicable for argument types: (gentle-wake-up-controller$_run_closure1) values: [gentle-wake-up-controller$_run_closure1@39fcbef6]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing gentle-wake-up.groovy
DECLARED METHODS
rootPage: ]
unsupportedDevicesPage: [(unsupportedDimmers = dimmers.findAll({ -> ... }))]]
controllerExplanationPage: ]
numbersPage: ]
defaultStart: [If ((this.usesOldSettings() && direction) && (direction == Down)),,],]
defaultEnd: [If ((this.usesOldSettings() && direction) && (direction == Down)),,],]
startLevelLabel: [If this.usesOldSettings(),[If (direction && (direction == Down)),,],,],]
endLevelLabel: [If this.usesOldSettings(),[If (direction && (direction == Down)),,],,],]
weekdays: ]
weekends: ]
schedulingPage: ]
completionPage: ]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@35f26e72[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2d6764b2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@67304a40[]]]][(controller = this.getController())][If controller,[(controller.label = app.label)],],]
initialize: [If startTime,[org.codehaus.groovy.ast.stmt.ExpressionStatement@49c6c24f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6fe1b4fb[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@79351f41[org.codehaus.groovy.ast.expr.VariableExpression@1c32386d[variable: startTime], ConstantExpression[scheduledStart]]]]],],[org.codehaus.groovy.ast.stmt.ExpressionStatement@6399551e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@13d73fa[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5023bb8b[org.codehaus.groovy.ast.expr.VariableExpression@5d5f10b2[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@74c79fa2[variable: appHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1e0f9063[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@53bd8fca[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7642df8f[org.codehaus.groovy.ast.expr.VariableExpression@3e30646a[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@5cde6747[variable: locationHandler]]]]][If manualOverride,[org.codehaus.groovy.ast.stmt.ExpressionStatement@63a270c9[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@37c7595[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3ed242a4[org.codehaus.groovy.ast.expr.VariableExpression@1199fe66[variable: dimmers], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@614df0a4[variable: stopDimmersHandler]]]]],],[If this.getAllChildDevices(),[(dni = $new Date().getTime())][(state.controllerDni = dni)],],]
appHandler: [If (evt.value == touch),[If atomicState.running,,],,],]
locationHandler: [If modeStart,,],[(isSpecifiedMode = (evt.value == modeStart))][(modeStopIsTrue = (modeStop && (modeStop != false)))][If (isSpecifiedMode && this.canStartAutomatically()),,[If (isSpecifiedMode && modeStopIsTrue),,],],]
stopDimmersHandler: [(percentComplete = this.completionPercentage())][If ((percentComplete > 2) && (percentComplete < 98)),[If (manualOverride == cancel),,[If (manualOverride == jumpTo),[(end = this.dynamicEndLevel())],],],,],]
scheduledStart: [If this.canStartAutomatically(),[org.codehaus.groovy.ast.stmt.ExpressionStatement@1fdf1c5[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2d96543c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[start] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@73a2e526[ConstantExpression[schedule]]]]],],]
start: [(atomicState.running = true)][(atomicState.runCounter = 0)][(atomicState.start = new java.util.Date().getTime())][org.codehaus.groovy.ast.stmt.ExpressionStatement@7d64e326[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@13f95696[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@cd1d761[ConstantExpression[0 * * * * ?], ConstantExpression[healthCheck]]]]]]
stop: [(atomicState.running = false)][(atomicState.start = 0)][(atomicState.runCounter = 0)][org.codehaus.groovy.ast.stmt.ExpressionStatement@68be8808[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@32193bea[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6b8d96d9[ConstantExpression[healthCheck]]]]]]
healthCheck: [If atomicState.running,,],]
sendStartEvent: [(eventData = [name:sessionStatus, value:running, descriptionText:$app.label has started dimming, displayed:true, linkText:app.label, isStateChange:true])][If (source == modeChange),[(eventData.descriptionText +=  because of a mode change)],[If (source == schedule),[(eventData.descriptionText +=  as scheduled)],[If (source == appTouch),[(eventData.descriptionText +=  because you pressed play on the app)],[If (source == controller),[(eventData.descriptionText +=  because you pressed play on the controller)],],],],],]
sendStopEvent: [(eventData = [name:sessionStatus, value:stopped, descriptionText:$app.label has stopped dimming, displayed:true, linkText:app.label, isStateChange:true])][If (source == modeChange),[(eventData.descriptionText +=  because of a mode change)][(eventData.value += cancelled)],[If (source == schedule),[(eventData.descriptionText = $app.label has finished dimming)],[If (source == appTouch),[(eventData.descriptionText +=  because you pressed play on the app)][(eventData.value += cancelled)],[If (source == controller),[(eventData.descriptionText +=  because you pressed stop on the controller)][(eventData.value += cancelled)],[If (source == settingsChange),[(eventData.descriptionText +=  because the settings have changed)][(eventData.value += cancelled)],[If (source == manualOverride),[(eventData.descriptionText +=  because the dimmer was manually turned off)][(eventData.value += cancelled)],],],],],],],]
sendTimeRemainingEvent: [(percentCompleteEventData = [name:percentComplete, value:(int) percentComplete, displayed:displayed, isStateChange:true])][(duration = this.sanitizeInt(duration, 30))][(timeRemaining = (duration - (duration * (percentComplete / 100))))][(timeRemainingEventData = [name:timeRemaining, value:this.displayableTime(timeRemaining), displayed:displayed, isStateChange:true])]]
sendControllerEvent: [(controller = this.getController())][If controller,,],]
getController: [(dni = state.controllerDni)][If dni,,],[(controller = this.getChildDevice(dni))][If controller,,],]
increment: [If atomicState.running,,],[If (atomicState.runCounter == null),[(atomicState.runCounter = 1)],[(atomicState.runCounter = (atomicState.runCounter + 1))]],[(percentComplete = this.completionPercentage())][If (percentComplete > 99),[(percentComplete = 99)],],[If (atomicState.runCounter > 100),[(percentComplete = 100)],],[If (percentComplete < 99),[(runAgain = this.stepDuration())][org.codehaus.groovy.ast.stmt.ExpressionStatement@69653e16[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@758705fa[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@ebaa6cb[org.codehaus.groovy.ast.expr.VariableExpression@906d29b[variable: runAgain], ConstantExpression[increment], org.codehaus.groovy.ast.expr.MapExpression@49d3c823[org.codehaus.groovy.ast.expr.MapEntryExpression@436bc36(key: ConstantExpression[overwrite], value: ConstantExpression[true])]]]]],[(completionDelay = this.completionDelaySeconds())][If completionDelay,[org.codehaus.groovy.ast.stmt.ExpressionStatement@5fe1ce85[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@604c5de8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@37091312[org.codehaus.groovy.ast.expr.VariableExpression@66fdec9[variable: completionDelay type: java.lang.Integer], ConstantExpression[completion], org.codehaus.groovy.ast.expr.MapExpression@57abad67[org.codehaus.groovy.ast.expr.MapEntryExpression@550a1967(key: ConstantExpression[overwrite], value: ConstantExpression[true])]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2a640157[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@52851b44[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@584f54e6[ConstantExpression[healthCheck]]]]],],],]
updateDimmers: ]
dynamicLevel: [(start = atomicState.startLevels[dimmer.id])][(end = this.dynamicEndLevel())][If percentComplete,,],[(totalDiff = (end - start))][(actualPercentage = (percentComplete / 100))][(percentOfTotalDiff = (totalDiff * actualPercentage))]]
completion: [If atomicState.running,,],[org.codehaus.groovy.ast.stmt.ExpressionStatement@5d8bafa9[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@576f63f6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[stop] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2dca0d64[ConstantExpression[schedule]]]]]]
handleCompletionSwitches: ]
handleCompletionMessaging: [If completionMessage,[If location.contactBookEnabled,,[If completionPhoneNumber,,],[If completionPush,,],],[If completionMusicPlayer,,],,],]
handleCompletionModesAndPhrases: [If completionMode,,],[If completionPhrase,,],]
speak: [(sound = this.textToSpeech(message))][(soundDuration = ((java.lang.Integer -> java.lang.Integer) sound.duration + 2))][org.codehaus.groovy.ast.stmt.ExpressionStatement@f80945f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@ff684e1[object: org.codehaus.groovy.ast.expr.VariableExpression@23aa363a[variable: log] method: ConstantExpression[debug] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5ef6ae06[org.codehaus.groovy.ast.expr.GStringExpression@55dfebeb[strings: [ConstantExpression[Scheduled resume in ], ConstantExpression[ sec]] values: [org.codehaus.groovy.ast.expr.VariableExpression@6e35bc3d[variable: soundDuration]]]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1cdc4c27[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@77b14724[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5d9b7a8a[org.codehaus.groovy.ast.expr.VariableExpression@1e8ce150[variable: soundDuration], org.codehaus.groovy.ast.expr.VariableExpression@604f2bd2[variable: resumePlaying], org.codehaus.groovy.ast.expr.MapExpression@1d3ac898[org.codehaus.groovy.ast.expr.MapEntryExpression@1b73be9f(key: ConstantExpression[overwrite], value: ConstantExpression[true])]]]]]]
resumePlaying: [(sonos = completionMusicPlayer)][If sonos,[(currentTrack = sonos.currentState(trackData).jsonValue)][If (currentTrack.status == playing),,],,],]
setLevelsInState: [(startLevels = [:])][(atomicState.startLevels = startLevels)]]
canStartAutomatically: [(today = new java.util.Date().format(EEEE))][If (days || days.contains(today)),,],]
completionPercentage: [If atomicState.running,,],[(now = new java.util.Date().getTime())][(timeElapsed = (now - atomicState.start))][(totalRunTime = (this.totalRunTimeMillis()) ? this.totalRunTimeMillis() : 1)][(percentComplete = ((timeElapsed / totalRunTime) * 100))]]
totalRunTimeMillis: [(minutes = this.sanitizeInt(duration, 30))]]
convertToMillis: [(seconds = (minutes * 60))][(millis = (seconds * 1000))]]
timeRemaining: [(normalizedPercentComplete = (percentComplete / 100))][(duration = this.sanitizeInt(duration, 30))][(timeElapsed = (duration * normalizedPercentComplete))][(timeRemaining = (duration - timeElapsed))]]
millisToEnd: ]
displayableTime: [(timeString = $timeRemaining)][(parts = timeString.split(\.))][If parts.size(),,],[(minutes = parts[0])][If (parts.size() == 1),,],[(fraction = (double) 0.$parts[1])][(seconds = $(int) (60 * fraction).padLeft(2, 0))]]
jumpTo: [(millisToEnd = this.millisToEnd(percentComplete))][(endTime = (new java.util.Date().getTime() + millisToEnd))][(duration = this.sanitizeInt(duration, 30))][(durationMillis = this.convertToMillis(duration))][(shiftedStart = (endTime - durationMillis))][(atomicState.start = shiftedStart)]]
dynamicEndLevel: [If this.usesOldSettings(),[If (direction && (direction == Down)),,],,],]
getHue: [(start = (int) atomicState.startLevels[dimmer.id])][(end = this.dynamicEndLevel())][If (start > end),,],]
getUpHue: ]
getDownHue: ]
getBlueHue: [If (level < 5),,],[If (level < 10),,],[If (level < 15),,],[If (level < 20),,],[If (level < 25),,],[If (level < 30),,],[If (level < 35),,],[If (level < 40),,],[If (level < 45),,],[If (level < 50),,],[If (level < 55),,],[If (level < 60),,],[If (level < 65),,],[If (level < 70),,],[If (level < 75),,],[If (level < 80),,],[If (level < 85),,],[If (level < 90),,],[If (level < 95),,],[If (level >= 95),,],]
getRedHue: [If (level < 6),,],[If (level < 12),,],[If (level < 18),,],[If (level < 24),,],[If (level < 30),,],[If (level < 36),,],[If (level < 42),,],[If (level < 48),,],[If (level < 54),,],[If (level < 60),,],[If (level < 66),,],[If (level < 72),,],[If (level < 78),,],[If (level < 84),,],[If (level < 90),,],[If (level < 96),,],[If (level >= 96),,],]
dimmersContainUnsupportedDevices: [(found = dimmers.find({ -> ... }))][return (found != null)]]
hasSetLevelCommand: ]
hasSetColorCommand: ]
hasCommand: [return (device.supportedCommands.find({ -> ... }) != null)]]
dimmersWithSetColorCommand: [(colorDimmers = [])]]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
sanitizeInt: ]
completionDelaySeconds: [(completionDelayMinutes = this.sanitizeInt(completionDelay))][(completionDelaySeconds = (completionDelayMinutes * 60))]]
stepDuration: [(minutes = this.sanitizeInt(duration, 30))][(stepDuration = ((minutes * 60) / 100))]]
debug: ]
smartThingsDateFormat: ]
humanReadableStartDate: ]
fancyString: [(fancify = { java.lang.Object list -> ... })]]
fancyDeviceString: ]
deviceLabel: ]
schedulingHrefDescription: [(descriptionParts = [])][If days,[If (days == this.weekdays()),,[If (days == this.weekends()),,],],,],[If startTime,,],[If modeStart,[If startTime,,],,],[If (descriptionParts.size() <= 1),,],]
completionHrefDescription: [(descriptionParts = [])][(example = Switch1 will be turned on. Switch2, Switch3, and Switch4 will be dimmed to 50%. The message '<message>' will be spoken, sent as a text, and sent as a push notification. The mode will be changed to '<mode>'. The phrase '<phrase>' will be executed)][If completionSwitches,[(switchesList = [])][(dimmersList = [])][If switchesList,,],[If dimmersList,,],,],[If (completionMessage && ((completionPhoneNumber || completionPush) || completionMusicPlayer)),[(messageParts = [])][If completionMusicPlayer,,],[If completionPhoneNumber,,],[If completionPush,,],,],[If completionMode,,],[If completionPhrase,,],]
numbersPageHrefDescription: [(title = All dimmers will dim for $(duration) ? duration : 30 minutes from $this.startLevelLabel() to $this.endLevelLabel())][If colorize,[(colorDimmers = this.dimmersWithSetColorCommand())][If (colorDimmers == dimmers),[(title +=  and will gradually change color.)],[(title += .
$this.fancyDeviceString(colorDimmers) will gradually change color.)]],,],]
hueSatToHex: [(convertedRGB = this.hslToRgb(h, s, 0.5))]]
hslToRgb: [(r = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(g = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(b = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (s == 0),[(r = (g = (b = l)))],[(hue2rgb = { java.lang.Object p, java.lang.Object q, java.lang.Object t -> ... })][(q = ((l < 0.5)) ? (l * (1 + s)) : ((l + s) - (l * s)))][(p = ((2 * l) - q))][(r = hue2rgb.call(p, q, (h + (1 / 3))))][(g = hue2rgb.call(p, q, h))][(b = hue2rgb.call(p, q, (h - (1 / 3))))]],]
rgbToHex: [(toHex = { -> ... })][(rgbToHex = { java.lang.Object r, java.lang.Object g, java.lang.Object b -> ... })]]
usesOldSettings: ]
hasStartLevel: [return ((startLevel != null) && (startLevel != ))]]
hasEndLevel: [return ((endLevel != null) && (endLevel != ))]]
Starting Points: []
IT HAS ATOMICSTATE
--app-start--
processing good-night-house.groovy
DECLARED METHODS
installed: [log.debug(Current mode = $location.mode)][org.codehaus.groovy.ast.stmt.ExpressionStatement@1477089c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@663411de[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@63dd899[org.codehaus.groovy.ast.expr.VariableExpression@59d2400d[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@75cd8043[variable: appTouch]]]]]]
updated: [log.debug(Current mode = $location.mode)][org.codehaus.groovy.ast.stmt.ExpressionStatement@33b1c5c5[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5b202a3a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@10b9db7b[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@9ef8eb7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@34cdeda2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6ee660fb[org.codehaus.groovy.ast.expr.VariableExpression@305a0c5f[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@4535b6d5[variable: appTouch]]]]]]
appTouch: [log.debug(changeMode, location.mode = $location.mode, newMode = $newMode, location.modes = $location.modes)][If (location.mode != newMode),,],[(delay = (((waitfor != null) && (waitfor != ))) ? (waitfor * 1000) : 120000)]]
Starting Points: []
IT HAS ATOMICSTATE
--app-start--
processing good-night.groovy
DECLARED METHODS
installed: [log.debug(Current mode = $location.mode)]]
updated: [log.debug(Current mode = $location.mode)][org.codehaus.groovy.ast.stmt.ExpressionStatement@54dcfa5a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1817f1eb[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@767e20cf[]]]]]
createSubscriptions: [org.codehaus.groovy.ast.stmt.ExpressionStatement@3a3e78f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@301ec38b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@17a1e4ca[org.codehaus.groovy.ast.expr.VariableExpression@10ded6a9[variable: motionSensors], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@c5dc4a2[variable: motionActiveHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4a194c39[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@52066604[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@340b9973[org.codehaus.groovy.ast.expr.VariableExpression@56113384[variable: motionSensors], ConstantExpression[motion.inactive], org.codehaus.groovy.ast.expr.VariableExpression@5669c5fb[variable: motionInactiveHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@373ebf74[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5f9678e1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@c4ed84[org.codehaus.groovy.ast.expr.VariableExpression@189aa67a[variable: switches], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@5a9d6f02[variable: switchOffHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@362045c0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@112f364d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5ccbeb64[org.codehaus.groovy.ast.expr.VariableExpression@6d9f7a80[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@59252cb6[variable: modeChangeHandler]]]]][If (state.modeStartTime == null),[(state.modeStartTime = 0)],],]
modeChangeHandler: [(state.modeStartTime = this.now())]]
switchOffHandler: [If (this.correctMode() && this.correctTime()),[If (this.allQuiet() && this.switchesOk()),,],,],]
motionActiveHandler: ]
motionInactiveHandler: [If (state.modeStartTime == null),[org.codehaus.groovy.ast.stmt.ExpressionStatement@31d0e481[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3243b914[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@241e8ea6[org.codehaus.groovy.ast.expr.VariableExpression@542e560f[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@626c44e7[variable: modeChangeHandler]]]]][(state.modeStartTime = 0)],],[If (this.correctMode() && this.correctTime()),[org.codehaus.groovy.ast.stmt.ExpressionStatement@4dc8caa7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1d730606[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3bcbb589[org.codehaus.groovy.ast.expr.BinaryExpression@3b00856b[org.codehaus.groovy.ast.expr.VariableExpression@3016fd5e[variable: minutes]("*" at 102:17:  "*" )ConstantExpression[60]], org.codehaus.groovy.ast.expr.VariableExpression@35d08e6c[variable: scheduleCheck], org.codehaus.groovy.ast.expr.MapExpression@53d102a2[org.codehaus.groovy.ast.expr.MapEntryExpression@6c45ee6e(key: ConstantExpression[overwrite], value: ConstantExpression[false])]]]]],],]
scheduleCheck: [log.debug(scheduleCheck, currentMode = $location.mode, newMode = $newMode)][If (this.correctMode() && this.correctTime()),[If (this.allQuiet() && this.switchesOk()),,],,],]
takeActions: [(message = Goodnight! SmartThings changed the mode to '$newMode')]]
correctMode: [If (location.mode != newMode),,],]
correctTime: [(t0 = this.now())][(modeStartTime = new java.util.Date(state.modeStartTime))][(startTime = this.timeTodayAfter(modeStartTime, timeOfDay, location.timeZone))][If (t0 >= startTime.time),,],]
switchesOk: [(result = true)][For (switches) ? switches : [],[If (it.currentSwitch == on),[(result = false)][(result = false)],],]switchesOk: [(result = true)][For (switches) ? switches : [],[If (it.currentSwitch == on),[(result = false)][(result = false)],],]]
allQuiet: [(threshold = (((1000 * 60) * minutes) - 1000))][(states = motionSensors.collect({ -> ... }).sort({ java.lang.Object a, java.lang.Object b -> ... }))][If states,[If states.find({ -> ... }),,[(sensor = states.first())][(elapsed = (this.now() - sensor.rawDateCreated.time))][If (elapsed >= threshold),,],],,],]
send: [If location.contactBookEnabled,,[If (sendPushMessage != No),,],[If phoneNumber,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing goodnight-ubi.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@2c5529ab[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@39a8312f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5f6722d3[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@2c532cd8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@294e5088[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@51972dc7[org.codehaus.groovy.ast.expr.VariableExpression@3700ec9c[variable: trigger], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@2002348[variable: switchOnHandler]]]]]]
switchOnHandler: [(timeDelay = (minutes * 60))][org.codehaus.groovy.ast.stmt.ExpressionStatement@5911e990[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@31000e60[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1d470d0[org.codehaus.groovy.ast.expr.VariableExpression@24d09c1[variable: timeDelay], org.codehaus.groovy.ast.expr.VariableExpression@54c62d71[variable: lightsOut]]]]][(phrase = )][If (phrase == ),[(phrase = The%20house%20is%20ready%20for%20night.)],[(phrase = ((You%20have%20left%20 + phrase) + open))]],[this.httpGet(https://portal.theubi.com/webapi/behaviour?access_token=$behaviorToken&variable=$phrase)][If (sayPhrase == Yes),,],]
lightsOut: [If (theSwitches == ),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing greetings-earthling.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@7216fb24[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2072acb2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@50ecde95[org.codehaus.groovy.ast.expr.VariableExpression@35a9782c[variable: people], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@70a36a66[variable: presence]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@45815ffc[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@732f29af[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@d3957fe[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6622fc65[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@299321e2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@23fb172e[org.codehaus.groovy.ast.expr.VariableExpression@64ba3208[variable: people], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@158a3b2e[variable: presence]]]]]]
presence: [(threshold = (((falseAlarmThreshold != null) && (falseAlarmThreshold != ))) ? (java.lang.Long -> java.lang.Long) ((falseAlarmThreshold * 60) * 1000) : ((10 * 60) * 1000))][If (location.mode != newMode),[(t0 = new java.util.Date((this.now() - threshold)))][If (evt.value == present),[(person = this.getPerson(evt))][(recentNotPresent = person.statesSince(presence, t0).find({ -> ... }))][If recentNotPresent,,[(message = $person.displayName arrived at home, changing mode to '$newMode')]],,],,],]
getPerson: ]
send: [If location.contactBookEnabled,,[If (sendPushMessage != No),,],[If phone,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing habit-helper.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@3300f4fd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@ebb6851[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@70ab2d48[org.codehaus.groovy.ast.expr.VariableExpression@5b068087[variable: time1], ConstantExpression[scheduleCheck]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6f152006[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3a393455[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@13518f37[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7cbc3762[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3a6f2de3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@49872d67[org.codehaus.groovy.ast.expr.VariableExpression@56303b57[variable: time1], ConstantExpression[scheduleCheck]]]]]]
scheduleCheck: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4b2a01d4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@8692d67[object: org.codehaus.groovy.ast.expr.VariableExpression@78f5c518[variable: log] method: ConstantExpression[trace] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2f48b3d2[ConstantExpression[scheduledCheck]]]]][(message = (message1) ? message1 : SmartThings - Habit Helper Reminder!)][If location.contactBookEnabled,,],]
Starting Points: [log.trace(scheduledCheck)]
IT HAS STATE
--app-start--
processing hall-light-welcome-home.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@68ead359[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6b53bcc2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@180da663[]]]]]
init: [(state.lastClosed = this.now())][org.codehaus.groovy.ast.stmt.ExpressionStatement@a43ce46[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@340da44c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@424ebba3[org.codehaus.groovy.ast.expr.VariableExpression@37052337[variable: people], ConstantExpression[presence.present], org.codehaus.groovy.ast.expr.VariableExpression@2320fa6f[variable: presence]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7a560583[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4d722ac9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@53f0a4cb[org.codehaus.groovy.ast.expr.VariableExpression@77a7cf58[variable: sensors], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@3d97a632[variable: doorOpened]]]]]]
presence: [(delay = (contactDelay) ? contactDelay : 10)][(state.lastPresence = this.now())][If ((this.now() - (delay * 1000)) < state.lastContact),,],]
doorOpened: [(delay = (presenceDelay) ? presenceDelay : 30)][(state.lastContact = this.now())][If ((this.now() - (delay * 1000)) < state.lastPresence),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing harmony-activity.groovy
DECLARED METHODS
parse: ]
on: ]
off: ]
huboff: ]
alloff: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: harmony-activity.metadata() is applicable for argument types: (harmony-activity$_run_closure1) values: [harmony-activity$_run_closure1@5829e4f4]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing has-barkley-been-fed.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@c2db68f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3cc41abc[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4566d049[org.codehaus.groovy.ast.expr.VariableExpression@61ce23ac[variable: time1], ConstantExpression[scheduleCheck]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@3668d4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1c3b9394[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6f2cfcc2[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7f6f61c8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4c2cc639[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@ccb4b1b[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4097cac[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@ec2cc4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2a5b3fee[org.codehaus.groovy.ast.expr.VariableExpression@7c1e2a2d[variable: time1], ConstantExpression[scheduleCheck]]]]]]
scheduleCheck: [org.codehaus.groovy.ast.stmt.ExpressionStatement@333dd51e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@52d645b1[object: org.codehaus.groovy.ast.expr.VariableExpression@2101b44a[variable: log] method: ConstantExpression[trace] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2cc3ad05[ConstantExpression[scheduledCheck]]]]][(midnight = new java.util.Date().clearTime())][(now = new java.util.Date())][(feederEvents = feeder1.eventsBetween(midnight, now))][(feederOpened = (feederEvents.count({ -> ... }) > 0))][If feederOpened,,[If location.contactBookEnabled,,],],]
Starting Points: [log.trace(scheduledCheck)]
IT HAS STATE
--app-start--
processing hello-home-phrase-director.groovy
DECLARED METHODS
selectPhrases: [(configured = (((settings.awayDay && settings.awayNight) && settings.homeDay) && settings.homeNight))]]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@3ecd267f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@58ffcbd7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@555cf22[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6bb2d00b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3c9bfddc[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1a9c38eb[org.codehaus.groovy.ast.expr.VariableExpression@319bc845[variable: people], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@4c5474f5[variable: presence]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2f4205be[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@54e22bdd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3bd418e4[ConstantExpression[60], org.codehaus.groovy.ast.expr.VariableExpression@544820b7[variable: checkSun]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6b98a075[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2e61d218[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3569fc08[org.codehaus.groovy.ast.expr.VariableExpression@20b12f8a[variable: location], ConstantExpression[sunrise], org.codehaus.groovy.ast.expr.VariableExpression@e84a8e1[variable: setSunrise]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2e554a3b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@54a67a45[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7d42c224[org.codehaus.groovy.ast.expr.VariableExpression@56aaaecd[variable: location], ConstantExpression[sunset], org.codehaus.groovy.ast.expr.VariableExpression@522a32b1[variable: setSunset]]]]]]
checkSun: [(zip = (java.lang.String -> java.lang.String) settings.zip)][(sunInfo = this.getSunriseAndSunset([zipCode:zip]))][(current = this.now())][If ((sunInfo.sunrise.time < current) && (sunInfo.sunset.time > current)),[(state.sunMode = sunrise)],[(state.sunMode = sunset)]],]
setSunrise: [(state.sunMode = sunrise)]]
setSunset: [(state.sunMode = sunset)]]
changeSunMode: [If allOk,[If (this.everyoneIsAway() && (state.sunMode == sunrise)),[(delay = (((falseAlarmThreshold != null) && (falseAlarmThreshold != ))) ? (falseAlarmThreshold * 60) : (10 * 60))][org.codehaus.groovy.ast.stmt.ExpressionStatement@35390ee3[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5e01a982[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5ddea849[org.codehaus.groovy.ast.expr.VariableExpression@5ee2b6f9[variable: delay], ConstantExpression[setAway]]]]],],[If (this.everyoneIsAway() && (state.sunMode == sunset)),[(delay = (((falseAlarmThreshold != null) && (falseAlarmThreshold != ))) ? (falseAlarmThreshold * 60) : (10 * 60))][org.codehaus.groovy.ast.stmt.ExpressionStatement@23d1e5d0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@704f1591[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@58fb7731[org.codehaus.groovy.ast.expr.VariableExpression@13e547a9[variable: delay], ConstantExpression[setAway]]]]],],,],]
presence: [If allOk,[If (evt.value == not present),[If this.everyoneIsAway(),[(delay = (((falseAlarmThreshold != null) && (falseAlarmThreshold != ))) ? (falseAlarmThreshold * 60) : (10 * 60))][org.codehaus.groovy.ast.stmt.ExpressionStatement@3fb6cf60[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@37ddb69a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@349c1daf[org.codehaus.groovy.ast.expr.VariableExpression@dfddc9a[variable: delay], ConstantExpression[setAway]]]]],],,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (1 * 60000))),,],[(state[evt.deviceId] = this.now())]],,],]
setAway: [If this.everyoneIsAway(),[If (state.sunMode == sunset),[(message = Performing "$awayNight" for you as requested.)],[If (state.sunMode == sunrise),[(message = Performing "$awayDay" for you as requested.)],],],,],]
setHome: [If this.anyoneIsHome(),[If (state.sunMode == sunset),[If (location.mode != $homeModeNight),[(message = Performing "$homeNight" for you as requested.)],],,],[If (state.sunMode == sunrise),[If (location.mode != $homeModeDay),[(message = Performing "$homeDay" for you as requested.)],],,],,],]
everyoneIsAway: [(result = true)][If people.findAll({ -> ... }),[(result = false)],],]
anyoneIsHome: [(result = false)][If people.findAll({ -> ... }),[(result = true)],],]
sendAway: [If (sendPushMessage != No),,],]
sendHome: [If (sendPushMessageHome != No),,],]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
getTimeIntervalLabel: ]
hideOptionsSection: ]
sendOutOfDateNotification: [If state.lastTime,[(state.lastTime = (new java.util.Date() + 31).getTime())],[If (new java.util.Date().getTime() >= state.lastTime),[(state.lastTime = (new java.util.Date() + 31).getTime())],],],]
Starting Points: []
IT HAS STATE
--app-start--
processing hub-ip-notifier.groovy
DECLARED METHODS
pageWithIp: [(currentIp = (state.localip) ? state.localip : unknown)][(registerDate = (state.lastRegister) ? state.lastRegister : null)]]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@68fa0ba8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6c5945a7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2f05be7f[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@640f11a1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5c10f1c3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7ac2e39b[org.codehaus.groovy.ast.expr.VariableExpression@78365cfa[variable: hub], ConstantExpression[hubInfo], org.codehaus.groovy.ast.expr.VariableExpression@64a8c844[variable: registrationHandler], org.codehaus.groovy.ast.expr.MapExpression@3f6db3fb[org.codehaus.groovy.ast.expr.MapEntryExpression@52de51b6(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]]]
registrationHandler: [(hubInfo = evt.description.split(,).inject([:], { java.lang.Object map, java.lang.Object token -> ... }))][(state.localip = hubInfo.localip)][(state.lastRegister = new java.util.Date())]]
Starting Points: []
IT HAS STATE
--app-start--
processing hue-bloom.groovy
DECLARED METHODS
initialize: ]
installed: ]
updated: ]
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],]
on: ]
off: ]
setLevel: [If this.verifyPercent(percent),,],]
setSaturation: [If this.verifyPercent(percent),,],]
setHue: [If this.verifyPercent(percent),,],]
setColor: [(events = [])][(validValues = [:])][If this.verifyPercent(value.hue),[(validValues.hue = value.hue)],],[If this.verifyPercent(value.saturation),[(validValues.saturation = value.saturation)],],[If (value.hex != null),[If (value.hex ==~ ^\#([A-Fa-f0-9]){6}$),[(validValues.hex = value.hex)],],,],[If this.verifyPercent(value.level),[(validValues.level = value.level)],],[If ((value.switch == off) || ((value.level != null) && (value.level <= 0))),[(validValues.switch = off)],[(validValues.switch = on)]],[If validValues.isEmpty(),,],]
reset: [(value = [hue:20, saturation:2])]]
setAdjustedColor: [If value,[(adjusted = (value + [:]))][(adjusted.level = null)],],]
refresh: ]
verifyPercent: [If (percent == null),,[If ((percent >= 0) && (percent <= 100)),,],],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: hue-bloom.metadata() is applicable for argument types: (hue-bloom$_run_closure1) values: [hue-bloom$_run_closure1@38f116f6]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing hue-bulb.groovy
DECLARED METHODS
initialize: ]
installed: ]
updated: ]
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],]
on: ]
off: ]
setLevel: [If this.verifyPercent(percent),,],]
setSaturation: [If this.verifyPercent(percent),,],]
setHue: [If this.verifyPercent(percent),,],]
setColor: [(events = [])][(validValues = [:])][If this.verifyPercent(value.hue),[(validValues.hue = value.hue)],],[If this.verifyPercent(value.saturation),[(validValues.saturation = value.saturation)],],[If (value.hex != null),[If (value.hex ==~ ^\#([A-Fa-f0-9]){6}$),[(validValues.hex = value.hex)],],,],[If this.verifyPercent(value.level),[(validValues.level = value.level)],],[If ((value.switch == off) || ((value.level != null) && (value.level <= 0))),[(validValues.switch = off)],[(validValues.switch = on)]],[If validValues.isEmpty(),,],]
reset: ]
setAdjustedColor: [If value,[(adjusted = (value + [:]))][(adjusted.level = null)],],]
setColorTemperature: [If value,,],]
refresh: ]
verifyPercent: [If (percent == null),,[If ((percent >= 0) && (percent <= 100)),,],],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: hue-bulb.metadata() is applicable for argument types: (hue-bulb$_run_closure1) values: [hue-bulb$_run_closure1@7bb6ab3a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing hue-lux-bulb.groovy
DECLARED METHODS
initialize: ]
installed: ]
updated: ]
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],]
on: ]
off: ]
setLevel: [If (((percent != null) && (percent >= 0)) && (percent <= 100)),,],]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: hue-lux-bulb.metadata() is applicable for argument types: (hue-lux-bulb$_run_closure1) values: [hue-lux-bulb$_run_closure1@3e14c16d]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing hue-mood-lighting.groovy
DECLARED METHODS
mainPage: ]
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]]
ifUnset: [If settings[name],,],]
ifSet: [If settings[name],,],]
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5d1659ea[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@793138bd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1951b871[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5c18016b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@33aeca0b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@43aaf813[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@57ac5227[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4ba302e0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@e98770d[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1ae67cad[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2f6e28bc[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7c098bb3[]]]]]
subscribeToEvents: [org.codehaus.groovy.ast.stmt.ExpressionStatement@31e4bb20[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@18cebaa5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@463b4ac8[org.codehaus.groovy.ast.expr.VariableExpression@765f05af[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@62f68dff[variable: appTouchHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@f001896[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@13f17eb4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1d0d6318[org.codehaus.groovy.ast.expr.VariableExpression@4bc28c33[variable: contact], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@4409e975[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5c153b9e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2a7686a7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@758a34ce[org.codehaus.groovy.ast.expr.VariableExpression@7ec3394b[variable: contactClosed], ConstantExpression[contact.closed], org.codehaus.groovy.ast.expr.VariableExpression@bff34c6[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1522d8a0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@312ab28e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5644dc81[org.codehaus.groovy.ast.expr.VariableExpression@246f8b8b[variable: acceleration], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@278bb07e[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4351c8c3[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3381b4fc[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6bea52d4[org.codehaus.groovy.ast.expr.VariableExpression@11981797[variable: motion], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@5c42d2b7[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@625abb97[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5b1f29fa[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@aeab9a1[org.codehaus.groovy.ast.expr.VariableExpression@40f70521[variable: mySwitch], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@774698ab[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@55342f40[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@a4ca3f6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@72ea6193[org.codehaus.groovy.ast.expr.VariableExpression@31aa3ca5[variable: mySwitchOff], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@45905bff[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2a2c13a8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@b6b1987[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6b44435b[org.codehaus.groovy.ast.expr.VariableExpression@2ccca26f[variable: arrivalPresence], ConstantExpression[presence.present], org.codehaus.groovy.ast.expr.VariableExpression@66b7550d[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3543df7d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7c541c15[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3542162a[org.codehaus.groovy.ast.expr.VariableExpression@698122b2[variable: departurePresence], ConstantExpression[presence.not present], org.codehaus.groovy.ast.expr.VariableExpression@4212a0c8[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1e7aa82b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3b2c0e88[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5bd82fed[org.codehaus.groovy.ast.expr.VariableExpression@c1bd0be[variable: smoke], ConstantExpression[smoke.detected], org.codehaus.groovy.ast.expr.VariableExpression@476b0ae6[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1c6804cd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@655f7ea[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@549949be[org.codehaus.groovy.ast.expr.VariableExpression@4b3a45f1[variable: smoke], ConstantExpression[smoke.tested], org.codehaus.groovy.ast.expr.VariableExpression@17a87e37[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3eeb318f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@20a14b55[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@39ad977d[org.codehaus.groovy.ast.expr.VariableExpression@6da00fb9[variable: smoke], ConstantExpression[carbonMonoxide.detected], org.codehaus.groovy.ast.expr.VariableExpression@a202ccb[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@20f12539[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@75b25825[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@18025ced[org.codehaus.groovy.ast.expr.VariableExpression@13cf7d52[variable: water], ConstantExpression[water.wet], org.codehaus.groovy.ast.expr.VariableExpression@3a3e4aff[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5d2a4eed[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@57459491[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3f0846c6[org.codehaus.groovy.ast.expr.VariableExpression@77a98a6a[variable: button1], ConstantExpression[button.pushed], org.codehaus.groovy.ast.expr.VariableExpression@78fbff54[variable: eventHandler]]]]][If triggerModes,[org.codehaus.groovy.ast.stmt.ExpressionStatement@3e10dc6[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7e22550a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@45e37a7e[org.codehaus.groovy.ast.expr.VariableExpression@62452cc9[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@6941827a[variable: modeChangeHandler]]]]],],[If timeOfDay,[org.codehaus.groovy.ast.stmt.ExpressionStatement@5a7005d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5bc9ba1d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1021f6c9[org.codehaus.groovy.ast.expr.VariableExpression@7516e4e5[variable: timeOfDay], org.codehaus.groovy.ast.expr.VariableExpression@488eb7f2[variable: scheduledTimeHandler]]]]],],]
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],]
modeChangeHandler: [If (evt.value in triggerModes),,],]
scheduledTimeHandler: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5e81e5ac[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4189d70b[object: org.codehaus.groovy.ast.expr.VariableExpression@3fa2213[variable: log] method: ConstantExpression[trace] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3e7634b9[ConstantExpression[scheduledTimeHandler()]]]]]]
appTouchHandler: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
takeAction: [If (frequency || oncePerDay),[(state[this.frequencyKey(evt)] = this.now())],],[(hueColor = 0)][(saturation = 100)]]
frequencyKey: ]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],]
oncePerDayOk: [(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result - $lastTime)]]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
timeIntervalLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing hue-white-ambiance-bulb.groovy
DECLARED METHODS
initialize: ]
installed: ]
updated: ]
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],]
on: ]
off: ]
setLevel: [If (((percent != null) && (percent >= 0)) && (percent <= 100)),,],]
setColorTemperature: [If value,,],]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: hue-white-ambiance-bulb.metadata() is applicable for argument types: (hue-white-ambiance-bulb$_run_closure1) values: [hue-white-ambiance-bulb$_run_closure1@fb9c7aa]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing humidity-alert.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@60a2630a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@29df4d43[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5dd91bca[org.codehaus.groovy.ast.expr.VariableExpression@40cb698e[variable: humiditySensor1], ConstantExpression[humidity], org.codehaus.groovy.ast.expr.VariableExpression@3382f8ae[variable: humidityHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@60641ec8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@75f65e45[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6eeade6c[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4a891c97[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@a5bd950[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4d18aa28[org.codehaus.groovy.ast.expr.VariableExpression@75390459[variable: humiditySensor1], ConstantExpression[humidity], org.codehaus.groovy.ast.expr.VariableExpression@7756c3cd[variable: humidityHandler]]]]]]
humidityHandler: [(currentHumidity = java.lang.Double.parseDouble(evt.value.replace(%, )))][(tooHumid = humidity1)][(notHumidEnough = humidity2)][(mySwitch = settings.switch1)][(deltaMinutes = 10)][(timeAgo = new java.util.Date((this.now() - ((1000 * 60) * deltaMinutes).toLong())))][(recentEvents = humiditySensor1.eventsSince(timeAgo))][(alreadySentSms = ((recentEvents.count({ -> ... }) > 1) || (recentEvents.count({ -> ... }) > 1)))][If (currentHumidity >= tooHumid),[log.debug(Checking how long the humidity sensor has been reporting >= $tooHumid)][If alreadySentSms,,],,],[If (currentHumidity <= notHumidEnough),[log.debug(Checking how long the humidity sensor has been reporting <= $notHumidEnough)][If alreadySentSms,,],,],]
send: [If (sendPushMessage != No),,],[If phone1,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing illuminance-measurement-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: illuminance-measurement-capability.metadata() is applicable for argument types: (illuminance-measurement-capability$_run_closure1) values: [illuminance-measurement-capability$_run_closure1@7c209437]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing it-moved.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4febb875[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@25e2a451[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1698ee84[org.codehaus.groovy.ast.expr.VariableExpression@10c626be[variable: accelerationSensor], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@2fc0cc3[variable: accelerationActiveHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@328cf0e1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@63b1d4fa[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@42e3ede4[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@201b6b6f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@75459c75[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@183e8023[org.codehaus.groovy.ast.expr.VariableExpression@45efc20d[variable: accelerationSensor], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@3e5499cc[variable: accelerationActiveHandler]]]]]]
accelerationActiveHandler: [(deltaSeconds = 5)][(timeAgo = new java.util.Date((this.now() - (1000 * deltaSeconds))))][(recentEvents = accelerationSensor.eventsSince(timeAgo))][(alreadySentSms = (recentEvents.count({ -> ... }) > 1))][If alreadySentSms,,[If location.contactBookEnabled,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing its-too-cold.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6821ea29[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@338494fa[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@505a9d7c[org.codehaus.groovy.ast.expr.VariableExpression@758c83d8[variable: temperatureSensor1], ConstantExpression[temperature], org.codehaus.groovy.ast.expr.VariableExpression@129b4fe2[variable: temperatureHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5af3a0f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@19ae6bb[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@10993713[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@58359ebd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@24b6b8f6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@72cf2de5[org.codehaus.groovy.ast.expr.VariableExpression@2bb7bd00[variable: temperatureSensor1], ConstantExpression[temperature], org.codehaus.groovy.ast.expr.VariableExpression@5f031ebd[variable: temperatureHandler]]]]]]
temperatureHandler: [(tooCold = temperature1)][(mySwitch = settings.switch1)][If (evt.doubleValue <= tooCold),[log.debug(Checking how long the temperature sensor has been reporting <= $tooCold)][(deltaMinutes = 10)][(timeAgo = new java.util.Date((this.now() - ((1000 * 60) * deltaMinutes).toLong())))][(recentEvents = temperatureSensor1.eventsSince(timeAgo)?.findAll({ -> ... }))][(alreadySentSms = (recentEvents.count({ -> ... }) > 1))][If alreadySentSms,,[(tempScale = (location.temperatureScale) ? location.temperatureScale : F)]],,],]
send: [If location.contactBookEnabled,,[If (sendPushMessage != No),,],[If phone1,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing its-too-hot.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@726e5805[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@40c80397[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4b672daa[org.codehaus.groovy.ast.expr.VariableExpression@ea9b7c6[variable: temperatureSensor1], ConstantExpression[temperature], org.codehaus.groovy.ast.expr.VariableExpression@e077866[variable: temperatureHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@ed3068a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7c2b6087[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3fffff43[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@a8e6492[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1c7fd41f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3b77a04f[org.codehaus.groovy.ast.expr.VariableExpression@7b324585[variable: temperatureSensor1], ConstantExpression[temperature], org.codehaus.groovy.ast.expr.VariableExpression@2e11485[variable: temperatureHandler]]]]]]
temperatureHandler: [(tooHot = temperature1)][(mySwitch = settings.switch1)][If (evt.doubleValue >= tooHot),[log.debug(Checking how long the temperature sensor has been reporting <= $tooHot)][(deltaMinutes = 10)][(timeAgo = new java.util.Date((this.now() - ((1000 * 60) * deltaMinutes).toLong())))][(recentEvents = temperatureSensor1.eventsSince(timeAgo)?.findAll({ -> ... }))][(alreadySentSms = (recentEvents.count({ -> ... }) > 1))][If alreadySentSms,,[(tempScale = (location.temperatureScale) ? location.temperatureScale : F)]],,],]
send: [If location.contactBookEnabled,,[If (sendPushMessage != No),,],[If phone1,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing jawbone-button-notifier.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@12bcd0c0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4879f0f2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@47db5fa5[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@354fc8f0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@41813449[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4678a2eb[org.codehaus.groovy.ast.expr.VariableExpression@5b43fbf6[variable: jawbone], ConstantExpression[sleeping], org.codehaus.groovy.ast.expr.VariableExpression@1080b026[variable: sendit]]]]]]
sendit: ]
sendMessage: [(msg = warnMessage)][If phone1,,],[If phone2,,],[If phone3,,],[If ((phone1 && phone2) && phone3),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing jawbone-user.groovy
DECLARED METHODS
generateSleepingEvent: [(value = this.formatValue(sleeping))][(linkText = this.getLinkText(device))][(descriptionText = this.formatDescriptionText(linkText, sleeping))][(handlerName = this.getState(sleeping))][(results = [name:sleeping, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName])][(results2 = [name:button, value:held, unit:null, linkText:linkText, descriptionText:$linkText button was pressed, handlerName:buttonHandler, ... ])]]
poll: [(results = parent.pollChild(this))]]
setMemberId: [log.debug(MemberId = $memberId)][(state.jawboneMemberId = memberId)]]
getMemberId: [log.debug(MemberId = $state.jawboneMemberId)][return state.jawboneMemberId]]
uninstalled: ]
formatValue: [If sleeping,,],]
formatDescriptionText: [If sleeping,,],]
getState: [If sleeping,,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: jawbone-user.metadata() is applicable for argument types: (jawbone-user$_run_closure1) values: [jawbone-user$_run_closure1@556d0826]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing jenkins-notifier.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@749c877b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@efde75f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@16ecee1[]]]]]
getHueColors: ]
getSaturation: ]
getMaxLevel: ]
initialize: [(successColor = [switch:on, hue:this.getHueColors()[colorSuccess], saturation:this.getSaturation(), level:(lightLevelSuccess) ? lightLevelSuccess : this.getMaxLevel()])][(failColor = [switch:on, hue:this.getHueColors()[colorFail], saturation:this.getSaturation(), level:(lightLevelFail) ? lightLevelFail : this.getMaxLevel()])][(state.successColor = successColor)][(state.failColor = failColor)][(cron = * */$(refreshInterval) ? refreshInterval : 15 * * * ?)][org.codehaus.groovy.ast.stmt.ExpressionStatement@3b220bcb[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2b95e48b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4a3329b9[org.codehaus.groovy.ast.expr.VariableExpression@3dddefd8[variable: cron], org.codehaus.groovy.ast.expr.VariableExpression@160ac7fb[variable: checkServer]]]]]]
checkServer: [(successColor = state.successColor)][(failColor = state.failColor)][(basicCredentials = $jenkinsUsername:$jenkinsPassword)][(encodedCredentials = basicCredentials.encodeAsBase64().toString())][(basicAuth = Basic $encodedCredentials)][(head = [Authorization:basicAuth])][(host = (jenkinsUrl.contains(lastBuild/api/json)) ? jenkinsUrl : $jenkinsUrl/lastBuild/api/json)]]
Starting Points: []
IT HAS STATE
--app-start--
processing keen-home-smart-vent.groovy
DECLARED METHODS
parse: [(map = [:])][If description?.startsWith(catchall:),[(map = this.parseCatchAllMessage(description))],[If description?.startsWith(read attr -),[(map = this.parseReportAttributeMessage(description))],[If (description?.startsWith(temperature: ) || description?.startsWith(humidity: )),[(map = this.parseCustomMessage(description))],[If description?.startsWith(on/off: ),[(map = this.parseOnOffMessage(description))],],],],],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseCatchAllMessage: [(cluster = zigbee.parse(description))][If this.shouldProcessMessage(cluster),,],]
shouldProcessMessage: [If ((((cluster.profileId != 260) || (cluster.command == 11)) || (cluster.command == 7)) || ((cluster.data.size() > 0) && (cluster.data.first() == 62))),,],]
parseReportAttributeMessage: [(descMap = (description - read attr - ).split(,).inject([:], { java.lang.Object map, java.lang.Object param -> ... }))][If ((descMap.cluster == 0006) && (descMap.attrId == 0000)),,[If ((descMap.cluster == 0008) && (descMap.attrId == 0000)),,[If ((descMap.cluster == 0402) && (descMap.attrId == 0000)),[(value = this.convertTemperatureHex(descMap.value))],[If ((descMap.cluster == 0001) && (descMap.attrId == 0021)),,[If ((descMap.cluster == 0403) && (descMap.attrId == 0020)),,[If ((descMap.cluster == 0000) && (descMap.attrId == 0006)),,],],],],],],]
parseCustomMessage: [(resultMap = [:])][If description?.startsWith(temperature: ),[(value = java.lang.Double.parseDouble(description.split(: )[1]))][(resultMap = this.makeTemperatureResult(this.convertTemperature(value)))],],]
parseOnOffMessage: [(resultMap = [:])][If description?.startsWith(on/off: ),[(value = java.lang.Integer.parseInt((description - on/off: )))][(resultMap = this.makeOnOffResult(value))],],]
makeOnOffResult: [(linkText = this.getLinkText(device))][(value = ((rawValue == 1)) ? on : off)]]
makeLevelResult: [(linkText = this.getLinkText(device))][(value = java.lang.Integer.parseInt(rawValue, 16))][(rangeMax = 254)][If (value == 255),,],[(value = java.lang.Math.floor(((value / rangeMax) * 100)))]]
makePressureResult: [(linkText = this.getLinkText(device))][(pascals = (rawValue / 10))][(result = [name:pressure, descriptionText:$linkText pressure is $pascalsPa, value:pascals])]]
makeBatteryResult: [(linkText = this.getLinkText(device))]]
makeTemperatureResult: [(linkText = this.getLinkText(device))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],]
convertTemperatureHex: [(celsius = (java.lang.Integer.parseInt(value, 16).shortValue() / 100))]]
convertTemperature: [If (this.getTemperatureScale() == C),,[(fahrenheit = (java.lang.Math.round((this.celsiusToFahrenheit(celsius) * 100)) / 100))]],]
makeSerialResult: [(linkText = this.getLinkText(device))]]
makeLevelCommand: [(rangeMax = 254)][(scaledLevel = java.lang.Math.round(((level * rangeMax) / 100)))][(hexLevel = new java.math.BigInteger(scaledLevel.toString()).toString(16).padLeft(2, 0))]]
on: [(linkText = this.getLinkText(device))][If (device.currentValue(switch) == obstructed),,],]
off: [(linkText = this.getLinkText(device))][If (device.currentValue(switch) == obstructed),,],]
clearObstruction: [(linkText = this.getLinkText(device))]]
setLevel: [(linkText = this.getLinkText(device))][(currentState = device.currentValue(switch))][If (currentState == obstructed),,],[If (value > 0),,],]
getOnOff: [If (device.currentValue(switch) == obstructed),,],]
getPressure: ]
getLevel: [If (device.currentValue(switch) == obstructed),,],]
getTemperature: ]
getBattery: ]
setZigBeeIdTile: [(linkText = this.getLinkText(device))]]
refresh: ]
ping: ]
configure: [(configCmds = [zdo bind 0x$device.deviceNetworkId 1 1 0x0008 {$device.zigbeeId} {}, delay 500, zdo bind 0x$device.deviceNetworkId 1 1 0x0402 {$device.zigbeeId} {}, delay 500, zdo bind 0x$device.deviceNetworkId 1 1 0x0403 {$device.zigbeeId} {}, delay 500, zdo bind 0x$device.deviceNetworkId 1 1 0x0001 {$device.zigbeeId} {}, delay 500])]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: keen-home-smart-vent.metadata() is applicable for argument types: (keen-home-smart-vent$_run_closure1) values: [keen-home-smart-vent$_run_closure1@45cff11c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing keep-me-cozy-ii.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@654d8173[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@56c9bbd8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@630cb4a4[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@636e8cc[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@f79a760[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@14f5da2c[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@12dae582[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@239b0f9d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@619bfe29[]]]]]
subscribeToEvents: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5b057c8c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1eb6749b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@652a7737[org.codehaus.groovy.ast.expr.VariableExpression@5b7ea70d[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@2bef51f2[variable: changedLocationMode]]]]][If sensor,[org.codehaus.groovy.ast.stmt.ExpressionStatement@650eab8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@30f5a68a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1e1d3956[org.codehaus.groovy.ast.expr.VariableExpression@4f2c9ba6[variable: sensor], ConstantExpression[temperature], org.codehaus.groovy.ast.expr.VariableExpression@4e28bdd1[variable: temperatureHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@53f48368[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@24d4d7c9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@f0e995e[org.codehaus.groovy.ast.expr.VariableExpression@4c37b5b[variable: thermostat], ConstantExpression[temperature], org.codehaus.groovy.ast.expr.VariableExpression@73db4768[variable: temperatureHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@71b3bc45[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@a8c1f44[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@150ab4ed[org.codehaus.groovy.ast.expr.VariableExpression@3c435123[variable: thermostat], ConstantExpression[thermostatMode], org.codehaus.groovy.ast.expr.VariableExpression@50fe837a[variable: temperatureHandler]]]]],],]
changedLocationMode: ]
temperatureHandler: ]
evaluate: [If sensor,[(threshold = 1.0)][(tm = thermostat.currentThermostatMode)][(ct = thermostat.currentTemperature)][(currentTemp = sensor.currentTemperature)][If (tm in [cool, auto]),[If ((currentTemp - coolingSetpoint) >= threshold),,[If (((coolingSetpoint - currentTemp) >= threshold) && ((ct - thermostat.currentCoolingSetpoint) >= threshold)),,],],,],[If (tm in [heat, emergency heat, auto]),[If ((heatingSetpoint - currentTemp) >= threshold),,[If (((currentTemp - heatingSetpoint) >= threshold) && ((thermostat.currentHeatingSetpoint - ct) >= threshold)),,],],,],,],]
coolingSetpointHandler: ]
heatingSetpointHandler: ]
Starting Points: []
IT HAS STATE
--app-start--
processing keep-me-cozy.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6bb75258[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@c260bdc[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@75e01201[org.codehaus.groovy.ast.expr.VariableExpression@2783717b[variable: thermostat], ConstantExpression[heatingSetpoint], org.codehaus.groovy.ast.expr.VariableExpression@76f7d241[variable: heatingSetpointHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4a335fa8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3f363cf5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3829ac1[org.codehaus.groovy.ast.expr.VariableExpression@4baf352a[variable: thermostat], ConstantExpression[coolingSetpoint], org.codehaus.groovy.ast.expr.VariableExpression@1bb1fde8[variable: coolingSetpointHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@15eebbff[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@22d6f11[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@30990c1b[org.codehaus.groovy.ast.expr.VariableExpression@2453f95d[variable: thermostat], ConstantExpression[temperature], org.codehaus.groovy.ast.expr.VariableExpression@44828f6b[variable: temperatureHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2dbe250d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@553f1d75[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6e1d8f9e[org.codehaus.groovy.ast.expr.VariableExpression@3e34ace1[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@62fe6067[variable: changedLocationMode]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4f071df8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4de41af9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@56ace400[org.codehaus.groovy.ast.expr.VariableExpression@47404bea[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@305f7627[variable: appTouch]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5d018107[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6cbcf243[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@29e6eb25[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@62435e70[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@339bf286[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@38be305c[org.codehaus.groovy.ast.expr.VariableExpression@269f4bad[variable: thermostat], ConstantExpression[heatingSetpoint], org.codehaus.groovy.ast.expr.VariableExpression@5ed731d0[variable: heatingSetpointHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3234f74e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7bc10d84[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@275fe372[org.codehaus.groovy.ast.expr.VariableExpression@40e10ff8[variable: thermostat], ConstantExpression[coolingSetpoint], org.codehaus.groovy.ast.expr.VariableExpression@557a1e2d[variable: coolingSetpointHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@26a4842b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7e38a7fe[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@366ef90e[org.codehaus.groovy.ast.expr.VariableExpression@33e01298[variable: thermostat], ConstantExpression[temperature], org.codehaus.groovy.ast.expr.VariableExpression@31e75d13[variable: temperatureHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@a5b0b86[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4b3c354a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@78fb9a67[org.codehaus.groovy.ast.expr.VariableExpression@73ff4fae[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@21aa6d6c[variable: changedLocationMode]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@b968a76[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2f9a01c1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2611b9a3[org.codehaus.groovy.ast.expr.VariableExpression@54227100[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@6b5894c8[variable: appTouch]]]]]]
heatingSetpointHandler: ]
coolingSetpointHandler: ]
temperatureHandler: ]
changedLocationMode: ]
appTouch: ]
event: ]
Starting Points: []
IT HAS STATE
--app-start--
processing laundry-monitor.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@56276db8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@51e8e6e6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@56f6d40b[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@36676c1a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5b408dc3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4d098f9b[org.codehaus.groovy.ast.expr.VariableExpression@2dbf4cbd[variable: sensor1], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@20b5f2ac[variable: accelerationActiveHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7fc44dec[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7e3060d8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@293d0107[org.codehaus.groovy.ast.expr.VariableExpression@2692b61e[variable: sensor1], ConstantExpression[acceleration.inactive], org.codehaus.groovy.ast.expr.VariableExpression@7b64240d[variable: accelerationInactiveHandler]]]]]]
accelerationActiveHandler: [If state.isRunning,[(state.isRunning = true)][(state.startedAt = this.now())],],[(state.stoppedAt = null)]]
accelerationInactiveHandler: [log.trace(no vibration, isRunning: $state.isRunning)][If state.isRunning,[log.debug(startedAt: $state.startedAt, stoppedAt: $state.stoppedAt)][If state.stoppedAt,[(state.stoppedAt = this.now())][(delay = java.lang.Math.floor((fillTime * 60)).toInteger())][org.codehaus.groovy.ast.stmt.ExpressionStatement@62fad19[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@47dbb1e2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@74cadd41[org.codehaus.groovy.ast.expr.VariableExpression@2e54db99[variable: delay], org.codehaus.groovy.ast.expr.VariableExpression@55e8ec2f[variable: checkRunning], org.codehaus.groovy.ast.expr.MapExpression@4f2613d1[org.codehaus.groovy.ast.expr.MapEntryExpression@6d24ffa1(key: ConstantExpression[overwrite], value: ConstantExpression[false])]]]]],],,],]
checkRunning: [If state.isRunning,[(fillTimeMsec = (fillTime) ? (fillTime * 60000) : 300000)][(sensorStates = sensor1.statesSince(acceleration, new java.util.Date((java.lang.Long -> java.lang.Long) (this.now() - fillTimeMsec))))][If sensorStates.find({ -> ... }),[(cycleTimeMsec = (cycleTime) ? (cycleTime * 60000) : 600000)][(duration = (this.now() - state.startedAt))][If ((duration - fillTimeMsec) > cycleTimeMsec),[(msg = $sensor1.displayName is finished)][If location.contactBookEnabled,,[If phone,,],],[If switches,[If lightMode?.equals(Turn On Lights),,],,],,],[(state.isRunning = false)],],,],]
flashLights: [(doFlash = true)][(onFor = (onFor) ? onFor : 1000)][(offFor = (offFor) ? offFor : 1000)][(numFlashes = (numFlashes) ? numFlashes : 3)][log.debug(LAST ACTIVATED IS: $state.lastActivated)][If state.lastActivated,[(elapsed = (this.now() - state.lastActivated))][(sequenceTime = ((numFlashes + 1) * (onFor + offFor)))][(doFlash = (elapsed > sequenceTime))][log.debug(DO FLASH: $doFlash, ELAPSED: $elapsed, LAST ACTIVATED: $state.lastActivated)],],[If doFlash,[(state.lastActivated = this.now())][log.debug(LAST ACTIVATED SET TO: $state.lastActivated)][(initialActionOn = switches.collect({ -> ... }))][(delay = 1)],],]
Starting Points: []
IT HAS STATE
--app-start--
processing left-it-open.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@69637b10[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@71984c3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@165b2f7f[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5536379e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@277f7dd3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6c8bca63[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2364305a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@470a696f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1bc715b8[]]]]]
subscribe: [org.codehaus.groovy.ast.stmt.ExpressionStatement@292d1c71[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2b491fee[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3f1c5af9[org.codehaus.groovy.ast.expr.VariableExpression@1c55f277[variable: contact], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@5ddabb18[variable: doorOpen]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3e8f7922[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@63192798[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@50eca7c6[org.codehaus.groovy.ast.expr.VariableExpression@58e6d4b8[variable: contact], ConstantExpression[contact.closed], org.codehaus.groovy.ast.expr.VariableExpression@1de5f0ef[variable: doorClosed]]]]]]
doorOpen: [(delay = (((openThreshold != null) && (openThreshold != ))) ? (openThreshold * 60) : 600)][org.codehaus.groovy.ast.stmt.ExpressionStatement@376a312c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@28d6290[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6ca0256d[org.codehaus.groovy.ast.expr.VariableExpression@5ef0d29e[variable: delay], org.codehaus.groovy.ast.expr.VariableExpression@38f57b3d[variable: doorOpenTooLong], org.codehaus.groovy.ast.expr.MapExpression@51850751[org.codehaus.groovy.ast.expr.MapEntryExpression@3ce3db41(key: ConstantExpression[overwrite], value: ConstantExpression[true])]]]]]]
doorClosed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@64df9a61[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@77602954[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@e260766[org.codehaus.groovy.ast.expr.VariableExpression@2c3dec30[variable: doorOpenTooLong]]]]]]
doorOpenTooLong: [(contactState = contact.currentState(contact))][(freq = (((frequency != null) && (frequency != ))) ? (frequency * 60) : 600)][If (contactState.value == open),[(elapsed = (this.now() - contactState.rawDateCreated.time))][(threshold = ((((openThreshold != null) && (openThreshold != ))) ? (openThreshold * 60000) : 60000 - 1000))][If (elapsed >= threshold),[org.codehaus.groovy.ast.stmt.ExpressionStatement@34a97744[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4275c20c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7c56e013[org.codehaus.groovy.ast.expr.VariableExpression@3fc9dfc5[variable: freq], org.codehaus.groovy.ast.expr.VariableExpression@40258c2f[variable: doorOpenTooLong], org.codehaus.groovy.ast.expr.MapExpression@2cac4385[org.codehaus.groovy.ast.expr.MapEntryExpression@6731787b(key: ConstantExpression[overwrite], value: ConstantExpression[false])]]]]],],,],]
sendMessage: [(minutes = (((openThreshold != null) && (openThreshold != ))) ? openThreshold : 10)][(msg = $contact.displayName has been left open for $minutes minutes.)][If location.contactBookEnabled,,[If phone,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing let-there-be-dark.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@42f3156d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1ddae9b5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@427b5f92[org.codehaus.groovy.ast.expr.VariableExpression@24bdb479[variable: contact1], ConstantExpression[contact], org.codehaus.groovy.ast.expr.VariableExpression@7e3f95fe[variable: contactHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@34625ccd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2c7d121c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@65aa6596[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@67389cb8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@419a20a6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@533377b[org.codehaus.groovy.ast.expr.VariableExpression@3383649e[variable: contact1], ConstantExpression[contact], org.codehaus.groovy.ast.expr.VariableExpression@10fde30a[variable: contactHandler]]]]]]
contactHandler: [If (evt.value == open),[(state.wasOn = (switch1.currentValue(switch) == on))],],[If (evt.value == closed),[If state.wasOn,,],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing let-there-be-light.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@18518ccf[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1991f767[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@768ccdc5[org.codehaus.groovy.ast.expr.VariableExpression@4c6daf0[variable: contact1], ConstantExpression[contact], org.codehaus.groovy.ast.expr.VariableExpression@10650953[variable: contactHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@659eef7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@162be91c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2488b073[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1c9f0a20[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@55787112[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1cd201a8[org.codehaus.groovy.ast.expr.VariableExpression@7db82169[variable: contact1], ConstantExpression[contact], org.codehaus.groovy.ast.expr.VariableExpression@1992eaf4[variable: contactHandler]]]]]]
contactHandler: [If (evt.value == open),,[If (evt.value == closed),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing life360-user.groovy
DECLARED METHODS
generatePresenceEvent: [(value = this.formatValue(present))][(linkText = this.getLinkText(device))][(descriptionText = this.formatDescriptionText(linkText, present))][(handlerName = this.getState(present))][(results = [name:presence, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName])]]
setMemberId: [log.debug(MemberId = $memberId)][(state.life360MemberId = memberId)]]
getMemberId: [log.debug(MemberId = $state.life360MemberId)][return state.life360MemberId]]
formatValue: [If present,,],]
formatDescriptionText: [If present,,],]
getState: [If present,,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: life360-user.metadata() is applicable for argument types: (life360-user$_run_closure1) values: [life360-user$_run_closure1@34a75079]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing lifx-color-bulb.groovy
DECLARED METHODS
initialize: ]
installed: ]
updated: ]
setHue: ]
setSaturation: ]
setColor: [(attrs = [])][(events = [])]]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
setLevel: [If ((percentage < 1) && (percentage > 0)),[(percentage = 1)],],[If (percentage == 0),,],]
setColorTemperature: ]
on: ]
off: ]
refresh: [(resp = parent.apiGET(/lights/$this.selector()))][If (resp.status == 404),[(state.online = false)],[If (resp.status != 200),,],],[(data = resp.data[0])][If data.connected,,],]
selector: [If device.deviceNetworkId.contains(:),,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: lifx-color-bulb.metadata() is applicable for argument types: (lifx-color-bulb$_run_closure1) values: [lifx-color-bulb$_run_closure1@3185fa6b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing lifx-white-bulb.groovy
DECLARED METHODS
initialize: ]
installed: ]
updated: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
setLevel: [If ((percentage < 1) && (percentage > 0)),[(percentage = 1)],],[If (percentage == 0),,],]
setColorTemperature: ]
on: ]
off: ]
refresh: [(resp = parent.apiGET(/lights/$this.selector()))][If (resp.status == 404),[(state.online = false)],[If (resp.status != 200),,],],[(data = resp.data[0])][If data.connected,,],]
selector: [If device.deviceNetworkId.contains(:),,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: lifx-white-bulb.metadata() is applicable for argument types: (lifx-white-bulb$_run_closure1) values: [lifx-white-bulb$_run_closure1@42b64ab8]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing light-follows-me.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@d5ae57e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@68759011[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7e242b4d[org.codehaus.groovy.ast.expr.VariableExpression@305f031[variable: motion1], ConstantExpression[motion], org.codehaus.groovy.ast.expr.VariableExpression@592e843a[variable: motionHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1d1f7216[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@423e4cbb[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6e16b8b5[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@43b4fe19[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@25ddbbbb[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1536602f[org.codehaus.groovy.ast.expr.VariableExpression@4ebea12c[variable: motion1], ConstantExpression[motion], org.codehaus.groovy.ast.expr.VariableExpression@2a1edad4[variable: motionHandler]]]]]]
motionHandler: [If (evt.value == active),,[If (evt.value == inactive),[org.codehaus.groovy.ast.stmt.ExpressionStatement@6256ac4f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@44c79f32[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7fcbe147[org.codehaus.groovy.ast.expr.BinaryExpression@235f4c10[org.codehaus.groovy.ast.expr.VariableExpression@743cb8e0[variable: minutes1]("*" at 55:18:  "*" )ConstantExpression[60]], org.codehaus.groovy.ast.expr.VariableExpression@c7a975a[variable: scheduleCheck], org.codehaus.groovy.ast.expr.MapExpression@2c1b9e4b[org.codehaus.groovy.ast.expr.MapEntryExpression@757d6814(key: ConstantExpression[overwrite], value: ConstantExpression[false])]]]]],],],]
scheduleCheck: [org.codehaus.groovy.ast.stmt.ExpressionStatement@649725e3[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3c0fae6c[object: org.codehaus.groovy.ast.expr.VariableExpression@4c168660[variable: log] method: ConstantExpression[debug] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@52b56a3e[ConstantExpression[schedule check]]]]][(motionState = motion1.currentState(motion))][If (motionState.value == inactive),[(elapsed = (this.now() - motionState.rawDateCreated.time))][(threshold = (((1000 * 60) * minutes1) - 1000))][If (elapsed >= threshold),,],,],]
Starting Points: [log.debug(schedule check)]
IT HAS STATE
--app-start--
processing light-sensor.groovy
DECLARED METHODS
parse: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If description?.startsWith(illuminance: ),[(raw = (description - illuminance: ))][If raw.isNumber(),[(result = this.createEvent([name:illuminance, value:java.lang.Math.round(zigbee.lux((java.lang.Integer -> java.lang.Integer) raw)).toString(), unit:lux]))],],,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: light-sensor.metadata() is applicable for argument types: (light-sensor$_run_closure1) values: [light-sensor$_run_closure1@2f058b8a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing light-up-the-night.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@64337702[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2cf92cc7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@30ea8c23[org.codehaus.groovy.ast.expr.VariableExpression@7b139eab[variable: lightSensor], ConstantExpression[illuminance], org.codehaus.groovy.ast.expr.VariableExpression@4e76dac[variable: illuminanceHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@611df6e3[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5f2f577[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6273c5a4[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5d465e4b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@53e211ee[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@41a90fa8[org.codehaus.groovy.ast.expr.VariableExpression@3d8bbcdc[variable: lightSensor], ConstantExpression[illuminance], org.codehaus.groovy.ast.expr.VariableExpression@52500920[variable: illuminanceHandler]]]]]]
illuminanceHandler: [(lastStatus = state.lastStatus)][If ((lastStatus != on) && (evt.integerValue < 30)),[(state.lastStatus = on)],[If ((lastStatus != off) && (evt.integerValue > 50)),[(state.lastStatus = off)],],],]
Starting Points: []
IT HAS STATE
--app-start--
processing lights-off-when-closed.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6ffab045[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@26fb628[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3e2943ab[org.codehaus.groovy.ast.expr.VariableExpression@70dd7e15[variable: contact1], ConstantExpression[contact.closed], org.codehaus.groovy.ast.expr.VariableExpression@4a9f80d3[variable: contactClosedHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@35beb15e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@41fe9859[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5ac86ba5[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6c67e137[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2c9399a4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@191ae03f[org.codehaus.groovy.ast.expr.VariableExpression@9635fa[variable: contact1], ConstantExpression[contact.closed], org.codehaus.groovy.ast.expr.VariableExpression@53ab0286[variable: contactClosedHandler]]]]]]
contactClosedHandler: ]
Starting Points: []
IT HAS STATE
--app-start--
processing lights-off-with-no-motion-and-presence.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6a62689d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4602c2a9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@60fa3495[org.codehaus.groovy.ast.expr.VariableExpression@3e2822[variable: motionSensor], ConstantExpression[motion], org.codehaus.groovy.ast.expr.VariableExpression@79e18e38[variable: motionHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@29a60c27[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1849db1a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@69c79f09[org.codehaus.groovy.ast.expr.VariableExpression@1ca25c47[variable: presenceSensors], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@5fcacc0[variable: presenceHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@533b266e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6d1d4d7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@89ff02e[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6865c751[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@62679465[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6a988392[org.codehaus.groovy.ast.expr.VariableExpression@1d71006f[variable: motionSensor], ConstantExpression[motion], org.codehaus.groovy.ast.expr.VariableExpression@5b6813df[variable: motionHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5f2606b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2b58f754[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3ebff828[org.codehaus.groovy.ast.expr.VariableExpression@2552f2cb[variable: presenceSensors], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@33352f32[variable: presenceHandler]]]]]]
motionHandler: [If (evt.value == inactive),[org.codehaus.groovy.ast.stmt.ExpressionStatement@5f3b9c57[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1e044120[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2cf23c81[org.codehaus.groovy.ast.expr.BinaryExpression@3624da92[org.codehaus.groovy.ast.expr.VariableExpression@35fe2125[variable: delayMins]("*" at 44:21:  "*" )ConstantExpression[60]], org.codehaus.groovy.ast.expr.VariableExpression@94f6bfb[variable: scheduleCheck], org.codehaus.groovy.ast.expr.MapExpression@34645867[org.codehaus.groovy.ast.expr.MapEntryExpression@2484f433(key: ConstantExpression[overwrite], value: ConstantExpression[true])]]]]],],]
presenceHandler: [If (evt.value == not present),[org.codehaus.groovy.ast.stmt.ExpressionStatement@60b71e8f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1255b1d1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@464649c[org.codehaus.groovy.ast.expr.BinaryExpression@7c22d4f[org.codehaus.groovy.ast.expr.VariableExpression@5f59185e[variable: delayMins]("*" at 51:21:  "*" )ConstantExpression[60]], org.codehaus.groovy.ast.expr.VariableExpression@60bdf15d[variable: scheduleCheck], org.codehaus.groovy.ast.expr.MapExpression@47da3952[org.codehaus.groovy.ast.expr.MapEntryExpression@51e4ccb3(key: ConstantExpression[overwrite], value: ConstantExpression[true])]]]]],],]
isActivePresence: [(noPresence = (presenceSensors.find({ -> ... }) == null))]]
scheduleCheck: [org.codehaus.groovy.ast.stmt.ExpressionStatement@46e8a539[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@495083a0[object: org.codehaus.groovy.ast.expr.VariableExpression@5fd62371[variable: log] method: ConstantExpression[debug] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@28a0fd6c[ConstantExpression[scheduled check]]]]][(motionState = motionSensor.currentState(motion))][If (motionState.value == inactive),[(elapsed = (this.now() - motionState.rawDateCreated.time))][(threshold = (((1000 * 60) * delayMins) - 1000))][If (elapsed >= threshold),[If this.isActivePresence(),,],,],,],]
Starting Points: [log.debug(scheduled check)]
IT HAS STATE
--app-start--
processing lock-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
lock: ]
unlock: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: lock-capability.metadata() is applicable for argument types: (lock-capability$_run_closure1) values: [lock-capability$_run_closure1@3f23a3a0]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing lock-it-at-a-specific-time.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@31024624[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@25bcd0c7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@32cb636e[org.codehaus.groovy.ast.expr.VariableExpression@63cd604c[variable: time], ConstantExpression[setTimeCallback]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@40dd3977[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3a4e343[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6a1d204a[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@62dae245[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4b6579e8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6fff253c[org.codehaus.groovy.ast.expr.VariableExpression@6c6357f9[variable: time], ConstantExpression[setTimeCallback]]]]]]
setTimeCallback: [If contact,,],]
doorOpenCheck: [(currentState = contact.contactState)][If (currentState?.value == open),[(msg = $contact.displayName is open.  Scheduled lock failed.)][If sendPushMessage,,],[If phone,,],,],]
lockMessage: [(msg = Locking $lock.displayName due to scheduled lock.)][If sendPushMessage,,],[If phone,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing lock-it-when-i-leave.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@7f69d591[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@61078690[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1cb3ec38[org.codehaus.groovy.ast.expr.VariableExpression@403132fc[variable: presence1], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@71c5b236[variable: presence]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@2cab9998[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2f7a7219[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@669513d8[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3a1d593e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4a8a60bc[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@361c294e[org.codehaus.groovy.ast.expr.VariableExpression@7859e786[variable: presence1], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@285d851a[variable: presence]]]]]]
presence: [If (evt.value == present),[If (unlock == Yes),[(anyLocked = (lock1.count({ -> ... }) != lock1.size()))][If anyLocked,,],,],,[(nobodyHome = (presence1.find({ -> ... }) == null))][If nobodyHome,[(anyUnlocked = (lock1.count({ -> ... }) != lock1.size()))][If anyUnlocked,,],,],],]
sendMessage: [If location.contactBookEnabled,,[If (spam == Yes),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing logitech-harmony-hub-c2c.groovy
DECLARED METHODS
initialize: ]
installed: ]
updated: ]
startActivity: ]
activityoff: ]
alloff: ]
poll: ]
ping: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: logitech-harmony-hub-c2c.metadata() is applicable for argument types: (logitech-harmony-hub-c2c$_run_closure1) values: [logitech-harmony-hub-c2c$_run_closure1@33617539]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing mail-arrived.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@f9b7332[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@74cec793[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6fefce9e[org.codehaus.groovy.ast.expr.VariableExpression@4f8969b0[variable: accelerationSensor], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@1bdf8190[variable: accelerationActiveHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@192f2f27[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@8a589a2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@c65a5ef[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6b5176f2[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@b672aa8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2fab4aff[org.codehaus.groovy.ast.expr.VariableExpression@ec0c838[variable: accelerationSensor], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@6e46d9f4[variable: accelerationActiveHandler]]]]]]
accelerationActiveHandler: [(deltaSeconds = 5)][(timeAgo = new java.util.Date((this.now() - (1000 * deltaSeconds))))][(recentEvents = accelerationSensor.eventsSince(timeAgo))][(alreadySentNotifications = (recentEvents.count({ -> ... }) > 1))][If alreadySentNotifications,,[If location.contactBookEnabled,,[If ((phone1 != null) && (phone1 != )),,],[If pushNotification,,],],],]
Starting Points: []
IT HAS STATE
--app-start--
processing make-it-so.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@74bdc168[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@644c78d4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@532a02d9[org.codehaus.groovy.ast.expr.VariableExpression@611f8234[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@7bb3a9fe[variable: changedLocationMode]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7cbee484[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7f811d00[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@62923ee6[org.codehaus.groovy.ast.expr.VariableExpression@4089713[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@f19c9d2[variable: appTouch]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@7807ac2c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@b91d8c4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4b6166aa[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@a77614d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4fd4cae3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4a067c25[org.codehaus.groovy.ast.expr.VariableExpression@a1217f9[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@3bde62ff[variable: changedLocationMode]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@523424b5[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2baa8d82[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@319dead1[org.codehaus.groovy.ast.expr.VariableExpression@791cbf87[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@a7e2d9d[variable: appTouch]]]]]]
appTouch: ]
changedLocationMode: ]
restoreState: [(map = (state[mode]) ? state[mode] : [:])]]
saveState: [(mode = currentMode)][(map = (state[mode]) ? state[mode] : [:])][(state[mode] = map)]]
getCurrentMode: ]
Starting Points: []
IT HAS STATE
--app-start--
processing medicine-management-contact-sensor.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@66ea1466[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1601e47[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3bffddff[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@66971f6b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@50687efb[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@517bd097[org.codehaus.groovy.ast.expr.VariableExpression@142eef62[variable: deviceContactSensor], ConstantExpression[contact], org.codehaus.groovy.ast.expr.VariableExpression@4a9cc6cb[variable: contactHandler]]]]][(state.minutesToCheckOpenDraw = 60)][(state.ledNotificationTriggered = false)][org.codehaus.groovy.ast.stmt.ExpressionStatement@5990e6c5[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@56e07a08[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@35d6ca49[org.codehaus.groovy.ast.expr.VariableExpression@1950e8a6[variable: reminderTime], org.codehaus.groovy.ast.expr.VariableExpression@47289387[variable: checkOpenDrawInPast]]]]]]
contactHandler: [If (evt.value == open),[If state.ledNotificationTriggered,,],,],]
checkOpenDrawInPast: [(cabinetOpened = this.isOpened(state.minutesToCheckOpenDraw))][If cabinetOpened,[(reminderTimePlus10 = new java.util.Date((this.now() + (10 * 60000))))][org.codehaus.groovy.ast.stmt.ExpressionStatement@12cd9150[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@114a85c2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runOnce] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@f415a95[org.codehaus.groovy.ast.expr.VariableExpression@cf65451[variable: reminderTimePlus10], org.codehaus.groovy.ast.expr.VariableExpression@724f138e[variable: checkOpenDrawAfterReminder]]]]],],]
checkOpenDrawAfterReminder: [(cabinetOpened = this.isOpened(10))][If cabinetOpened,,],]
sendNotification: ]
isOpened: [(previousDateTime = new java.util.Date((this.now() - (minutes * 60000))))][(evts = deviceContactSensor.eventsSince(previousDateTime))][(cabinetOpened = false)][If (evts.size() > 0),,],]
setLEDNotification: [(state.ledNotificationTriggered = true)][(state.ledState = deviceLight.currentValue(switch))][(state.origColor = deviceLight.currentValue(hue))][log.debug(LED set to RED. Original color stored: $state.origColor)]]
resetLEDNotification: [(state.ledNotificationTriggered = false)][log.debug(Reset LED color to: $state.origColor)][If (state.origColor != null),[deviceLight.setHue(state.origColor)],],[If (state.ledState == off),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing medicine-management-temp-motion.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@70fab835[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1b0a7baf[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@62417a16[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@32057e6[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@26be6ca7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6ea1bcdc[org.codehaus.groovy.ast.expr.VariableExpression@759fad4[variable: deviceTemperatureMeasurement], ConstantExpression[temperature], org.codehaus.groovy.ast.expr.VariableExpression@64712be[variable: tempHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@53499d85[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@30ed9c6c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@782a4fff[org.codehaus.groovy.ast.expr.VariableExpression@46c670a6[variable: deviceAccelerationSensor], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@59fc684e[variable: motionHandler]]]]][(state.minutesToCheckPriorToReminder = 60)][org.codehaus.groovy.ast.stmt.ExpressionStatement@5ae81e1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2fd1731c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5ae76500[org.codehaus.groovy.ast.expr.VariableExpression@6063d80a[variable: reminderTime], org.codehaus.groovy.ast.expr.VariableExpression@1133ec6e[variable: checkMotionInPast]]]]]]
tempHandler: [If (evt.doubleValue > tempThreshold),,],]
motionHandler: ]
checkMotionInPast: [(movement = this.isMoved(state.minutesToCheckPriorToReminder))][If movement,[(reminderTimePlus10 = new java.util.Date((this.now() + (10 * 60000))))][org.codehaus.groovy.ast.stmt.ExpressionStatement@355e34c7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@54709809[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runOnce] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2a2da905[org.codehaus.groovy.ast.expr.VariableExpression@24f360b2[variable: reminderTimePlus10], org.codehaus.groovy.ast.expr.VariableExpression@60cf80e7[variable: checkMotionAfterReminder]]]]],],]
checkMotionAfterReminder: [(movement = this.isMoved(10))][If movement,,],]
sendNotification: ]
isMoved: [(previousDateTime = new java.util.Date((this.now() - (minutes * 60000))))][(evts = deviceAccelerationSensor.eventsSince(previousDateTime))][(motion = false)][If (evts.size() > 0),,],]
setLEDNotification: [(state.ledState = deviceLight.currentValue(switch))][(state.origColor = deviceLight.currentValue(hue))][log.debug(LED set to RED. Original color stored: $state.origColor)]]
resetLEDNotification: [log.debug(Reset LED color to: $state.origColor)][deviceLight.setHue(state.origColor)][If (state.ledState == off),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing medicine-reminder.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@59aa20b3[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@363f6148[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4b21844c[]]]]]
initialize: [(window = timeWindowMsec)]]
scheduleCheck0: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1b28f282[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@138fe6ec[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[scheduleCheck] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5e77f0f4[]]]]]
scheduleCheck1: [org.codehaus.groovy.ast.stmt.ExpressionStatement@19b30c92[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@455351c4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[scheduleCheck] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@29876704[]]]]]
scheduleCheck2: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4816c290[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4940809c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[scheduleCheck] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@16423501[]]]]]
scheduleCheck3: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4efcf8a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7a138fc5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[scheduleCheck] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@379ab47b[]]]]]
scheduleCheck: [org.codehaus.groovy.ast.stmt.ExpressionStatement@307765b4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4a9e6faf[object: org.codehaus.groovy.ast.expr.VariableExpression@2c95ac9e[variable: log] method: ConstantExpression[debug] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4e4efc1b[ConstantExpression[scheduleCheck]]]]][(t0 = new java.util.Date((this.now() - (2 * timeWindowMsec))))][(t1 = new java.util.Date())][(cabinetOpened = cabinet1.eventsBetween(t0, t1).find({ -> ... }))][If cabinetOpened,,],]
sendMessage: [(msg = Please remember to take your medicine)][If location.contactBookEnabled,,[If phone1,,],[If (sendPush == Yes),,],],]
getTimeWindowMsec: ]
Starting Points: []
IT HAS STATE
--app-start--
processing mini-hue-controller.groovy
DECLARED METHODS
installed: [(state.colorIndex = -1)]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4da855dd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6691490c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2187fff7[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@2e5c7f0b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@21d5c1a0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4de025bf[org.codehaus.groovy.ast.expr.VariableExpression@538613b3[variable: controller], ConstantExpression[button], org.codehaus.groovy.ast.expr.VariableExpression@1eef9aef[variable: buttonHandler]]]]]]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
buttonHandler: ]
toggleState: [If (currentSwitchState == on),,],]
levelUp: [(level = java.lang.Math.min((currentSwitchLevel + 10), 100))][log.debug(level = $level)]]
levelDown: [(level = java.lang.Math.max((currentSwitchLevel - 10), 10))][log.debug(level = $level)]]
changeColor: [(colors = [[name:Soft White, hue:23, saturation:56], [name:Daylight, hue:53, saturation:91], [name:White, hue:52, saturation:19], [name:Warm White, hue:20, saturation:80], [name:Blue, hue:70, saturation:100], [name:Green, hue:39, saturation:100], [name:Yellow, hue:25, saturation:100], [name:Orange, hue:10, saturation:100], [name:Purple, hue:75, saturation:100], [name:Pink, hue:83, saturation:100], [name:Red, hue:100, saturation:100]])][(maxIndex = (colors.size() - 1))][If (state.colorIndex < maxIndex),[(state.colorIndex = (state.colorIndex + 1))],[(state.colorIndex = 0)]],[(color = colors[state.colorIndex])]]
getCurrentSwitchState: [(on = 0)][(off = 0)]]
getCurrentSwitchLevel: [(level = 0)]]
Starting Points: []
IT HAS STATE
--app-start--
processing mobile-presence.groovy
DECLARED METHODS
parse: [(name = this.parseName(description))][(value = this.parseValue(description))][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(handlerName = this.getState(value))][(isStateChange = this.isStateChange(device, name, value))][(results = [translatable:true, name:name, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName, ... ])]]
parseName: [If description?.startsWith(presence: ),,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseValue: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseDescriptionText: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
getState: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: mobile-presence.metadata() is applicable for argument types: (mobile-presence$_run_closure1) values: [mobile-presence$_run_closure1@4152d38d]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing momentary-button-tile.groovy
DECLARED METHODS
parse: ]
push: ]
on: ]
off: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: momentary-button-tile.metadata() is applicable for argument types: (momentary-button-tile$_run_closure1) values: [momentary-button-tile$_run_closure1@3f093abe]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing momentary-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
push: ]
off: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: momentary-capability.metadata() is applicable for argument types: (momentary-capability$_run_closure1) values: [momentary-capability$_run_closure1@16fb356]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing monitor-on-sense.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@9573b3b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@67427b69[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@78461bc4[org.codehaus.groovy.ast.expr.VariableExpression@544630b7[variable: accelerationSensor], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@64f857e7[variable: accelerationActiveHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1095f122[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@58c540cf[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3d6300e8[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1b822fcc[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@24a1c17f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@56102e1c[org.codehaus.groovy.ast.expr.VariableExpression@73511076[variable: accelerationSensor], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@7927bd9f[variable: accelerationActiveHandler]]]]]]
accelerationActiveHandler: ]
Starting Points: []
IT HAS STATE
--app-start--
processing mood-cube.groovy
DECLARED METHODS
scenesPage: [(sceneId = this.getOrientation())]]
scenePage: [(currentSceneId = this.getOrientation())][(sceneId = ((java.lang.Integer -> java.lang.Integer) params.sceneId) ? (java.lang.Integer -> java.lang.Integer) params.sceneId : state.lastDisplayedSceneId)][(state.lastDisplayedSceneId = sceneId)]]
devicePage: [(sceneId = ((java.lang.Integer -> java.lang.Integer) params.sceneId) ? (java.lang.Integer -> java.lang.Integer) params.sceneId : state.lastDisplayedSceneId)]]
saveStatesPage: ]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5b800468[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2e185cd7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7e1a1da6[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5f7f2382[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@407cf41[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6815c5f2[org.codehaus.groovy.ast.expr.VariableExpression@46cc127b[variable: cube], ConstantExpression[threeAxis], org.codehaus.groovy.ast.expr.VariableExpression@60094a13[variable: positionHandler]]]]]]
positionHandler: [(sceneId = this.getOrientation(evt.xyzValue))][If (sceneId != state.lastActiveSceneId),,],[(state.lastActiveSceneId = sceneId)]]
sceneIsDefined: [(tgt = onoff_$sceneId.toString())][(settings.find({ -> ... }) != null)]]
updateSetting: [(settings[name] = value)]]
closestLevel: ]
saveStates: [(sceneId = (java.lang.Integer -> java.lang.Integer) params.sceneId)]]
restoreStates: ]
switchLevel: [(percent = settings.level_$sceneId_$light.id)][If percent,,],]
getDeviceCapabilities: [(caps = [:])][(state.lightCapabilities = caps)]]
getLevels: [(levels = [])][For ((i = 0); (i <= 100); (i += 5)),]getLevels: [(levels = [])][For ((i = 0); (i <= 100); (i += 5)),]]
getOrientation: [(threshold = 250)][(value = (xyz) ? xyz : cube.currentValue(threeAxis))][(x = ((java.lang.Math.abs(value.x) > threshold)) ? ((value.x > 0)) ? 1 : -1 : 0)][(y = ((java.lang.Math.abs(value.y) > threshold)) ? ((value.y > 0)) ? 1 : -1 : 0)][(z = ((java.lang.Math.abs(value.z) > threshold)) ? ((value.z > 0)) ? 1 : -1 : 0)][(orientation = 0)][If (z > 0),[If ((x == 0) && (y == 0)),[(orientation = 1)],],,[If (z < 0),[If ((x == 0) && (y == 0)),[(orientation = 2)],],,[If (x > 0),[If (y == 0),[(orientation = 3)],],,[If (x < 0),[If (y == 0),[(orientation = 4)],],,[If (y > 0),[(orientation = 5)],[If (y < 0),[(orientation = 6)],],],],],],],]
sceneName: [(names = [UNDEFINED, One, Two, Three, Four, Five, Six])]]
Starting Points: []
IT HAS STATE
--app-start--
processing motion-detector.groovy
DECLARED METHODS
parse: [(name = null)][(value = description)][(descriptionText = null)][If zigbee.isZoneType19(description),[(name = motion)][(isActive = zigbee.translateStatusZoneType19(description))][(value = (isActive) ? active : inactive)][(descriptionText = (isActive) ? $device.displayName detected motion : $device.displayName motion has stopped)],],[(result = this.createEvent([name:name, value:value, descriptionText:descriptionText]))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: motion-detector.metadata() is applicable for argument types: (motion-detector$_run_closure1) values: [motion-detector$_run_closure1@3deb2326]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing motion-sensor-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: motion-sensor-capability.metadata() is applicable for argument types: (motion-sensor-capability$_run_closure1) values: [motion-sensor-capability$_run_closure1@655a5d9c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing my-light-toggle.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@77cf3f8b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1df98368[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@21ca139c[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@226f885f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2cd2c8fe[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7d61eccf[org.codehaus.groovy.ast.expr.VariableExpression@cc6460c[variable: motionToggler], ConstantExpression[motion], org.codehaus.groovy.ast.expr.VariableExpression@52350abb[variable: toggleSwitches]]]]]]
toggleSwitches: [If ((evt.value == active) && (masterToggle.currentSwitch == off)),,[If ((evt.value == active) && (masterToggle.currentSwitch == on)),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing netatmo-additional-module.groovy
DECLARED METHODS
parse: ]
poll: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: netatmo-additional-module.metadata() is applicable for argument types: (netatmo-additional-module$_run_closure1) values: [netatmo-additional-module$_run_closure1@74f7d1d2]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing netatmo-basestation.groovy
DECLARED METHODS
parse: ]
poll: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: netatmo-basestation.metadata() is applicable for argument types: (netatmo-basestation$_run_closure1) values: [netatmo-basestation$_run_closure1@677dbd89]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing netatmo-outdoor-module.groovy
DECLARED METHODS
parse: ]
poll: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: netatmo-outdoor-module.metadata() is applicable for argument types: (netatmo-outdoor-module$_run_closure1) values: [netatmo-outdoor-module$_run_closure1@5c77053b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing netatmo-rain.groovy
DECLARED METHODS
parse: ]
poll: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: netatmo-rain.metadata() is applicable for argument types: (netatmo-rain$_run_closure1) values: [netatmo-rain$_run_closure1@2970a5bc]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing nfc-tag-toggle.groovy
currentValue, arg not ConstantExpression
currentValue, arg not ConstantExpression
DECLARED METHODS
pageTwo: ]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@40f33492[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4fbdc0f0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2ad3a1bb[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6bc28a83[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@324c64cd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@13579834[org.codehaus.groovy.ast.expr.VariableExpression@24be2d9c[variable: tag], ConstantExpression[nfcTouch], org.codehaus.groovy.ast.expr.VariableExpression@5bd73d1a[variable: touchHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@aec50a1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2555fff0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@70d2e40b[org.codehaus.groovy.ast.expr.VariableExpression@120f38e6[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@7a0e1b5e[variable: touchHandler]]]]]]
currentStatus: [(result = null)][If master,[(result = devices.find({ -> ... })?.currentValue(attribute))],[(map = [:])][(result = map.collect({ -> ... }).sort({ -> ... })[-1].key)]],[log.debug($attribute = $result)]]
touchHandler: [If switch1,[(status = this.currentStatus(switch1, masterSwitch, switch))],],[If lock,[(status = this.currentStatus(lock, masterLock, lock))],],[If garageDoor,[(status = this.currentStatus(garageDoor, masterDoor, status))],],]
Starting Points: []
IT HAS STATE
--app-start--
processing nobody-home.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@384fc774[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@e3cee7b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@71e9a896[]]]]]
init: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6b9267b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@408b35bf[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@29ad44e3[org.codehaus.groovy.ast.expr.VariableExpression@15bcf458[variable: people], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@5af9926a[variable: presence]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@43c67247[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@fac80[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@726386ed[org.codehaus.groovy.ast.expr.VariableExpression@649f2009[variable: location], ConstantExpression[sunrise], org.codehaus.groovy.ast.expr.VariableExpression@14bb2297[variable: setSunrise]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@69adf72c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@797501a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1a15b789[org.codehaus.groovy.ast.expr.VariableExpression@57f791c6[variable: location], ConstantExpression[sunset], org.codehaus.groovy.ast.expr.VariableExpression@51650883[variable: setSunset]]]]][(state.sunMode = location.mode)]]
setSunrise: ]
setSunset: ]
changeSunMode: [(state.sunMode = newMode)][If (this.everyoneIsAway() && (location.mode == newAwayMode)),,[If (location.mode != newMode),[(message = $app.label changed your mode to '$newMode')],],],]
presence: [If (evt.value == not present),[If this.everyoneIsAway(),[(delay = (((awayThreshold != null) && (awayThreshold != ))) ? (awayThreshold * 60) : (10 * 60))][org.codehaus.groovy.ast.stmt.ExpressionStatement@6c4f9535[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5bd1ceca[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@30c31dd7[org.codehaus.groovy.ast.expr.VariableExpression@499b2a5c[variable: delay], ConstantExpression[setAway]]]]],],,[If (location.mode != state.sunMode),[If this.anyoneIsHome(),[log.info(Starting $state.sunMode sequence)][this.changeSunMode(state.sunMode)],],,],],]
setAway: [If this.everyoneIsAway(),[If (location.mode != newAwayMode),[(message = $app.label changed your mode to '$newAwayMode' because everyone left home)],],,],]
everyoneIsAway: [(result = true)][If people.findAll({ -> ... }),[(result = false)],],]
anyoneIsHome: [(result = false)][If people.findAll({ -> ... }),[(result = true)],],]
send: [If (sendPushMessage != No),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing notify-me-when-it-opens.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@66238be2[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1c25b8a7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@200606de[org.codehaus.groovy.ast.expr.VariableExpression@750fe12e[variable: contact1], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@f8908f6[variable: contactOpenHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@3e587920[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2ef8a8c3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@24f43aa3[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@63fd4873[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1e11bc55[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7544a1e4[org.codehaus.groovy.ast.expr.VariableExpression@70e0accd[variable: contact1], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@7957dc72[variable: contactOpenHandler]]]]]]
contactOpenHandler: ]
Starting Points: []
IT HAS STATE
--app-start--
processing notify-me-when.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@77b7ffa4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5ed190be[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@402f80f5[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5bbc9f97[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@133e019b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@41382722[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7dac3fd8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@425357dd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2102a4d5[]]]]]
subscribeToEvents: [org.codehaus.groovy.ast.stmt.ExpressionStatement@210386e0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3d4d3fe7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@65f87a2c[org.codehaus.groovy.ast.expr.VariableExpression@51684e4a[variable: button], ConstantExpression[button.pushed], org.codehaus.groovy.ast.expr.VariableExpression@6ce1f601[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@38875e7d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1e886a5b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@d816dde[org.codehaus.groovy.ast.expr.VariableExpression@6e33c391[variable: contact], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@6c451c9c[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@31c269fd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@372b0d86[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@47747fb9[org.codehaus.groovy.ast.expr.VariableExpression@3113a37[variable: contactClosed], ConstantExpression[contact.closed], org.codehaus.groovy.ast.expr.VariableExpression@213e3629[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4e9658b5[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2a7b6f69[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@20312893[org.codehaus.groovy.ast.expr.VariableExpression@70eecdc2[variable: acceleration], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@c41709a[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7db0565c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@54ec8cc9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@52eacb4b[org.codehaus.groovy.ast.expr.VariableExpression@5528a42c[variable: motion], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@2a551a63[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1a6f5124[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1edb61b1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@ec2bf82[org.codehaus.groovy.ast.expr.VariableExpression@cc62a3b[variable: mySwitch], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@6cc0bcf6[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@29539e36[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@32f61a31[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@f5c79a6[org.codehaus.groovy.ast.expr.VariableExpression@669253b7[variable: mySwitchOff], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@5305c37d[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@51a06cbe[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3dddbe65[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@49a64d82[org.codehaus.groovy.ast.expr.VariableExpression@344561e0[variable: arrivalPresence], ConstantExpression[presence.present], org.codehaus.groovy.ast.expr.VariableExpression@66d23e4a[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@36ac8a63[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4d9d1b69[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@52c8295b[org.codehaus.groovy.ast.expr.VariableExpression@251f7d26[variable: departurePresence], ConstantExpression[presence.not present], org.codehaus.groovy.ast.expr.VariableExpression@77b21474[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@52d10fb8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@41c07648[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1fe8d51b[org.codehaus.groovy.ast.expr.VariableExpression@781e7326[variable: smoke], ConstantExpression[smoke.detected], org.codehaus.groovy.ast.expr.VariableExpression@22680f52[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@60d84f61[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@39c11e6c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@324dcd31[org.codehaus.groovy.ast.expr.VariableExpression@503d56b5[variable: smoke], ConstantExpression[smoke.tested], org.codehaus.groovy.ast.expr.VariableExpression@72bca894[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@433ffad1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1fc793c2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2575f671[org.codehaus.groovy.ast.expr.VariableExpression@329a1243[variable: smoke], ConstantExpression[carbonMonoxide.detected], org.codehaus.groovy.ast.expr.VariableExpression@ecf9fb3[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2d35442b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@27f9e982[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4593ff34[org.codehaus.groovy.ast.expr.VariableExpression@37d3d232[variable: water], ConstantExpression[water.wet], org.codehaus.groovy.ast.expr.VariableExpression@30c0ccff[variable: eventHandler]]]]]]
eventHandler: [If frequency,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],]
sendMessage: [(msg = messageText)][(options = [:])][If messageText,[(msg = this.defaultText(evt))][(options = [translatable:true, triggerEvent:evt])],],[If location.contactBookEnabled,,[If phone,[(options.phone = phone)][If (pushAndPhone != No),[(options.method = both)],[(options.method = phone)]],,[If (pushAndPhone != No),[(options.method = push)],[(options.method = none)]],],],[If frequency,[(state[evt.deviceId] = this.now())],],]
defaultText: [If (evt.name == presence),[If (evt.value == present),[If includeArticle,,],,[If includeArticle,,],],,],]
getIncludeArticle: [(name = location.name.toLowerCase())][(segs = name.split( ))]]
Starting Points: []
IT HAS STATE
--app-start--
processing notify-me-with-hue.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@238b521e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1b39fd82[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3e2fc448[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@21680803[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@588ab592[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@c8b96ec[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4cc61eb1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2d8f2f3a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2024293c[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7048f722[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@c074c0c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@58a55449[]]]]]
subscribeToEvents: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5949eba8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6e0ff644[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@58dea0a5[org.codehaus.groovy.ast.expr.VariableExpression@2a2bb0eb[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@3c291aad[variable: appTouchHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2d0566ba[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@733037[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7728643a[org.codehaus.groovy.ast.expr.VariableExpression@320e400[variable: contact], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@5167268[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1cfd1875[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@28c0b664[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2c444798[org.codehaus.groovy.ast.expr.VariableExpression@1af7f54a[variable: contactClosed], ConstantExpression[contact.closed], org.codehaus.groovy.ast.expr.VariableExpression@6ebd78d1[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@436390f4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4d157787[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@68ed96ca[org.codehaus.groovy.ast.expr.VariableExpression@6d1310f6[variable: acceleration], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@3228d990[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@54e7391d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@50b8ae8d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@255990cc[org.codehaus.groovy.ast.expr.VariableExpression@51c929ae[variable: motion], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@3c8bdd5b[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@29d2d081[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@40e4ea87[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@58783f6c[org.codehaus.groovy.ast.expr.VariableExpression@3a7b503d[variable: mySwitch], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@512d92b[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@62c5bbdc[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7bdf6bb7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1bc53649[org.codehaus.groovy.ast.expr.VariableExpression@88d6f9b[variable: mySwitchOff], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@47d93e0d[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@475b7792[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@751e664e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@160c3ec1[org.codehaus.groovy.ast.expr.VariableExpression@182b435b[variable: arrivalPresence], ConstantExpression[presence.present], org.codehaus.groovy.ast.expr.VariableExpression@4d0402b[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2fa7ae9[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7577b641[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3704122f[org.codehaus.groovy.ast.expr.VariableExpression@3153ddfc[variable: departurePresence], ConstantExpression[presence.not present], org.codehaus.groovy.ast.expr.VariableExpression@60afd40d[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@28a2a3e7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3f2049b6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@10b3df93[org.codehaus.groovy.ast.expr.VariableExpression@ea27e34[variable: smoke], ConstantExpression[smoke.detected], org.codehaus.groovy.ast.expr.VariableExpression@33a2499c[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@e72dba7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@33c2bd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1dfd5f51[org.codehaus.groovy.ast.expr.VariableExpression@3c321bdb[variable: smoke], ConstantExpression[smoke.tested], org.codehaus.groovy.ast.expr.VariableExpression@24855019[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3abd581e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4d4d8fcf[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@610db97e[org.codehaus.groovy.ast.expr.VariableExpression@6f0628de[variable: smoke], ConstantExpression[carbonMonoxide.detected], org.codehaus.groovy.ast.expr.VariableExpression@3fabf088[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1e392345[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@12f3afb5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4ced35ed[org.codehaus.groovy.ast.expr.VariableExpression@2c22a348[variable: water], ConstantExpression[water.wet], org.codehaus.groovy.ast.expr.VariableExpression@7bd69e82[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@74d7184a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@51b01960[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6831d8fd[org.codehaus.groovy.ast.expr.VariableExpression@27dc79f7[variable: button1], ConstantExpression[button.pushed], org.codehaus.groovy.ast.expr.VariableExpression@6b85300e[variable: eventHandler]]]]][If triggerModes,[org.codehaus.groovy.ast.stmt.ExpressionStatement@3aaf4f07[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5cbf9e9f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@18e8473e[org.codehaus.groovy.ast.expr.VariableExpression@5a2f016d[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@1a38ba58[variable: modeChangeHandler]]]]],],[If timeOfDay,[org.codehaus.groovy.ast.stmt.ExpressionStatement@3ad394e6[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6058e535[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@42deb43a[org.codehaus.groovy.ast.expr.VariableExpression@1deb2c43[variable: timeOfDay], org.codehaus.groovy.ast.expr.VariableExpression@3bb9efbc[variable: scheduledTimeHandler]]]]],],]
eventHandler: [If frequency,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],]
modeChangeHandler: [If (evt.value in triggerModes),,],]
scheduledTimeHandler: ]
appTouchHandler: ]
takeAction: [If frequency,[(state[evt.deviceId] = this.now())],],[(hueColor = 0)][If (color == Blue),[(hueColor = 70)],[If (color == Green),[(hueColor = 39)],[If (color == Yellow),[(hueColor = 25)],[If (color == Orange),[(hueColor = 10)],[If (color == Purple),[(hueColor = 75)],[If (color == Pink),[(hueColor = 83)],],],],],],],[(state.previous = [:])][log.debug(current values = $state.previous)][(newValue = [hue:hueColor, saturation:100, level:((java.lang.Integer -> java.lang.Integer) lightLevel) ? (java.lang.Integer -> java.lang.Integer) lightLevel : 100])][log.debug(new value = $newValue)]]
setTimer: [If duration,,[If (duration < 10),,[org.codehaus.groovy.ast.stmt.ExpressionStatement@1cefc4b3[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2b27cc70[object: org.codehaus.groovy.ast.expr.VariableExpression@6f6a7463[variable: log] method: ConstantExpression[debug] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1bdaa23d[org.codehaus.groovy.ast.expr.GStringExpression@79f227a9[strings: [ConstantExpression[runIn ], ConstantExpression[, resetHue]] values: [org.codehaus.groovy.ast.expr.VariableExpression@6ca320ab[variable: duration]]]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@50d68830[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1e53135d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7674a051[org.codehaus.groovy.ast.expr.VariableExpression@3a7704c[variable: duration], ConstantExpression[resetHue], org.codehaus.groovy.ast.expr.MapExpression@6754ef00[org.codehaus.groovy.ast.expr.MapEntryExpression@619bd14c(key: ConstantExpression[overwrite], value: ConstantExpression[false])]]]]]],],]
resetHue: ]
Starting Points: []
IT HAS STATE
--app-start--
processing obything-music-connect.groovy
DECLARED METHODS
installed: ]
updated: ]
initialize: [(parts = theAddr.split(:))][(iphex = this.convertIPtoHex(parts[0]))][(porthex = this.convertPortToHex(parts[1]))][(dni = $iphex:$porthex)][(hubNames = location.hubs*?.name.findAll({ -> ... }))][(d = this.addChildDevice(com.obycode, ObyThing Music, dni, theHub.id, [label:$app.label, name:ObyThing]))]]
convertIPtoHex: [(hex = ipAddress.tokenize(.).collect({ -> ... }).join())]]
convertPortToHex: [(hexport = port.toString().format(%04X, port.toInteger()))]]
Starting Points: []
IT HAS STATE
--app-start--
processing on-off-button-tile.groovy
DECLARED METHODS
parse: ]
on: ]
off: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: on-off-button-tile.metadata() is applicable for argument types: (on-off-button-tile$_run_closure1) values: [on-off-button-tile$_run_closure1@c20be82]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing on-off-shield.groovy
DECLARED METHODS
parse: [(value = zigbee.parse(description)?.text)][(name = ((value in [on, off])) ? switch : null)][(result = this.createEvent([name:name, value:value]))]]
on: ]
off: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: on-off-shield.metadata() is applicable for argument types: (on-off-shield$_run_closure1) values: [on-off-shield$_run_closure1@3a71c100]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing once-a-day.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@63a5e46c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7e8e8651[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@49ef32e0[org.codehaus.groovy.ast.expr.VariableExpression@271f18d3[variable: startTime], ConstantExpression[startTimerCallback]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6bd51ed8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@61e3a1fd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@51abf713[org.codehaus.groovy.ast.expr.VariableExpression@eadb475[variable: stopTime], ConstantExpression[stopTimerCallback]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4d4d48a6[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@315df4bb[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3fc08eec[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5cad8b7d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7b02e036[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@25243bc1[org.codehaus.groovy.ast.expr.VariableExpression@1e287667[variable: startTime], ConstantExpression[startTimerCallback]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2e6ee0bc[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4201a617[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@467f77a5[org.codehaus.groovy.ast.expr.VariableExpression@1bb9aa43[variable: stopTime], ConstantExpression[stopTimerCallback]]]]]]
startTimerCallback: ]
stopTimerCallback: ]
Starting Points: []
IT HAS STATE
--app-start--
processing open-closed-sensor.groovy
DECLARED METHODS
parse: [(resMap = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If description.startsWith(zone),[(resMap = this.createEvent([name:contact, value:(zigbee.parseZoneStatus(description).isAlarm1Set()) ? open : closed]))],],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: open-closed-sensor.metadata() is applicable for argument types: (open-closed-sensor$_run_closure1) values: [open-closed-sensor$_run_closure1@1556f2dd]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing particulate-detector.groovy
DECLARED METHODS
parse: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: particulate-detector.metadata() is applicable for argument types: (particulate-detector$_run_closure1) values: [particulate-detector$_run_closure1@d71adc2]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing pet-feeder-shield.groovy
DECLARED METHODS
parse: [(value = zigbee.parse(description)?.text)][(name = ((value && (value != ping))) ? response : null)][(result = this.createEvent([name:name, value:value]))]]
feed: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: pet-feeder-shield.metadata() is applicable for argument types: (pet-feeder-shield$_run_closure1) values: [pet-feeder-shield$_run_closure1@2e27d72f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing photo-burst-when.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@49bf29c6[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7ee55e70[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3fcdcf[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@7668d560[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@46292372[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@126be319[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6c44052e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5c371e13[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@530a8454[]]]]]
subscribeToEvents: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1e34c607[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5215cd9a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@36b6964d[org.codehaus.groovy.ast.expr.VariableExpression@31198ceb[variable: contact], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@9257031[variable: sendMessage]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@75201592[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7726e185[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@aa5455e[org.codehaus.groovy.ast.expr.VariableExpression@282308c3[variable: acceleration], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@5dda14d0[variable: sendMessage]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1db0ec27[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3d9fc57a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@d4ab71a[org.codehaus.groovy.ast.expr.VariableExpression@3b4ef7[variable: motion], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@1af05b03[variable: sendMessage]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5987e932[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1ad777f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5bbbdd4b[org.codehaus.groovy.ast.expr.VariableExpression@438bad7c[variable: mySwitch], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@25230246[variable: sendMessage]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4fdf8f12[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4a8b5227[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@54f5f647[org.codehaus.groovy.ast.expr.VariableExpression@6979efad[variable: arrivalPresence], ConstantExpression[presence.present], org.codehaus.groovy.ast.expr.VariableExpression@5a6d5a8f[variable: sendMessage]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4a67318f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@315ba14a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@17f9344b[org.codehaus.groovy.ast.expr.VariableExpression@27f0ad19[variable: departurePresence], ConstantExpression[presence.not present], org.codehaus.groovy.ast.expr.VariableExpression@54e81b21[variable: sendMessage]]]]]]
sendMessage: [If location.contactBookEnabled,,[If phone,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing plant-link.groovy
DECLARED METHODS
updated: ]
parse: [(map = [:])][If description?.startsWith(read attr -),[(descMap = this.parseDescriptionAsMap(description))][If ((descMap.cluster == 0405) && (descMap.attrId == 0000)),[(map.name = humidity)][(map.value = this.calculateHumidity(descMap.value))],[If ((descMap.cluster == 0001) && (descMap.attrId == 0000)),[(map.name = battery)][(map.value = this.calculateBattery(descMap.value))],],],,],[(result = null)][If map,[(result = this.createEvent(map))],],]
parseDescriptionAsMap: ]
calculateHumidity: [(range = 576)][(percent = ((java.lang.Integer.parseInt(value, 16) / range) * 100))][(percent = java.lang.Math.max(0.0, java.lang.Math.min(percent, 100.0)))]]
calculateBattery: [(min = 2300)][(percent = ((java.lang.Integer.parseInt(value, 16) - min) / 10))][(percent = java.lang.Math.max(0.0, java.lang.Math.min(percent, 100.0)))]]
hex: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: plant-link.metadata() is applicable for argument types: (plant-link$_run_closure1) values: [plant-link$_run_closure1@5bb3d42d]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing plantlink.groovy
DECLARED METHODS
updated: ]
installed: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
setStatusIcon: [(status = )]]
setPlantFuelLevel: ]
setBatteryLevel: ]
setInstallSmartApp: ]
parse: [(description_map = this.parseDescriptionAsMap(description))][(event_name = )][(measurement_map = [type:link, signal:0x00, zigbeedeviceid:device.zigbeeId, created:(int) (new java.util.Date().time / 1000)])][If (description_map.cluster == 0001),[(event_name = battery_status)][(measurement_map[battery] = 0x$description_map.value)],[If (description_map.cluster == 0B04),[(measurement_map[moisture] = 0x$description_map.value)][(event_name = moisture_status)],],],[(json_builder = new groovy.json.JsonBuilder(measurement_map))][(result = this.createEvent([name:event_name, value:json_builder.toString()]))]]
parseDescriptionAsMap: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: plantlink.metadata() is applicable for argument types: (plantlink$_run_closure1) values: [plantlink$_run_closure1@3f3ddbd9]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing power-allowance.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@777c9dc9[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@71b1a49c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@73e132e0[org.codehaus.groovy.ast.expr.VariableExpression@3773862a[variable: theSwitch], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@2472c7d8[variable: switchOnHandler], org.codehaus.groovy.ast.expr.MapExpression@589b028e[org.codehaus.groovy.ast.expr.MapEntryExpression@22175d4f(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@9fecdf1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3b809711[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3b0f7d9d[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@236ab296[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5c84624f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@63034ed1[org.codehaus.groovy.ast.expr.VariableExpression@232024b9[variable: theSwitch], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@55a8dc49[variable: switchOnHandler], org.codehaus.groovy.ast.expr.MapExpression@2a415aa9[org.codehaus.groovy.ast.expr.MapEntryExpression@53cdecf6(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]]]
switchOnHandler: [(delay = (minutesLater * 60))][org.codehaus.groovy.ast.stmt.ExpressionStatement@71ea1fda[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@62b3df3a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@420745d7[org.codehaus.groovy.ast.expr.VariableExpression@7e11ab3d[variable: delay], org.codehaus.groovy.ast.expr.VariableExpression@5fa47fea[variable: turnOffSwitch]]]]]]
turnOffSwitch: ]
Starting Points: []
IT HAS STATE
--app-start--
processing presence-change-push.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6c2f1700[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@350b3a17[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@38600b[org.codehaus.groovy.ast.expr.VariableExpression@669d2b1b[variable: presence], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@721eb7df[variable: presenceHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1ea9f009[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5d52e3ef[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5298dead[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@553f3b6e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4c7a078[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4e406694[org.codehaus.groovy.ast.expr.VariableExpression@5ab9b447[variable: presence], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@76f10035[variable: presenceHandler]]]]]]
presenceHandler: [If (evt.value == present),,[If (evt.value == not present),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing presence-change-text.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@18ca3c62[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2c0f7678[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@44d70181[org.codehaus.groovy.ast.expr.VariableExpression@6aa648b9[variable: presence], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@23c650a3[variable: presenceHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@742d4e15[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@88a8218[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@50b1f030[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4163f1cd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5fa05212[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3e681bc[org.codehaus.groovy.ast.expr.VariableExpression@5c09d180[variable: presence], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@23aae55[variable: presenceHandler]]]]]]
presenceHandler: [If (evt.value == present),[If location.contactBookEnabled,,],,[If (evt.value == not present),[If location.contactBookEnabled,,],,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing presence-sensor-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: presence-sensor-capability.metadata() is applicable for argument types: (presence-sensor-capability$_run_closure1) values: [presence-sensor-capability$_run_closure1@2ba45490]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-eggtray.groovy
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],]
eggReport: ]
poll: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-eggtray.metadata() is applicable for argument types: (quirky-wink-eggtray$_run_closure1) values: [quirky-wink-eggtray$_run_closure1@4943defe]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-nimbus.groovy
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],]
poll: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-nimbus.metadata() is applicable for argument types: (quirky-wink-nimbus$_run_closure1) values: [quirky-wink-nimbus$_run_closure1@5d10455d]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-porkfolio.groovy
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],]
poll: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-porkfolio.metadata() is applicable for argument types: (quirky-wink-porkfolio$_run_closure1) values: [quirky-wink-porkfolio$_run_closure1@2a3a299]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-powerstrip.groovy
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],]
on: ]
off: ]
poll: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-powerstrip.metadata() is applicable for argument types: (quirky-wink-powerstrip$_run_closure1) values: [quirky-wink-powerstrip$_run_closure1@771158fb]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-spotter.groovy
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],]
poll: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-spotter.metadata() is applicable for argument types: (quirky-wink-spotter$_run_closure1) values: [quirky-wink-spotter$_run_closure1@6bfdb014]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing ready-for-rain.groovy
DECLARED METHODS
mainPage: ]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@347bdeef[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2aa27288[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7f34a967[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@77e80a5e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1d8e2eea[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@240139e1[]]]]]
init: [(state.lastMessage = 0)][(state.lastCheck = [time:0, result:false])][org.codehaus.groovy.ast.stmt.ExpressionStatement@7ea4d397[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@49298ce7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@253c1256[ConstantExpression[0 0,30 * * * ?], org.codehaus.groovy.ast.expr.VariableExpression@8dfe921[variable: scheduleCheck]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@503fbbc6[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@55f45b92[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@109f5dd8[org.codehaus.groovy.ast.expr.VariableExpression@67fe380b[variable: sensors], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@4a325eb9[variable: scheduleCheck]]]]]]
scheduleCheck: [(open = sensors.findAll({ -> ... }))][(plural = ((open.size() > 1)) ? are : is)][If (((this.now() - ((30 * 60) * 1000)) > state.lastCheck[time]) && open),[(response = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (location.channelName != samsungtv),[(response = this.getWeatherFeature(forecast, zipCode))],[(response = this.getWeatherFeature(forecast))]],[(weather = this.isStormy(response))][If weather,,],,[If ((((this.now() - ((30 * 60) * 1000)) <= state.lastCheck[time]) && state.lastCheck[result]) && open),[this.send($open.join(, ) $plural open and $state.lastCheck[result] coming.)],],],]
send: [(delay = (((messageDelay != null) && (messageDelay != ))) ? ((messageDelay * 60) * 1000) : 0)][If ((this.now() - delay) > state.lastMessage),[(state.lastMessage = this.now())][If (sendPushMessage == Yes),,],[If phone,,],,],]
isStormy: [(types = [rain, snow, showers, sprinkles, precipitation])][(forecast = json?.forecast?.txt_forecast?.forecastday?.first())][(result = false)][If forecast,[(text = forecast?.fcttext?.toLowerCase())][If text,[For ((i = 0); ((i < types.size()) && result); (i++)),[If text.contains(types[i]),[(result = types[i])],],][For ((i = 0); ((i < types.size()) && result); (i++)),[If text.contains(types[i]),[(result = types[i])],],],],,],[(state.lastCheck = [time:this.now(), result:result])]]
Starting Points: []
IT HAS STATE
--app-start--
processing relative-humidity-measurement-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: relative-humidity-measurement-capability.metadata() is applicable for argument types: (relative-humidity-measurement-capability$_run_closure1) values: [relative-humidity-measurement-capability$_run_closure1@210f0cc1]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing ridiculously-automated-garage-door.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6d868997[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2c383e33[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@74a195a4[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@76304b46[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2fa3be26[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4287d447[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3af37506[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4e6d7365[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7c0da600[]]]]]
subscribe: [org.codehaus.groovy.ast.stmt.ExpressionStatement@d4602a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@21ae6e73[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@47dd778[org.codehaus.groovy.ast.expr.VariableExpression@15515c51[variable: doorSensor], ConstantExpression[contact], org.codehaus.groovy.ast.expr.VariableExpression@36a7abe1[variable: garageDoorContact]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@64a896b0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@e044b4a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@11a82d0f[org.codehaus.groovy.ast.expr.VariableExpression@1adb7478[variable: cars], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@3ae66c85[variable: carPresence]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@16943e88[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4604b900[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@73d6d0c[org.codehaus.groovy.ast.expr.VariableExpression@e36bb2a[variable: carDoorSensors], ConstantExpression[acceleration], org.codehaus.groovy.ast.expr.VariableExpression@3961a41a[variable: accelerationActive]]]]][If interiorDoorSensor,[org.codehaus.groovy.ast.stmt.ExpressionStatement@5a4ed68f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@367795c7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@d2387c8[org.codehaus.groovy.ast.expr.VariableExpression@3956b302[variable: interiorDoorSensor], ConstantExpression[contact.closed], org.codehaus.groovy.ast.expr.VariableExpression@1500e009[variable: interiorDoorClosed]]]]],],]
doorOpenCheck: [(thresholdMinutes = openThreshold)][If thresholdMinutes,[(currentState = doorSensor.contactState)][If (currentState?.value == open),[log.debug(open for $(this.now() - currentState.date.time), openDoorNotificationSent: $state.openDoorNotificationSent)][If (state.openDoorNotificationSent && ((this.now() - currentState.date.time) > ((thresholdMinutes * 60) * 1000))),[(msg = $doorSwitch.displayName was been open for $thresholdMinutes minutes)][If location.contactBookEnabled,,[If phone,,],],[(state.openDoorNotificationSent = true)],],,[(state.openDoorNotificationSent = false)]],,],]
carPresence: [(openDoorAwayInterval = (falseAlarmThreshold) ? (falseAlarmThreshold * 60) : 600)][If (evt.value == present),[(car = this.getCar(evt))][(t0 = new java.util.Date((this.now() - (openDoorAwayInterval * 1000))))][(states = car.statesSince(presence, t0))][(recentNotPresentState = states.find({ -> ... }))][If recentNotPresentState,,[If (doorSensor.currentContact == closed),[(state.appOpenedDoor = this.now())],],],,[If (doorSensor.currentContact == open),,],],]
garageDoorContact: [If (evt.value == open),[org.codehaus.groovy.ast.stmt.ExpressionStatement@1fd386c3[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@edf4f36[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@29d334c[ConstantExpression[0 * * * * ?], ConstantExpression[doorOpenCheck]]]]],[org.codehaus.groovy.ast.stmt.ExpressionStatement@100f9bbe[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@13e9f2e2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@673bb956[ConstantExpression[doorOpenCheck]]]]]],]
interiorDoorClosed: [(threshold = ((15 * 60) * 1000))][If (state.appOpenedDoor && ((this.now() - state.appOpenedDoor) < threshold)),[(state.appOpenedDoor = 0)],],]
accelerationActive: [If (doorSensor.currentContact == closed),,],]
openDoor: [If (doorSensor.currentContact == closed),,],]
closeDoor: [If (doorSensor.currentContact == open),,],]
getCar: ]
Starting Points: []
IT HAS STATE
--app-start--
processing rise-and-shine.groovy
DECLARED METHODS
installed: [log.debug(installed, current mode = $location.mode, state.actionTakenOn = $state.actionTakenOn)]]
updated: [log.debug(updated, current mode = $location.mode, state.actionTakenOn = $state.actionTakenOn)][org.codehaus.groovy.ast.stmt.ExpressionStatement@654c1a54[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5bdaf2ce[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@42d236fb[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1ce93c18[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@19f21b6b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1532c619[org.codehaus.groovy.ast.expr.VariableExpression@46044faa[variable: motionSensors], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@1358b28e[variable: motionActiveHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1a78dacd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@19f9d595[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7de4a01f[org.codehaus.groovy.ast.expr.VariableExpression@2bfeb1ef[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@778ca8ef[variable: modeChangeHandler]]]]][If (state.modeStartTime == null),[(state.modeStartTime = 0)],],]
modeChangeHandler: [(state.modeStartTime = this.now())]]
motionActiveHandler: [If (state.modeStartTime == null),[org.codehaus.groovy.ast.stmt.ExpressionStatement@208e9ef6[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@78b236a0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@261d8190[org.codehaus.groovy.ast.expr.VariableExpression@34448e6c[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@60e9df3c[variable: modeChangeHandler]]]]][(state.modeStartTime = 0)],],[(t0 = this.now())][(modeStartTime = new java.util.Date(state.modeStartTime))][(timeZone = (location.timeZone) ? location.timeZone : this.timeZone(timeOfDay))][(startTime = this.timeTodayAfter(modeStartTime, timeOfDay, timeZone))][(endTime = this.timeTodayAfter(startTime, (endTime) ? endTime : 16:00, timeZone))][log.debug(startTime: $startTime, endTime: $endTime, t0: $new Date(t0), modeStartTime: $modeStartTime,  actionTakenOn: $state.actionTakenOn, currentMode: $location.mode, newMode: $newMode )][If (((t0 >= startTime.time) && (t0 <= endTime.time)) && (location.mode != newMode)),[(message = Good morning! SmartThings changed the mode to '$newMode')][(dateString = new java.util.Date().format(yyyy-MM-dd))][log.debug(last turned on switches on $state.actionTakenOn, today is $dateString)][If (state.actionTakenOn != dateString),[(state.actionTakenOn = dateString)],],,[log.debug(not in time window, or mode is already set, currentMode = $location.mode, newMode = $newMode)]],]
send: [If location.contactBookEnabled,,[If (sendPushMessage != No),,],[If phoneNumber,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing routine-director.groovy
DECLARED METHODS
selectRoutines: [(configured = (((settings.awayDay && settings.awayNight) && settings.homeDay) && settings.homeNight))]]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@56f2bbea[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@78f9ed3e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1059754c[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@b0964b2[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@48e7b3d2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7f4037ed[org.codehaus.groovy.ast.expr.VariableExpression@24e8de5c[variable: people], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@64040287[variable: presence]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@110844f6[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6f89f665[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@df1cff6[org.codehaus.groovy.ast.expr.VariableExpression@4925f4f5[variable: location], ConstantExpression[sunrise], org.codehaus.groovy.ast.expr.VariableExpression@1ad926d3[variable: setSunrise]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3a43d133[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@39ce27f2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5f2afe62[org.codehaus.groovy.ast.expr.VariableExpression@c96a4ea[variable: location], ConstantExpression[sunset], org.codehaus.groovy.ast.expr.VariableExpression@28782602[variable: setSunset]]]]][(state.homestate = null)]]
checkSun: [(zip = (java.lang.String -> java.lang.String) settings.zip)][(sunInfo = this.getSunriseAndSunset([zipCode:zip]))][(current = this.now())][If ((sunInfo.sunrise.time < current) && (sunInfo.sunset.time > current)),[(state.sunMode = sunrise)][org.codehaus.groovy.ast.stmt.ExpressionStatement@60c16548[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@68105edc[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@511816c0[ConstantExpression[60], ConstantExpression[setSunrise]]]]],[(state.sunMode = sunset)][org.codehaus.groovy.ast.stmt.ExpressionStatement@38b972d7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5339bbad[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3935e9a8[ConstantExpression[60], ConstantExpression[setSunset]]]]]],]
setSunrise: [(state.sunMode = sunrise)][log.debug(Current sun mode is $state.sunMode)]]
setSunset: [(state.sunMode = sunset)][log.debug(Current sun mode is $state.sunMode)]]
changeSunMode: [If allOk,[If this.everyoneIsAway(),[(delay = (((falseAlarmThreshold != null) && (falseAlarmThreshold != ))) ? (falseAlarmThreshold * 60) : (10 * 60))],[If this.anyoneIsHome(),,],],,],]
presence: [If allOk,[If (evt.value == not present),[If this.everyoneIsAway(),[(delay = (((falseAlarmThreshold != null) && (falseAlarmThreshold != ))) ? (falseAlarmThreshold * 60) : (10 * 60))][org.codehaus.groovy.ast.stmt.ExpressionStatement@288a4658[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5b56b654[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@452c8a40[org.codehaus.groovy.ast.expr.VariableExpression@534243e4[variable: delay], ConstantExpression[setAway]]]]],],,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (1 * 60000))),,],[(state[evt.deviceId] = this.now())]],,],]
setAway: [If this.everyoneIsAway(),[If (state.sunMode == sunset),[(message = Performing "$awayNight" for you as requested.)][(state.homestate = away)],[If (state.sunMode == sunrise),[(message = Performing "$awayDay" for you as requested.)][(state.homestate = away)],],],,],]
setHome: [If this.anyoneIsHome(),[If (state.sunMode == sunset),[If (state.homestate != homeNight),[(message = Performing "$homeNight" for you as requested.)][(state.homestate = homeNight)],],,],[If (state.sunMode == sunrise),[If (state.homestate != homeDay),[(message = Performing "$homeDay" for you as requested.)][(state.homestate = homeDay)],],,],,],]
everyoneIsAway: [(result = true)][If people.findAll({ -> ... }),[(result = false)],],]
anyoneIsHome: [(result = false)][If people.findAll({ -> ... }),[(result = true)],],]
sendAway: [If sendPushMessage,[If recipients,,[If phone,,],],,],]
sendHome: [If sendPushMessageHome,[If recipients,,[If phone,,],],,],]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
getTimeIntervalLabel: ]
hideOptionsSection: ]
Starting Points: []
IT HAS STATE
--app-start--
processing safe-watch.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6c8a68c1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@56193c7d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@28c88600[]]]]]
init: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5f8890c2[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@607b2792[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7f9e1534[org.codehaus.groovy.ast.expr.VariableExpression@138a7441[variable: contact], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@81ff872[variable: triggerContact]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@31611954[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3e598df9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7e31ce0f[org.codehaus.groovy.ast.expr.VariableExpression@99a65d3[variable: motion], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@3088660d[variable: triggerMotion]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@42cc13a0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@32fdec40[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6813a331[org.codehaus.groovy.ast.expr.VariableExpression@1bd81830[variable: knock], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@39ab59f8[variable: triggerKnock]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@64e92d61[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@111610e6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4ad4936c[org.codehaus.groovy.ast.expr.VariableExpression@29d37757[variable: temp], ConstantExpression[temperature], org.codehaus.groovy.ast.expr.VariableExpression@4fcc529[variable: triggerTemp]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@25cc7470[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4beddc56[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@79b663b3[org.codehaus.groovy.ast.expr.VariableExpression@1b812421[variable: axis], ConstantExpression[threeAxis], org.codehaus.groovy.ast.expr.VariableExpression@5d28bcd5[variable: triggerAxis]]]]]]
triggerContact: [If this.everyoneIsAway(),,],]
triggerMotion: [If this.everyoneIsAway(),,],]
triggerKnock: [If this.everyoneIsAway(),,],]
triggerTemp: [(temperature = evt.doubleValue)][If ((maxTemp && (maxTemp < temperature)) || (minTemp && (minTemp > temperature))),,],]
triggerAxis: [If this.everyoneIsAway(),,],]
everyoneIsAway: [(result = true)][If people.findAll({ -> ... }),[(result = false)],],]
send: [(delay = (((messageDelay != null) && (messageDelay != ))) ? ((messageDelay * 60) * 1000) : 0)][If ((this.now() - delay) > state.lastMessage),[(state.lastMessage = this.now())][If (sendPushMessage == Yes),,],[If phone,,],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing scheduled-mode-change.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@3e521715[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@26a529dc[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@265c5d69[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1286528d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3cc20577[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@33a630fa[org.codehaus.groovy.ast.expr.VariableExpression@775594f2[variable: time], org.codehaus.groovy.ast.expr.VariableExpression@5767b2af[variable: changeMode]]]]]]
changeMode: [log.debug(changeMode, location.mode = $location.mode, newMode = $newMode, location.modes = $location.modes)][If (location.mode != newMode),[If location.modes?.find({ -> ... }),,],,],]
send: [If location.contactBookEnabled,,[If (sendPushMessage == Yes),,],[If phoneNumber,,],],]
getLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing severe-weather-alert.groovy
DECLARED METHODS
mainPage: ]
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1d2644e3[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4fa06f52[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[scheduleJob] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@602c4656[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5ffc5491[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@705202d1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3c443976[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3e58d65e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3bd55d8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[scheduleJob] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@63998bf4[]]]]]
scheduleJob: [(sec = java.lang.Math.round(java.lang.Math.floor((java.lang.Math.random() * 60))))][(min = java.lang.Math.round(java.lang.Math.floor((java.lang.Math.random() * 60))))][(cron = $sec $min * * * ?)][org.codehaus.groovy.ast.stmt.ExpressionStatement@7e0b9178[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@61942c1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6f63c44f[org.codehaus.groovy.ast.expr.VariableExpression@408a247c[variable: cron], ConstantExpression[checkForSevereWeather]]]]]]
checkForSevereWeather: [(alerts = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If this.locationIsDefined(),[If this.zipcodeIsValid(),[(alerts = this.getWeatherFeature(alerts, zipCode)?.alerts)],[(alerts = this.getWeatherFeature(alerts)?.alerts)]],,],[(newKeys = (alerts?.collect({ -> ... })) ? alerts?.collect({ -> ... }) : [])][(oldKeys = (state.alertKeys) ? state.alertKeys : [])][If (newKeys != oldKeys),[(state.alertKeys = newKeys)],],]
descriptionFilter: [(filterList = [special, statement, test])][(passesFilter = true)]]
locationIsDefined: ]
zipcodeIsValid: [((zipcode && zipcode.isNumber()) && (zipcode.size() == 5))]]
send: [If location.contactBookEnabled,,[If settings.phone1,,],[If settings.phone2,,],[If settings.phone3,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing shabbat-and-holiday-modes.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5f212d84[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@127d7908[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6b9c69a9[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6622a690[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@30b9eadd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@497570fb[ConstantExpression[0 0 8 1/1 * ? *], org.codehaus.groovy.ast.expr.VariableExpression@412c995d[variable: poll]]]]]]
poll: [org.codehaus.groovy.ast.stmt.ExpressionStatement@3249a1ce[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4dd94a58[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2f4919b0[ConstantExpression[endChag]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@a8a8b75[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@75b21c3b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@72be135f[ConstantExpression[setChag]]]]]]
Hebcal_WebRequest: [(today = new java.util.Date().format(yyyy-MM-dd))][(zip = (java.lang.String -> java.lang.String) settings.zip)][(locale = this.getWeatherFeature(geolookup, zip))][(timezone = java.util.TimeZone.getTimeZone(locale.location.tz_long))][(hebcal_date = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(hebcal_category = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(hebcal_title = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(candlelighting = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(candlelightingLocalTime = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(havdalah = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(havdalahLocalTime = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pushMessage = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(testmessage = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(urlRequest = http://www.hebcal.com/hebcal/?v=1&cfg=json&nh=off&nx=off&year=now&month=now&mf=off&c=on&zip=$zipcode&m=$havdalahOffset&s=off&D=off&d=off&o=off&ss=off)][(hebcal = { java.lang.Object response -> ... })]]
HebCal_GetTime12: [(returnTime = (((hebcal_title.split(:)[1] + :) + hebcal_title.split(:)[2]) +  ))]]
HebCal_GetTime24: [(returnTime = hebcal_date.split(T)[1])][(returnTime = returnTime.split(-)[0])]]
setChag: [If (location.mode != startMode),[If location.modes?.find({ -> ... }),[(dayofweek = new java.util.Date().format(EEE))][If (dayofweek == Fri),,],,],,],[org.codehaus.groovy.ast.stmt.ExpressionStatement@155d1021[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4bd2f0dc[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2e647e59[ConstantExpression[setChag]]]]]]
endChag: [If (location.mode != endMode),[If location.modes?.find({ -> ... }),,],,],[org.codehaus.groovy.ast.stmt.ExpressionStatement@2c42b421[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@51e37590[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@deb3b60[ConstantExpression[endChag]]]]]]
sendMessage: [If (sendPushMessage != No),,],[If phone,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing simple-sync-trigger.groovy
DECLARED METHODS
agentSelection: [If agent,[(state.refreshCount = 0)],],]
control: [(activities = agent.latestValue(activities))][If (activities || state.refreshCount),[(refreshCount = (state.refreshCount) ? 0 : (int) state.refreshCount)][(state.refreshCount = (refreshCount + 1))][(refreshInterval = ((refreshCount == 0)) ? 2 : 4)][If ((refreshCount % 5) == 0),,],,],]
anythingSet: [For [motion, motionInactive, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, button1, triggerModes, timeOfDay],[If settings[name],,],]anythingSet: [For [motion, motionInactive, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, button1, triggerModes, timeOfDay],[If settings[name],,],]]
ifUnset: [If settings[name],,],]
ifSet: [If settings[name],,],]
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@56febdc[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3b8ee898[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7d151a[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@294bdeb4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5300f14a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1f86099a[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@77bb0ab5[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@f2c488[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@54acff7d[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7bc9e6ab[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5488b5c5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4248ed58[]]]]]
subscribeToEvents: [org.codehaus.groovy.ast.stmt.ExpressionStatement@712ca57b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4564e94b[object: org.codehaus.groovy.ast.expr.VariableExpression@54534abf[variable: log] method: ConstantExpression[trace] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@51745f40[ConstantExpression[subscribeToEvents()]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@45673f68[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@27abb83e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@69e308c6[org.codehaus.groovy.ast.expr.VariableExpression@1a1ed4e5[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@667e34b1[variable: appTouchHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1c6e0a08[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6dba847b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1efdcd5[org.codehaus.groovy.ast.expr.VariableExpression@1623bbe5[variable: contact], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@7af1cd63[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4351171a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3c2772d1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@37d00a23[org.codehaus.groovy.ast.expr.VariableExpression@433e536f[variable: contactClosed], ConstantExpression[contact.closed], org.codehaus.groovy.ast.expr.VariableExpression@89c65d5[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@faa3fed[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@381cad29[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@988246e[org.codehaus.groovy.ast.expr.VariableExpression@62515a47[variable: acceleration], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@3c5a54b7[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@61f2c3f0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@291120f4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@417ad4f3[org.codehaus.groovy.ast.expr.VariableExpression@2f6bcf87[variable: motion], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@58f174d9[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@78c7f9b3[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6f8d7714[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1e6b9a95[org.codehaus.groovy.ast.expr.VariableExpression@4d6f623d[variable: motionInactive], ConstantExpression[motion.inactive], org.codehaus.groovy.ast.expr.VariableExpression@aa21042[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@e93f3d5[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4cee7fa0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7a26928a[org.codehaus.groovy.ast.expr.VariableExpression@601cbd8c[variable: mySwitch], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@7180e701[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4e2c95ee[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@d0ec63[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5a5c128[org.codehaus.groovy.ast.expr.VariableExpression@73eb8672[variable: mySwitchOff], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@5942ee04[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5e76a2bb[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@757194dc[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5a865416[org.codehaus.groovy.ast.expr.VariableExpression@14faa38c[variable: arrivalPresence], ConstantExpression[presence.present], org.codehaus.groovy.ast.expr.VariableExpression@7ff2b8d2[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6dc1484[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6e92c6ad[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2fb5fe30[org.codehaus.groovy.ast.expr.VariableExpression@456be73c[variable: departurePresence], ConstantExpression[presence.not present], org.codehaus.groovy.ast.expr.VariableExpression@2375b321[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5baaae4c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5b6e8f77[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@41a6d121[org.codehaus.groovy.ast.expr.VariableExpression@4f449e8f[variable: button1], ConstantExpression[button.pushed], org.codehaus.groovy.ast.expr.VariableExpression@411291e5[variable: eventHandler]]]]][If triggerModes,[org.codehaus.groovy.ast.stmt.ExpressionStatement@6e28bb87[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@19f040ba[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@72ab05ed[org.codehaus.groovy.ast.expr.VariableExpression@27e32fe4[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@c3c4c1c[variable: modeChangeHandler]]]]],],[If timeOfDay,[org.codehaus.groovy.ast.stmt.ExpressionStatement@17d238b1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3d7cc3cb[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@35e478f[org.codehaus.groovy.ast.expr.VariableExpression@6d6cb754[variable: timeOfDay], org.codehaus.groovy.ast.expr.VariableExpression@6b7d1df8[variable: scheduledTimeHandler]]]]],],]
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],]
modeChangeHandler: [If (evt.value in triggerModes),,],]
scheduledTimeHandler: ]
appTouchHandler: ]
startActivity: [If frequency,[(state.lastActionTimeStamp = this.now())],],]
frequencyKey: ]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],]
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting).time)][(stop = this.timeToday(ending).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
timeIntervalLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing simulated-alarm.groovy
DECLARED METHODS
strobe: ]
siren: ]
both: ]
off: ]
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-alarm.metadata() is applicable for argument types: (simulated-alarm$_run_closure1) values: [simulated-alarm$_run_closure1@22101c80]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-button.groovy
DECLARED METHODS
parse: ]
hold1: ]
push1: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-button.metadata() is applicable for argument types: (simulated-button$_run_closure1) values: [simulated-button$_run_closure1@203dd56b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-color-control.groovy
DECLARED METHODS
parse: ]
setSaturation: ]
setHue: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-color-control.metadata() is applicable for argument types: (simulated-color-control$_run_closure1) values: [simulated-color-control$_run_closure1@1450078a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-contact-sensor.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
open: ]
close: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-contact-sensor.metadata() is applicable for argument types: (simulated-contact-sensor$_run_closure1) values: [simulated-contact-sensor$_run_closure1@6999cd39]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-dimmable-bulb.groovy
DECLARED METHODS
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],]
installed: ]
updated: ]
ping: ]
refresh: ]
configure: ]
on: ]
off: ]
setLevel: [(levelEventMap = this.buildSetLevelEvent(value))][If (levelEventMap.value == 0),,],]
setLevel: ]
getSwitch: [(switchState = device.currentState(switch))]]
getLevel: [(levelState = device.currentState(level))]]
initialize: ]
buildSetLevelEvent: [(intValue = (java.lang.Integer -> java.lang.Integer) value)][(newLevel = java.lang.Math.max(java.lang.Math.min(intValue, 99), 0))][(eventMap = [name:level, value:newLevel, unit:%])]]
implicitOn: [If (device.currentValue(switch) != on),,],]
turnOn: ]
turnOff: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-dimmable-bulb.metadata() is applicable for argument types: (simulated-dimmable-bulb$_run_closure1) values: [simulated-dimmable-bulb$_run_closure1@3b0ca5e1]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-dimmer-switch.groovy
DECLARED METHODS
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],]
installed: ]
updated: ]
refresh: ]
configure: ]
on: ]
off: ]
setLevel: [(levelEventMap = this.buildSetLevelEvent(value))][If (levelEventMap.value == 0),,],]
setLevel: ]
initialize: ]
buildSetLevelEvent: [(intValue = (java.lang.Integer -> java.lang.Integer) value)][(newLevel = java.lang.Math.max(java.lang.Math.min(intValue, 99), 0))][(eventMap = [name:level, value:newLevel, unit:%])]]
implicitOn: [If (device.currentValue(switch) != on),,],]
turnOn: ]
turnOff: ]
onPhysical: ]
offPhysical: ]
setLevelPhysical: [(eventMap = this.buildSetLevelEvent(value))][If (eventMap.value == 0),[(eventMap.value = 1)],],[(eventMap.type = physical)]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-dimmer-switch.metadata() is applicable for argument types: (simulated-dimmer-switch$_run_closure1) values: [simulated-dimmer-switch$_run_closure1@25c5e994]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-garage-door-opener.groovy
DECLARED METHODS
parse: ]
open: [org.codehaus.groovy.ast.stmt.ExpressionStatement@a10c1b5[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@644abb8f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1a411233[ConstantExpression[6], org.codehaus.groovy.ast.expr.VariableExpression@70325d20[variable: finishOpening]]]]]]
close: [org.codehaus.groovy.ast.stmt.ExpressionStatement@7c2327fa[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4d847d32[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5f462e3b[ConstantExpression[6], org.codehaus.groovy.ast.expr.VariableExpression@3d7fa3ae[variable: finishClosing]]]]]]
finishOpening: ]
finishClosing: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-garage-door-opener.metadata() is applicable for argument types: (simulated-garage-door-opener$_run_closure1) values: [simulated-garage-door-opener$_run_closure1@c9d82f9]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-lock.groovy
DECLARED METHODS
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],]
installed: ]
updated: ]
initialize: ]
processPreferences: [(strBatteryLevel = $prefBatteryLevel)][(batteryLevel = (strBatteryLevel.isInteger()) ? strBatteryLevel.toInteger() : null)][If batteryLevel,,],[If prefJamNextOperation,,],[If prefJamImmediately,,],]
refresh: ]
ping: ]
lock: [If (device.currentValue(doesNextOperationJam) == true),,],]
unlock: [If (device.currentValue(doesNextOperationJam) == true),,],]
jam: [If (device.currentValue(doesNextOperationJam) == true),,],]
setJamNextOperation: ]
clearJamNextOperation: ]
setBatteryLevel: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-lock.metadata() is applicable for argument types: (simulated-lock$_run_closure1) values: [simulated-lock$_run_closure1@466d49f0]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-minimote.groovy
DECLARED METHODS
parse: ]
push1: ]
push2: ]
push3: ]
push4: ]
hold1: ]
hold2: ]
hold3: ]
hold4: ]
push: ]
hold: ]
installed: ]
updated: ]
initialize: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-minimote.metadata() is applicable for argument types: (simulated-minimote$_run_closure1) values: [simulated-minimote$_run_closure1@1136b469]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-motion-sensor.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
active: ]
inactive: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-motion-sensor.metadata() is applicable for argument types: (simulated-motion-sensor$_run_closure1) values: [simulated-motion-sensor$_run_closure1@5183d589]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-presence-sensor.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
arrived: ]
departed: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-presence-sensor.metadata() is applicable for argument types: (simulated-presence-sensor$_run_closure1) values: [simulated-presence-sensor$_run_closure1@1eea9d2d]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-refrigerator-door.groovy
DECLARED METHODS
installed: ]
open: ]
close: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-refrigerator-door.metadata() is applicable for argument types: (simulated-refrigerator-door$_run_closure1) values: [simulated-refrigerator-door$_run_closure1@cda0432]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-refrigerator-temperature-control.groovy
DECLARED METHODS
installed: [this.sendEvent([name:temperature, value:((device.componentName == freezer)) ? 2 : 40])][this.sendEvent([name:coolingSetpoint, value:((device.componentName == freezer)) ? 2 : 40])]]
updated: ]
tempUp: [(value = (java.lang.Integer -> java.lang.Integer) device.currentValue(temperature))]]
tempDown: [(value = (java.lang.Integer -> java.lang.Integer) device.currentValue(temperature))]]
setpointUp: [(value = (java.lang.Integer -> java.lang.Integer) device.currentValue(coolingSetpoint))]]
setpointDown: [(value = (java.lang.Integer -> java.lang.Integer) device.currentValue(coolingSetpoint))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-refrigerator-temperature-control.metadata() is applicable for argument types: (simulated-refrigerator-temperature-control$_run_closure1) values: [simulated-refrigerator-temperature-control$_run_closure1@4a1c0752]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-refrigerator.groovy
DECLARED METHODS
installed: [(state.counter = (state.counter) ? (state.counter + 1) : 1)][If (state.counter == 1),,],]
doorOpen: ]
doorClosed: [If childDevices.find({ -> ... }),,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-refrigerator.metadata() is applicable for argument types: (simulated-refrigerator$_run_closure1) values: [simulated-refrigerator$_run_closure1@4a03bb68]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-rgb-bulb.groovy
DECLARED METHODS
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],]
installed: ]
updated: ]
ping: ]
refresh: [(currentMode = device.currentValue(bulbMode))][If MODE.containsValue(currentMode),,],]
configure: ]
on: [this.simulateBulbState(state.lastMode)]]
off: ]
setLevel: [(boundedPercent = this.boundInt(levelPercent, PERCENT_RANGE))][(effectiveMode = device.currentValue(bulbMode))][If (boundedPercent > 0),,[(effectiveMode = MODE.OFF)]],]
setSaturation: [(currentHue = device.currentValue(hue))]]
setHue: [(currentSaturation = device.currentValue(saturation))]]
setColor: [(boundedHue = this.boundInt(huePercent, PERCENT_RANGE))][(boundedSaturation = this.boundInt(saturationPercent, PERCENT_RANGE))][(logMsg = Executing 'setColor' from separate values hue: $boundedHue, saturation: $boundedSaturation)][If ((huePercent != boundedHue) || (saturationPercent != boundedSaturation)),[(logMsg +=  (pre-bounded values hue: $huePercent, saturation: $saturationPercent))],],[(colorHSMap = this.buildColorHSMap(hue, saturation))]]
setColor: [If (hex == #000000),,[(hsvList = colorUtil.hexToHsv(hex))][(colorHSMap = this.buildColorHSMap(hsvList[0], hsvList[1]))]],]
setColor: ]
initialize: [(state.lastMode = MODE.COLOR)]]
implicitOn: [If (device.currentValue(switch) != on),,],]
turnOn: ]
turnOff: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
buildColorHSMap: [(colorHSMap = [hue:0, saturation:0])]]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
simulateBulbState: [(valueText = ---)][(hexColor = BLACK.rgb)][(colorIndicator = 0)]]
flattenHueSat: [(flatHueSat = 0)][If (HUE_RANGE.contains(hue) && SAT_RANGE.contains(sat)),[(scaledHue = (hue * HUE_SCALE))][(flatHueSat = ((scaledHue + sat) + COLOR_OFFSET))],],]
restoreHueSat: [(flatHueSat -= COLOR_OFFSET)][(sat = (flatHueSat % HUE_SCALE))][(hue = flatHueSat.intdiv(HUE_SCALE))]]
done: ]
boundInt: [(value = java.lang.Math.max(theRange.getFrom(), value))][(value = java.lang.Math.min(theRange.getTo(), value))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-rgb-bulb.metadata() is applicable for argument types: (simulated-rgb-bulb$_run_closure1) values: [simulated-rgb-bulb$_run_closure1@1440c311]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-smoke-alarm.groovy
DECLARED METHODS
parse: ]
smoke: ]
test: ]
clear: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-smoke-alarm.metadata() is applicable for argument types: (simulated-smoke-alarm$_run_closure1) values: [simulated-smoke-alarm$_run_closure1@2b97cc1f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-switch.groovy
DECLARED METHODS
parse: ]
on: ]
off: ]
onPhysical: ]
offPhysical: ]
getVersion: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-switch.metadata() is applicable for argument types: (simulated-switch$_run_closure1) values: [simulated-switch$_run_closure1@10ec523c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-temperature-sensor.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
setLevel: ]
up: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue + 1) : 72)]]
down: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue - 1) : 72)]]
setTemperature: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-temperature-sensor.metadata() is applicable for argument types: (simulated-temperature-sensor$_run_closure1) values: [simulated-temperature-sensor$_run_closure1@6b1e7ad3]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-thermostat.groovy
DECLARED METHODS
installed: ]
configure: ]
initialize: [(state.isHvacRunning = false)][(state.lastOperatingState = DEFAULT_OP_STATE)][(state.lastUserSetpointMode = DEFAULT_PREVIOUS_STATE)][org.codehaus.groovy.ast.stmt.ExpressionStatement@76911385[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5467eea4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@160396db[]]]]]
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],]
ping: ]
refresh: ]
getThermostatMode: ]
setThermostatMode: [If (value in SUPPORTED_MODES),[this.proposeSetpoints(this.getHeatingSetpoint(), this.getCoolingSetpoint(), state.lastUserSetpointMode)],],]
cycleMode: [(nextMode = this.nextListElement(SUPPORTED_MODES, this.getThermostatMode()))]]
isThermostatOff: [return (this.getThermostatMode() == MODE.OFF)]]
getFanMode: ]
setThermostatFanMode: [If (value in SUPPORTED_FAN_MODES),,],]
cycleFanMode: [(nextMode = this.nextListElement(SUPPORTED_FAN_MODES, this.getFanMode()))]]
no code yet for classclass org.codehaus.groovy.ast.stmt.ThrowStatement
no code yet for classclass org.codehaus.groovy.ast.stmt.ThrowStatement
nextListElement: [If (uniqueList != uniqueList.unique().asList()),,[If (currentElt in uniqueList),,],],[(listIdxMax = (uniqueList.size() - 1))][(currentEltIdx = uniqueList.indexOf(currentElt))][(nextEltIdx = ((currentEltIdx < listIdxMax)) ? (++currentEltIdx) : 0)][(nextElt = (java.lang.String -> java.lang.String) uniqueList[nextEltIdx])]]
getOperatingState: [(operatingState = (device.currentValue(thermostatOperatingState)) ? device.currentValue(thermostatOperatingState) : OP_STATE.IDLE)]]
setOperatingState: [If (operatingState in OP_STATE.values()),[If (operatingState != OP_STATE.IDLE),[(state.lastOperatingState = operatingState)],],,[log.warn('$operatingState' is not a supported operating state. Please set one of $OP_STATE.values().join(, ))]],]
getThermostatSetpoint: [(ts = device.currentState(thermostatSetpoint))]]
getHeatingSetpoint: [(hs = device.currentState(heatingSetpoint))]]
setHeatingSetpoint: [(state.lastUserSetpointMode = SETPOINT_TYPE.HEATING)]]
setHeatingSetpointInternal: ]
heatUp: [(newHsp = (this.getHeatingSetpoint() + 1))][If (this.getThermostatMode() in (HEAT_ONLY_MODES + DUAL_SETPOINT_MODES)),,],]
heatDown: [(newHsp = (this.getHeatingSetpoint() - 1))][If (this.getThermostatMode() in (HEAT_ONLY_MODES + DUAL_SETPOINT_MODES)),,],]
getCoolingSetpoint: [(cs = device.currentState(coolingSetpoint))]]
setCoolingSetpoint: [(state.lastUserSetpointMode = SETPOINT_TYPE.COOLING)]]
setCoolingSetpointInternal: ]
coolUp: [(newCsp = (this.getCoolingSetpoint() + 1))][If (this.getThermostatMode() in (COOL_ONLY_MODES + DUAL_SETPOINT_MODES)),,],]
coolDown: [(newCsp = (this.getCoolingSetpoint() - 1))][If (this.getThermostatMode() in (COOL_ONLY_MODES + DUAL_SETPOINT_MODES)),,],]
setpointUp: [(mode = this.getThermostatMode())][If (mode in COOL_ONLY_MODES),,[If (mode in (HEAT_ONLY_MODES + DUAL_SETPOINT_MODES)),,],],]
setpointDown: [(mode = this.getThermostatMode())][If (mode in (COOL_ONLY_MODES + DUAL_SETPOINT_MODES)),,[If (mode in HEAT_ONLY_MODES),,],],]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
getTemperature: [(ts = device.currentState(temperature))][(currentTemp = DEFAULT_TEMPERATURE)]]
setTemperature: ]
tempUp: [(newTemp = (this.getTemperature()) ? (this.getTemperature() + 1) : DEFAULT_TEMPERATURE)]]
tempDown: [(newTemp = (this.getTemperature()) ? (this.getTemperature() - 1) : DEFAULT_TEMPERATURE)]]
setHumidityPercent: [(curHum = (java.lang.Integer -> java.lang.Integer) device.currentValue(humidity))][If (humidityValue != null),[(hum = this.boundInt(humidityValue, (0..100)))][If (hum != humidityValue),[(humidityValue = hum)],],,],]
getHumidityPercent: [(hp = device.currentState(humidity))]]
boundInt: [(value = java.lang.Math.max(theRange.getFrom(), java.lang.Math.min(theRange.getTo(), value)))]]
proposeHeatSetpoint: ]
proposeCoolSetpoint: ]
proposeSetpoints: [(newHeatSetpoint = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(newCoolSetpoint = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(mode = this.getThermostatMode())][(proposedHeatSetpoint = (heatSetpoint) ? heatSetpoint : this.getHeatingSetpoint())][(proposedCoolSetpoint = (coolSetpoint) ? coolSetpoint : this.getCoolingSetpoint())][If (coolSetpoint == null),[(prioritySetpointType = SETPOINT_TYPE.HEATING)],[If (heatSetpoint == null),[(prioritySetpointType = SETPOINT_TYPE.COOLING)],[If (prioritySetpointType == null),[(prioritySetpointType = DEFAULT_SETPOINT_TYPE)],],],],[If (mode in HEAT_ONLY_MODES),[(newHeatSetpoint = this.boundInt(proposedHeatSetpoint, FULL_SETPOINT_RANGE))][If (newHeatSetpoint != proposedHeatSetpoint),,],,[If (mode in COOL_ONLY_MODES),[(newCoolSetpoint = this.boundInt(proposedCoolSetpoint, FULL_SETPOINT_RANGE))][If (newCoolSetpoint != proposedCoolSetpoint),,],,[If (mode in DUAL_SETPOINT_MODES),[If (prioritySetpointType == SETPOINT_TYPE.HEATING),[(newHeatSetpoint = this.boundInt(proposedHeatSetpoint, HEATING_SETPOINT_RANGE))][(customCoolingSetpointRange = ((newHeatSetpoint + AUTO_MODE_SETPOINT_SPREAD)..COOLING_SETPOINT_RANGE.getTo()))][(newCoolSetpoint = this.boundInt(proposedCoolSetpoint, customCoolingSetpointRange))],[If (prioritySetpointType == SETPOINT_TYPE.COOLING),[(newCoolSetpoint = this.boundInt(proposedCoolSetpoint, COOLING_SETPOINT_RANGE))][(customHeatingSetpointRange = (HEATING_SETPOINT_RANGE.getFrom()..(newCoolSetpoint - AUTO_MODE_SETPOINT_SPREAD)))][(newHeatSetpoint = this.boundInt(proposedHeatSetpoint, customHeatingSetpointRange))],],],,[If (mode == MODE.OFF),,],],],],[If (newHeatSetpoint != null),,],[If (newCoolSetpoint != null),,],]
evaluateOperatingState: [(currentTemp = (overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value) ? overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value : (java.lang.Integer -> java.lang.Integer) this.getTemperature())][(heatingSetpoint = (overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value) ? overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value : (java.lang.Integer -> java.lang.Integer) this.getHeatingSetpoint())][(coolingSetpoint = (overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value) ? overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value : (java.lang.Integer -> java.lang.Integer) this.getCoolingSetpoint())][(tsMode = this.getThermostatMode())][(currentOperatingState = this.getOperatingState())][(isHeating = false)][(isCooling = false)][(isIdle = false)][If (tsMode in (HEAT_ONLY_MODES + DUAL_SETPOINT_MODES)),[If ((heatingSetpoint - currentTemp) >= THRESHOLD_DEGREES),[(isHeating = true)],],,],[If ((tsMode in (COOL_ONLY_MODES + DUAL_SETPOINT_MODES)) && isHeating),[If ((currentTemp - coolingSetpoint) >= THRESHOLD_DEGREES),[(isCooling = true)],],,],[If (isHeating || isCooling),,],]
startSimHvac: [(operatingState = this.getOperatingState())][(isRunning = (state?.isHvacRunning) ? state?.isHvacRunning : false)][(shouldBeRunning = (operatingState in RUNNING_OP_STATES))][If (isRunning && shouldBeRunning),[(state.isHvacRunning = true)][org.codehaus.groovy.ast.stmt.ExpressionStatement@40ab8a8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6ff37443[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@65cc8228[org.codehaus.groovy.ast.expr.VariableExpression@53093491[variable: SIM_HVAC_CYCLE_SECONDS], ConstantExpression[runSimHvacCycle]]]]],[If isRunning,,[If shouldBeRunning,,],],],]
runSimHvacCycle: [(operatingState = this.getOperatingState())][(currentTemp = this.getTemperature())][(heatSet = this.getHeatingSetpoint())][(coolSet = this.getCoolingSetpoint())][If ((operatingState == OP_STATE.HEATING) && ((heatSet - currentTemp) >= THRESHOLD_DEGREES)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@21719a0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@76b224cd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@77ee25f1[org.codehaus.groovy.ast.expr.VariableExpression@6dd93a21[variable: SIM_HVAC_CYCLE_SECONDS], ConstantExpression[runSimHvacCycle]]]]],[If ((operatingState == OP_STATE.COOLING) && ((currentTemp - coolSet) >= THRESHOLD_DEGREES)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@57b9e423[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@304a3655[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@368d5c00[org.codehaus.groovy.ast.expr.VariableExpression@12a160c2[variable: SIM_HVAC_CYCLE_SECONDS], ConstantExpression[runSimHvacCycle]]]]],[(state.isHvacRunning = false)]],],]
done: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-thermostat.metadata() is applicable for argument types: (simulated-thermostat$_run_closure1) values: [simulated-thermostat$_run_closure1@4784013e]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-water-sensor.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
wet: ]
dry: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-water-sensor.metadata() is applicable for argument types: (simulated-water-sensor$_run_closure1) values: [simulated-water-sensor$_run_closure1@5cf87cfd]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-water-valve.groovy
DECLARED METHODS
installed: ]
open: ]
close: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-water-valve.metadata() is applicable for argument types: (simulated-water-valve$_run_closure1) values: [simulated-water-valve$_run_closure1@2571066a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing single-button-controller.groovy
DECLARED METHODS
selectButton: ]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4c27d39d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@40ee0a22[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7bde1f3a[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@15923407[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@67dba613[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@57540fd0[org.codehaus.groovy.ast.expr.VariableExpression@5cf8edcf[variable: buttonDevice], ConstantExpression[button], org.codehaus.groovy.ast.expr.VariableExpression@58cec85b[variable: buttonEvent]]]]]]
configured: ]
buttonConfigured: ]
buttonEvent: [(buttonNumber = evt.data)][(value = evt.value)][log.debug(buttonEvent: $evt.name = $evt.value ($evt.data))][(recentEvents = buttonDevice.eventsSince(new java.util.Date((this.now() - 3000))).findAll({ -> ... }))]]
executeHandlers: [(lights = this.find(lights, buttonNumber, value))][If (lights != null),,],[(locks = this.find(locks, buttonNumber, value))][If (locks != null),,],[(sonos = this.find(sonos, buttonNumber, value))][If (sonos != null),,],[(mode = this.find(mode, buttonNumber, value))][If (mode != null),,],[(phrase = this.find(phrase, buttonNumber, value))][If (phrase != null),,],]
find: [(preferenceName = ((((type + _) + buttonNumber) + _) + value))][(pref = settings[preferenceName])][If (pref != null),,],]
toggle: [log.debug(toggle: $devices = $devices*.currentValue(switch))][If devices*.currentValue(switch).contains(on),,[If devices*.currentValue(switch).contains(off),,[If devices*.currentValue(lock).contains(locked),,[If devices*.currentValue(lock).contains(unlocked),,],],],],]
changeMode: [log.debug(changeMode: $mode, location.mode = $location.mode, location.modes = $location.modes)][If ((location.mode != mode) && location.modes?.find({ -> ... })),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing sleepy-time.groovy
DECLARED METHODS
selectPhrases: ]
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@562c877a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@67001148[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@989da1[org.codehaus.groovy.ast.expr.VariableExpression@31cb96e1[variable: jawbone], ConstantExpression[sleeping], org.codehaus.groovy.ast.expr.VariableExpression@3eed0f5[variable: jawboneHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@64030b91[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2032e725[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4d23015c[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@383f1975[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@441cc260[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@73a00e09[org.codehaus.groovy.ast.expr.VariableExpression@26dcd8c0[variable: jawbone], ConstantExpression[sleeping], org.codehaus.groovy.ast.expr.VariableExpression@66e889df[variable: jawboneHandler]]]]]]
initialize: ]
jawboneHandler: [log.debug(In Jawbone Event Handler, Event Name = $evt.name, Value = $evt.value)][If ((evt.value == sleeping) && sleepPhrase),,[If ((evt.value == not sleeping) && wakePhrase),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-auto-lock-unlock.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5b22b970[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@22d1886d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7df60067[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1cbb3d3b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@529cfee5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7ca0863b[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@319854f0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@748fe51d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@415156bf[org.codehaus.groovy.ast.expr.VariableExpression@393881f0[variable: lock1], ConstantExpression[lock], org.codehaus.groovy.ast.expr.VariableExpression@4af46df3[variable: doorHandler], org.codehaus.groovy.ast.expr.MapExpression@4158debd[org.codehaus.groovy.ast.expr.MapEntryExpression@af78c87(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@773dab28[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1ecfcbc9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1965539b[org.codehaus.groovy.ast.expr.VariableExpression@2fc07784[variable: lock1], ConstantExpression[unlock], org.codehaus.groovy.ast.expr.VariableExpression@353efdbf[variable: doorHandler], org.codehaus.groovy.ast.expr.MapExpression@55cff952[org.codehaus.groovy.ast.expr.MapEntryExpression@660591fb(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4a55a6e8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@8c46918[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@226b143b[org.codehaus.groovy.ast.expr.VariableExpression@682bd3c4[variable: contact1], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@f2e4acf[variable: doorHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@24097e9b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5eb97ced[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@68ba310d[org.codehaus.groovy.ast.expr.VariableExpression@153f66e7[variable: contact1], ConstantExpression[contact.closed], org.codehaus.groovy.ast.expr.VariableExpression@7aad3f7d[variable: doorHandler]]]]]]
lockDoor: [If (lock1.latestValue(lock) == unlocked),[If (sendPushMessage != No),,],[If ((sendText == Yes) && (phoneNumber != 0)),,],,[If (lock1.latestValue(lock) == locked),,],],]
unlockDoor: [If (lock1.latestValue(lock) == locked),[If (sendPushMessage != No),,],[If ((sendText == Yes) && (phoneNumber != 0)),,],,[If (lock1.latestValue(lock) == unlocked),,],],]
doorHandler: [If ((contact1.latestValue(contact) == open) && (evt.value == locked)),[(delay = secondsLater)][org.codehaus.groovy.ast.stmt.ExpressionStatement@6f667ad1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@566d0c69[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@388b401d[org.codehaus.groovy.ast.expr.VariableExpression@2bcec6a6[variable: delay], org.codehaus.groovy.ast.expr.VariableExpression@77a281fc[variable: unlockDoor]]]]],[If ((contact1.latestValue(contact) == open) && (evt.value == unlocked)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@4912d525[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2bfbffb2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@765df79d[org.codehaus.groovy.ast.expr.VariableExpression@151335cb[variable: unlockDoor]]]]],[If ((contact1.latestValue(contact) == closed) && (evt.value == locked)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@4a7761b1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3e850122[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@27fde870[org.codehaus.groovy.ast.expr.VariableExpression@2b4c3c29[variable: lockDoor]]]]],[If ((contact1.latestValue(contact) == closed) && (evt.value == unlocked)),[(delay = (minutesLater * 60))][org.codehaus.groovy.ast.stmt.ExpressionStatement@5ac7aa18[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4cdd2c73[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4abf3f0[org.codehaus.groovy.ast.expr.VariableExpression@4e4c3a38[variable: delay], org.codehaus.groovy.ast.expr.VariableExpression@293cde83[variable: lockDoor]]]]],[If ((lock1.latestValue(lock) == unlocked) && (evt.value == open)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@c27d163[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@57c88764[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@78faea5f[org.codehaus.groovy.ast.expr.VariableExpression@37fdfb05[variable: lockDoor]]]]],[If ((lock1.latestValue(lock) == unlocked) && (evt.value == closed)),[(delay = (minutesLater * 60))][org.codehaus.groovy.ast.stmt.ExpressionStatement@5e39850[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1603dc2f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@398474a2[org.codehaus.groovy.ast.expr.VariableExpression@61799544[variable: delay], org.codehaus.groovy.ast.expr.VariableExpression@78c1a023[variable: lockDoor]]]]],[If ((lock1.latestValue(lock) == locked) && (evt.value == open)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@70abf9b0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6a10b263[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@476ec9d0[org.codehaus.groovy.ast.expr.VariableExpression@325bb9a6[variable: lockDoor]]]]],[If ((lock1.latestValue(lock) == locked) && (evt.value == closed)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@1d12b024[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@72fe8a4f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@43effd89[org.codehaus.groovy.ast.expr.VariableExpression@2c16fadb[variable: lockDoor]]]]],[org.codehaus.groovy.ast.stmt.ExpressionStatement@248deced[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2227a6c1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1e9804b9[org.codehaus.groovy.ast.expr.VariableExpression@543e593[variable: lockDoor]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4e628b52[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@51ec2df1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@f8f56b9[org.codehaus.groovy.ast.expr.VariableExpression@15fa55a6[variable: unlockDoor]]]]]],],],],],],],],]
Starting Points: [this.runIn(delay, unlockDoor), this.unschedule(unlockDoor), this.unschedule(lockDoor), this.runIn(delay, lockDoor), this.unschedule(lockDoor), this.runIn(delay, lockDoor), this.unschedule(lockDoor), this.unschedule(lockDoor), this.unschedule(lockDoor), this.unschedule(unlockDoor)]
IT HAS STATE
--app-start--
processing smart-block.groovy
DECLARED METHODS
parse: ]
on: ]
off: ]
setLevel: [(signal = this.convertLevelToSignal((int) newLevel))]]
sendSignalToMC: [(url = http://$state.serverIp:3333/block?x=$state.x&y=$state.y&z=$state.z&name=level&value=$newSignal)][this.httpPost(url, foo=bar, { java.lang.Object response -> ... })]]
sendSwitchStateToMC: [(url = http://$state.serverIp:3333/block?x=$state.x&y=$state.y&z=$state.z&name=switch&value=$switchState)][this.httpPost(url, foo=bar, { java.lang.Object response -> ... })]]
setCoordinates: [(state.x = x)][(state.y = y)][(state.z = z)]]
getCoordinates: ]
getCoordinate: [If [x, y, z].contains(axis),,],[return state.$axis]]
isDestroyed: [state.destroyed]]
setDestroyed: [(state.destroyed = isDestroyed)]]
setWorldSeed: [(state.worldSeed = worldSeed)]]
setDimensionName: [(state.dimensionName = dimensionName)]]
setPlacedBy: [(state.placedBy = placedBy)]]
setClosestPlayer: [(state.closestPlayer = closestPlayer)][(state.closestPlayerChanged = new java.util.Date())]]
setSignalStrength: [(state.signalStrength = signalStrength)]]
setLastNeighborChanged: [(state.neighborBlockId = blockId)][(state.neighborBlockName = blockName)]]
setServerIp: [If ip,,],[(ip = ip.replace(https://, ))][(ip = ip.replace(http://, ))][(serverParts = ip.split(:))][If (serverParts.size() > 1),[(state.serverPort = serverParts[1])],],[If (serverParts.size() > 0),[(state.serverIp = serverParts[0])],],[If state.serverIp,[(state.blockServer = state.serverIp)],],[If state.serverPort,[(state.blockServer = $state.blockServer:$state.serverPort)],],[this.sendEvent([name:blockServer, value:$state.blockServer])]]
calculateDNI: [$state.worldSeed|$state.dimensionName|$this.getCoordinates().encodeAsMD5()]]
neighborBlockChange: [If data?.closestPlayer,,],[(signalStrength = (int) data?.signalStrength)][If data?.worldSeed,,],[If data?.dimensionName,,],[If data?.placedBy,,],]
convertLevelToSignal: [If (level <= 0),,],[If (level >= 99),,],[(signal = (15 - ((99 - level) / 7)))]]
convertSignalToLevel: [If (signal <= 0),,],[If (signal >= 15),,],[(level = (99 - ((15 - signal) * 7)))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smart-block.metadata() is applicable for argument types: (smart-block$_run_closure1) values: [smart-block$_run_closure1@7d755813]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smart-care-daily-routine.groovy
DECLARED METHODS
disclaimerPage: [(disclaimerText = ((((((((((((((((((((((((SMARTTHINGS INC. SMART CARE SUPPLEMENTAL TERMS AND DISCLAIMER
 + SmartThings Inc. is not an emergency medical response service of any kind and does not provide ) + medical or health-related advice, which should be obtained from qualified medical personnel. ) + SmartThings Inc., the contents of the app (such as text, graphics, images, videos, data and ) + information contained therein) and such materials obtained from third parties are provided for ) + information purposes only and are not substitutes for professional medical advice, diagnosis, ) + examination, or treatment by a health care provider. If you think you or a loved one has a medical ) + emergency, call your doctor or 911 immediately. Do not rely on electronic communications or ) + communication through this app for immediate, urgent medical needs. ) + THIS APP IS NOT DESIGNED TO FACILITATE OR AID IN MEDICAL EMERGENCIES.

) + If you have any concerns or questions about your health or the health of a loved one, ) + you should always consult with a physician or other health care professional.) + You understand and acknowledge that all users of this app are responsible for their own medical care, ) + treatment, and oversight. You also understand and acknowledge that you should never disregard, ) + avoid, or delay obtaining medical or health-related advice ) + relating to treatment or standard of care because of information contained in or transmitted through the app. ) + RELIANCE ON ANY INFORMATION PROVIDED BY THE APP OR OTHER THIRD-PARTY PLATFORMS IS SOLELY AT YOUR OWN RISK.

) + While SmartThings Inc. strives to make the information on the app as timely and accurate as possible, ) + SmartThings Inc. makes no claims, promises, or guarantees about the accuracy, completeness, ) + or adequacy of the content or information on the app. SmartThings Inc. expressly disclaims liability for any errors ) + and omissions in content or for the availability of content on the app. ) + SmartThings Inc. will not be liable for any losses, injuries, or damages arising from the display ) + or use of content on the app. SMARTTHINGS INC., ITS OFFICERS, ) + EMPLOYEES AND AGENTS DO NOT ACCEPT LIABILITY HOWEVER ARISING, INCLUDING LIABILITY FOR NEGLIGENCE, ) + FOR ANY LOSS RESULTING FROM THE USE OF OR RELIANCE UPON THE INFORMATION AND/OR SERVICES AT ANY TIME.))][If (disclaimerResponse && (disclaimerResponse == I agree to these terms)),,],]
configurationPage: ]
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@60dd3c23[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@52b6319f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5e9456ae[org.codehaus.groovy.ast.expr.VariableExpression@16a9a4f1[variable: time1], ConstantExpression[scheduleCheck]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1f1cae23[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7c455e96[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@985696[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5bcde458[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@215a34b4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@77bd7fe7[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@35d3ab60[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@10876a6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@71870da7[org.codehaus.groovy.ast.expr.VariableExpression@6dd91637[variable: time1], ConstantExpression[scheduleCheck]]]]]]
scheduleCheck: [If (this.noRecentContact() && this.noRecentMotion()),[(person = (person1) ? person1 : your elder)][(msg = Alert! There has been no activity at $persons place $timePhrase)][If location.contactBookEnabled,,[If phone1,,],],,],]
noRecentMotion: [If motion1,[(motionEvents = motion1.eventsSince(sinceTime))][If motionEvents.find({ -> ... }),,],,],]
noRecentContact: [If contact1,[(contactEvents = contact1.eventsSince(sinceTime))][If contactEvents.find({ -> ... }),,],,],]
getSinceTime: [If time0,,],]
getTimePhrase: [(interval = (this.now() - sinceTime.time))][If (interval < 3600000),,[If (interval < 7200000),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-care-detect-motion.groovy
DECLARED METHODS
disclaimerPage: [(disclaimerText = ((((((((((((((((((((((((SMARTTHINGS INC. SMART CARE SUPPLEMENTAL TERMS AND DISCLAIMER
 + SmartThings Inc. is not an emergency medical response service of any kind and does not provide ) + medical or health-related advice, which should be obtained from qualified medical personnel. ) + SmartThings Inc., the contents of the app (such as text, graphics, images, videos, data and ) + information contained therein) and such materials obtained from third parties are provided for ) + information purposes only and are not substitutes for professional medical advice, diagnosis, ) + examination, or treatment by a health care provider. If you think you or a loved one has a medical ) + emergency, call your doctor or 911 immediately. Do not rely on electronic communications or ) + communication through this app for immediate, urgent medical needs. ) + THIS APP IS NOT DESIGNED TO FACILITATE OR AID IN MEDICAL EMERGENCIES.

) + If you have any concerns or questions about your health or the health of a loved one, ) + you should always consult with a physician or other health care professional.) + You understand and acknowledge that all users of this app are responsible for their own medical care, ) + treatment, and oversight. You also understand and acknowledge that you should never disregard, ) + avoid, or delay obtaining medical or health-related advice ) + relating to treatment or standard of care because of information contained in or transmitted through the app. ) + RELIANCE ON ANY INFORMATION PROVIDED BY THE APP OR OTHER THIRD-PARTY PLATFORMS IS SOLELY AT YOUR OWN RISK.

) + While SmartThings Inc. strives to make the information on the app as timely and accurate as possible, ) + SmartThings Inc. makes no claims, promises, or guarantees about the accuracy, completeness, ) + or adequacy of the content or information on the app. SmartThings Inc. expressly disclaims liability for any errors ) + and omissions in content or for the availability of content on the app. ) + SmartThings Inc. will not be liable for any losses, injuries, or damages arising from the display ) + or use of content on the app. SMARTTHINGS INC., ITS OFFICERS, ) + EMPLOYEES AND AGENTS DO NOT ACCEPT LIABILITY HOWEVER ARISING, INCLUDING LIABILITY FOR NEGLIGENCE, ) + FOR ANY LOSS RESULTING FROM THE USE OF OR RELIANCE UPON THE INFORMATION AND/OR SERVICES AT ANY TIME.))][If (disclaimerResponse && (disclaimerResponse == I agree to these terms)),,],]
configurationPage: ]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6124287a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@19569ebd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4632cfc[]]]]]
initialize: [(state.active = 0)][org.codehaus.groovy.ast.stmt.ExpressionStatement@6e1f8469[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2e380628[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3b6c624[org.codehaus.groovy.ast.expr.VariableExpression@1eaf1e62[variable: bedroomMotion], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@c81fd12[variable: bedroomActive]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@62e6a3ec[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5754de72[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@31ee96f4[org.codehaus.groovy.ast.expr.VariableExpression@320494b6[variable: bathroomMotion], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@652ab8d9[variable: bathroomActive]]]]]]
bedroomActive: [(start = this.timeToday(startTime, location?.timeZone))][(stop = this.timeToday(stopTime, location?.timeZone))][(now = new java.util.Date())][log.debug(bedroomActive, status: $state.ststus, start: $start, stop: $stop, now: $now)][If (state.status == waiting),[org.codehaus.groovy.ast.stmt.ExpressionStatement@14fc5d40[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@51e0301d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@47d7bfb3[ConstantExpression[sendMessage]]]]][(state.status = null)],[If (start.before(now) && stop.after(now)),[(state.status = pending)],],],]
bathroomActive: [log.debug(bathroomActive, status: $state.status)][If (state.status == pending),[(delay = (threshold.toInteger() * 60))][(state.status = waiting)][org.codehaus.groovy.ast.stmt.ExpressionStatement@770b3be0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1eb6e1c[object: org.codehaus.groovy.ast.expr.VariableExpression@51dbd6e4[variable: log] method: ConstantExpression[debug] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2b8bd14b[org.codehaus.groovy.ast.expr.GStringExpression@5f13be1[strings: [ConstantExpression[runIn(], ConstantExpression[)]] values: [org.codehaus.groovy.ast.expr.VariableExpression@5f303ecd[variable: delay]]]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@50d3bf39[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@25a73de1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@29852487[org.codehaus.groovy.ast.expr.VariableExpression@771db12c[variable: delay], org.codehaus.groovy.ast.expr.VariableExpression@3afae281[variable: sendMessage]]]]],],]
sendMessage: [(msg = warnMessage)][If location.contactBookEnabled,,[If phone1,,],[If phone2,,],[If phone3,,],],[(state.status = null)]]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-home-ventilation.groovy
DECLARED METHODS
mainPage: ]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@46d8f407[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3c0036b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@17814b1c[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7ac9af2a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7bb004b8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@78e89bfe[]]]]]
init: [(midnightTime = this.timeToday(2000-01-01T00:01:00.999-0000, location.timeZone))][org.codehaus.groovy.ast.stmt.ExpressionStatement@652ce654[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@522ba524[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@29c5ee1d[org.codehaus.groovy.ast.expr.VariableExpression@15cea7b0[variable: midnightTime], org.codehaus.groovy.ast.expr.VariableExpression@17d2ed1b[variable: midNight]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@185f7840[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1e6cc850[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7e7f0f0a[org.codehaus.groovy.ast.expr.VariableExpression@7ec58feb[variable: location], ConstantExpression[mode], org.codehaus.groovy.ast.expr.VariableExpression@1dbb650b[variable: locationHandler]]]]]]
startProcess: [(state.dayCount = state.data.size())][If state.dayCount,[(state.counter = 0)],],]
startDay: [(start = this.convertEpoch(state.data[state.counter].start))][(stop = this.convertEpoch(state.data[state.counter].stop))][org.codehaus.groovy.ast.stmt.ExpressionStatement@656d10a4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@63ec445c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runOnce] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3104351d[org.codehaus.groovy.ast.expr.VariableExpression@77d18d0b[variable: start], org.codehaus.groovy.ast.expr.VariableExpression@7a344b65[variable: turnOnSwitch], org.codehaus.groovy.ast.expr.MapExpression@7b7b3edb[org.codehaus.groovy.ast.expr.MapEntryExpression@6b474074(key: ConstantExpression[overwrite], value: ConstantExpression[true])]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@108531c2[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@48b22fd4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runOnce] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6a9d5dff[org.codehaus.groovy.ast.expr.VariableExpression@3b08f438[variable: stop], org.codehaus.groovy.ast.expr.VariableExpression@2bac9ba[variable: incDay], org.codehaus.groovy.ast.expr.MapExpression@5b2f8ab6[org.codehaus.groovy.ast.expr.MapEntryExpression@5bdd5689(key: ConstantExpression[overwrite], value: ConstantExpression[true])]]]]]]
incDay: [If state.modeChange,,[(state.counter = (state.counter + 1))][If (state.counter < state.dayCount),,],],]
locationHandler: [(result = false)][(state.modeChange = true)][If result,,],]
midNight: ]
turnOnSwitch: ]
turnOffSwitch: ]
schedDesc: [(title = )][(dayListClean = On )][(modeListClean = Scenario runs in )][If (dayList && (dayList.size() < 7)),[(dayListSize = dayList.size())][For dayList,[(dayListClean = ($dayListClean + $dayName))][(dayListSize = (dayListSize - 1))][If dayListSize,[(dayListClean = $dayListClean, )],],][(dayListSize = dayList.size())][For dayList,[(dayListClean = ($dayListClean + $dayName))][(dayListSize = (dayListSize - 1))][If dayListSize,[(dayListClean = $dayListClean, )],],],[(dayListClean = Every day)]],[If modeList,[(modeListSize = modeList.size())][(modePrefix = modes)][If (modeListSize == 1),[(modePrefix = mode)],],[For modeList,[(modeListClean = ($modeListClean + '$modeName'))][(modeListSize = (modeListSize - 1))][If modeListSize,[(modeListClean = $modeListClean, )],[(modeListClean = $modeListClean $modePrefix)]],][(modeListSize = modeList.size())][(modePrefix = modes)][If (modeListSize == 1),[(modePrefix = mode)],],[For modeList,[(modeListClean = ($modeListClean + '$modeName'))][(modeListSize = (modeListSize - 1))][If modeListSize,[(modeListClean = $modeListClean, )],[(modeListClean = $modeListClean $modePrefix)]],],[(modeListClean = $modeListCleanall modes)]],[If (on1 && off1),[(title += Schedule 1: $this.humanReadableTime(on1) to $this.humanReadableTime(off1))],],[If (on2 && off2),[(title += 
Schedule 2: $this.humanReadableTime(on2) to $this.humanReadableTime(off2))],],[If (on3 && off3),[(title += 
Schedule 3: $this.humanReadableTime(on3) to $this.humanReadableTime(off3))],],[If (on4 && off4),[(title += 
Schedule 4: $this.humanReadableTime(on4) to $this.humanReadableTime(off4))],],[If (((on1 || on2) || on3) || on4),[(title += 
$modeListClean)][(title += 
$dayListClean)],],[If (((on1 && on2) && on3) && on4),[(title = Click to configure scenario)],],]
greyOut: [(result = ((((on1 || on2) || on3) || on4)) ? complete : )]]
humanReadableTime: ]
convertEpoch: ]
getTitle: [(title = (txt) ? txt : Scenario $scenario)]]
daysOk: [(result = true)][If dayList,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = dayList.contains(day))],],]
timeOk: [If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting).time)][(stop = this.timeToday(ending).time)][If (((start < stop) && (start >= currTime)) && (stop >= currTime)),[(state.data << [start:start, stop:stop])],],,],]
createDayArray: [(state.modeChange = false)][(state.data = [])][If (modeA && modeA.contains(location.mode)),[If this.daysOk(daysA),,],,],[If (modeB && modeB.contains(location.mode)),[If this.daysOk(daysB),,],,],[If (modeC && modeC.contains(location.mode)),[If this.daysOk(daysC),,],,],[If (modeD && modeD.contains(location.mode)),[If this.daysOk(daysD),,],,],[state.data.sort({ -> ... })]]
textAppName: [(text = Smart Home Ventilation)]]
textVersion: [(text = Version 2.1.2 (05/31/2015))]]
textCopyright: [(text = Copyright  2015 Michael Struck)]]
textLicense: [(text = ((((((((((Licensed under the Apache License, Version 2.0 (the 'License');  + you may not use this file except in compliance with the License. ) + You may obtain a copy of the License at) + 

) +     http://www.apache.org/licenses/LICENSE-2.0) + 

) + Unless required by applicable law or agreed to in writing, software ) + distributed under the License is distributed on an 'AS IS' BASIS, ) + WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ) + See the License for the specific language governing permissions and ) + limitations under the License.))]]
textHelp: [(text = ((((Within each scenario, choose a start and end time for the ventilation fan. You can have up to 4 different  + venting scenarios, and 4 schedules within each scenario. Each scenario can be restricted to specific modes or certain days of the week. It is recommended ) + that each scenario does not overlap and run in separate modes (i.e. Home, Out of town, etc). Also note that you should  ) + avoid scheduling the ventilation fan at exactly midnight; the app resets itself at that time. It is suggested to start any new schedule ) + at 12:15 am or later.))]]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-humidifier.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@141e879d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@109d724c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1704f67f[org.codehaus.groovy.ast.expr.VariableExpression@e4d2696[variable: humiditySensor1], ConstantExpression[humidity], org.codehaus.groovy.ast.expr.VariableExpression@6e0f7aad[variable: humidityHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@15fb7a32[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@257cc1fc[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@42e22a53[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@57adfab0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1949309d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5af97169[org.codehaus.groovy.ast.expr.VariableExpression@99a78d7[variable: humiditySensor1], ConstantExpression[humidity], org.codehaus.groovy.ast.expr.VariableExpression@31da6b2e[variable: humidityHandler]]]]]]
humidityHandler: [(currentHumidity = java.lang.Double.parseDouble(evt.value.replace(%, )))][(humidityHigh1 = humidityHigh)][(humidityLow1 = humidityLow)][(mySwitch = settings.switch1)][If (currentHumidity >= humidityHigh1),[log.debug(Checking how long the humidity sensor has been reporting >= $humidityHigh1)][(deltaMinutes = 10)][(timeAgo = new java.util.Date((this.now() - ((1000 * 60) * deltaMinutes).toLong())))][(recentEvents = humiditySensor1.eventsSince(timeAgo))][(alreadySentSms1 = (recentEvents.count({ -> ... }) > 1))][If alreadySentSms1,,[If (state.lastStatus != off),[(state.lastStatus = off)],],],,[If (currentHumidity <= humidityLow1),[log.debug(Checking how long the humidity sensor has been reporting <= $humidityLow1)][(deltaMinutes = 10)][(timeAgo = new java.util.Date((this.now() - ((1000 * 60) * deltaMinutes).toLong())))][(recentEvents = humiditySensor1.eventsSince(timeAgo))][(alreadySentSms2 = (recentEvents.count({ -> ... }) > 1))][If alreadySentSms2,,[If (state.lastStatus != on),[(state.lastStatus = on)],],],,],],]
send: [If (sendPushMessage != No),,],[If phone1,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-light-timer-x-minutes-unless-already-on.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@545607f2[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@39109136[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@27c04377[]]]][log.debug((state:  + state.myState))]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@34dc85a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@67403656[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5a6482a9[org.codehaus.groovy.ast.expr.VariableExpression@7f9ab969[variable: switches], ConstantExpression[switch], org.codehaus.groovy.ast.expr.VariableExpression@12f8b1d8[variable: switchChange]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@746cd757[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@ae372b9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2098d37d[org.codehaus.groovy.ast.expr.VariableExpression@77b9d0c7[variable: motions], ConstantExpression[motion], org.codehaus.groovy.ast.expr.VariableExpression@65fd6708[variable: motionHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@749ab7b4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@127f9161[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2bf94401[org.codehaus.groovy.ast.expr.VariableExpression@2532b351[variable: contacts], ConstantExpression[contact], org.codehaus.groovy.ast.expr.VariableExpression@4349754[variable: contactHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6a2eea2a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@b967222[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runEvery1Minute] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3b0ee03a[ConstantExpression[scheduleCheck]]]]][(state.myState = ready)]]
switchChange: [If (evt.value == on),[If (state.myState == activating),[(state.myState = active)],[If (state.myState != active),[(state.myState = already on)],],],,[If ((state.myState == active) || (state.myState == activating)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@1ba05e38[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6c298dc[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3e7dfd44[]]]],],[(state.myState = ready)]],[log.debug((state:  + state.myState))]]
contactHandler: [If (evt.value == open),[If (state.myState == ready),[(state.inactiveAt = null)][(state.myState = activating)],],,[If (evt.value == closed),[If ((state.inactiveAt && (state.myState == active)) || (state.myState == activating)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@723ed581[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6b760460[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[setActiveAndSchedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@796065aa[]]]],],,],],[log.debug((state:  + state.myState))]]
motionHandler: [If (evt.value == active),[If (((state.myState == ready) || (state.myState == active)) || (state.myState == activating)),[(state.inactiveAt = null)][(state.myState = activating)],],,[If (evt.value == inactive),[If ((state.inactiveAt && (state.myState == active)) || (state.myState == activating)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@28a6301f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2c306a57[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[setActiveAndSchedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@773e2eb5[]]]],],,],],[log.debug((state:  + state.myState))]]
setActiveAndSchedule: [org.codehaus.groovy.ast.stmt.ExpressionStatement@d8948cd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1436a7ab[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3b7b05a8[]]]][(state.myState = active)][(state.inactiveAt = this.now())][org.codehaus.groovy.ast.stmt.ExpressionStatement@3d36dff4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7abe27bf[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runEvery1Minute] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5b94ccbc[ConstantExpression[scheduleCheck]]]]]]
scheduleCheck: [log.debug(schedule check, ts = $state.inactiveAt)][If (state.myState != already on),[If (state.inactiveAt != null),[(elapsed = (this.now() - state.inactiveAt))][(threshold = ((1000 * 60) * minutes1))][If (elapsed >= threshold),[If (state.myState == active),,],[(state.inactiveAt = null)][(state.myState = ready)],],,],,],[log.debug((state:  + state.myState))]]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-nightlight.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@54562ea6[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1a35993f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5b12012e[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2f7dcef2[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4a3be6a5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7cf162bc[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@3721177d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@766a4535[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@63718b93[org.codehaus.groovy.ast.expr.VariableExpression@14e2e1c3[variable: motionSensor], ConstantExpression[motion], org.codehaus.groovy.ast.expr.VariableExpression@2b4786dd[variable: motionHandler]]]]][If lightSensor,[org.codehaus.groovy.ast.stmt.ExpressionStatement@f202d6d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@60e21209[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@630d1b2f[org.codehaus.groovy.ast.expr.VariableExpression@746b18fd[variable: lightSensor], ConstantExpression[illuminance], org.codehaus.groovy.ast.expr.VariableExpression@7a2e0858[variable: illuminanceHandler], org.codehaus.groovy.ast.expr.MapExpression@aac3f4e[org.codehaus.groovy.ast.expr.MapEntryExpression@1f38957(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]],[org.codehaus.groovy.ast.stmt.ExpressionStatement@2df3c564[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2715644a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4c2869a9[org.codehaus.groovy.ast.expr.VariableExpression@518cf84a[variable: location], ConstantExpression[position], org.codehaus.groovy.ast.expr.VariableExpression@62e7dffa[variable: locationPositionChange]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6edcd0d8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6136998b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@57ce634f[org.codehaus.groovy.ast.expr.VariableExpression@b8a7e43[variable: location], ConstantExpression[sunriseTime], org.codehaus.groovy.ast.expr.VariableExpression@35835fa[variable: sunriseSunsetTimeHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@56f71edb[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7207cb51[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2a27cb34[org.codehaus.groovy.ast.expr.VariableExpression@6892cc6f[variable: location], ConstantExpression[sunsetTime], org.codehaus.groovy.ast.expr.VariableExpression@6fd1660[variable: sunriseSunsetTimeHandler]]]]]],]
locationPositionChange: ]
sunriseSunsetTimeHandler: [(state.lastSunriseSunsetEvent = this.now())]]
motionHandler: [If (evt.value == active),[If this.enabled(),[(state.lastStatus = on)],],[(state.motionStopTime = null)],[(state.motionStopTime = this.now())][If delayMinutes,[org.codehaus.groovy.ast.stmt.ExpressionStatement@4a6c18ad[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5e8604bf[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@20095ab4[org.codehaus.groovy.ast.expr.BinaryExpression@4e2916c3[org.codehaus.groovy.ast.expr.VariableExpression@64aad6db[variable: delayMinutes]("*" at 101:22:  "*" )ConstantExpression[60]], org.codehaus.groovy.ast.expr.VariableExpression@ae7950d[variable: turnOffMotionAfterDelay], org.codehaus.groovy.ast.expr.MapExpression@60d1b21f[org.codehaus.groovy.ast.expr.MapEntryExpression@66c83fc8(key: ConstantExpression[overwrite], value: ConstantExpression[true])]]]]],],],]
illuminanceHandler: [log.debug($evt.name: $evt.value, lastStatus: $state.lastStatus, motionStopTime: $state.motionStopTime)][(lastStatus = state.lastStatus)][If ((lastStatus != off) && (evt.integerValue > 50)),[(state.lastStatus = off)],[If state.motionStopTime,[If (lastStatus != off),[(elapsed = (this.now() - state.motionStopTime))][If (elapsed >= (((delayMinutes) ? delayMinutes : 0 * 60000) - 2000)),[(state.lastStatus = off)],],,],,[If ((lastStatus != on) && (evt.integerValue < 30)),[(state.lastStatus = on)],],],],]
turnOffMotionAfterDelay: [log.trace(In turnOffMotionAfterDelay, state.motionStopTime = $state.motionStopTime, state.lastStatus = $state.lastStatus)][If (state.motionStopTime && (state.lastStatus != off)),[(elapsed = (this.now() - state.motionStopTime))][log.trace(elapsed = $elapsed)][If (elapsed >= (((delayMinutes) ? delayMinutes : 0 * 60000) - 2000)),[(state.lastStatus = off)],],,],]
scheduleCheck: [org.codehaus.groovy.ast.stmt.ExpressionStatement@546621c4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@621f89b8[object: org.codehaus.groovy.ast.expr.VariableExpression@f339eae[variable: log] method: ConstantExpression[debug] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2822c6ff[ConstantExpression[In scheduleCheck - skipping]]]]]]
astroCheck: [(s = this.getSunriseAndSunset([zipCode:zipCode, sunriseOffset:sunriseOffset, sunsetOffset:sunsetOffset]))][(state.riseTime = s.sunrise.time)][(state.setTime = s.sunset.time)][log.debug(rise: $new Date(state.riseTime)($state.riseTime), set: $new Date(state.setTime)($state.setTime))]]
enabled: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If lightSensor,[(result = (lightSensor.currentIlluminance?.toInteger() < 30))],[(t = this.now())][(result = ((t < state.riseTime) || (t > state.setTime)))]],]
getSunriseOffset: [(sunriseOffsetValue) ? ((sunriseOffsetDir == Before)) ? -$sunriseOffsetValue : sunriseOffsetValue : null]]
getSunsetOffset: [(sunsetOffsetValue) ? ((sunsetOffsetDir == Before)) ? -$sunsetOffsetValue : sunsetOffsetValue : null]]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-security.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@576c5536[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@55ecbafe[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5a8ba37c[]]]][(state.alarmActive = null)]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@37c2eacb[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@232cce0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@32b9bd12[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@352e787a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@159a48a6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@15bc339[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7e75bf2d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@385ef531[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7fc645e4[]]]][(state.alarmActive = null)][(state.residentsAreUp = null)][(state.lastIntruderMotion = null)]]
subscribeToEvents: [org.codehaus.groovy.ast.stmt.ExpressionStatement@205b132e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@73044cdf[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3cbcd8f3[org.codehaus.groovy.ast.expr.VariableExpression@719843e5[variable: intrusionMotions], ConstantExpression[motion], org.codehaus.groovy.ast.expr.VariableExpression@9a2ec9b[variable: intruderMotion]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@58112bc4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2301b75[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3104f7bd[org.codehaus.groovy.ast.expr.VariableExpression@2f5c1332[variable: intrusionContacts], ConstantExpression[contact], org.codehaus.groovy.ast.expr.VariableExpression@7ec25216[variable: contact]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7cab1508[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6a84bc3f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@258ee7de[org.codehaus.groovy.ast.expr.VariableExpression@4930539b[variable: alarms], ConstantExpression[alarm], org.codehaus.groovy.ast.expr.VariableExpression@6d171ce0[variable: alarm]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@22bd2039[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@705f83a7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3bb8aabc[org.codehaus.groovy.ast.expr.VariableExpression@6e1d4137[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@256a1825[variable: appTouch]]]]]]
residentsHaveBeenQuiet: [(threshold = (((((residentsQuietThreshold != null) && (residentsQuietThreshold != ))) ? residentsQuietThreshold : 3 * 60) * 1000))][(result = true)][(t0 = new java.util.Date((this.now() - threshold)))][For residentMotions,[(recentStates = sensor.statesSince(motion, t0))][If recentStates.find({ -> ... }),[(result = false)][(result = false)],],]residentsHaveBeenQuiet: [(threshold = (((((residentsQuietThreshold != null) && (residentsQuietThreshold != ))) ? residentsQuietThreshold : 3 * 60) * 1000))][(result = true)][(t0 = new java.util.Date((this.now() - threshold)))][For residentMotions,[(recentStates = sensor.statesSince(motion, t0))][If recentStates.find({ -> ... }),[(result = false)][(result = false)],],]]
intruderMotionInactive: [(result = true)][For intrusionMotions,[If (sensor.currentMotion == active),[(result = false)][(result = false)],],]intruderMotionInactive: [(result = true)][For intrusionMotions,[If (sensor.currentMotion == active),[(result = false)][(result = false)],],]]
isResidentMotionSensor: [(residentMotions?.find({ -> ... }) != null)]]
appTouch: [(state.alarmActive = false)]]
motion: [If this.isResidentMotionSensor(evt),,],]
intruderMotion: [If (evt.value == active),[log.debug(motion by potential intruder, residentsAreUp: $state.residentsAreUp)][If state.residentsAreUp,[If this.residentsHaveBeenQuiet(),,],,],,],[(state.lastIntruderMotion = this.now())]]
residentMotion: [org.codehaus.groovy.ast.stmt.ExpressionStatement@29a4f594[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@57b75756[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5327a06e[org.codehaus.groovy.ast.expr.VariableExpression@2679311f[variable: residentMotions]]]]]]
contact: [If (evt.value == open),[If state.residentsAreUp,[If this.residentsHaveBeenQuiet(),,],,],,],]
alarm: [If (evt.value == off),[(state.alarmActive = false)],],]
disarmIntrusionDetection: [(state.residentsAreUp = true)][org.codehaus.groovy.ast.stmt.ExpressionStatement@287f7811[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@451f87af[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[scheduleReArmCheck] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2b556bb2[]]]]]
scheduleReArmCheck: [(cron = 0 * * * * ?)][org.codehaus.groovy.ast.stmt.ExpressionStatement@44cb460e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@17271176[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2e3cdec2[org.codehaus.groovy.ast.expr.VariableExpression@2e34384c[variable: cron], ConstantExpression[checkForReArm]]]]]]
checkForReArm: [(threshold = (((((residentsQuietThreshold != null) && (residentsQuietThreshold != ))) ? residentsQuietThreshold : 3 * 60) * 1000))][(lastIntruderMotion = state.lastIntruderMotion)][log.debug(checkForReArm: lastIntruderMotion=$lastIntruderMotion)][If (lastIntruderMotion != null),[If ((this.now() - lastIntruderMotion) > threshold),[(state.residentsAreUp = false)][org.codehaus.groovy.ast.stmt.ExpressionStatement@3051e0b2[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1f52eb6f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@57d0fc89[]]]],],,],]
startAlarmSequence: [If state.alarmActive,,[(state.alarmActive = true)][If newMode,,],[If this.silentAlarm(),[If location.contactBookEnabled,,[If phone,,],],,[(delayTime = seconds)][If delayTime,[org.codehaus.groovy.ast.stmt.ExpressionStatement@58294867[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@67c277a0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6fc3e1a4[org.codehaus.groovy.ast.expr.VariableExpression@3fa76c61[variable: delayTime], ConstantExpression[soundSiren]]]]],],],[If lights,,],],]
soundSiren: [If state.alarmActive,[If location.contactBookEnabled,,[If phone,,],],[If lights,,],,],[org.codehaus.groovy.ast.stmt.ExpressionStatement@2d5f7182[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@59546cfe[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@29ea78b1[ConstantExpression[soundSiren]]]]]]
continueFlashing: [org.codehaus.groovy.ast.stmt.ExpressionStatement@2d2acd89[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7baf6acf[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1e6dad8[]]]][If state.alarmActive,[org.codehaus.groovy.ast.stmt.ExpressionStatement@7b3315a5[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@8ed9cf[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@f72203[org.codehaus.groovy.ast.expr.MethodCallExpression@377008df[object: org.codehaus.groovy.ast.expr.VariableExpression@540dbda9[variable: util] method: ConstantExpression[cronExpression] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@22bb5646[org.codehaus.groovy.ast.expr.BinaryExpression@1be59f28[org.codehaus.groovy.ast.expr.MethodCallExpression@2ce45a7b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[now] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@153d4abb[]]("+" at 295:38:  "+" )ConstantExpression[10000]]]], ConstantExpression[continueFlashing]]]]],],]
flashLights: [(onFor = 1000)][(offFor = 1000)][(delay = 1)]]
silentAlarm: ]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-turn-it-on.groovy
DECLARED METHODS
installed: [If timeOne,[org.codehaus.groovy.ast.stmt.ExpressionStatement@5fad41be[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6dcd5639[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3b36e000[org.codehaus.groovy.ast.expr.VariableExpression@333cb916[variable: timeOne], ConstantExpression[turnOn]]]]],],]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@629ae7e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1d25c1c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@de88ac6[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5bca7664[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@105b693d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3fae596[]]]][If timeOne,[org.codehaus.groovy.ast.stmt.ExpressionStatement@4a0df195[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@42fcc7e6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@9255c05[org.codehaus.groovy.ast.expr.VariableExpression@5da7cee2[variable: timeOne], ConstantExpression[turnOn]]]]],],]
turnOn: [(dayCheck = dayOne.contains(new java.util.Date().format(EEE)))][(dayTwo = new java.util.Date().format(EEE))][If dayCheck,[(presenceTwo = presenceOne.latestValue(presence).contains(present))][If presenceTwo,[(delay = (timeTwo * 60))][org.codehaus.groovy.ast.stmt.ExpressionStatement@78830d9a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5ce4369b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7f829c76[org.codehaus.groovy.ast.expr.VariableExpression@1cb19dba[variable: delay], ConstantExpression[turnOff]]]]],],,],]
turnOff: ]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-windows.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@29a69a35[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@67e28be3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@e344ad3[org.codehaus.groovy.ast.expr.VariableExpression@de18f63[variable: inTemp], ConstantExpression[temperature], org.codehaus.groovy.ast.expr.VariableExpression@108bdbd8[variable: temperatureHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6345e7b9[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4f8b4bd0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4e904fd5[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@b18c4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4cbf4f53[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@597f48df[org.codehaus.groovy.ast.expr.VariableExpression@15dd5ac2[variable: inTemp], ConstantExpression[temperature], org.codehaus.groovy.ast.expr.VariableExpression@4d48bd85[variable: temperatureHandler]]]]]]
temperatureHandler: [(currentOutTemp = null)][If outTemp,[(currentOutTemp = outTemp.latestValue(temperature))],[(currentOutTemp = this.weatherCheck())]],[(currentInTemp = evt.doubleValue)][(openWindows = sensors.findAll({ -> ... }))][If retryPeriod,[(retryPeriod = 30)],],[(timeAgo = new java.util.Date((this.now() - ((1000 * 60) * retryPeriod).toLong())))][(recentEvents = inTemp.eventsSince(timeAgo))][If ((currentInTemp > minTemp) && (currentInTemp < maxTemp)),,[If (currentInTemp > maxTemp),[(alreadyNotified = (recentEvents.count({ -> ... }) > 1))][If alreadyNotified,[If ((currentOutTemp < maxTemp) && openWindows),,[If ((currentOutTemp > maxTemp) && openWindows),,],],,],,[If (currentInTemp < minTemp),[(alreadyNotified = (recentEvents.count({ -> ... }) > 1))][If alreadyNotified,[If ((currentOutTemp > minTemp) && openWindows),,[If ((currentOutTemp < minTemp) && openWindows),,],],,],,],],],]
weatherCheck: [(json = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (location.channelName != samsungtv),[(json = this.getWeatherFeature(conditions, zipCode))],[(json = this.getWeatherFeature(conditions))]],[(currentTemp = json?.current_observation?.temp_f)][If currentTemp,,],]
send: [If (sendPushMessage != No),,],[If phone1,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing smartblock-chat-sender.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1237e0be[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@528f8f8b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@ea9e141[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1e54cb33[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@33cbfa57[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1d96d872[org.codehaus.groovy.ast.expr.VariableExpression@5c748168[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@6441c486[variable: modeChangeHandler]]]]]]
modeChangeHandler: [(newMode = evt.value)][If (modes && modes.contains(newMode)),[(message = (customMessage) ? customMessage : SmartThings mode has changed to: "$newMode")],],]
chatMessageToMC: [(parent = app.getParent())][(url = $parent.getServerURL()/chat?message=$message.encodeAsURL())][If username,[(url += &username=$username.encodeAsURL())],],[this.httpPost(url, foo=bar, { java.lang.Object response -> ... })]]
Starting Points: []
IT HAS STATE
--app-start--
processing smartblock-linker.groovy
DECLARED METHODS
linkerPage: ]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@369c9bb[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@76d05cc9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@42b21d99[]]]]]
initialize: [If blockUpdatesSwitch,[org.codehaus.groovy.ast.stmt.ExpressionStatement@68dcfd52[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@25b5c5e3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5177e388[org.codehaus.groovy.ast.expr.VariableExpression@37b72ea[variable: linkedSmartBlock], ConstantExpression[level], org.codehaus.groovy.ast.expr.VariableExpression@cc239ba[variable: updateSwitchLevel]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7d37f1c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@69d6a7cd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3162743f[org.codehaus.groovy.ast.expr.VariableExpression@2c708440[variable: linkedSmartBlock], ConstantExpression[switch], org.codehaus.groovy.ast.expr.VariableExpression@3047254d[variable: updateSwitchState]]]]],],[If switchUpdatesBlock,[org.codehaus.groovy.ast.stmt.ExpressionStatement@6cf31447[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4e92466a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@66e8997c[org.codehaus.groovy.ast.expr.VariableExpression@6f0cb5a1[variable: linkedSwitch], ConstantExpression[level], org.codehaus.groovy.ast.expr.VariableExpression@1b29d52b[variable: updateBlockLevel]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@47547132[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@655523dd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6f7e336b[org.codehaus.groovy.ast.expr.VariableExpression@3a2b2322[variable: linkedSwitch], ConstantExpression[switch], org.codehaus.groovy.ast.expr.VariableExpression@5e1218b4[variable: updateBlockState]]]]],],]
updateSwitchLevel: [(level = (int) evt.value)]]
updateBlockLevel: [(level = (int) evt.value)]]
updateSwitchState: ]
updateBlockState: ]
getBlockId: ]
getLinkerDescription: [(left = (linkedSmartBlock) ? $(linkedSmartBlock.label) ? linkedSmartBlock.label : linkedSmartBlock.name : )][(right = (linkedSwitch) ? $(linkedSwitch.label) ? linkedSwitch.label : linkedSwitch.name : )][(leftLink = (switchUpdatesBlock) ? < : )][(rightLink = (blockUpdatesSwitch) ? > : )][If ((leftLink == ) && (rightLink == )),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing smartblock-notifier.groovy
latestValue, arg not ConstantExpression
DECLARED METHODS
firstPage: [(defaultLabelValue = (smartBlock) ? (smartBlock.label) ? smartBlock.label : smartBlock.name : null)][(destroyedPageName = destroyedPage)][(destroyedComplete = this.pageStateComplete(destroyedPageName))][(destroyedState = (destroyedComplete) ? complete : null)][(destroyedDescription = (destroyedComplete) ? this.messageDescriptionForPage(destroyedPageName) : null)][(redstonePageName = redstonePage)][(redstoneComplete = this.pageStateComplete(redstonePageName))][(redstoneState = (redstoneComplete) ? complete : null)][(redstoneDescription = (redstoneComplete) ? this.messageDescriptionForPage(redstonePageName) : null)][(neighborPageName = neighborBlockPage)][(neighborComplete = this.pageStateComplete(neighborPageName))][(neighborState = (neighborComplete) ? complete : null)][(neighborDescription = (neighborComplete) ? this.messageDescriptionForPage(neighborPageNamePageName) : null)]]
destroyedPage: [(pageName = destroyedPage)]]
redstonePage: [(pageName = redstonePage)]]
neighborBlockPage: [(pageName = neighborBlockPage)]]
messageBuilderPage: [(pageName = params.pageName)][(size = (this.messageBuilderOptions().size() * 2))]]
smartPhoneNotificationSection: ]
chatSection: ]
messageBuilderSection: ]
messageBuilderHref: [(partsAreSet = this.messagePartsSet(pageName))][(messageState = (partsAreSet) ? complete : )][(messageDescription = (partsAreSet) ? this.messageDescriptionForPage(pageName) : this.defaultMessageDescription(pageName))]]
chatClosestPlayerSection: ]
pageStateComplete: [If (pageName == redstonePage),[If redstoneGreaterThan,,],[If redstoneLessThan,,],[If redstoneEqualTo,,],,],[If (pageName == neighborBlockPage),[If neighborBlockParsed,,],,],[If app.$pageNameWantsPush,,],[If app.$pageNameWantsSms,,],[If app.$pageNameWantsHH,,],[If app.$pageNameChatAllUsers,,],[If app.$pageNameChatUsername,,],[If app.$pageNameClosestPlayer,,],]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@748e9b20[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2063c53e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2a9bc08f[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@50f40653[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@50a3d0f6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6e57b5e9[org.codehaus.groovy.ast.expr.VariableExpression@1abc9f14[variable: smartBlock], ConstantExpression[redstoneSignalStrength], org.codehaus.groovy.ast.expr.VariableExpression@6a0ac48e[variable: redstoneSignalStrengthHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@24e08d59[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@77cb9cd1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@971e903[org.codehaus.groovy.ast.expr.VariableExpression@35636217[variable: smartBlock], ConstantExpression[smartBlockNeighborChanged], org.codehaus.groovy.ast.expr.VariableExpression@1549bba7[variable: smartBlockNeighborChangedHandler], org.codehaus.groovy.ast.expr.MapExpression@3e4f80cb[org.codehaus.groovy.ast.expr.MapEntryExpression@38704ff0(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@16ade133[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4e61e4c2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@c6a6c1d[org.codehaus.groovy.ast.expr.VariableExpression@36dfbdaf[variable: smartBlock], ConstantExpression[smartBlockNeighborChanged], org.codehaus.groovy.ast.expr.VariableExpression@4f82663e[variable: smartBlockNeighborChangedHandler], org.codehaus.groovy.ast.expr.MapExpression@e04ccf8[org.codehaus.groovy.ast.expr.MapEntryExpression@51d143a1(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1a28aef1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4647881c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6e0cff20[org.codehaus.groovy.ast.expr.VariableExpression@359b650b[variable: smartBlock], ConstantExpression[blockDestroyed.true], org.codehaus.groovy.ast.expr.VariableExpression@6a9b0a6f[variable: smartBlockDestroyedHandler], org.codehaus.groovy.ast.expr.MapExpression@10667848[org.codehaus.groovy.ast.expr.MapEntryExpression@191a709b(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]]]
smartBlockDestroyedHandler: [(pageName = destroyedPage)][(message = this.message(pageName))]]
smartBlockNeighborChangedHandler: [If neighborBlockParsed?.contains(evt.value),,],]
redstoneSignalStrengthHandler: [(newValue = (int) evt.value)][(lastValue = (int) smartBlock.latestState(redstoneSignalStrength).value)][If redstoneGreaterThan,[(gt = (int) redstoneGreaterThan)][If (newValue > gt),,],,],[If redstoneLessThan,[(lt = (int) redstoneLessThan)][If (newValue < lt),,],,],[If redstoneEqualTo,[(et = (int) redstoneEqualTo)][If (newValue == et),,],,],]
notifyUserOfRedstoneChange: [(msg = this.message(redstonePage))][(notificationMessage = (msg) ? msg : $smartBlock redstone signal is $value)]]
notifyUserOfNeighborChange: [(msg = this.message(neighborPage))][(notificationMessage = (msg) ? msg : $smartBlock was updated by $value)]]
notifyUser: [(closestPlayerMessage = this.message($pageNameClosestPlayer))][log.debug(closestPlayerMessage = $closestPlayerMessage)][(latestClosePlayer = this.getLatestClosePlayer())][log.debug(latestClosePlayer = $latestClosePlayer)][If (closestPlayerMessage && (latestClosePlayer != unknown)),,],[(wantsHH = app.$pageNameWantsHH)][log.debug(wantsHH = $wantsHH)][If wantsHH,,[If location.contactBookEnabled,,[(wantsPush = app.$pageNameWantsPush)][log.debug(wantsPush = $wantsPush)][If (wantsPush && (wantsPush != false)),,],[(wantsSms = app.$pageNameWantsSms)][log.debug(wantsSms = $wantsSms)][If wantsSms,,],],],[(username = app.$pageNameChatUsername)][(allUsers = app.$pageNameChatAllUsers)][log.debug(username = $username)][log.debug(allUsers = $allUsers)][If (username && (username != )),,[If allUsers,,],],]
chatMessageToMC: [(url = $app.getParent().getServerURL()/chat?message=$message.encodeAsURL())][If username,[(url = $url&username=$username.encodeAsURL())],],[this.httpPost(url, foo=bar, { -> ... })]]
messageDescriptionPartsForPage: [(size = (this.messageBuilderOptions().size() * 2))]]
messagePartsSet: ]
defaultMessageDescription: [(description = )][If (((pageName == destroyedPage) || (pageName == redstonePage)) || (pageName == neighborBlockPage)),[(second = this.messageBuilderOptions()[this.messagePartDefaultValue(pageName, 1)])][If second,[(description = ${$second})],],[(third = this.messagePartDefaultValue(pageName, 2))][If third,[(description = $description $third)],],[(fourth = this.messageBuilderOptions()[this.messagePartDefaultValue(pageName, 3)])][If fourth,[(description = $description ${$fourth})],],,],]
messageDescriptionForPage: [(parts = this.messageDescriptionPartsForPage(pageName))][(messageParts = [])][If messageParts,,],]
messagePartDefaultValue: [If (pageName == destroyedPage),[If (part == 1),,],[If (part == 2),,],[If (part == 3),,],,],[If (pageName == neighborBlockPage),[If (part == 1),,],[If (part == 2),,],[If (part == 3),,],,],[If (pageName == redstonePage),[If (part == 1),,],[If (part == 2),,],[If (part == 3),,],,],]
message: [(messageParts = [])][(message = messageParts.join( ).trim())]]
messageBuilderOptions: ]
getMessagePartFromOption: [If (optionKey == name),,],[If (optionKey == closestPlayer),,],[If (optionKey == blockDestroyed),,],]
getLatestClosePlayer: [(now = new java.util.Date())][(minusOne = new java.util.Date([minutes:(now.minutes - 1)]))][(latestStates = smartBlock.statesSince(closestPlayer, minusOne))][If latestStates.size,,],]
settingsAsIds: [(subscribedIds = [])][org.codehaus.groovy.ast.stmt.ReturnStatement@77c7ed8e[expression:org.codehaus.groovy.ast.expr.VariableExpression@453d496b[variable: subscribedIds]]]]
convertBlockSettingToBlockId: [(id = setting.substring(0, setting.indexOf( )))][(name = this.allBlocks()[id])]]
allBlocksParsed: ]
allBlocks: ]
Starting Points: []
IT HAS STATE
--app-start--
processing smartpower-dimming-outlet.groovy
DECLARED METHODS
parse: [(event = zigbee.getEvent(description))][If event,,[If (event.name == power),[(event.value = (event.value / 10))],],],]
setLevel: ]
off: ]
on: ]
refresh: ]
configure: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartpower-dimming-outlet.metadata() is applicable for argument types: (smartpower-dimming-outlet$_run_closure1) values: [smartpower-dimming-outlet$_run_closure1@79d743e6]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartpower-outlet-v1.groovy
DECLARED METHODS
parse: [If description?.startsWith(catchall: 0104 000A),,[(name = (description?.startsWith(on/off: )) ? switch : null)][(value = ((name == switch)) ? (description?.endsWith( 1)) ? on : off : null)][(result = this.createEvent([name:name, value:value]))]],]
on: ]
off: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartpower-outlet-v1.metadata() is applicable for argument types: (smartpower-outlet-v1$_run_closure1) values: [smartpower-outlet-v1$_run_closure1@14379273]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartpower-outlet.groovy
DECLARED METHODS
parse: [(event = zigbee.getEvent(description))][If event,[If (event.name == power),[(value = ((java.lang.Integer -> java.lang.Integer) event.value / 10))][(event = this.createEvent([name:event.name, value:value, descriptionText:{{ device.displayName }} power is {{ value }} Watts, translatable:true]))],[If (event.name == switch),[(descriptionText = ((event.value == on)) ? {{ device.displayName }} is On : {{ device.displayName }} is Off)][(event = this.createEvent([name:event.name, value:event.value, descriptionText:descriptionText, translatable:true]))],],],,[(cluster = zigbee.parse(description))][If ((cluster && (cluster.clusterId == 6)) && (cluster.command == 7)),[If (cluster.data[0] == 0),[(event = this.createEvent([name:checkInterval, value:(60 * 12), displayed:false, data:[protocol:zigbee, hubHardwareId:device.hub.hardwareID]]))],[(event = null)]],,],],]
off: ]
on: ]
ping: ]
refresh: ]
configure: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartpower-outlet.metadata() is applicable for argument types: (smartpower-outlet$_run_closure1) values: [smartpower-outlet$_run_closure1@7e2f86e6]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartsense-garage-door-multi.groovy
DECLARED METHODS
parse: [(results = [:])][If (this.isSupportedDescription(description) || description.startsWith(zone)),,[(results = this.parseMultiSensorMessage(description))]],]
updated: [(threeAxis = device.currentState(threeAxis))][If threeAxis,[(xyz = threeAxis.xyzValue)][(value = ((java.lang.Math.round(xyz.z) > 925)) ? open : closed)],],]
actuate: ]
parseMultiSensorMessage: [(results = [])][If this.isAccelerationMessage(description),[(results = this.parseAccelerationMessage(description))],[If this.isContactMessage(description),[(results = this.parseContactMessage(description))],[If this.isRssiLqiMessage(description),[(results = this.parseRssiLqiMessage(description))],[If this.isOrientationMessage(description),[(results = this.parseOrientationMessage(description))],],],],],]
parseAccelerationMessage: [(results = [])][(parts = description.split(,))]]
parseContactMessage: [(results = [])][(parts = description.split(,))]]
parseOrientationMessage: [(results = [])][(xyzResults = [x:0, y:0, z:0])][(parts = description.split(,))][(xyz = this.getXyzResult(xyzResults, description))][(a = xyz.value.split(,).collect({ -> ... }))][(absValueXY = java.lang.Math.max(java.lang.Math.abs(a[0]), java.lang.Math.abs(a[1])))][(absValueZ = java.lang.Math.abs(a[2]))][If ((absValueZ > 825) && (absValueXY < 175)),,[If ((absValueZ < 75) && (absValueXY > 825)),,],],]
parseRssiLqiMessage: [(results = [])][(parts = description.split(,))]]
getAccelerationResult: [(name = acceleration)][(value = (part.endsWith(1)) ? active : inactive)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]]
getTempResult: [(name = temperature)][(temperatureScale = this.getTemperatureScale())][(value = zigbee.parseSmartThingsTemperatureValue(part, temp: , temperatureScale))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],[(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value$temperatureScale)][(isStateChange = this.isTemperatureStateChange(device, name, value.toString()))]]
getXyzResult: [(name = threeAxis)][(value = $results.x,$results.y,$results.z)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
getRssiResult: [(name = (lastHop) ? lastHopRssi : rssi)][(valueString = part.split(:)[1].trim())][(value = (java.lang.Integer.parseInt(valueString) - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]]
getLqiResult: [(name = (lastHop) ? lastHopLqi : lqi)][(valueString = part.split(:)[1].trim())][(percentageOf = 255)][(value = java.lang.Math.round(((java.lang.Integer.parseInt(valueString) / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was: $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
isAccelerationMessage: [(description ==~ acceleration:.*rssi:.*lqi:.*)]]
isContactMessage: [(description ==~ contactState:.*accelerationState:.*temp:.*battery:.*rssi:.*lqi:.*)]]
isRssiLqiMessage: [(description ==~ lastHopRssi:.*lastHopLqi:.*rssi:.*lqi:.*)]]
isOrientationMessage: [(description ==~ x:.*y:.*z:.*rssi:.*lqi:.*)]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-garage-door-multi.metadata() is applicable for argument types: (smartsense-garage-door-multi$_run_closure1) values: [smartsense-garage-door-multi$_run_closure1@1ad8df52]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartsense-garage-door-sensor-button.groovy
DECLARED METHODS
open: [If (device.currentValue(status) != open),,],]
close: [If (device.currentValue(status) != closed),,],]
parse: [(results = null)][If (this.isSupportedDescription(description) || description.startsWith(zone)),,[(results = this.parseMultiSensorMessage(description))]],]
actuate: ]
parseMultiSensorMessage: [(results = [])][If this.isAccelerationMessage(description),[(results = this.parseAccelerationMessage(description))],[If this.isContactMessage(description),[(results = this.parseContactMessage(description))],[If this.isRssiLqiMessage(description),[(results = this.parseRssiLqiMessage(description))],[If this.isOrientationMessage(description),[(results = this.parseOrientationMessage(description))],],],],],]
parseAccelerationMessage: [(results = [])][(parts = description.split(,))]]
parseContactMessage: [(results = [])][(parts = description.split(,))]]
parseOrientationMessage: [(results = [])][(xyzResults = [x:0, y:0, z:0])][(parts = description.split(,))][(xyz = this.getXyzResult(xyzResults, description))][(a = xyz.value.split(,).collect({ -> ... }))][(absValueXY = java.lang.Math.max(java.lang.Math.abs(a[0]), java.lang.Math.abs(a[1])))][(absValueZ = java.lang.Math.abs(a[2]))][If ((absValueZ > 825) && (absValueXY < 175)),,[If ((absValueZ < 75) && (absValueXY > 825)),,],],]
parseRssiLqiMessage: [(results = [])][(parts = description.split(,))]]
getAccelerationResult: [(name = acceleration)][(value = (part.endsWith(1)) ? active : inactive)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]]
getTempResult: [(name = temperature)][(temperatureScale = this.getTemperatureScale())][(value = zigbee.parseSmartThingsTemperatureValue(part, temp: , temperatureScale))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],[(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value$temperatureScale)][(isStateChange = this.isTemperatureStateChange(device, name, value.toString()))]]
getXyzResult: [(name = threeAxis)][(value = $results.x,$results.y,$results.z)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
getRssiResult: [(name = (lastHop) ? lastHopRssi : rssi)][(valueString = part.split(:)[1].trim())][(value = (java.lang.Integer.parseInt(valueString) - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]]
getLqiResult: [(name = (lastHop) ? lastHopLqi : lqi)][(valueString = part.split(:)[1].trim())][(percentageOf = 255)][(value = java.lang.Math.round(((java.lang.Integer.parseInt(valueString) / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was: $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
isAccelerationMessage: [(description ==~ acceleration:.*rssi:.*lqi:.*)]]
isContactMessage: [(description ==~ contactState:.*accelerationState:.*temp:.*battery:.*rssi:.*lqi:.*)]]
isRssiLqiMessage: [(description ==~ lastHopRssi:.*lastHopLqi:.*rssi:.*lqi:.*)]]
isOrientationMessage: [(description ==~ x:.*y:.*z:.*rssi:.*lqi:.*)]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-garage-door-sensor-button.metadata() is applicable for argument types: (smartsense-garage-door-sensor-button$_run_closure1) values: [smartsense-garage-door-sensor-button$_run_closure1@acf859d]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartsense-motion.groovy
DECLARED METHODS
parse: [(results = [:])][If (description.startsWith(zone) || this.isSupportedDescription(description)),[(results = this.parseBasicMessage(description))],[If this.isMotionStatusMessage(description),[(results = this.parseMotionStatusMessage(description))],],],]
parseBasicMessage: [(name = this.parseName(description))][(results = [:])][If (name != null),[(value = this.parseValue(description))][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(handlerName = value)][(isStateChange = this.isStateChange(device, name, value))][(results = [name:name, value:value, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName, isStateChange:isStateChange, ... ])],],]
parseName: [If this.isSupportedDescription(description),,],]
parseValue: [(zs = zigbee.parseZoneStatus(description))][If zs,,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseDescriptionText: ]
isMotionStatusMessage: [((description ==~ raw:.*dni:.*motion:.*battery:.*powerSource:.*rssi:.*lqi:.*) || (description ==~ raw:.*dni:.*motion:.*powerSource:.*battery:.*rssi:.*lqi:.*))]]
parseMotionStatusMessage: [(results = [])][(parts = description.split(,))]]
getMotionResult: [(name = motion)][(valueString = part.split(:)[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(value = ((valueInt == 0)) ? inactive : active)][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(isStateChange = this.isStateChange(device, name, value))]]
getPowerSourceResult: [(name = powerSource)][(valueString = part.split(:)[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(value = ((valueInt == 0)) ? battery : powered)][(linkText = this.getLinkText(device))][(descriptionText = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (value == battery),[(descriptionText = $linkText is $value powered)],[(descriptionText = $linkText is plugged in)]],[(isStateChange = this.isStateChange(device, name, value))]]
getBatteryResult: [(name = battery)][(valueString = part.split(:)[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][If (valueInt == 0),,],[(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText battery was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
getRssiResult: [(name = rssi)][(parts = part.split(:))][If (parts.size() != 2),,],[(valueString = parts[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(value = (valueInt - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]]
getLqiResult: [(name = lqi)][(parts = part.split(:))][If (parts.size() != 2),,],[(valueString = parts[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(percentageOf = 255)][(value = java.lang.Math.round(((valueInt / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText Signal (LQI) was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-motion.metadata() is applicable for argument types: (smartsense-motion$_run_closure1) values: [smartsense-motion$_run_closure1@327c7bea]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartsense-multi.groovy
DECLARED METHODS
parse: [(results = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (this.isSupportedDescription(description) || description.startsWith(zone)),[(results = this.parseSingleMessage(description))],[If (description == updated),[(results = this.parseOtherMessage(description))],[(results = this.parseMultiSensorMessage(description))]],],]
parseSingleMessage: [(name = this.parseName(description))][(value = this.parseValue(description))][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(handlerName = ((value == open)) ? opened : value)][(isStateChange = this.isStateChange(device, name, value))][(results = [])]]
parseOtherMessage: [(name = null)][(value = description)][(linkText = this.getLinkText(device))][(descriptionText = description)][(handlerName = description)][(isStateChange = this.isStateChange(device, name, value))][(results = [name:name, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName, isStateChange:isStateChange, ... ])]]
parseMultiSensorMessage: [(results = [])][If this.isAccelerationMessage(description),[(results = this.parseAccelerationMessage(description))],[If this.isContactMessage(description),[(results = this.parseContactMessage(description))],[If this.isRssiLqiMessage(description),[(results = this.parseRssiLqiMessage(description))],[If this.isOrientationMessage(description),[(results = this.parseOrientationMessage(description))],],],],],]
parseAccelerationMessage: [(results = [])][(parts = description.split(,))]]
parseContactMessage: [(results = [])][(parts = description.split(,))]]
parseOrientationMessage: [(results = [])][(xyzResults = [x:0, y:0, z:0])][(parts = description.split(,))]]
parseRssiLqiMessage: [(results = [])][(parts = description.split(,))]]
getContactResult: [(name = contact)][(value = (part.endsWith(1)) ? open : closed)][(handlerName = ((value == open)) ? opened : value)][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $handlerName)][(isStateChange = this.isStateChange(device, name, value))][(results = [])]]
getAccelerationResult: [(name = acceleration)][(value = (part.endsWith(1)) ? active : inactive)][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value)][(isStateChange = this.isStateChange(device, name, value))]]
getTempResult: [(name = temperature)][(temperatureScale = this.getTemperatureScale())][(value = zigbee.parseSmartThingsTemperatureValue(part, temp: , temperatureScale))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],[(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value$temperatureScale)][(isStateChange = this.isTemperatureStateChange(device, name, value.toString()))]]
getXyzResult: [(name = threeAxis)][(value = $results.x,$results.y,$results.z)][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value)][(isStateChange = this.isStateChange(device, name, value))]]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText Battery was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
getRssiResult: [(name = (lastHop) ? lastHopRssi : rssi)][(valueString = part.split(:)[1].trim())][(value = (java.lang.Integer.parseInt(valueString) - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value dBm)][If lastHop,[(descriptionText +=  on the last hop)],],[(isStateChange = this.isStateChange(device, name, value))]]
getLqiResult: [(name = (lastHop) ? lastHopLqi : lqi)][(valueString = part.split(:)[1].trim())][(percentageOf = 255)][(value = java.lang.Math.round(((java.lang.Integer.parseInt(valueString) / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText Signal (LQI) was: $value$unit)][If lastHop,[(descriptionText +=  on the last hop)],],[(isStateChange = this.isStateChange(device, name, value))]]
isAccelerationMessage: [(description ==~ acceleration:.*rssi:.*lqi:.*)]]
isContactMessage: [(description ==~ contactState:.*accelerationState:.*temp:.*battery:.*rssi:.*lqi:.*)]]
isRssiLqiMessage: [(description ==~ lastHopRssi:.*lastHopLqi:.*rssi:.*lqi:.*)]]
isOrientationMessage: [(description ==~ x:.*y:.*z:.*rssi:.*lqi:.*)]]
parseName: [If this.isSupportedDescription(description),,],]
parseValue: [If this.isSupportedDescription(description),,],]
parseDescriptionText: [If this.isSupportedDescription(description),,],[(value) ? $linkText was $((value == open)) ? opened : value : ]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-multi.metadata() is applicable for argument types: (smartsense-multi$_run_closure1) values: [smartsense-multi$_run_closure1@4682eba5]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartsense-virtual-open-closed.groovy
DECLARED METHODS
parse: [(results = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (this.isSupportedDescription(description) || description.startsWith(zone)),,[(results = this.parseMultiSensorMessage(description))]],]
parseMultiSensorMessage: [(results = [])][If this.isAccelerationMessage(description),[(results = this.parseAccelerationMessage(description))],[If this.isContactMessage(description),[(results = this.parseContactMessage(description))],[If this.isRssiLqiMessage(description),[(results = this.parseRssiLqiMessage(description))],[If this.isOrientationMessage(description),[(results = this.parseOrientationMessage(description))],],],],],]
parseAccelerationMessage: [(results = [])][(parts = description.split(,))]]
parseContactMessage: [(results = [])][(parts = description.split(,))]]
parseOrientationMessage: [(results = [])][(xyzResults = [x:0, y:0, z:0])][(parts = description.split(,))][(xyz = this.getXyzResult(xyzResults, description))][(a = xyz.value.split(,).collect({ -> ... }))][(absValueXY = java.lang.Math.max(java.lang.Math.abs(a[0]), java.lang.Math.abs(a[1])))][(absValueZ = java.lang.Math.abs(a[2]))][If ((absValueZ > 825) && (absValueXY < 175)),,[If ((absValueZ < 75) && (absValueXY > 825)),,],],]
parseRssiLqiMessage: [(results = [])][(parts = description.split(,))]]
getAccelerationResult: [(name = acceleration)][(value = (part.endsWith(1)) ? active : inactive)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]]
getTempResult: [(name = temperature)][(temperatureScale = this.getTemperatureScale())][(value = zigbee.parseSmartThingsTemperatureValue(part, temp: , temperatureScale))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],[(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value$temperatureScale)][(isStateChange = this.isTemperatureStateChange(device, name, value.toString()))]]
getXyzResult: [(name = threeAxis)][(value = $results.x,$results.y,$results.z)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
getRssiResult: [(name = (lastHop) ? lastHopRssi : rssi)][(valueString = part.split(:)[1].trim())][(value = (java.lang.Integer.parseInt(valueString) - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]]
getLqiResult: [(name = (lastHop) ? lastHopLqi : lqi)][(valueString = part.split(:)[1].trim())][(percentageOf = 255)][(value = java.lang.Math.round(((java.lang.Integer.parseInt(valueString) / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was: $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
isAccelerationMessage: [(description ==~ acceleration:.*rssi:.*lqi:.*)]]
isContactMessage: [(description ==~ contactState:.*accelerationState:.*temp:.*battery:.*rssi:.*lqi:.*)]]
isRssiLqiMessage: [(description ==~ lastHopRssi:.*lastHopLqi:.*rssi:.*lqi:.*)]]
isOrientationMessage: [(description ==~ x:.*y:.*z:.*rssi:.*lqi:.*)]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-virtual-open-closed.metadata() is applicable for argument types: (smartsense-virtual-open-closed$_run_closure1) values: [smartsense-virtual-open-closed$_run_closure1@5e2f3be5]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartweather-station-controller.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@38eb2c50[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@8bffb8b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@21422231[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@10ee04df[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7186333e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[scheduledEvent] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@692fd26[]]]]]
scheduledEvent: [org.codehaus.groovy.ast.stmt.ExpressionStatement@36f1046f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@56d93692[object: org.codehaus.groovy.ast.expr.VariableExpression@1686f0b4[variable: log] method: ConstantExpression[info] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@76c548f[ConstantExpression[SmartWeather Station Controller / scheduledEvent terminated due to deprecation]]]]]]
Starting Points: [log.info(SmartWeather Station Controller / scheduledEvent terminated due to deprecation)]
IT HAS STATE
--app-start--
processing smartweather-station-tile.groovy
DECLARED METHODS
parse: ]
installed: ]
uninstalled: [org.codehaus.groovy.ast.stmt.ExpressionStatement@3157e4c0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6eaa21d8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@328902d5[]]]]]
poll: [(obs = this.get(conditions)?.current_observation)][If obs,[(weatherIcon = obs.icon_url.split(/)[-1].split(\.)[0])][If (this.getTemperatureScale() == C),,],[If (obs.local_tz_offset != device.currentValue(timeZoneOffset)),,],[(cityValue = $obs.display_location.city, $obs.display_location.state)][If (cityValue != device.currentValue(city)),,],[(a = this.get(astronomy)?.moon_phase)][(today = this.localDate(GMT$obs.local_tz_offset))][(ltf = new java.text.SimpleDateFormat(yyyy-MM-dd HH:mm))][(utf = new java.text.SimpleDateFormat(yyyy-MM-dd'T'HH:mm:ss.SSS'Z'))][(sunriseDate = ltf.parse($today $a.sunrise.hour:$a.sunrise.minute))][(sunsetDate = ltf.parse($today $a.sunset.hour:$a.sunset.minute))][(tf = new java.text.SimpleDateFormat(h:mm a))][(localSunrise = $tf.format(sunriseDate))][(localSunset = $tf.format(sunsetDate))][(f = this.get(forecast))][(f1 = f?.forecast?.simpleforecast?.forecastday)][If f1,[(icon = f1[0].icon_url.split(/)[-1].split(\.)[0])][(value = (java.lang.String -> java.lang.String) f1[0].pop)],],[(alerts = this.get(alerts)?.alerts)][(newKeys = (alerts?.collect({ -> ... })) ? alerts?.collect({ -> ... }) : [])][log.debug(WUSTATION: newKeys = $newKeys)][(oldKeys = device.currentState(alertKeys)?.jsonValue)][log.debug(WUSTATION: oldKeys = $oldKeys)][(noneString = no current weather alerts)][If (newKeys && (oldKeys == null)),,[If (newKeys != oldKeys),[If (oldKeys == null),[(oldKeys = [])],],[(newAlerts = false)][If (newAlerts && (device.currentValue(alert) != noneString)),,],,],],,],]
refresh: ]
configure: ]
pad: [(n = ((size - s.size()) / 2))][If (n > 0),[(sb = )][(sb += s)],],]
get: ]
localDate: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))]]
send: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
estimateLux: [(lux = 0)][(now = new java.util.Date().time)][If ((now > sunriseDate.time) && (now < sunsetDate.time)),,[(lux = 10)]],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartweather-station-tile.metadata() is applicable for argument types: (smartweather-station-tile$_run_closure1) values: [smartweather-station-tile$_run_closure1@23202c31]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing sonos-music-modes.groovy
DECLARED METHODS
songOptions: [(options = new java.util.LinkedHashSet())][If state.selectedSong?.station,[(options << state.selectedSong.station)],[If state.selectedSong?.description,[(options << state.selectedSong.description)],],],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))]]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSongs: ]
mainPage: ]
chooseTrack: ]
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@3506d826[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@35dd9ed3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@8ff5094[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@363f0ba0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@35fb22a9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6c8909c3[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1e008f36[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@50acf55d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3cae7b8b[]]]]]
subscribeToEvents: [org.codehaus.groovy.ast.stmt.ExpressionStatement@184dbacc[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2aeefcc[object: org.codehaus.groovy.ast.expr.VariableExpression@359ff4d9[variable: log] method: ConstantExpression[trace] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7a22a3c2[ConstantExpression[subscribeToEvents()]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@f4cfd90[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7ae9a33a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@301aa982[org.codehaus.groovy.ast.expr.VariableExpression@5fc930f0[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@3701e6e4[variable: modeChangeHandler]]]]]]
modeChangeHandler: [If allOk,[If frequency,[(lastTime = state[this.frequencyKey(evt)])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],]
takeAction: [(name = mode_$evt.value.toString())][(selectedSong = state.selectedSongs.$name)][If (selectedSong == PAUSE),,[If (volume != null),,],],[If (frequency || oncePerDay),[(state[this.frequencyKey(evt)] = this.now())],],]
frequencyKey: ]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],]
oncePerDayOk: [(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)]]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
timeIntervalLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing sonos-remote-control.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@11e33bac[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@30501e60[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@289778cd[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@7495699f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7c2312fa[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4cb0a000[org.codehaus.groovy.ast.expr.VariableExpression@5ff2e84b[variable: buttonDevice], ConstantExpression[button], org.codehaus.groovy.ast.expr.VariableExpression@74abbb[variable: buttonEvent]]]]]]
buttonEvent: [(buttonNumber = evt.data)][(value = evt.value)][log.debug(buttonEvent: $evt.name = $evt.value ($evt.data))][(recentEvents = buttonDevice.eventsSince(new java.util.Date((this.now() - 2000))).findAll({ -> ... }))][If (recentEvents.size <= 1),,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
extractButtonNumber: [(buttonNumber = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)]]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
handleButton: ]
togglePlayPause: [(currentStatus = sonos.currentValue(status))][If (currentStatus == playing),,],]
adjustVolume: [(changeAmount = ((volumeOffset) ? volumeOffset : 5 * (doubleAmount) ? 2 : 1))][(currentVolume = sonos.currentValue(level))][If up,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing spark.groovy
DECLARED METHODS
parse: ]
on: ]
off: ]
put: [(apiKey = fb91rfPFS84wmzH3)]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: spark.metadata() is applicable for argument types: (spark$_run_closure1) values: [spark$_run_closure1@21f8e55f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing speaker-control.groovy
DECLARED METHODS
mainPage: ]
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]]
ifUnset: [If settings[name],,],]
ifSet: [If settings[name],,],]
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@2f04105[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@309028af[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@724c5cbe[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@70101687[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@70e889e9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@418c020b[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@51351f28[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@21618fa7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@15f2eda3[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@34cf294c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4d7aaca2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@604b1e1d[]]]]]
subscribeToEvents: [org.codehaus.groovy.ast.stmt.ExpressionStatement@62566842[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2f1ea80d[object: org.codehaus.groovy.ast.expr.VariableExpression@37191ef0[variable: log] method: ConstantExpression[trace] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@f1a45f8[ConstantExpression[subscribeToEvents()]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5edf2821[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4dbad37[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7b4acdc2[org.codehaus.groovy.ast.expr.VariableExpression@26a262d6[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@11bd803[variable: appTouchHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@58f07f02[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@75798d03[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@40f8f5a8[org.codehaus.groovy.ast.expr.VariableExpression@1ffcf674[variable: contact], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@442f92e6[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7d070ef5[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7a55f148[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2e2f720[org.codehaus.groovy.ast.expr.VariableExpression@3ae2ed38[variable: contactClosed], ConstantExpression[contact.closed], org.codehaus.groovy.ast.expr.VariableExpression@7f572c37[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2add4d24[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3f93e4a8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@12b5454f[org.codehaus.groovy.ast.expr.VariableExpression@5445f5ba[variable: acceleration], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@1431267b[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@342726f1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@c808207[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@77134e08[org.codehaus.groovy.ast.expr.VariableExpression@6a0cbc6f[variable: motion], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@67110f71[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6f89292e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@20749d9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@de77232[org.codehaus.groovy.ast.expr.VariableExpression@62628e78[variable: mySwitch], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@44841b43[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7c75db8b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4ab550d5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3cd206b5[org.codehaus.groovy.ast.expr.VariableExpression@58e85c6f[variable: mySwitchOff], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@a137d7a[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6ac0b715[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@468be356[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5c9ac4cc[org.codehaus.groovy.ast.expr.VariableExpression@4df39a88[variable: arrivalPresence], ConstantExpression[presence.present], org.codehaus.groovy.ast.expr.VariableExpression@2264e43c[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3bec2275[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@31da3d60[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@60acd609[org.codehaus.groovy.ast.expr.VariableExpression@65ec8b24[variable: departurePresence], ConstantExpression[presence.not present], org.codehaus.groovy.ast.expr.VariableExpression@3f49e266[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5f18f9d2[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@598260a6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@58b67519[org.codehaus.groovy.ast.expr.VariableExpression@281ce6bb[variable: smoke], ConstantExpression[smoke.detected], org.codehaus.groovy.ast.expr.VariableExpression@30d25c03[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7a1f8def[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@116a2108[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5e8c34a0[org.codehaus.groovy.ast.expr.VariableExpression@7c1c5936[variable: smoke], ConstantExpression[smoke.tested], org.codehaus.groovy.ast.expr.VariableExpression@7aead3af[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3ac8cf9b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@55ec556[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1b15f922[org.codehaus.groovy.ast.expr.VariableExpression@37ce3644[variable: smoke], ConstantExpression[carbonMonoxide.detected], org.codehaus.groovy.ast.expr.VariableExpression@4b869331[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@38018b62[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@ce9b9a9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4ad3d266[org.codehaus.groovy.ast.expr.VariableExpression@3533df16[variable: water], ConstantExpression[water.wet], org.codehaus.groovy.ast.expr.VariableExpression@15d0849[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4038cd3a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@14ac77b9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3f4cd155[org.codehaus.groovy.ast.expr.VariableExpression@563a89b5[variable: button1], ConstantExpression[button.pushed], org.codehaus.groovy.ast.expr.VariableExpression@506dcf55[variable: eventHandler]]]]][If triggerModes,[org.codehaus.groovy.ast.stmt.ExpressionStatement@270b6b5e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7e94d093[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7c6189d5[org.codehaus.groovy.ast.expr.VariableExpression@4248e66b[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@3e6534e7[variable: modeChangeHandler]]]]],],[If timeOfDay,[org.codehaus.groovy.ast.stmt.ExpressionStatement@66ad7bf0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@167279d1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@138caeca[org.codehaus.groovy.ast.expr.VariableExpression@4d96250[variable: timeOfDay], org.codehaus.groovy.ast.expr.VariableExpression@9a6fbc0[variable: scheduledTimeHandler]]]]],],]
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],]
modeChangeHandler: [If (evt.value in triggerModes),,],]
scheduledTimeHandler: ]
appTouchHandler: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
takeAction: [(options = [:])][If volume,[(options.delay = 1000)],],]
frequencyKey: ]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],]
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
timeIntervalLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing speaker-mood-music.groovy
DECLARED METHODS
songOptions: [(options = new java.util.LinkedHashSet())][If state.selectedSong?.station,[(options << state.selectedSong.station)],[If state.selectedSong?.description,[(options << state.selectedSong.description)],],],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))]]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSong: ]
mainPage: ]
chooseTrack: ]
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes, timeOfDay],[If settings[name],,],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes, timeOfDay],[If settings[name],,],]]
ifUnset: [If settings[name],,],]
ifSet: [If settings[name],,],]
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@778db7c5[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@681e144[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2875b016[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@72ee5d84[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@68c7ef83[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6145b81e[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@64355120[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@64b7225f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@33db72bd[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7f92b990[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@31e04b13[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6c1832aa[]]]]]
subscribeToEvents: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4beeb0e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6e8a9c30[object: org.codehaus.groovy.ast.expr.VariableExpression@5d01ea21[variable: log] method: ConstantExpression[trace] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@70211e49[ConstantExpression[subscribeToEvents()]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3b46dd8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@39651a82[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6be7bf6d[org.codehaus.groovy.ast.expr.VariableExpression@134c370e[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@33364212[variable: appTouchHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2216effc[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@745c2004[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6da9dc6[org.codehaus.groovy.ast.expr.VariableExpression@7fd69dd[variable: contact], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@12010fd1[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7c84195[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@552ed807[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3971f0fe[org.codehaus.groovy.ast.expr.VariableExpression@23940f86[variable: contactClosed], ConstantExpression[contact.closed], org.codehaus.groovy.ast.expr.VariableExpression@66153688[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@455824ad[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7318daf8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@70f31322[org.codehaus.groovy.ast.expr.VariableExpression@3f1ddac2[variable: acceleration], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@3be4fcc0[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@e1e2e5e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@661c46bc[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@37864b77[org.codehaus.groovy.ast.expr.VariableExpression@2b98b3bb[variable: motion], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@540b0448[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@50a691d3[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@557eb543[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3b95d13c[org.codehaus.groovy.ast.expr.VariableExpression@3730ab42[variable: mySwitch], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@537c8c7e[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7308ffff[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6601cc93[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@54d901aa[org.codehaus.groovy.ast.expr.VariableExpression@63716833[variable: mySwitchOff], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@573284a5[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3fbfbf84[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@23f72d88[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4bafe935[org.codehaus.groovy.ast.expr.VariableExpression@87b5b49[variable: arrivalPresence], ConstantExpression[presence.present], org.codehaus.groovy.ast.expr.VariableExpression@4a7a965d[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@507b79f7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@64a9d48c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@365a6a43[org.codehaus.groovy.ast.expr.VariableExpression@288cdaab[variable: departurePresence], ConstantExpression[presence.not present], org.codehaus.groovy.ast.expr.VariableExpression@23b3aa8c[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@99407c2[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6c796cc1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@226eba67[org.codehaus.groovy.ast.expr.VariableExpression@1cb7936c[variable: smoke], ConstantExpression[smoke.detected], org.codehaus.groovy.ast.expr.VariableExpression@35342d2f[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@128c502c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@45667d98[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@65eabaab[org.codehaus.groovy.ast.expr.VariableExpression@7123be6c[variable: smoke], ConstantExpression[smoke.tested], org.codehaus.groovy.ast.expr.VariableExpression@1de9d54[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@77a2aa4a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@47ad69f7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2b917fb0[org.codehaus.groovy.ast.expr.VariableExpression@5e5073ab[variable: smoke], ConstantExpression[carbonMonoxide.detected], org.codehaus.groovy.ast.expr.VariableExpression@3c4262d1[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@100c567f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@30c0d731[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6d5037a9[org.codehaus.groovy.ast.expr.VariableExpression@422b8438[variable: water], ConstantExpression[water.wet], org.codehaus.groovy.ast.expr.VariableExpression@30669dac[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@629adce[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6a282fdd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@743c6ce4[org.codehaus.groovy.ast.expr.VariableExpression@70331432[variable: button1], ConstantExpression[button.pushed], org.codehaus.groovy.ast.expr.VariableExpression@3bbf9027[variable: eventHandler]]]]][If triggerModes,[org.codehaus.groovy.ast.stmt.ExpressionStatement@10c2064a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@70e13fa[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6ff415ad[org.codehaus.groovy.ast.expr.VariableExpression@280d9edc[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@28fd3dc1[variable: modeChangeHandler]]]]],],[If timeOfDay,[org.codehaus.groovy.ast.stmt.ExpressionStatement@5f9b6ae7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@108d55c4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5432c277[org.codehaus.groovy.ast.expr.VariableExpression@15e0fe05[variable: timeOfDay], org.codehaus.groovy.ast.expr.VariableExpression@1128620c[variable: scheduledTimeHandler]]]]],],]
eventHandler: [If allOk,[If frequency,[(lastTime = state[this.frequencyKey(evt)])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],]
modeChangeHandler: [If (evt.value in triggerModes),,],]
scheduledTimeHandler: ]
appTouchHandler: ]
takeAction: [log.info(Playing '$state.selectedSong)][If (volume != null),,],[sonos.playTrack(state.selectedSong)][If (frequency || oncePerDay),[(state[this.frequencyKey(evt)] = this.now())],],]
frequencyKey: ]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],]
oncePerDayOk: [(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)]]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
timeIntervalLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing speaker-notify-with-sound.groovy
DECLARED METHODS
mainPage: ]
chooseTrack: ]
songOptions: [(options = new java.util.LinkedHashSet())][If state.selectedSong?.station,[(options << state.selectedSong.station)],[If state.selectedSong?.description,[(options << state.selectedSong.description)],],],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))]]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSong: ]
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes, timeOfDay],[If settings[name],,],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes, timeOfDay],[If settings[name],,],]]
ifUnset: [If settings[name],,],]
ifSet: [If settings[name],,],]
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@7275c74b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@19058533[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4315e9af[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@42210be1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1eb2d371[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2babf189[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@479f2dc2[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@dab48d3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@58a2b4c[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7159a5cd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4f966719[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@18ac53e8[]]]]]
subscribeToEvents: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4ca8dbfa[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7063686f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@c3177d5[org.codehaus.groovy.ast.expr.VariableExpression@76f856a8[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@7c853486[variable: appTouchHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@174e1b69[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1046498a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@243f003c[org.codehaus.groovy.ast.expr.VariableExpression@71cb3139[variable: contact], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@1639f93a[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3491e86e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@68f32020[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@409986fe[org.codehaus.groovy.ast.expr.VariableExpression@19b047fe[variable: contactClosed], ConstantExpression[contact.closed], org.codehaus.groovy.ast.expr.VariableExpression@22590e3e[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@53dad875[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5f780a86[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@446c3920[org.codehaus.groovy.ast.expr.VariableExpression@2eaef76d[variable: acceleration], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@2b329bbd[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@34819867[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@118102ee[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@48cd9a2c[org.codehaus.groovy.ast.expr.VariableExpression@771d1ffb[variable: motion], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@4f67e3df[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@56681eaf[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@72d0f2b4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6d2dc9d2[org.codehaus.groovy.ast.expr.VariableExpression@1da4b6b3[variable: mySwitch], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@b2f4ece[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7e1f584d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7dff6d05[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@45d64d27[org.codehaus.groovy.ast.expr.VariableExpression@34fe326d[variable: mySwitchOff], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@30a7c98f[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@36361ddb[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@41fed14f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4d6ee47[org.codehaus.groovy.ast.expr.VariableExpression@a33b4e3[variable: arrivalPresence], ConstantExpression[presence.present], org.codehaus.groovy.ast.expr.VariableExpression@c6da8bb[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3bae64d0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@8b91134[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1fba386c[org.codehaus.groovy.ast.expr.VariableExpression@7e736350[variable: departurePresence], ConstantExpression[presence.not present], org.codehaus.groovy.ast.expr.VariableExpression@36b310aa[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@76c387f9[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3874b815[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5d7835a8[org.codehaus.groovy.ast.expr.VariableExpression@736048ed[variable: smoke], ConstantExpression[smoke.detected], org.codehaus.groovy.ast.expr.VariableExpression@1976f537[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@45f421c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1816e24a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6940f685[org.codehaus.groovy.ast.expr.VariableExpression@47b179d7[variable: smoke], ConstantExpression[smoke.tested], org.codehaus.groovy.ast.expr.VariableExpression@39008c9f[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@162b3d47[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@783115d9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3402b4c9[org.codehaus.groovy.ast.expr.VariableExpression@95bb2a2[variable: smoke], ConstantExpression[carbonMonoxide.detected], org.codehaus.groovy.ast.expr.VariableExpression@46d567cb[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@363a3d15[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@173f73e7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@43a51d00[org.codehaus.groovy.ast.expr.VariableExpression@2e23c180[variable: water], ConstantExpression[water.wet], org.codehaus.groovy.ast.expr.VariableExpression@499683c4[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@25da615a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4efc25fc[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7ee3d262[org.codehaus.groovy.ast.expr.VariableExpression@396e6d9[variable: button1], ConstantExpression[button.pushed], org.codehaus.groovy.ast.expr.VariableExpression@75308740[variable: eventHandler]]]]][If triggerModes,[org.codehaus.groovy.ast.stmt.ExpressionStatement@5acc9fdf[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3a5c2626[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@e48bf9a[org.codehaus.groovy.ast.expr.VariableExpression@7fb33394[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@41bf79da[variable: modeChangeHandler]]]]],],[If timeOfDay,[org.codehaus.groovy.ast.stmt.ExpressionStatement@1a891add[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5176d279[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@373f7450[org.codehaus.groovy.ast.expr.VariableExpression@d74bac4[variable: timeOfDay], org.codehaus.groovy.ast.expr.VariableExpression@5ff90645[variable: scheduledTimeHandler]]]]],],[If song,,],]
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],]
modeChangeHandler: [If (evt.value in triggerModes),,],]
scheduledTimeHandler: ]
appTouchHandler: ]
takeAction: [If song,[sonos.playSoundAndTrack(state.sound.uri, state.sound.duration, state.selectedSong, volume)],[If resumePlaying,[sonos.playTrackAndResume(state.sound.uri, state.sound.duration, volume)],[sonos.playTrackAndRestore(state.sound.uri, state.sound.duration, volume)]],],[If (frequency || oncePerDay),[(state[this.frequencyKey(evt)] = this.now())],],]
frequencyKey: ]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],]
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
getTimeLabel: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
loadText: ]
Starting Points: []
IT HAS STATE
--app-start--
processing speaker-weather-forecast.groovy
DECLARED METHODS
mainPage: ]
chooseTrack: ]
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes],[If settings[name],,],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes],[If settings[name],,],]]
ifUnset: [If settings[name],,],]
ifSet: [If settings[name],,],]
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@11ebb1b6[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@aaee2a2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@f3021cb[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4aaae508[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6009bea[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7bc6d27a[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@75769ab0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6869a3b3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6ab4ba9f[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@27ace0b1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@664e5dee[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@431f1eaf[]]]]]
subscribeToEvents: [org.codehaus.groovy.ast.stmt.ExpressionStatement@cb03411[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4c59e45e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@58ec7116[org.codehaus.groovy.ast.expr.VariableExpression@63bde6c2[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@6ea04618[variable: appTouchHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6dd82486[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@56078cea[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5a00eb1e[org.codehaus.groovy.ast.expr.VariableExpression@36fcf6c0[variable: contact], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@1aac188d[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7026b7ee[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2d23faef[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7cb8437d[org.codehaus.groovy.ast.expr.VariableExpression@62a4417[variable: contactClosed], ConstantExpression[contact.closed], org.codehaus.groovy.ast.expr.VariableExpression@43f61afb[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@713064e8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4fad6218[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1bf39d06[org.codehaus.groovy.ast.expr.VariableExpression@68217d41[variable: acceleration], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@1ac45389[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3e5d4f6b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@39c1fe0b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5ae95707[org.codehaus.groovy.ast.expr.VariableExpression@62891fc8[variable: motion], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@367b22e5[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@fca387[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@10bd9df0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3ae0b770[org.codehaus.groovy.ast.expr.VariableExpression@55e3d6c3[variable: mySwitch], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@30e6a763[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4c48fe92[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@732c9b5c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@38320e34[org.codehaus.groovy.ast.expr.VariableExpression@3d6a6bee[variable: mySwitchOff], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@36ddaebf[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@213c3543[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@9d7ccfe[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@670ce331[org.codehaus.groovy.ast.expr.VariableExpression@3cff0139[variable: arrivalPresence], ConstantExpression[presence.present], org.codehaus.groovy.ast.expr.VariableExpression@7c29adc8[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4b2e3e8f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4bbb49b0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@f096f37[org.codehaus.groovy.ast.expr.VariableExpression@3effd4f3[variable: departurePresence], ConstantExpression[presence.not present], org.codehaus.groovy.ast.expr.VariableExpression@41f4fe5[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@15f8701f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@514cd540[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@11d4dbd6[org.codehaus.groovy.ast.expr.VariableExpression@6f4ade6e[variable: smoke], ConstantExpression[smoke.detected], org.codehaus.groovy.ast.expr.VariableExpression@39e43310[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@eb507b9[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@390877d2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@86733[org.codehaus.groovy.ast.expr.VariableExpression@186cb891[variable: smoke], ConstantExpression[smoke.tested], org.codehaus.groovy.ast.expr.VariableExpression@3ec2ecea[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@440eaa07[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7fc7c4a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7aa9e414[org.codehaus.groovy.ast.expr.VariableExpression@53a5e217[variable: smoke], ConstantExpression[carbonMonoxide.detected], org.codehaus.groovy.ast.expr.VariableExpression@624a24f6[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6b00ad9[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@338cc75f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4f453e63[org.codehaus.groovy.ast.expr.VariableExpression@7c9bdee9[variable: water], ConstantExpression[water.wet], org.codehaus.groovy.ast.expr.VariableExpression@7afbf561[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@2f98635e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@49c8f6e8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6b0615ae[org.codehaus.groovy.ast.expr.VariableExpression@4e73b552[variable: button1], ConstantExpression[button.pushed], org.codehaus.groovy.ast.expr.VariableExpression@221dad51[variable: eventHandler]]]]][If triggerModes,[org.codehaus.groovy.ast.stmt.ExpressionStatement@2cec704c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@771cbb1a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2416498e[org.codehaus.groovy.ast.expr.VariableExpression@6b2e0f78[variable: location], org.codehaus.groovy.ast.expr.VariableExpression@240f6c41[variable: modeChangeHandler]]]]],],[If timeOfDay,[org.codehaus.groovy.ast.stmt.ExpressionStatement@3659d7b1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2015b2cd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3bdb2c78[org.codehaus.groovy.ast.expr.VariableExpression@64693226[variable: timeOfDay], org.codehaus.groovy.ast.expr.VariableExpression@1c758545[variable: scheduledTimeHandler]]]]],],[If song,,],]
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],]
modeChangeHandler: [If (evt.value in triggerModes),,],]
scheduledTimeHandler: ]
appTouchHandler: ]
takeAction: [If song,[sonos.playSoundAndTrack(state.sound.uri, state.sound.duration, state.selectedSong, volume)],[If resumePlaying,[sonos.playTrackAndResume(state.sound.uri, state.sound.duration, volume)],[If volume,[sonos.playTrackAtVolume(state.sound.uri, volume)],[sonos.playTrack(state.sound.uri)]],],],[If (frequency || oncePerDay),[(state[this.frequencyKey(evt)] = this.now())],],]
songOptions: [(options = new java.util.LinkedHashSet())][If state.selectedSong?.station,[(options << state.selectedSong.station)],[If state.selectedSong?.description,[(options << state.selectedSong.description)],],],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))]]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSong: ]
frequencyKey: ]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],]
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
getTimeLabel: ]
loadText: [If (location.timeZone || zipCode),[(weather = this.getWeatherFeature(forecast, zipCode))][(current = this.getWeatherFeature(conditions, zipCode))][(isMetric = (location.temperatureScale == C))][(delim = )][(sb = new java.lang.StringBuilder())][(msg = sb.toString())][(msg = msg.replaceAll(([0-9]+)C, $1 degrees))][log.debug(msg = $msg)][(state.sound = this.textToSpeech(msg, true))],[(state.sound = this.textToSpeech(Please set the location of your hub with the SmartThings mobile app, or enter a zip code to receive weather forecasts.))]],]
list: ]
list: ]
Starting Points: []
IT HAS STATE
--app-start--
processing sprayer-controller-2.groovy
DECLARED METHODS
installed: [(startHour = startHour1)][(stopHour = stopHour1)][(startTime = minutes)][If (minutes == 1),[(startTime = ((((0 0  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 2),[(startTime = ((((0 0,30  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 3),[(startTime = ((((0 0,20,40  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 4),[(startTime = ((((0 0,15,30,45  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 5),[(startTime = ((((0 0,12,24,36,48  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 6),[(startTime = ((((0 0,10,20,30,40,50  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 12),[(startTime = ((((0 0,5,10,15,20,25,30,35,40,45,50,55  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 20),[(startTime = ((((0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 30),[(startTime = ((((0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58  + startHour) + -) + stopHour) +  * * ?))],[(startTime = ((((0 0  + startHour) + -) + stopHour) +  * * ?))]],],],],],],],],],[org.codehaus.groovy.ast.stmt.ExpressionStatement@213bd3d5[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@470a659f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@451882b2[org.codehaus.groovy.ast.expr.VariableExpression@4a23350[variable: startTime], org.codehaus.groovy.ast.expr.VariableExpression@7b78ed6a[variable: openValve]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6fca5907[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6ec65b5e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7bebcd65[org.codehaus.groovy.ast.expr.VariableExpression@47447ccf[variable: valves1], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@7afb1741[variable: valveOnHandler], org.codehaus.groovy.ast.expr.MapExpression@263bbfeb[org.codehaus.groovy.ast.expr.MapEntryExpression@31edeac(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@67d86804[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@45bb2aa1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3e84111a[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4b1a43d8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6fa69af7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@73545b80[]]]][(startHour = startHour1)][(stopHour = stopHour1)][(startTime = minutes)][If (minutes == 1),[(startTime = ((((0 0  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 2),[(startTime = ((((0 0,30  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 3),[(startTime = ((((0 0,20,40  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 4),[(startTime = ((((0 0,15,30,45  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 5),[(startTime = ((((0 0,12,24,36,48  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 6),[(startTime = ((((0 0,10,20,30,40,50  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 12),[(startTime = ((((0 0,5,10,15,20,25,30,35,40,45,50,55  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 20),[(startTime = ((((0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 30),[(startTime = ((((0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58  + startHour) + -) + stopHour) +  * * ?))],[(startTime = ((((0 0  + startHour) + -) + stopHour) +  * * ?))]],],],],],],],],],[org.codehaus.groovy.ast.stmt.ExpressionStatement@6d469831[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@74db12c2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2ff15f8c[org.codehaus.groovy.ast.expr.VariableExpression@7ea899a9[variable: startTime], org.codehaus.groovy.ast.expr.VariableExpression@2776015d[variable: openValve]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@b174a73[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2e3f79a2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1460c81d[org.codehaus.groovy.ast.expr.VariableExpression@38b5f25[variable: valves1], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@327ed9f5[variable: valveOnHandler], org.codehaus.groovy.ast.expr.MapExpression@67594471[org.codehaus.groovy.ast.expr.MapEntryExpression@756b58a7(key: ConstantExpression[filterEvents], value: ConstantExpression[false])]]]]]]
openValve: ]
closeValve: ]
valveOnHandler: [(delay = duration)][org.codehaus.groovy.ast.stmt.ExpressionStatement@2cc04358[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@68b58644[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@45e22def[org.codehaus.groovy.ast.expr.VariableExpression@6ae3fb94[variable: delay], org.codehaus.groovy.ast.expr.VariableExpression@4417af13[variable: closeValve]]]]]]
setStartTime: [If (minutes == 1),[(startTime = 0 0 $startHour * * ?)],[If (minutes == 2),[(startTime = 0 0,30 $startHour * * ?)],[If (minutes == 3),[(startTime = 0 0,20,40 $startHour * * ?)],[If (minutes == 4),[(startTime = 0 0,15,30,45 $startHour * * ?)],[If (minutes == 5),[(startTime = 0 0,12,24,36,48 $startHour * * ?)],[If (minutes == 6),[(startTime = 0 0,10,20,30,40,50 $startHour * * ?)],[If (minutes == 12),[(startTime = 0 0,5,10,15,20,25,30,35,40,45,50,55 $startHour * * ?)],[If (minutes == 20),[(startTime = 0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57 $startHour * * ?)],[If (minutes == 30),[(startTime = 0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58 $startHour * * ?)],[(startTime = 0 0 $startHour * * ?)]],],],],],],],],],]
Starting Points: []
IT HAS STATE
--app-start--
processing spruce-scheduler.groovy
subscribe: not a ConstantExpression!
subscribe: first arg not a VariableExpression
subscribe: not a ConstantExpression!
subscribe: first arg not a VariableExpression
subscribe: not a ConstantExpression!
subscribe: first arg not a VariableExpression
subscribe: not a ConstantExpression!
subscribe: first arg not a VariableExpression
DECLARED METHODS
startPage: ]
globalPage: ]
weatherPage: ]
zipcodePage: ]
getPWSID: [(PWSID = location.zipCode)][If zipcode,[(PWSID = zipcode)],],[If (nearestPWS && zipcode),[(geoLocation = location.zipCode)][If (location.latitude && location.longitude),[(geoLocation = $location.latitude%2C$location.longitude)],],[(wdata = this.getWeatherFeature(geolookup, geoLocation))][If ((wdata && wdata.response) && wdata.response.containsKey(error)),[If ((wdata.response.features.containsKey(geolookup) && (wdata.response.features.geolookup.toInteger() == 1)) && wdata.location),[(PWSID = wdata.location.nearby_weather_stations.pws.station[0].id)],],,],,],]
startTimeString: [If startTime,,],]
enableString: [If (enable && enableManual),,[If enable,,[If enableManual,,],],],]
waterStoppersString: [(stoppers = Contact Sensor)][If settings.contacts,[If (settings.contacts.size() != 1),[(stoppers += s)],],[(stoppers += : )][(i = 1)][(stoppers = $stoppers
Pause: When $settings.contactStop
)],[(stoppers += : None
)]],[(stoppers += Switch)][If settings.toggles,[If (settings.toggles.size() != 1),[(stoppers += es)],],[(stoppers += : )][(i = 1)][(stoppers = $stoppers
Pause: When switched $settings.toggleStop
)],[(stoppers += : None
)]],[(cd = 10)][If (settings.contactDelay && (settings.contactDelay > 10)),[(cd = settings.contactDelay.toInteger())],],[(stoppers += Restart Delay: $cd secs)]]
isRainString: [If (settings.isRain && settings.rainDelay),,],[If settings.isRain,,],]
seasonalAdjString: [If settings.isSeason,,],]
syncString: [If settings.sync,,],]
notifyString: [(notifyStr = )][If settings.notify,[If settings.notify.contains(Daily),[(notifyStr +=  Daily)],],[If settings.notify.contains(Delays),[(notifyStr +=  Delays)],],[If settings.notify.contains(Warnings),[(notifyStr +=  Warnings)],],[If settings.notify.contains(Weather),[(notifyStr +=  Weather)],],[If settings.notify.contains(Moisture),[(notifyStr +=  Moisture)],],[If settings.notify.contains(Events),[(notifyStr +=  Events)],],,],[If (notifyStr == ),[(notifyStr =  None)],],[If settings.logAll,[(notifyStr += 
Sending all Notifications to Hello Home log)],],]
daysString: [(daysString = )][If days,[If (days.contains(Even) || days.contains(Odd)),[If days.contains(Even),[(daysString +=  Even)],],[If days.contains(Odd),[(daysString +=  Odd)],],,[If days.contains(Monday),[(daysString +=  M)],],[If days.contains(Tuesday),[(daysString +=  Tu)],],[If days.contains(Wednesday),[(daysString +=  W)],],[If days.contains(Thursday),[(daysString +=  Th)],],[If days.contains(Friday),[(daysString +=  F)],],[If days.contains(Saturday),[(daysString +=  Sa)],],[If days.contains(Sunday),[(daysString +=  Su)],],],,],[If (daysString == ),,],]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
pumpDelayString: [If pumpDelay,,],]
delayPage: ]
zonePage: ]
zoneActive: [If ((zoneNumberEnum && zoneNumber) && (zoneNumber >= z.toInteger())),,[If ((zoneNumberEnum && zoneNumber) && (zoneNumber != z.toInteger())),,[If (zoneNumberEnum && zoneNumberEnum.contains(z)),,],],],]
zoneString: [(numberString = Add zones to setup)][If zoneNumber,[(numberString = Zones enabled: $zoneNumber)],],[If learn,[(numberString = $numberString
Sensor mode: Adaptive)],[(numberString = $numberString
Sensor mode: Delay)]],]
zoneSettingsPage: ]
zoneSetPage: [this.dynamicPage([name:zoneSetPage, title:Zone $state.app Setup], { -> ... })]]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
setString: ]
plantSetPage: [this.dynamicPage([name:plantSetPage, title:$settings[name$state.app] Landscape Select], { -> ... })]]
sprinklerSetPage: [this.dynamicPage([name:sprinklerSetPage, title:$settings[name$state.app] Sprinkler Select], { -> ... })]]
optionSetPage: [this.dynamicPage([name:optionSetPage, title:$settings[name$state.app] Options], { -> ... })]]
setPage: [If i,[(state.app = i)],],[return state.app]]
getaZoneSummary: [If (settings.zone$zone || (settings.zone$zone == Off)),,],[(daysString = )][(tpw = this.initTPW(zone))][(dpw = this.initDPW(zone))][(runTime = this.calcRunTime(tpw, dpw))][If (learn && settings.sensor$zone),[(daysString = if Moisture is low on: )][(dpw = this.daysAvailable())],],[If (days && (days.contains(Even) || days.contains(Odd))),[If (dpw == 1),[(daysString = Every 8 days)],],[If (dpw == 2),[(daysString = Every 4 days)],],[If (dpw == 4),[(daysString = Every 2 days)],],[If (days.contains(Even) && days.contains(Odd)),[(daysString = any day)],],,[(dpwMap = [0, 0, 0, 0, 0, 0, 0])][(dpwMap = this.getDPWDays(dpw))][(daysString += this.getRunDays(dpwMap))]],]
getZoneSummary: [(summary = )][If learn,[(summary = Moisture Learning enabled)],[(summary = Moisture Learning disabled)]],[(zone = 1)][While (zone <= 16),[If (this.nozzle(zone) == 4),[(summary = $summary
$zone: $settings.zone$zone)],[If ((this.initDPW(zone) != 0) && this.zoneActive(zone.toString())),[(summary = $summary
$this.getaZoneSummary(zone))],],],]getZoneSummary: [(summary = )][If learn,[(summary = Moisture Learning enabled)],[(summary = Moisture Learning disabled)]],[(zone = 1)][While (zone <= 16),[If (this.nozzle(zone) == 4),[(summary = $summary
$zone: $settings.zone$zone)],[If ((this.initDPW(zone) != 0) && this.zoneActive(zone.toString())),[(summary = $summary
$this.getaZoneSummary(zone))],],],][If summary,,],]
display: [(displayString = )][(tpw = this.initTPW(i.toInteger()))][(dpw = this.initDPW(i.toInteger()))][(runTime = this.calcRunTime(tpw, dpw))][If settings.zone$i,[(displayString += (settings.zone$i +  : ))],],[If settings.plant$i,[(displayString += (settings.plant$i +  : ))],],[If settings.option$i,[(displayString += (settings.option$i +  : ))],],[(j = i.toInteger())][If settings.sensor$i,[(displayString += settings.sensor$i)][(displayString += =$this.getDrySp(j)% : )],],[If ((runTime != 0) && (dpw != 0)),[(displayString = $displayString$runTime minutes, $dpw days per week)],],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
getimage: [(imageStr = image)][If image.isNumber(),[(zoneStr = settings.zone$image)][If zoneStr,[If (zoneStr == Off),,],[If (zoneStr == Master Valve),,],[If (zoneStr == Pump),,],[If settings.plant$image,[(imageStr = settings.plant$image)],],,],,],]
getname: [If settings.name$i,,],]
zipString: [If settings.zipcode,,],[If settings.zipcode.isNumber(),,],]
installed: [(state.dpwMap = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])][(state.tpwMap = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])][(state.Rain = [0, 0, 0, 0, 0, 0, 0])][(state.daycount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])][(atomicState.run = false)][(state.pauseTime = null)][(atomicState.startTime = null)][(atomicState.finishTime = null)][org.codehaus.groovy.ast.stmt.ExpressionStatement@23382f76[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7c551ad4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[installSchedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7d5508e0[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@554cd74a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@37ed010a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[installSchedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@633a2e99[]]]]]
installSchedule: [If state.seasonAdj,[(state.seasonAdj = 100.0)],],[If state.weekseasonAdj,[(state.weekseasonAdj = 0)],],[If (state.daysAvailable != 0),[(state.daysAvailable = 0)],],[(state.daysAvailable = this.daysAvailable())][If atomicState.run,,[org.codehaus.groovy.ast.stmt.ExpressionStatement@367d2816[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5b84f14[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5a82ebf8[]]]]],[org.codehaus.groovy.ast.stmt.ExpressionStatement@68fe48d7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@379ce046[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@701bc94e[org.codehaus.groovy.ast.expr.VariableExpression@3d8b319e[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@27a97e08[variable: appTouch]]]]][(rand = new java.util.Random())][(randomOffset = 0)][(randomSeconds = rand.nextInt(59))][If (settings.isRain || settings.isSeason),[org.codehaus.groovy.ast.stmt.ExpressionStatement@77e7246b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5918c260[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3d7b1f1c[org.codehaus.groovy.ast.expr.GStringExpression@51ce6f85[strings: [ConstantExpression[], ConstantExpression[ 57 23 1/1 * ? *]] values: [org.codehaus.groovy.ast.expr.VariableExpression@1f44ddab[variable: randomSeconds type: java.lang.Integer]]], org.codehaus.groovy.ast.expr.VariableExpression@5017e1[variable: getRainToday]]]]],],[If ((settings.switches && settings.startTime) && settings.enable),[(randomOffset = (rand.nextInt(60000) + 20000))][(checktime = (this.timeToday(settings.startTime, location.timeZone).getTime() + randomOffset))][org.codehaus.groovy.ast.stmt.ExpressionStatement@65b66b08[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4726927c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7eb6b6b6[org.codehaus.groovy.ast.expr.VariableExpression@7ed9499e[variable: checktime], org.codehaus.groovy.ast.expr.VariableExpression@28e19366[variable: preCheck]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5b275174[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@10ef5fa0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[note] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@244e619a[ConstantExpression[schedule], org.codehaus.groovy.ast.expr.GStringExpression@10acd6[strings: [ConstantExpression[], ConstantExpression[: Starts at ], ConstantExpression[]] values: [org.codehaus.groovy.ast.expr.PropertyExpression@61dde151[object: org.codehaus.groovy.ast.expr.VariableExpression@b25b095[variable: app] property: ConstantExpression[label]], org.codehaus.groovy.ast.expr.MethodCallExpression@5cb042da[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[startTimeString] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@59c33386[]]]], ConstantExpression[i]]]]],[org.codehaus.groovy.ast.stmt.ExpressionStatement@571a9686[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@719d35e8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2f651f93[org.codehaus.groovy.ast.expr.VariableExpression@6ffa56fa[variable: preCheck]]]]]],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
attemptRecovery: [If atomicState.run,,[(csw = settings.switches.currentSwitch)][(cst = settings.switches.currentStatus)]],]
resetEverything: [If atomicState.run,[(atomicState.run = false)],],[org.codehaus.groovy.ast.stmt.ExpressionStatement@6c575325[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@747d1932[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@736309a9[org.codehaus.groovy.ast.expr.VariableExpression@4e93dcb9[variable: cycleOn]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@188b6035[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4a34e9f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6f6621e3[org.codehaus.groovy.ast.expr.VariableExpression@3fc05ea2[variable: checkRunMap]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7c891ba7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6240651f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3cf7298d[org.codehaus.groovy.ast.expr.VariableExpression@1ff55ff[variable: writeCycles]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@351f2244[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5496c165[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@51a8313b[org.codehaus.groovy.ast.expr.VariableExpression@2a03d65c[variable: subOff]]]]][If settings.enableManual,[org.codehaus.groovy.ast.stmt.ExpressionStatement@6642dc5a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@43da41e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@148c7c4b[org.codehaus.groovy.ast.expr.PropertyExpression@2009f9b0[object: org.codehaus.groovy.ast.expr.VariableExpression@50d951e7[variable: settings] property: ConstantExpression[switches]], ConstantExpression[switch.programOn], org.codehaus.groovy.ast.expr.VariableExpression@39ad12b6[variable: manualStart]]]]],],]
unsubAllBut: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4eb45fec[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@211febf3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3bd3d05e[org.codehaus.groovy.ast.expr.PropertyExpression@6aba5d30[object: org.codehaus.groovy.ast.expr.VariableExpression@61d34b4[variable: settings] property: ConstantExpression[switches]]]]]][If settings.sync,[org.codehaus.groovy.ast.stmt.ExpressionStatement@588307f7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7df76d99[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@459cfcca[org.codehaus.groovy.ast.expr.PropertyExpression@2acbc859[object: org.codehaus.groovy.ast.expr.VariableExpression@6ab7ce48[variable: settings] property: ConstantExpression[sync]]]]]],],]
appTouch: [log.debug(appTouch(): atomicState.run = $atomicState.run)][org.codehaus.groovy.ast.stmt.ExpressionStatement@2c6aed22[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@e322ec9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7acfb656[ConstantExpression[2], org.codehaus.groovy.ast.expr.VariableExpression@2e5ee2c9[variable: preCheck]]]]]]
isWaterStopped: [If (settings.contacts && settings.contacts.currentContact.contains(settings.contactStop)),,],[If (settings.toggles && settings.toggles.currentSwitch.contains(settings.toggleStop)),,],]
subWaterStop: [If settings.contacts,[org.codehaus.groovy.ast.stmt.ExpressionStatement@55a609dd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4afd21c6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4d0753c9[org.codehaus.groovy.ast.expr.PropertyExpression@1416a80a[object: org.codehaus.groovy.ast.expr.VariableExpression@719bb3b4[variable: settings] property: ConstantExpression[contacts]]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@52cb4f50[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@25a5c7db[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4d27d9d[org.codehaus.groovy.ast.expr.PropertyExpression@28f878a0[object: org.codehaus.groovy.ast.expr.VariableExpression@20411320[variable: settings] property: ConstantExpression[contacts]], org.codehaus.groovy.ast.expr.GStringExpression@2b5183ec[strings: [ConstantExpression[contact.], ConstantExpression[]] values: [org.codehaus.groovy.ast.expr.PropertyExpression@3c782d8e[object: org.codehaus.groovy.ast.expr.VariableExpression@572e6fd9[variable: settings] property: ConstantExpression[contactStop]]]], org.codehaus.groovy.ast.expr.VariableExpression@7f5eae0f[variable: waterStop]]]]],],[If settings.toggles,[org.codehaus.groovy.ast.stmt.ExpressionStatement@58b71ceb[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@255e5e2e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@12abdfb[org.codehaus.groovy.ast.expr.PropertyExpression@b0e5507[object: org.codehaus.groovy.ast.expr.VariableExpression@6bbe50c9[variable: settings] property: ConstantExpression[toggles]]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3c46dcbe[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@68577ba8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1108adc8[org.codehaus.groovy.ast.expr.PropertyExpression@8a98f38[object: org.codehaus.groovy.ast.expr.VariableExpression@20011bf[variable: settings] property: ConstantExpression[toggles]], org.codehaus.groovy.ast.expr.GStringExpression@51d9b06c[strings: [ConstantExpression[switch.], ConstantExpression[]] values: [org.codehaus.groovy.ast.expr.PropertyExpression@5eb2172[object: org.codehaus.groovy.ast.expr.VariableExpression@41ffaeb8[variable: settings] property: ConstantExpression[toggleStop]]]], org.codehaus.groovy.ast.expr.VariableExpression@43f0c2d1[variable: waterStop]]]]],],]
subWaterStart: [If settings.contacts,[org.codehaus.groovy.ast.stmt.ExpressionStatement@5fb65013[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@38a1a26[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3fbcfe81[org.codehaus.groovy.ast.expr.PropertyExpression@7a1f45ed[object: org.codehaus.groovy.ast.expr.VariableExpression@1744a475[variable: settings] property: ConstantExpression[contacts]]]]]][(cond = ((settings.contactStop == open)) ? closed : open)][org.codehaus.groovy.ast.stmt.ExpressionStatement@444cc791[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1c5c616f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1c6c6f24[org.codehaus.groovy.ast.expr.PropertyExpression@2eb917d0[object: org.codehaus.groovy.ast.expr.VariableExpression@c6b2dd9[variable: settings] property: ConstantExpression[contacts]], org.codehaus.groovy.ast.expr.GStringExpression@73437222[strings: [ConstantExpression[contact.], ConstantExpression[]] values: [org.codehaus.groovy.ast.expr.VariableExpression@ca93621[variable: cond]]], org.codehaus.groovy.ast.expr.VariableExpression@6a48a7f3[variable: waterStart]]]]],],[If settings.toggles,[org.codehaus.groovy.ast.stmt.ExpressionStatement@3f985a86[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@57a2ed35[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@12ffd1de[org.codehaus.groovy.ast.expr.PropertyExpression@3d278b4d[object: org.codehaus.groovy.ast.expr.VariableExpression@4096aa05[variable: settings] property: ConstantExpression[toggles]]]]]][(cond = ((settings.toggleStop == on)) ? off : on)][org.codehaus.groovy.ast.stmt.ExpressionStatement@9d3c67[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6c806c8b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6dfcffb5[org.codehaus.groovy.ast.expr.PropertyExpression@184fb68d[object: org.codehaus.groovy.ast.expr.VariableExpression@71d8cfe7[variable: settings] property: ConstantExpression[toggles]], org.codehaus.groovy.ast.expr.GStringExpression@1e530163[strings: [ConstantExpression[switch.], ConstantExpression[]] values: [org.codehaus.groovy.ast.expr.VariableExpression@14d8444b[variable: cond]]], org.codehaus.groovy.ast.expr.VariableExpression@71466383[variable: waterStart]]]]],],]
unsubWaterStoppers: [If settings.contacts,[org.codehaus.groovy.ast.stmt.ExpressionStatement@46d63dbb[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4088741b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@16a49a5d[org.codehaus.groovy.ast.expr.PropertyExpression@54bca971[object: org.codehaus.groovy.ast.expr.VariableExpression@23706db8[variable: settings] property: ConstantExpression[contacts]]]]]],],[If settings.toggles,[org.codehaus.groovy.ast.stmt.ExpressionStatement@205bed61[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@129fed45[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@23592946[org.codehaus.groovy.ast.expr.PropertyExpression@3e48d38[object: org.codehaus.groovy.ast.expr.VariableExpression@7c2b58c0[variable: settings] property: ConstantExpression[toggles]]]]]],],]
getWaterStopList: [(deviceList = )][(i = 1)][If settings.contacts,,],[If settings.toggles,,],]
writeSettings: [If state.tpwMap,[(state.tpwMap = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])],],[If state.dpwMap,[(state.dpwMap = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])],],[If state.setMoisture,[(state.setMoisture = null)],],[If state.seasonAdj,[(state.seasonAdj = 100.0)],],[If state.weekseasonAdj,[(state.weekseasonAdj = 0)],],]
getWeekDay: [(weekdays = [Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday])][(mapDay = [Monday:1, Tuesday:2, Wednesday:3, Thursday:4, Friday:5, Saturday:6, Sunday:7])][If (day && weekdays.contains(day)),,],[(today = new java.util.Date().format(EEEE, location.timeZone))]]
getRunDays: [(str = )][If day1,[(str += M)],],[If day2,[(str += T)],],[If day3,[(str += W)],],[If day4,[(str += Th)],],[If day5,[(str += F)],],[If day6,[(str += Sa)],],[If day7,[(str += Su)],],[If (str == ),[(str = 0 Days/week)],],]
manualStart: [(running = this.attemptRecovery())][If ((settings.enableManual && running) && (settings.switches.currentStatus != pause)),[If (settings.sync && ((settings.sync.currentSwitch != off) || (settings.sync.currentStatus == pause))),,[(runNowMap = [])][(runNowMap = this.cycleLoop(0))][If runNowMap,[(atomicState.run = true)][org.codehaus.groovy.ast.stmt.ExpressionStatement@11b377c5[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7bca6fac[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5c60b0a0[org.codehaus.groovy.ast.expr.PropertyExpression@7a2b1eb4[object: org.codehaus.groovy.ast.expr.VariableExpression@702c436b[variable: settings] property: ConstantExpression[switches]], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@5833f5cd[variable: cycleOff]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@10fbbdb[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@23f3dbf0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@31d6f3fe[ConstantExpression[60], org.codehaus.groovy.ast.expr.VariableExpression@760cf594[variable: cycleOn]]]]][(newString = )][(tt = state.totalTime)][If tt,[(hours = (tt / 60))][(mins = (tt - (hours * 60)))][(hourString = )][(s = )][If (hours > 1),[(s = s)],],[If (hours > 0),[(hourString = $hours hour$s & )],],[(s = s)][If (mins == 1),[(s = )],],[(newString = run time: $hourString$mins minute$s:
)],],,],],,],]
busy: [If atomicState.run,[If this.attemptRecovery(),,],,],[If settings.sync,[If ((settings.sync.currentSwitch != off) || (settings.sync.currentStatus == pause)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@aa149ed[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@37303f12[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@31ff6309[org.codehaus.groovy.ast.expr.PropertyExpression@204e90f7[object: org.codehaus.groovy.ast.expr.VariableExpression@20a05b32[variable: settings] property: ConstantExpression[sync]], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@165e389b[variable: syncOn]]]]],],,],[(csw = settings.switches.currentSwitch)][(cst = settings.switches.currentStatus)][If ((csw == off) && (cst != pause)),,],[If this.isDay(),[org.codehaus.groovy.ast.stmt.ExpressionStatement@5c73f672[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@8ee0c23[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2ab5afc7[org.codehaus.groovy.ast.expr.PropertyExpression@4dc8c0ea[object: org.codehaus.groovy.ast.expr.VariableExpression@e4b6f47[variable: settings] property: ConstantExpression[switches]], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@763cf5b9[variable: busyOff]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@71f0b72e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7a34f66a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[note] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2f508f3c[ConstantExpression[delayed], org.codehaus.groovy.ast.expr.GStringExpression@3ed03652[strings: [ConstantExpression[], ConstantExpression[: Waiting for currently running schedule to complete before starting]] values: [org.codehaus.groovy.ast.expr.PropertyExpression@4aedaf61[object: org.codehaus.groovy.ast.expr.VariableExpression@173797f0[variable: app] property: ConstantExpression[label]]]], ConstantExpression[c]]]]],],[org.codehaus.groovy.ast.stmt.ExpressionStatement@3c35c345[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3681037[object: org.codehaus.groovy.ast.expr.VariableExpression@2459319c[variable: log] method: ConstantExpression[debug] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@ffaaaf0[org.codehaus.groovy.ast.expr.GStringExpression@1dc76fa1[strings: [ConstantExpression[Another schedule is running, but ], ConstantExpression[ is not scheduled for today anyway]] values: [org.codehaus.groovy.ast.expr.PropertyExpression@5eed2d86[object: org.codehaus.groovy.ast.expr.VariableExpression@33d53216[variable: app] property: ConstantExpression[label]]]]]]]]]
busyOff: [(cst = settings.switches.currentStatus)][If ((settings.switches.currentSwitch == off) && (cst != pause)),[org.codehaus.groovy.ast.stmt.ExpressionStatement@69a2b3b6[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4f3e7344[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7808f638[org.codehaus.groovy.ast.expr.VariableExpression@62d73ead[variable: switches]]]]][(rand = new java.util.Random())][(randomSeconds = (rand.nextInt(120) + 15))][org.codehaus.groovy.ast.stmt.ExpressionStatement@1e141e42[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@228cea97[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1d0a61c8[org.codehaus.groovy.ast.expr.VariableExpression@46731692[variable: randomSeconds type: java.lang.Integer], org.codehaus.groovy.ast.expr.VariableExpression@782bf610[variable: preCheck]]]]],],]
preCheck: [If this.isDay(),[org.codehaus.groovy.ast.stmt.ExpressionStatement@3db663d0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@73fc518f[object: org.codehaus.groovy.ast.expr.VariableExpression@2de50ee4[variable: log] method: ConstantExpression[debug] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@ad9e63e[org.codehaus.groovy.ast.expr.GStringExpression@47fbc56[strings: [ConstantExpression[preCheck() Skipping: ], ConstantExpression[ is not scheduled for today]] values: [org.codehaus.groovy.ast.expr.PropertyExpression@151ef57f[object: org.codehaus.groovy.ast.expr.VariableExpression@10895b16[variable: app] property: ConstantExpression[label]]]]]]]],],[If this.busy(),[(atomicState.run = true)][org.codehaus.groovy.ast.stmt.ExpressionStatement@5524b72f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2cc03cd1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4e17913b[ConstantExpression[45], org.codehaus.groovy.ast.expr.VariableExpression@149c3204[variable: checkRunMap]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@64f16277[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@497aec8c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3b9632d1[org.codehaus.groovy.ast.expr.PropertyExpression@4e6f2bb5[object: org.codehaus.groovy.ast.expr.VariableExpression@21e20ad5[variable: settings] property: ConstantExpression[switches]], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@3f628ce9[variable: cycleOff]]]]][(start = this.now())][(end = this.now())][If this.isWeather(),,[org.codehaus.groovy.ast.stmt.ExpressionStatement@35e8316e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@26d96e5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@336880df[ConstantExpression[2], org.codehaus.groovy.ast.expr.VariableExpression@1846579f[variable: checkRunMap]]]]]],,],]
cycleOn: [If atomicState.run,[If this.isWaterStopped(),[org.codehaus.groovy.ast.stmt.ExpressionStatement@6cd166b8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2650f79[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@75fc1992[org.codehaus.groovy.ast.expr.PropertyExpression@5fac521d[object: org.codehaus.groovy.ast.expr.VariableExpression@38af1bf6[variable: settings] property: ConstantExpression[switches]], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@129bd55d[variable: cycleOff]]]]][(newString = $app.label: Starting...)][If atomicState.startTime,[(atomicState.startTime = this.now())][If atomicState.startTime,[(atomicState.finishTime = null)],],[If state.pauseTime,[(state.pauseTime = null)],],[If state.totalTime,[(finishTime = new java.util.Date((this.now() + (60000 * state.totalTime).toLong())).format(EE @ h:mm a, location.timeZone))][(newString = $app.label: Starting - ETC: $finishTime)],],,[If state.pauseTime,[(elapsedTime = java.lang.Math.round(((this.now() - state.pauseTime) / 60000)))][(tt = ((state.totalTime + elapsedTime) + 1))][(state.totalTime = tt)][(finishTime = new java.util.Date((atomicState.startTime + (60000 * tt).toLong())).format(EE @ h:mm a, location.timeZone))][(state.pauseTime = null)][(newString = $app.label: Resuming - New ETC: $finishTime)],],],,],,],]
cycleOff: [If atomicState.run,[(ft = new java.util.Date())][(atomicState.finishTime = ft)][(finishTime = ft.format(h:mm a, location.timeZone))],],]
checkRunMap: [If atomicState.run,[(runNowMap = [])][(runNowMap = this.cycleLoop(1))][If runNowMap,[org.codehaus.groovy.ast.stmt.ExpressionStatement@7be7e15[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3abfe845[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7a0f244f[ConstantExpression[60], org.codehaus.groovy.ast.expr.VariableExpression@3672276e[variable: cycleOn]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4248b963[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7f08caf[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4defd42[org.codehaus.groovy.ast.expr.PropertyExpression@2330e3e0[object: org.codehaus.groovy.ast.expr.VariableExpression@24b4d544[variable: settings] property: ConstantExpression[switches]], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@27a2a089[variable: cycleOff]]]]][If atomicState.startTime,[(atomicState.startTime = null)],],[If state.pauseTime,[(state.pauseTime = null)],],[(newString = )][(tt = state.totalTime)][If tt,[(hours = (tt / 60))][(mins = (tt - (hours * 60)))][(hourString = )][(s = )][If (hours > 1),[(s = s)],],[If (hours > 0),[(hourString = $hours hour$s & )],],[(s = s)][If (mins == 1),[(s = )],],[(newString = run time: $hourString$mins minute$s:
)],],,[org.codehaus.groovy.ast.stmt.ExpressionStatement@54657dd2[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@706eab5d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@72725ee1[org.codehaus.groovy.ast.expr.PropertyExpression@40e60ece[object: org.codehaus.groovy.ast.expr.VariableExpression@3f9270ed[variable: settings] property: ConstantExpression[switches]]]]]][If enableManual,[org.codehaus.groovy.ast.stmt.ExpressionStatement@3a230001[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5ac6c4f2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2aa6311a[org.codehaus.groovy.ast.expr.PropertyExpression@61f39bb[object: org.codehaus.groovy.ast.expr.VariableExpression@249e0271[variable: settings] property: ConstantExpression[switches]], ConstantExpression[switch.programOn], org.codehaus.groovy.ast.expr.VariableExpression@4893b344[variable: manualStart]]]]],],[If atomicState.run,[(atomicState.run = false)],],],,[log.debug(checkRunMap(): atomicState.run = false)]],]
cycleLoop: [(isDebug = false)][If isDebug,,],[(zone = 1)][(dpw = 0)][(tpw = 0)][(cyc = 0)][(rtime = 0)][(timeMap = [:])][(pumpMap = )][(runNowMap = )][(soilString = )][(totalCycles = 0)][(totalTime = 0)][If atomicState.startTime,[(atomicState.startTime = null)],],[While (zone <= 16),[(rtime = 0)][(setZ = settings.zone$zone)][If (((setZ && (setZ != Off)) && (this.nozzle(zone) != 4)) && this.zoneActive(zone.toString())),[(dpw = this.getDPW(zone))][(runToday = 0)][If (((i == 0) || (state.daysAvailable == 7)) || settings.sensor$zone),[(runToday = 1)],[(dpw = this.getDPW(zone))][If (settings.days && (settings.days.contains(Even) || settings.days.contains(Odd))),[(daynum = new java.util.Date().format(dd, location.timeZone))][(dayint = java.lang.Integer.parseInt(daynum))][If (settings.days.contains(Odd) && (((dayint + 1) % java.lang.Math.round((31 / (dpw * 4)))) == 0)),[(runToday = 1)],[If (settings.days.contains(Even) && ((dayint % java.lang.Math.round((31 / (dpw * 4)))) == 0)),[(runToday = 1)],],],,[(weekDay = (this.getWeekDay() - 1))][(dpwMap = this.getDPWDays(dpw))][(runToday = dpwMap[weekDay])][If isDebug,,],],],[If (runToday == 1),[(soil = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (i == 0),[(soil = this.moisture(0))],[(soil = this.moisture(zone))]],[(soilString = $soilString$soil[1])][If (soil[0] == 1),[(cyc = this.cycles(zone))][(tpw = this.getTPW(zone))][(dpw = this.getDPW(zone))][(rtime = this.calcRunTime(tpw, dpw))][If (settings.isSeason && (settings.learn || settings.sensor$zone)),[(rtime = java.lang.Math.round((((rtime / cyc) * (state.seasonAdj / 100.0)) + 0.4)))],[(rtime = java.lang.Math.round(((rtime / cyc) + 0.4)))]],[(totalCycles += cyc)][(totalTime += (rtime * cyc))][(runNowMap += $settings.name$zone: $cyc x $rtime min
)][If isDebug,,],,],,],,],[If (this.nozzle(zone) == 4),[(pumpMap += $settings.name$zone: $settings.zone$zone on
)],],[(timeMap.$(zone + 1) = $rtime)]]cycleLoop: [(isDebug = false)][If isDebug,,],[(zone = 1)][(dpw = 0)][(tpw = 0)][(cyc = 0)][(rtime = 0)][(timeMap = [:])][(pumpMap = )][(runNowMap = )][(soilString = )][(totalCycles = 0)][(totalTime = 0)][If atomicState.startTime,[(atomicState.startTime = null)],],[While (zone <= 16),[(rtime = 0)][(setZ = settings.zone$zone)][If (((setZ && (setZ != Off)) && (this.nozzle(zone) != 4)) && this.zoneActive(zone.toString())),[(dpw = this.getDPW(zone))][(runToday = 0)][If (((i == 0) || (state.daysAvailable == 7)) || settings.sensor$zone),[(runToday = 1)],[(dpw = this.getDPW(zone))][If (settings.days && (settings.days.contains(Even) || settings.days.contains(Odd))),[(daynum = new java.util.Date().format(dd, location.timeZone))][(dayint = java.lang.Integer.parseInt(daynum))][If (settings.days.contains(Odd) && (((dayint + 1) % java.lang.Math.round((31 / (dpw * 4)))) == 0)),[(runToday = 1)],[If (settings.days.contains(Even) && ((dayint % java.lang.Math.round((31 / (dpw * 4)))) == 0)),[(runToday = 1)],],],,[(weekDay = (this.getWeekDay() - 1))][(dpwMap = this.getDPWDays(dpw))][(runToday = dpwMap[weekDay])][If isDebug,,],],],[If (runToday == 1),[(soil = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (i == 0),[(soil = this.moisture(0))],[(soil = this.moisture(zone))]],[(soilString = $soilString$soil[1])][If (soil[0] == 1),[(cyc = this.cycles(zone))][(tpw = this.getTPW(zone))][(dpw = this.getDPW(zone))][(rtime = this.calcRunTime(tpw, dpw))][If (settings.isSeason && (settings.learn || settings.sensor$zone)),[(rtime = java.lang.Math.round((((rtime / cyc) * (state.seasonAdj / 100.0)) + 0.4)))],[(rtime = java.lang.Math.round(((rtime / cyc) + 0.4)))]],[(totalCycles += cyc)][(totalTime += (rtime * cyc))][(runNowMap += $settings.name$zone: $cyc x $rtime min
)][If isDebug,,],,],,],,],[If (this.nozzle(zone) == 4),[(pumpMap += $settings.name$zone: $settings.zone$zone on
)],],[(timeMap.$(zone + 1) = $rtime)]][If soilString,[(seasonStr = )][(plus = )][(sa = state.seasonAdj)][If ((settings.isSeason && (sa != 100.0)) && (sa != 0.0)),[(sadj = (sa - 100.0))][If (sadj > 0.0),[(plus = +)],],[(iadj = java.lang.Math.round(sadj))][If (iadj != 0),[(seasonStr = Adjusting $plus$iadj% for weather forecast
)],],,],,],[If runNowMap,,],[org.codehaus.groovy.ast.stmt.ExpressionStatement@53a665ad[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2c0b4c83[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@78525ef9[ConstantExpression[30], org.codehaus.groovy.ast.expr.VariableExpression@2d0ecb24[variable: writeCycles]]]]][(pDelay = 0)][If (settings.pumpDelay && settings.pumpDelay.isNumber()),[(pDelay = settings.pumpDelay.toInteger())],],[(totalTime += java.lang.Math.round(((pDelay * (totalCycles - 1)) / 60.0)))][(state.totalTime = totalTime)][If state.pauseTime,[(state.pauseTime = null)],],]
writeCycles: [(cyclesMap = [:])][(cyclesMap.1 = this.pumpDelayString())][(zone = 1)][(cycle = 0)][While (zone <= 17),[If (this.nozzle(zone) == 4),[(cycle = 4)],[(cycle = this.cycles(zone))]],[(cyclesMap.$(zone + 1) = $cycle)]]writeCycles: [(cyclesMap = [:])][(cyclesMap.1 = this.pumpDelayString())][(zone = 1)][(cycle = 0)][While (zone <= 17),[If (this.nozzle(zone) == 4),[(cycle = 4)],[(cycle = this.cycles(zone))]],[(cyclesMap.$(zone + 1) = $cycle)]]]
resume: ]
syncOn: [If ((settings.sync.currentSwitch == off) && (settings.sync.currentStatus != pause)),[(rand = new java.util.Random())][(randomSeconds = (rand.nextInt(120) + 15))][org.codehaus.groovy.ast.stmt.ExpressionStatement@4d654825[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3bfc6a5e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@51b35e4e[org.codehaus.groovy.ast.expr.VariableExpression@abff8b7[variable: randomSeconds type: java.lang.Integer], org.codehaus.groovy.ast.expr.VariableExpression@6d7cada5[variable: preCheck]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@350a94ce[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7e00ed0f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[note] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@b0fc838[ConstantExpression[schedule], org.codehaus.groovy.ast.expr.GStringExpression@3964d79[strings: [ConstantExpression[], ConstantExpression[: ], ConstantExpression[ finished, starting in ], ConstantExpression[ seconds]] values: [org.codehaus.groovy.ast.expr.PropertyExpression@62db0521[object: org.codehaus.groovy.ast.expr.VariableExpression@1b4ae4e0[variable: app] property: ConstantExpression[label]], org.codehaus.groovy.ast.expr.PropertyExpression@6ef1a1b9[object: org.codehaus.groovy.ast.expr.VariableExpression@5fbdc49b[variable: settings] property: ConstantExpression[sync]], org.codehaus.groovy.ast.expr.VariableExpression@65753040[variable: randomSeconds type: java.lang.Integer]]], ConstantExpression[c]]]]],],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
waterStop: [org.codehaus.groovy.ast.stmt.ExpressionStatement@2954b5ea[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4acb2510[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7be3a9ce[org.codehaus.groovy.ast.expr.VariableExpression@37d871c2[variable: cycleOn]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3baf6936[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@285f38f6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4e1459ea[org.codehaus.groovy.ast.expr.PropertyExpression@3ab6678b[object: org.codehaus.groovy.ast.expr.VariableExpression@7a904f32[variable: settings] property: ConstantExpression[switches]]]]]][If state.pauseTime,[(state.pauseTime = this.now())][(cond = evt.value)],],[If (settings.switches.currentSwitch != off),[org.codehaus.groovy.ast.stmt.ExpressionStatement@2b59501e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@476e8796[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4eed2acf[ConstantExpression[30], org.codehaus.groovy.ast.expr.VariableExpression@36fc05ff[variable: subOff]]]]],[org.codehaus.groovy.ast.stmt.ExpressionStatement@57c47a9e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@642505c7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4339e0de[org.codehaus.groovy.ast.expr.PropertyExpression@153cd6bb[object: org.codehaus.groovy.ast.expr.VariableExpression@61d84e08[variable: settings] property: ConstantExpression[switches]], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@2d9f64c9[variable: cycleOff]]]]]],]
subOff: [org.codehaus.groovy.ast.stmt.ExpressionStatement@21ac5eb4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@52d6cd34[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@715d6168[org.codehaus.groovy.ast.expr.PropertyExpression@27b2faa6[object: org.codehaus.groovy.ast.expr.VariableExpression@6428591a[variable: settings] property: ConstantExpression[switches]], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@7397c6[variable: offPauseCheck]]]]]]
offPauseCheck: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1abfe081[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2a685eba[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@c2e3264[org.codehaus.groovy.ast.expr.PropertyExpression@107f4980[object: org.codehaus.groovy.ast.expr.VariableExpression@75a118e6[variable: settings] property: ConstantExpression[switches]]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1d540566[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6014a9ba[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@acdcf71[org.codehaus.groovy.ast.expr.PropertyExpression@77d680e6[object: org.codehaus.groovy.ast.expr.VariableExpression@4a14c44f[variable: settings] property: ConstantExpression[switches]], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@f08fdce[variable: cycleOff]]]]][If (settings.switches.currentStatus != pause),,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
waterStart: [If this.isWaterStopped(),[(cDelay = 10)][If (settings.contactDelay > 10),[(cDelay = settings.contactDelay)],],[org.codehaus.groovy.ast.stmt.ExpressionStatement@6bda1d19[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@28c86134[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4492eede[org.codehaus.groovy.ast.expr.VariableExpression@cbc8d0f[variable: cDelay], org.codehaus.groovy.ast.expr.VariableExpression@37b57b54[variable: cycleOn]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5c1f6d57[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@f288c14[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6794ac0b[org.codehaus.groovy.ast.expr.PropertyExpression@7be71476[object: org.codehaus.groovy.ast.expr.VariableExpression@5cb5bb88[variable: settings] property: ConstantExpression[switches]]]]]][(cond = evt.value)],],]
initDPW: [If state.dpwMap,[(state.dpwMap = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])],],[(tpw = this.getTPW(zone))][(dpw = 0)][If (tpw > 0),[(perDay = 20.0)][If settings.perDay$zone,[(perDay = settings.perDay$zone.toFloat())],],[(dpw = java.lang.Math.round((tpw.toFloat() / perDay)))][If (dpw <= 1),[(dpw = 1)],],[If ((((dpw == 3) && days) && (days.contains(Even) || days.contains(Odd))) && (days.contains(Even) && days.contains(Odd))),[If ((tpw.toFloat() / perDay) < 3.0),[(dpw = 2)],[(dpw = 4)]],,],[(daycheck = this.daysAvailable())][If (daycheck < dpw),[(dpw = daycheck)],],,],[(state.dpwMap[(zone - 1)] = dpw)]]
getDPW: [If state.dpwMap,[return state.dpwMap[(zone - 1)]],],]
initTPW: [If state.tpwMap,[(state.tpwMap = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])],],[(n = this.nozzle(zone))][(zn = settings.zone$zone)][If (((((zn || (zn == Off)) || (n == 0)) || (n == 4)) || (this.plant(zone) == 0)) || this.zoneActive(zone.toString())),,],[(gainAdjust = 100.0)][If (settings.gain && (settings.gain != 0)),[(gainAdjust += settings.gain)],],[(seasonAdjust = 100.0)][(wsa = state.weekseasonAdj)][If ((wsa && isSeason) && (settings.plant$zone != New Plants)),[(seasonAdjust = wsa)],],[(tpw = 0)][If settings.sensor$zone,[(seasonAdjust = 100.0)][If (state.tpwMap && settings.learn),[(tpw = state.tpwMap[(zone - 1)])],],,],[(minWeek = 0)][(mw = settings.minWeek$zone)][If mw,[(minWeek = mw.toInteger())],],[If (minWeek != 0),[(tpw = java.lang.Math.round((minWeek * (seasonAdjust / 100.0))))],[If (tpw || (tpw == 0)),[(tpw = java.lang.Math.round((((this.plant(zone) * this.nozzle(zone)) * (gainAdjust / 100.0)) * (seasonAdjust / 100.0))))],],],[(state.tpwMap[(zone - 1)] = tpw)]]
getTPW: [If state.tpwMap,[return state.tpwMap[(zone - 1)]],],]
calcRunTime: [(duration = 0)][If ((tpw > 0) && (dpw > 0)),[(duration = java.lang.Math.round((tpw.toFloat() / dpw.toFloat())))],],]
moisture: [(isDebug = false)][If isDebug,,],[(endMsecs = 0)][If ((i == 0) || settings.sensor$i),,],[(spHum = this.getDrySp(i))][(hours = 48)][(yesterday = new java.util.Date((this.now() - (3600000 * hours).toLong())))][(latestHum = settings.sensor$i.latestValue(humidity).toFloat())][(lastHumDate = settings.sensor$i.latestState(humidity).date)][If (lastHumDate < yesterday),[If (latestHum < spHum),[(latestHum = (spHum - 1.0))],[(latestHum = (spHum + 0.99))]],,],[If settings.learn,[If (latestHum <= spHum.toFloat()),,],,],[(tpw = this.getTPW(i))][(dpw = this.getDPW(i))][(cpd = this.cycles(i))][If isDebug,,],[(diffHum = 0.0)][If (latestHum > 0.0),[(diffHum = ((spHum - latestHum) / 100.0))],[(diffHum = 0.02)]],[(daysA = state.daysAvailable)][(minimum = (cpd * dpw))][If (minimum < daysA),[(minimum = daysA)],],[(tpwAdjust = 0)][If (diffHum > 0.01),[(tpwAdjust = java.lang.Math.round(((((tpw * diffHum) + 0.5) * dpw) * cpd)))][(adjFactor = (2.0 / daysA))][If (tpwAdjust > (tpw * adjFactor)),[(tpwAdjust = java.lang.Math.round(((tpw * adjFactor) + 0.5)))],],[If (tpwAdjust < minimum),[(tpwAdjust = minimum)],],,[If (diffHum < -0.01),[If (diffHum < -0.05),[(diffHum = -0.05)],],[(tpwAdjust = java.lang.Math.round(((((tpw * diffHum) - 0.5) * dpw) * cpd)))][(adjFactor = (-0.6667 / daysA))][If (tpwAdjust < (tpw * adjFactor)),[(tpwAdjust = java.lang.Math.round(((tpw * adjFactor) - 0.5)))],],[If (tpwAdjust > (-1 * minimum)),[(tpwAdjust = (-1 * minimum))],],,],],[(seasonAdjust = 0)][If isSeason,[(sa = state.seasonAdj)][If ((sa != 100.0) && (sa != 0.0)),[(sadj = (sa - 100.0))][If (sa > 0.0),[(seasonAdjust = java.lang.Math.round((((sadj / 100.0) * tpw) + 0.5)))],[(seasonAdjust = java.lang.Math.round((((sadj / 100.0) * tpw) - 0.5)))]],,],,],[If isDebug,,],[(newTPW = ((tpw + tpwAdjust) + seasonAdjust))][(perDay = 20)][(perD = settings.perDay$i)][If perD,[(perDay = perD.toInteger())],],[If (perDay == 0),[(perDay = (daysA * cpd))],],[If (newTPW < perDay),[(newTPW = perDay)],],[(adjusted = 0)][If ((tpwAdjust + seasonAdjust) > 0),[(maxTPW = (daysA * 120))][If (newTPW > maxTPW),[(newTPW = maxTPW)],],[If (newTPW > (maxTPW * 0.75)),,],[If (state.tpwMap[(i - 1)] != newTPW),[(state.tpwMap[(i - 1)] = newTPW)][(dpw = this.initDPW(i))][(adjusted = (newTPW - tpw))],],,[If ((tpwAdjust + seasonAdjust) < 0),[(minimum = (cpd * daysA))][(minLimit = 0)][(minL = settings.minWeek$i)][If minL,[(minLimit = minL.toInteger())],],[If (minLimit > 0),[If (newTPW < minLimit),[(newTPW = minLimit)],],,[If (newTPW < minimum),[(newTPW = minimum)],],],[If (state.tpwMap[(i - 1)] != newTPW),[(state.tpwMap[(i - 1)] = newTPW)][(dpw = this.initDPW(i))][(adjusted = (newTPW - tpw))],],,],],[(moistureSum = )][(adjStr = )][(plus = )][If (adjusted > 0),[(plus = +)],],[If (adjusted != 0),[(adjStr = , $plus$adjusted min)],],[If (java.lang.Math.abs(adjusted) > 1),[(adjStr = $adjStrs)],],[If (diffHum >= 0.0),[(moistureSum = > $settings.name$i, Water: $settings.sensor$i @ $latestHum% ($spHum%)$adjStr ($newTPW min/wk)
)],[(moistureSum = > $settings.name$i, Skip: $settings.sensor$i @ $latestHum% ($spHum%)$adjStr ($newTPW min/wk)
)]],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
getDrySp: [If settings.sensorSp$i,,],[If (settings.plant$i == New Plants),,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
note: [(notifyController = true)][If (settings.notify || settings.logAll),[(spruceMsg = Spruce $msg)],],[If notifyController,[If (atomicState.run || ((settings.switches.currentSwitch == off) && (settings.switches.currentStatus != pause))),,],,],]
sendIt: [If (location.contactBookEnabled && settings.recipients),,],]
daysAvailable: [(daysA = state.daysAvailable)][If (daysA && (daysA > 0)),,],[If settings.days,[(state.daysAvailable = 7)],],[(dayCount = 0)][If (settings.days.contains(Even) || settings.days.contains(Odd)),[(dayCount = 4)][If (settings.days.contains(Even) && settings.days.contains(Odd)),[(dayCount = 7)],],,[If settings.days.contains(Monday),[(dayCount += 1)],],[If settings.days.contains(Tuesday),[(dayCount += 1)],],[If settings.days.contains(Wednesday),[(dayCount += 1)],],[If settings.days.contains(Thursday),[(dayCount += 1)],],[If settings.days.contains(Friday),[(dayCount += 1)],],[If settings.days.contains(Saturday),[(dayCount += 1)],],[If settings.days.contains(Sunday),[(dayCount += 1)],],],[(state.daysAvailable = dayCount)]]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
nozzle: [(getT = settings.zone$i)][If getT,,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
plant: [(getP = settings.plant$i)][If getP,,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
cycles: [(getC = settings.option$i)][If getC,,],]
isDay: [If (this.daysAvailable() == 7),,],[(daynow = new java.util.Date())][(today = daynow.format(EEEE, location.timeZone))][If settings.days.contains(today),,],[(daynum = daynow.format(dd, location.timeZone))][(dayint = java.lang.Integer.parseInt(daynum))][If (settings.days.contains(Even) && ((dayint % 2) == 0)),,],[If (settings.days.contains(Odd) && ((dayint % 2) != 0)),,],]
setSeason: [(isDebug = false)][If isDebug,,],[(zone = 1)][While (zone <= 16),[If ((settings.learn || settings.sensor$zone) || (state.tpwMap[(zone - 1)] == 0)),[(tpw = this.initTPW(zone))][(dpw = this.initDPW(zone))][If isDebug,[If ((settings.learn && (tpw != 0)) && (state.weekseasonAdj != 0)),[log.debug(Zone $zone: seasonally adjusted by $(state.weekseasonAdj - 100)% to $tpw)],],,],,],]setSeason: [(isDebug = false)][If isDebug,,],[(zone = 1)][While (zone <= 16),[If ((settings.learn || settings.sensor$zone) || (state.tpwMap[(zone - 1)] == 0)),[(tpw = this.initTPW(zone))][(dpw = this.initDPW(zone))][If isDebug,[If ((settings.learn && (tpw != 0)) && (state.weekseasonAdj != 0)),[log.debug(Zone $zone: seasonally adjusted by $(state.weekseasonAdj - 100)% to $tpw)],],,],,],]]
getRainToday: [(wzipcode = this.zipString())][(wdata = this.getWeatherFeature(conditions, wzipcode))][If wdata,,[If (wdata.response || wdata.response.containsKey(error)),,[(TRain = 0.0)][If wdata.current_observation.precip_today_in.isNumber(),[(TRain = wdata.current_observation.precip_today_in.toFloat())][If (TRain > 25.0),[(TRain = 25.0)],[If (TRain < 0.0),[(TRain = 0.0)],],],,],[(day = this.getWeekDay())][If (day == 7),[(day = 0)],],[(state.Rain[day] = (java.lang.Float -> java.lang.Float) TRain)]],],]
isWeather: [(startMsecs = 0)][(endMsecs = 0)][(isDebug = false)][If isDebug,,],[If (settings.isRain && settings.isSeason),,],[(wzipcode = this.zipString())][If isDebug,,],[(featureString = forecast/conditions)][If settings.isSeason,[(featureString = $featureString/astronomy)],],[If isDebug,[(startMsecs = this.now())],],[(wdata = this.getWeatherFeature(featureString, wzipcode))][If isDebug,[(endMsecs = this.now())],],[If (wdata && wdata.response),[If isDebug,,],[If wdata.response.containsKey(error),[If (wdata.response.error.type != invalidfeature),,],,],,[If isDebug,,],],[(city = wzipcode)][If wdata.current_observation,[If (wdata.current_observation.observation_location.city != ),[(city = wdata.current_observation.observation_location.city)],[If (wdata.current_observation.observation_location.full != ),[(city = wdata.current_observation.display_location.full)],],],[If wdata.current_observation.estimated.estimated,[(city = $city (est))],],,],[(qpfTodayIn = 0.0)][(qpfTomIn = 0.0)][(popToday = 50.0)][(popTom = 50.0)][(TRain = 0.0)][(YRain = 0.0)][(weeklyRain = 0.0)][If settings.isRain,[If isDebug,,],[If wdata.forecast,,],[If wdata.forecast.simpleforecast.forecastday[0].qpf_allday.in.isNumber(),[(qpfTodayIn = wdata.forecast.simpleforecast.forecastday[0].qpf_allday.in.toFloat())],],[If wdata.forecast.simpleforecast.forecastday[0].pop.isNumber(),[(popToday = wdata.forecast.simpleforecast.forecastday[0].pop.toFloat())],],[If wdata.forecast.simpleforecast.forecastday[1].qpf_allday.in.isNumber(),[(qpfTomIn = wdata.forecast.simpleforecast.forecastday[1].qpf_allday.in.toFloat())],],[If wdata.forecast.simpleforecast.forecastday[1].pop.isNumber(),[(popTom = wdata.forecast.simpleforecast.forecastday[1].pop.toFloat())],],[If (qpfTodayIn > 25.0),[(qpfTodayIn = 25.0)],[If (qpfTodayIn < 0.0),[(qpfTodayIn = 0.0)],],],[If (qpfTomIn > 25.0),[(qpfTomIn = 25.0)],[If (qpfTomIn < 0.0),[(qpfTomIn = 0.0)],],],[If wdata.current_observation,,],[If wdata.current_observation.precip_today_in.isNumber(),[(TRain = wdata.current_observation.precip_today_in.toFloat())][If (TRain > 25.0),[(TRain = 25.0)],[If (TRain < 0.0),[(TRain = 0.0)],],],,],[If (TRain > (qpfTodayIn * (popToday / 100.0))),[(qpfTodayIn = TRain)][(popToday = 100)],],[(day = this.getWeekDay())][(YRain = state.Rain[(day - 1)])][If isDebug,,],[(i = 0)][While (i <= 6),[(factor = 0)][If ((day - i) > 0),[(factor = (day - i))],[(factor = ((day + 7) - i))]],[(getrain = state.Rain[i])][If (factor != 0),[(weeklyRain += (getrain / factor))],],][If isDebug,,],[If wdata.forecast,,],[If wdata.forecast.simpleforecast.forecastday[0].qpf_allday.in.isNumber(),[(qpfTodayIn = wdata.forecast.simpleforecast.forecastday[0].qpf_allday.in.toFloat())],],[If wdata.forecast.simpleforecast.forecastday[0].pop.isNumber(),[(popToday = wdata.forecast.simpleforecast.forecastday[0].pop.toFloat())],],[If wdata.forecast.simpleforecast.forecastday[1].qpf_allday.in.isNumber(),[(qpfTomIn = wdata.forecast.simpleforecast.forecastday[1].qpf_allday.in.toFloat())],],[If wdata.forecast.simpleforecast.forecastday[1].pop.isNumber(),[(popTom = wdata.forecast.simpleforecast.forecastday[1].pop.toFloat())],],[If (qpfTodayIn > 25.0),[(qpfTodayIn = 25.0)],[If (qpfTodayIn < 0.0),[(qpfTodayIn = 0.0)],],],[If (qpfTomIn > 25.0),[(qpfTomIn = 25.0)],[If (qpfTomIn < 0.0),[(qpfTomIn = 0.0)],],],[If wdata.current_observation,,],[If wdata.current_observation.precip_today_in.isNumber(),[(TRain = wdata.current_observation.precip_today_in.toFloat())][If (TRain > 25.0),[(TRain = 25.0)],[If (TRain < 0.0),[(TRain = 0.0)],],],,],[If (TRain > (qpfTodayIn * (popToday / 100.0))),[(qpfTodayIn = TRain)][(popToday = 100)],],[(day = this.getWeekDay())][(YRain = state.Rain[(day - 1)])][If isDebug,,],[(i = 0)][While (i <= 6),[(factor = 0)][If ((day - i) > 0),[(factor = (day - i))],[(factor = ((day + 7) - i))]],[(getrain = state.Rain[i])][If (factor != 0),[(weeklyRain += (getrain / factor))],],][If isDebug,,],,],[If isDebug,,],[(highToday = 0)][(highTom = 0)][If wdata.forecast.simpleforecast.forecastday[0].high.fahrenheit.isNumber(),[(highToday = wdata.forecast.simpleforecast.forecastday[0].high.fahrenheit.toInteger())],],[If wdata.forecast.simpleforecast.forecastday[1].high.fahrenheit.isNumber(),[(highTom = wdata.forecast.simpleforecast.forecastday[1].high.fahrenheit.toInteger())],],[(weatherString = $app.label: $city weather:
 TDA: $highTodayF)][If settings.isRain,[(weatherString = $weatherString, $qpfTodayInin rain ($Math.round(popToday)% PoP))],],[(weatherString = $weatherString
 TMW: $highTomF)][If settings.isRain,[(weatherString = $weatherString, $qpfTomInin rain ($Math.round(popTom)% PoP)
 YDA: $YRainin rain)],],[If settings.isSeason,[If settings.isRain,[If wdata.forecast,,],,],[(heatAdjust = 100.0)][(avgHigh = highToday.toFloat())][If (highToday != 0),[(totalHigh = highToday)][(j = 1)][(highs = 1)][While (j < 4),[If wdata.forecast.simpleforecast.forecastday[j].high.fahrenheit.isNumber(),[(totalHigh += wdata.forecast.simpleforecast.forecastday[j].high.fahrenheit.toInteger())],],][(totalHigh = highToday)][(j = 1)][(highs = 1)][While (j < 4),[If wdata.forecast.simpleforecast.forecastday[j].high.fahrenheit.isNumber(),[(totalHigh += wdata.forecast.simpleforecast.forecastday[j].high.fahrenheit.toInteger())],],][If (highs > 0),[(avgHigh = (totalHigh / highs))],],[(heatAdjust = (avgHigh / highToday))],],[If isDebug,,],[(humToday = 0)][If wdata.forecast.simpleforecast.forecastday[0].avehumidity.isNumber(),[(humToday = wdata.forecast.simpleforecast.forecastday[0].avehumidity.toInteger())],],[(humAdjust = 100.0)][(avgHum = humToday.toFloat())][If (humToday != 0),[(j = 1)][(highs = 1)][(totalHum = humToday)][While (j < 4),[If wdata.forecast.simpleforecast.forecastday[j].avehumidity.isNumber(),[(totalHum += wdata.forecast.simpleforecast.forecastday[j].avehumidity.toInteger())],],][(j = 1)][(highs = 1)][(totalHum = humToday)][While (j < 4),[If wdata.forecast.simpleforecast.forecastday[j].avehumidity.isNumber(),[(totalHum += wdata.forecast.simpleforecast.forecastday[j].avehumidity.toInteger())],],][If (highs > 1),[(avgHum = (totalHum / highs))],],[(humAdjust = (1.5 - ((0.5 * avgHum) / humToday)))],],[If isDebug,,],[(sa = (((heatAdjust + humAdjust) / 2) * 100.0))][(state.seasonAdj = sa)][(sa = (sa - 100.0))][(plus = )][If (sa > 0),[(plus = +)],],[(weatherString = $weatherString
 Adjusting $plus$Math.round(sa)% for weather forecast)][If ((this.getWeekDay() == 1) || (state.weekseasonAdj == 0)),[If wdata.sun_phase,[(getsunRH = 0)][(getsunRM = 0)][(getsunSH = 0)][(getsunSM = 0)][If wdata.sun_phase.sunrise.hour.isNumber(),[(getsunRH = wdata.sun_phase.sunrise.hour.toInteger())],],[If wdata.sun_phase.sunrise.minute.isNumber(),[(getsunRM = wdata.sun_phase.sunrise.minute.toInteger())],],[If wdata.sun_phase.sunset.hour.isNumber(),[(getsunSH = wdata.sun_phase.sunset.hour.toInteger())],],[If wdata.sun_phase.sunset.minute.isNumber(),[(getsunSM = wdata.sun_phase.sunset.minute.toInteger())],],[(daylight = (((getsunSH * 60) + getsunSM) - ((getsunRH * 60) + getsunRM)))][If (daylight >= 850),[(daylight = 850)],],[(qFact = 75.0)][(wa = (((daylight / 700.0) * (((avgHigh / 70.0) + (1.5 - ((avgHum * 0.5) / 65.46))) / 2.0)) * qFact))][(state.weekseasonAdj = wa)][(plus = )][If (wa != 0),[If (wa > 100.0),[(plus = +)],],[(waStr = java.lang.String.format(%.2f, (wa - 100.0)))][(weatherString = $weatherString
 Seasonal adjustment of $waStr% for the week)],],,],,],,],[If settings.isRain,,],[(setrainDelay = 0.2)][If settings.rainDelay,[(setrainDelay = settings.rainDelay.toFloat())],],[If this.anySensors(),[If (settings.switches.latestValue(rainsensor) == rainsensoron),,],[(popRain = (qpfTodayIn * (popToday / 100.0)))][If (popRain > setrainDelay),[(rainStr = java.lang.String.format(%.2f, popRain))],],[(popRain += (qpfTomIn * (popTom / 100.0)))][If (popRain > setrainDelay),[(rainStr = java.lang.String.format(%.2f, popRain))],],[If (weeklyRain > setrainDelay),[(rainStr = java.lang.String.format(%.2f, weeklyRain))],],,[(popRain = ((qpfTodayIn * (popToday / 100.0)) - TRain))][If (popRain > setrainDelay),[(rainStr = java.lang.String.format(%.2f, popRain))],],[(popRain += (qpfTomIn * (popTom / 100.0)))][If (popRain > setrainDelay),[(rainStr = java.lang.String.format(%.2f, popRain))],],],[If isDebug,,],]
anySensors: [(zone = 1)][While (zone <= 16),[(zoneStr = settings.zone$zone)][If ((zoneStr && (zoneStr != Off)) && settings.sensor$zone),,],]anySensors: [(zone = 1)][While (zone <= 16),[(zoneStr = settings.zone$zone)][If ((zoneStr && (zoneStr != Off)) && settings.sensor$zone),,],]]
getDPWDays: [If (((dpw && dpw.isNumber()) && (dpw >= 1)) && (dpw <= 7)),[return state.DPWDays$dpw],],]
createDPWMap: [(state.DPWDays1 = [])][(state.DPWDays2 = [])][(state.DPWDays3 = [])][(state.DPWDays4 = [])][(state.DPWDays5 = [])][(state.DPWDays6 = [])][(state.DPWDays7 = [])][(dayDistance = [[0, 1, 2, 3, 3, 2, 1], [1, 0, 1, 2, 3, 3, 2], [2, 1, 0, 1, 2, 3, 3], [3, 2, 1, 0, 1, 2, 3], [3, 3, 2, 1, 0, 1, 2], [2, 3, 3, 2, 1, 0, 1], [1, 2, 3, 3, 2, 1, 0]])][(ndaysAvailable = this.daysAvailable())][(i = 0)][(daysAvailable = [0, 0, 0, 0, 0, 0, 0])][If settings.days,[If (settings.days.contains(Even) || settings.days.contains(Odd)),,],[If settings.days.contains(Monday),[(daysAvailable[i] = 0)],],[If settings.days.contains(Tuesday),[(daysAvailable[i] = 1)],],[If settings.days.contains(Wednesday),[(daysAvailable[i] = 2)],],[If settings.days.contains(Thursday),[(daysAvailable[i] = 3)],],[If settings.days.contains(Friday),[(daysAvailable[i] = 4)],],[If settings.days.contains(Saturday),[(daysAvailable[i] = 5)],],[If settings.days.contains(Sunday),[(daysAvailable[i] = 6)],],[If (i != ndaysAvailable),[(ndaysAvailable = i)][(state.daysAvailable = i)],],,[(daysAvailable = [0, 1, 2, 3, 4, 5, 6])]],[(maxday = -1)][(max = -1)][(dDays = [])][(runDays = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]])][For ((a = 0); (a < ndaysAvailable); (a++)),[If (((a > 0) && (ndaysAvailable >= 2)) && (a != (ndaysAvailable - 1))),[If (a == 1),[For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If (d > max),[(max = d)][(maxday = daysAvailable[c])],],][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If (d > max),[(max = d)][(maxday = daysAvailable[c])],],][(dDays[0] = maxday)],],[If (a > 1),[(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = 5)][While (max == -1),[(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],]][(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = 5)][While (max == -1),[(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],]][(dDays[(a - 1)] = maxday)],],,],[For ((b = 0); (b < 7); (b++)),[If (a == (ndaysAvailable - 1)),[(runDays[a][b] = 0)][For ((c = 0); (c < ndaysAvailable); (c++)),[If (b == daysAvailable[c]),[(runDays[a][b] = 1)],],][(runDays[a][b] = 0)][For ((c = 0); (c < ndaysAvailable); (c++)),[If (b == daysAvailable[c]),[(runDays[a][b] = 1)],],],[If (a == 0),[If (b == daysAvailable[0]),[(runDays[a][b] = 1)],[(runDays[a][b] = 0)]],,[If (b == daysAvailable[0]),[(runDays[a][b] = 1)],[(runDays[a][b] = 0)][For ((c = 0); (c < a); (c++)),[If (b == dDays[c]),[(runDays[a][b] = 1)],],][(runDays[a][b] = 0)][For ((c = 0); (c < a); (c++)),[If (b == dDays[c]),[(runDays[a][b] = 1)],],]],],],][If (((a > 0) && (ndaysAvailable >= 2)) && (a != (ndaysAvailable - 1))),[If (a == 1),[For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If (d > max),[(max = d)][(maxday = daysAvailable[c])],],][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If (d > max),[(max = d)][(maxday = daysAvailable[c])],],][(dDays[0] = maxday)],],[If (a > 1),[(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = 5)][While (max == -1),[(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],]][(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = 5)][While (max == -1),[(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],]][(dDays[(a - 1)] = maxday)],],,],[For ((b = 0); (b < 7); (b++)),[If (a == (ndaysAvailable - 1)),[(runDays[a][b] = 0)][For ((c = 0); (c < ndaysAvailable); (c++)),[If (b == daysAvailable[c]),[(runDays[a][b] = 1)],],][(runDays[a][b] = 0)][For ((c = 0); (c < ndaysAvailable); (c++)),[If (b == daysAvailable[c]),[(runDays[a][b] = 1)],],],[If (a == 0),[If (b == daysAvailable[0]),[(runDays[a][b] = 1)],[(runDays[a][b] = 0)]],,[If (b == daysAvailable[0]),[(runDays[a][b] = 1)],[(runDays[a][b] = 0)][For ((c = 0); (c < a); (c++)),[If (b == dDays[c]),[(runDays[a][b] = 1)],],][(runDays[a][b] = 0)][For ((c = 0); (c < a); (c++)),[If (b == dDays[c]),[(runDays[a][b] = 1)],],]],],],]]createDPWMap: [(state.DPWDays1 = [])][(state.DPWDays2 = [])][(state.DPWDays3 = [])][(state.DPWDays4 = [])][(state.DPWDays5 = [])][(state.DPWDays6 = [])][(state.DPWDays7 = [])][(dayDistance = [[0, 1, 2, 3, 3, 2, 1], [1, 0, 1, 2, 3, 3, 2], [2, 1, 0, 1, 2, 3, 3], [3, 2, 1, 0, 1, 2, 3], [3, 3, 2, 1, 0, 1, 2], [2, 3, 3, 2, 1, 0, 1], [1, 2, 3, 3, 2, 1, 0]])][(ndaysAvailable = this.daysAvailable())][(i = 0)][(daysAvailable = [0, 0, 0, 0, 0, 0, 0])][If settings.days,[If (settings.days.contains(Even) || settings.days.contains(Odd)),,],[If settings.days.contains(Monday),[(daysAvailable[i] = 0)],],[If settings.days.contains(Tuesday),[(daysAvailable[i] = 1)],],[If settings.days.contains(Wednesday),[(daysAvailable[i] = 2)],],[If settings.days.contains(Thursday),[(daysAvailable[i] = 3)],],[If settings.days.contains(Friday),[(daysAvailable[i] = 4)],],[If settings.days.contains(Saturday),[(daysAvailable[i] = 5)],],[If settings.days.contains(Sunday),[(daysAvailable[i] = 6)],],[If (i != ndaysAvailable),[(ndaysAvailable = i)][(state.daysAvailable = i)],],,[(daysAvailable = [0, 1, 2, 3, 4, 5, 6])]],[(maxday = -1)][(max = -1)][(dDays = [])][(runDays = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]])][For ((a = 0); (a < ndaysAvailable); (a++)),[If (((a > 0) && (ndaysAvailable >= 2)) && (a != (ndaysAvailable - 1))),[If (a == 1),[For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If (d > max),[(max = d)][(maxday = daysAvailable[c])],],][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If (d > max),[(max = d)][(maxday = daysAvailable[c])],],][(dDays[0] = maxday)],],[If (a > 1),[(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = 5)][While (max == -1),[(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],]][(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = 5)][While (max == -1),[(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],]][(dDays[(a - 1)] = maxday)],],,],[For ((b = 0); (b < 7); (b++)),[If (a == (ndaysAvailable - 1)),[(runDays[a][b] = 0)][For ((c = 0); (c < ndaysAvailable); (c++)),[If (b == daysAvailable[c]),[(runDays[a][b] = 1)],],][(runDays[a][b] = 0)][For ((c = 0); (c < ndaysAvailable); (c++)),[If (b == daysAvailable[c]),[(runDays[a][b] = 1)],],],[If (a == 0),[If (b == daysAvailable[0]),[(runDays[a][b] = 1)],[(runDays[a][b] = 0)]],,[If (b == daysAvailable[0]),[(runDays[a][b] = 1)],[(runDays[a][b] = 0)][For ((c = 0); (c < a); (c++)),[If (b == dDays[c]),[(runDays[a][b] = 1)],],][(runDays[a][b] = 0)][For ((c = 0); (c < a); (c++)),[If (b == dDays[c]),[(runDays[a][b] = 1)],],]],],],][If (((a > 0) && (ndaysAvailable >= 2)) && (a != (ndaysAvailable - 1))),[If (a == 1),[For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If (d > max),[(max = d)][(maxday = daysAvailable[c])],],][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If (d > max),[(max = d)][(maxday = daysAvailable[c])],],][(dDays[0] = maxday)],],[If (a > 1),[(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = 5)][While (max == -1),[(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],]][(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = 5)][While (max == -1),[(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],]][(dDays[(a - 1)] = maxday)],],,],[For ((b = 0); (b < 7); (b++)),[If (a == (ndaysAvailable - 1)),[(runDays[a][b] = 0)][For ((c = 0); (c < ndaysAvailable); (c++)),[If (b == daysAvailable[c]),[(runDays[a][b] = 1)],],][(runDays[a][b] = 0)][For ((c = 0); (c < ndaysAvailable); (c++)),[If (b == daysAvailable[c]),[(runDays[a][b] = 1)],],],[If (a == 0),[If (b == daysAvailable[0]),[(runDays[a][b] = 1)],[(runDays[a][b] = 0)]],,[If (b == daysAvailable[0]),[(runDays[a][b] = 1)],[(runDays[a][b] = 0)][For ((c = 0); (c < a); (c++)),[If (b == dDays[c]),[(runDays[a][b] = 1)],],][(runDays[a][b] = 0)][For ((c = 0); (c < a); (c++)),[If (b == dDays[c]),[(runDays[a][b] = 1)],],]],],],]][(state.DPWDays1 = runDays[0])][(state.DPWDays2 = runDays[1])][(state.DPWDays3 = runDays[2])][(state.DPWDays4 = runDays[3])][(state.DPWDays5 = runDays[4])][(state.DPWDays6 = runDays[5])][(state.DPWDays7 = runDays[6])]]
zoneSetPage1: [(state.app = 1)]]
zoneSetPage2: [(state.app = 2)]]
zoneSetPage3: [(state.app = 3)]]
zoneSetPage4: [(state.app = 4)]]
zoneSetPage5: [(state.app = 5)]]
zoneSetPage6: [(state.app = 6)]]
zoneSetPage7: [(state.app = 7)]]
zoneSetPage8: [(state.app = 8)]]
zoneSetPage9: [(state.app = 9)]]
zoneSetPage10: [(state.app = 10)]]
zoneSetPage11: [(state.app = 11)]]
zoneSetPage12: [(state.app = 12)]]
zoneSetPage13: [(state.app = 13)]]
zoneSetPage14: [(state.app = 14)]]
zoneSetPage15: [(state.app = 15)]]
zoneSetPage16: [(state.app = 16)]]
Starting Points: []
IT HAS STATE
--app-start--
processing step-notifier.groovy
DECLARED METHODS
setupNotifications: ]
chooseTrack: ]
songOptions: [(options = new java.util.LinkedHashSet())][If state.selectedSong?.station,[(options << state.selectedSong.station)],[If state.selectedSong?.description,[(options << state.selectedSong.description)],],],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))]]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSong: ]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@56f521c6[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@680a66dd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2dd8239[]]]]]
initialize: [(state.lastSteps = 0)][(state.steps = jawbone.currentValue(steps).toInteger())][(state.goal = jawbone.currentValue(goal).toInteger())][org.codehaus.groovy.ast.stmt.ExpressionStatement@472698d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7b7683d4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@40712ee9[org.codehaus.groovy.ast.expr.VariableExpression@2e53b094[variable: jawbone], ConstantExpression[goal], org.codehaus.groovy.ast.expr.VariableExpression@39fa8ad2[variable: goalHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@76ddd61a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3f92a84e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@cf67838[org.codehaus.groovy.ast.expr.VariableExpression@6137cf6e[variable: jawbone], ConstantExpression[steps], org.codehaus.groovy.ast.expr.VariableExpression@7942a854[variable: stepHandler]]]]][If song,,],]
goalHandler: [(goal = evt.value.toInteger())][(state.goal = goal)]]
stepHandler: [log.debug(state.steps = $state.steps)][log.debug(state.goal = $state.goal)][(steps = evt.value.toInteger())][(state.lastSteps = state.steps)][(state.steps = steps)][(stepGoal = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (settings.thresholdType == Goal),[(stepGoal = state.goal)],[(stepGoal = settings.threshold)]],[If ((state.lastSteps < stepGoal) && (state.steps >= stepGoal)),[If (settings.notificationType != None),[If location.contactBookEnabled,,[(options = [method:settings.notificationType.toLowerCase(), phone:settings.phone])]],,],[If settings.sonos,,],[If settings.hues,,],[If settings.lights,,],,],]
lightsNotification: [(state.previousLights = [:])][For (1..flashCount),]lightsNotification: [(state.previousLights = [:])][For (1..flashCount),]]
hueNotification: [(hueColor = 0)][If (color == Blue),[(hueColor = 70)],[If (color == Green),[(hueColor = 39)],[If (color == Yellow),[(hueColor = 25)],[If (color == Orange),[(hueColor = 10)],[If (color == Purple),[(hueColor = 75)],[If (color == Pink),[(hueColor = 83)],],],],],],],[(state.previousHue = [:])][log.debug(current values = $state.previousHue)][(newValue = [hue:hueColor, saturation:100, level:((java.lang.Integer -> java.lang.Integer) lightLevel) ? (java.lang.Integer -> java.lang.Integer) lightLevel : 100])][log.debug(new value = $newValue)]]
setTimer: [org.codehaus.groovy.ast.stmt.ExpressionStatement@53b8afea[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6c302a1d[object: org.codehaus.groovy.ast.expr.VariableExpression@33a3c44a[variable: log] method: ConstantExpression[debug] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5fcfca62[org.codehaus.groovy.ast.expr.GStringExpression@499ef98e[strings: [ConstantExpression[runIn ], ConstantExpression[, resetHue]] values: [org.codehaus.groovy.ast.expr.VariableExpression@24934262[variable: duration]]]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@93f432e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@288214b1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@16eedaa6[org.codehaus.groovy.ast.expr.VariableExpression@28501a4b[variable: duration], org.codehaus.groovy.ast.expr.VariableExpression@5b051a5c[variable: resetHue], org.codehaus.groovy.ast.expr.MapExpression@639aba11[org.codehaus.groovy.ast.expr.MapEntryExpression@341672e(key: ConstantExpression[overwrite], value: ConstantExpression[false])]]]]]]
resetHue: ]
sonosNotification: [If settings.song,[If settings.resumePlaying,[If settings.volume,[sonos.playTrackAndResume(state.selectedSong, settings.songDuration, settings.volume)],[sonos.playTrackAndResume(state.selectedSong, settings.songDuration)]],,[If settings.volume,[sonos.playTrackAtVolume(state.selectedSong, settings.volume)],[sonos.playTrack(state.selectedSong)]],],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing sunrise-sunset.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@ad3324b[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3872bc37[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1a87b51[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@12968227[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@144ab54[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2cfa2c4f[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6ecab872[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@48eb9836[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6c518474[org.codehaus.groovy.ast.expr.VariableExpression@11b455e5[variable: location], ConstantExpression[position], org.codehaus.groovy.ast.expr.VariableExpression@2a066689[variable: locationPositionChange]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3e3861d7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5e2a3040[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6d025d1d[org.codehaus.groovy.ast.expr.VariableExpression@74294c1a[variable: location], ConstantExpression[sunriseTime], org.codehaus.groovy.ast.expr.VariableExpression@9e2ad91[variable: sunriseTimeHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@64524dd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@79d06bbd[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@47a7a101[org.codehaus.groovy.ast.expr.VariableExpression@5bb51241[variable: location], ConstantExpression[sunsetTime], org.codehaus.groovy.ast.expr.VariableExpression@7479b626[variable: sunsetTimeHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@e8ea697[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@74dbb1ee[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[scheduleWithOffset] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@70f822e[org.codehaus.groovy.ast.expr.MethodCallExpression@3efedc6f[object: org.codehaus.groovy.ast.expr.VariableExpression@45bf6f39[variable: location] method: ConstantExpression[currentValue] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6c42f2a1[ConstantExpression[sunsetTime]]], org.codehaus.groovy.ast.expr.VariableExpression@17a703f5[variable: sunsetOffsetValue], org.codehaus.groovy.ast.expr.VariableExpression@5ff2b8ca[variable: sunsetOffsetDir], ConstantExpression[sunsetHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@618ad2aa[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1aa6e3c0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[scheduleWithOffset] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3531f3ca[org.codehaus.groovy.ast.expr.MethodCallExpression@7fcf294e[object: org.codehaus.groovy.ast.expr.VariableExpression@4867ab9f[variable: location] method: ConstantExpression[currentValue] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@65f2f9b0[ConstantExpression[sunriseTime]]], org.codehaus.groovy.ast.expr.VariableExpression@5fe7f967[variable: sunriseOffsetValue], org.codehaus.groovy.ast.expr.VariableExpression@59e43e8c[variable: sunriseOffsetDir], ConstantExpression[sunriseHandler]]]]]]
locationPositionChange: ]
sunsetTimeHandler: [org.codehaus.groovy.ast.stmt.ExpressionStatement@2caa5d7c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5e671e20[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[scheduleWithOffset] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3eabe84a[org.codehaus.groovy.ast.expr.PropertyExpression@46c3a14d[object: org.codehaus.groovy.ast.expr.VariableExpression@38fc5554[variable: evt] property: ConstantExpression[value]], org.codehaus.groovy.ast.expr.VariableExpression@5e8cda75[variable: sunsetOffsetValue], org.codehaus.groovy.ast.expr.VariableExpression@3f049056[variable: sunsetOffsetDir], ConstantExpression[sunsetHandler]]]]]]
sunriseTimeHandler: [org.codehaus.groovy.ast.stmt.ExpressionStatement@64968732[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3e1a3801[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[scheduleWithOffset] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6fd12c5[org.codehaus.groovy.ast.expr.PropertyExpression@1de0a46c[object: org.codehaus.groovy.ast.expr.VariableExpression@4d1f1ff5[variable: evt] property: ConstantExpression[value]], org.codehaus.groovy.ast.expr.VariableExpression@222afc67[variable: sunriseOffsetValue], org.codehaus.groovy.ast.expr.VariableExpression@4c2fb9dd[variable: sunriseOffsetDir], ConstantExpression[sunriseHandler]]]]]]
scheduleWithOffset: [(nextSunriseSunsetTimeDate = java.util.Date.parse(yyyy-MM-dd'T'HH:mm:ss.SSS'Z', nextSunriseSunsetTime))][(offsetTime = new java.util.Date((nextSunriseSunsetTimeDate.time + this.getOffset(offset, offsetDir))))][org.codehaus.groovy.ast.stmt.ExpressionStatement@54f4a7f0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@61a1ea2c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runOnce] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@149debbb[org.codehaus.groovy.ast.expr.VariableExpression@25cd49a4[variable: offsetTime], org.codehaus.groovy.ast.expr.VariableExpression@5477a1ca[variable: handlerName]]]]]]
sunriseHandler: [If sunriseOn,,],[If sunriseOff,,],]
sunsetHandler: [If sunsetOn,,],[If sunsetOff,,],]
changeMode: [If (newMode && (location.mode != newMode)),[If location.modes?.find({ -> ... }),,],,],]
send: [If location.contactBookEnabled,,[If (sendPushMessage != No),,],[If phoneNumber,,],],]
getLabel: ]
getOffset: [(timeOffsetMillis = this.calculateTimeOffsetMillis(offsetValue))][If (offsetDir == Before),,],]
calculateTimeOffsetMillis: [(result = 0)][If offset,,],[(before = offset.startsWith(-))][If (before || offset.startsWith(+)),[(offset = offset[(1..-1)])],],[If offset.isNumber(),[(result = java.lang.Math.round(((java.lang.Double -> java.lang.Double) offset * 60000)))],[If offset.contains(:),[(segs = offset.split(:))][(result = ((segs[0].toLong() * 3600000) + (segs[1].toLong() * 60000)))],],],[If before,[(result = result)],],]
Starting Points: []
IT HAS STATE
--app-start--
processing switch-activates-home-phrase-or-mode.groovy
DECLARED METHODS
getPref: ]
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5633dafd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5d5160e6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2eadc9f6[org.codehaus.groovy.ast.expr.VariableExpression@2903c6ff[variable: controlSwitch], ConstantExpression[switch], ConstantExpression[switchHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@61af1510[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@37af1f93[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@778d82e9[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@408e96d9[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@59901c4d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@168cd36b[org.codehaus.groovy.ast.expr.VariableExpression@d8d9199[variable: controlSwitch], ConstantExpression[switch], ConstantExpression[switchHandler]]]]]]
switchHandler: [If ((evt.value == on) && (phrase_on || onMode)),[If phrase_on,,],[If onMode,,],,[If ((evt.value == off) && (phrase_off || offMode)),[If phrase_off,,],[If offMode,,],,],],]
changeMode: [If (location.mode != newMode),[If location.modes?.find({ -> ... }),,],,],]
textAppName: [(text = Switch Activates Home Phrase or Mode)]]
textVersion: [(text = Version 1.0.1 (06/20/2015))]]
textCopyright: [(text = Copyright  2015 Michael Struck)]]
textLicense: [(text = ((((((((((Licensed under the Apache License, Version 2.0 (the 'License');  + you may not use this file except in compliance with the License. ) + You may obtain a copy of the License at) + 

) +     http://www.apache.org/licenses/LICENSE-2.0) + 

) + Unless required by applicable law or agreed to in writing, software ) + distributed under the License is distributed on an 'AS IS' BASIS, ) + WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ) + See the License for the specific language governing permissions and ) + limitations under the License.))]]
textHelp: [(text = ((Ties a Hello, Home phrase or mode to a switch's (virtual or real) on/off state. Perfect for use with IFTTT.  + Simple define a switch to be used, then tie the on/off state of the switch to a specific Hello, Home phrases or mode. ) + Connect the switch to an IFTTT action, and the Hello, Home phrase or mode will fire with the switch state change.))]]
Starting Points: []
IT HAS STATE
--app-start--
processing switch-activates-home-phrase.groovy
DECLARED METHODS
getPref: ]
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@319c3a25[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@238bfd6c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@ef1695a[org.codehaus.groovy.ast.expr.VariableExpression@58860997[variable: controlSwitch], ConstantExpression[switch], ConstantExpression[switchHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@81b5db0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7487b142[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7139bd31[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@199bc830[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4b3fe06e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@27b45ea[org.codehaus.groovy.ast.expr.VariableExpression@3e17a0a1[variable: controlSwitch], ConstantExpression[switch], ConstantExpression[switchHandler]]]]]]
switchHandler: [If (evt.value == on),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing switch-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
on: ]
off: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: switch-capability.metadata() is applicable for argument types: (switch-capability$_run_closure1) values: [switch-capability$_run_closure1@fb6097b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing switch-changes-mode.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@a518813[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@43d38654[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@75361cf6[org.codehaus.groovy.ast.expr.VariableExpression@6d303498[variable: controlSwitch], ConstantExpression[switch], ConstantExpression[switchHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6ba7383d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3419e23b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@710d89e2[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1d75e7af[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4fc142ec[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@34b27915[org.codehaus.groovy.ast.expr.VariableExpression@29eda4f8[variable: controlSwitch], ConstantExpression[switch], ConstantExpression[switchHandler]]]]]]
switchHandler: [If (evt.value == on),,],]
changeMode: [If (newMode && (location.mode != newMode)),[If location.modes?.find({ -> ... }),,],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing switch-child-device.groovy
DECLARED METHODS
on: ]
off: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: switch-child-device.metadata() is applicable for argument types: (switch-child-device$_run_closure1) values: [switch-child-device$_run_closure1@42714a7]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing switch-level-capability.groovy
DECLARED METHODS
parse: [(pairs = description.split(,))][(result = [])]]
on: ]
off: ]
setLevel: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: switch-level-capability.metadata() is applicable for argument types: (switch-level-capability$_run_closure1) values: [switch-level-capability$_run_closure1@19962194]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing sylvania-ultra-iq.groovy
DECLARED METHODS
parse: [If description?.startsWith(catchall:),[(msg = zigbee.parse(description))],[(name = (description?.startsWith(on/off: )) ? switch : null)][(value = ((name == switch)) ? (description?.endsWith( 1)) ? on : off : null)][(result = this.createEvent([name:name, value:value]))]],]
on: ]
off: ]
setLevel: [(cmds = [])][If (value == 0),,[If (device.latestValue(switch) == off),,],],[(level = this.hexString(java.lang.Math.round(((value * 255) / 100))))]]
configure: ]
hex: [(s = new java.math.BigInteger(java.lang.Math.round(value).toString()).toString(16))][While (s.size() < width),[(s = (0 + s))]]hex: [(s = new java.math.BigInteger(java.lang.Math.round(value).toString()).toString(16))][While (s.size() < width),[(s = (0 + s))]]]
getEndpointId: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: sylvania-ultra-iq.metadata() is applicable for argument types: (sylvania-ultra-iq$_run_closure1) values: [sylvania-ultra-iq$_run_closure1@ac20bb4]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing talking-alarm-clock.groovy
DECLARED METHODS
pageMain: ]
pageSetupScenarioA: ]
pageWeatherSettingsA: ]
pageSetupScenarioB: ]
pageWeatherSettingsB: ]
pageSetupScenarioC: ]
pageWeatherSettingsC: ]
pageSetupScenarioD: ]
pageWeatherSettingsD: ]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6f139fc9[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@55259aa7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@19382338[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@66420549[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@15dc339f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6cd56321[]]]]]
initialize: [If (A_alarmType == 1),,],[If (B_alarmType == 1),,],[If (C_alarmType == 1),,],[If (D_alarmType == 1),,],[If (alarmSummary && summarySonos),[org.codehaus.groovy.ast.stmt.ExpressionStatement@34acbc60[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@42b28ff1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@36061cf3[org.codehaus.groovy.ast.expr.VariableExpression@718dbd79[variable: app], org.codehaus.groovy.ast.expr.VariableExpression@20134094[variable: appTouchHandler]]]]],],[If ((((ScenarioNameA && A_timeStart) && A_sonos) && A_alarmOn) && A_alarmType),[org.codehaus.groovy.ast.stmt.ExpressionStatement@76889e60[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@706fe5c6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6c15e8c7[org.codehaus.groovy.ast.expr.VariableExpression@56380231[variable: A_timeStart], org.codehaus.groovy.ast.expr.VariableExpression@64f1fd08[variable: alarm_A]]]]][If A_musicTrack,,],,],[If ((((ScenarioNameB && B_timeStart) && B_sonos) && B_alarmOn) && B_alarmType),[org.codehaus.groovy.ast.stmt.ExpressionStatement@6b3f6585[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@282ffbf5[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3e104d4b[org.codehaus.groovy.ast.expr.VariableExpression@55e2fe3c[variable: B_timeStart], org.codehaus.groovy.ast.expr.VariableExpression@45e1aa48[variable: alarm_B]]]]][If B_musicTrack,,],,],[If ((((ScenarioNameC && C_timeStart) && C_sonos) && C_alarmOn) && C_alarmType),[org.codehaus.groovy.ast.stmt.ExpressionStatement@12c60152[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2e807c54[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6cd164a6[org.codehaus.groovy.ast.expr.VariableExpression@242a209e[variable: C_timeStart], org.codehaus.groovy.ast.expr.VariableExpression@64469d8[variable: alarm_C]]]]][If C_musicTrack,,],,],[If ((((ScenarioNameD && D_timeStart) && D_sonos) && D_alarmOn) && D_alarmType),[org.codehaus.groovy.ast.stmt.ExpressionStatement@2b8bd798[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4c18621b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@39c385d6[org.codehaus.groovy.ast.expr.VariableExpression@1cec219f[variable: D_timeStart], org.codehaus.groovy.ast.expr.VariableExpression@692e028d[variable: alarm_D]]]]][If D_musicTrack,,],,],]
alarm_A: [If ((A_mode || A_mode.contains(location.mode)) && this.getDayOk(A_day)),[If ((A_switches || A_dimmers) || A_thermostats),[(dimLevel = (java.lang.Integer -> java.lang.Integer) A_level)][If A_thermostats,[(thermostatState = A_thermostats.currentThermostatMode)][If (thermostatState == auto),,[If (thermostatState == heat),,],],,],,],[If A_phrase,,],[If (A_triggerMode && (location.mode != A_triggerMode)),[If location.modes?.find({ -> ... }),,],,],[If A_volume,,],[If ((A_alarmType == 2) || ((A_alarmType == 1) && (A_secondAlarm == 1))),[(state.fullMsgA = )][If A_wakeMsg,,],[If (((A_weatherReport || A_humidity) || A_includeTemp) || A_localTemp),,],[If (A_includeSunrise || A_includeSunset),,],[If (((A_switches || A_dimmers) || A_thermostats) && A_confirmSwitches),,],[If (A_phrase && A_confirmPhrase),,],[If (A_triggerMode && A_confirmMode),,],[(state.soundA = this.textToSpeech(state.fullMsgA, true))],],[If (A_alarmType == 1),[If ((A_secondAlarm == 1) && state.soundAlarmA),[A_sonos.playSoundAndTrack(state.soundAlarmA.uri, state.soundAlarmA.duration, state.soundA.uri)],],[If (((A_secondAlarm == 2) && state.selectedSongA) && state.soundAlarmA),[A_sonos.playSoundAndTrack(state.soundAlarmA.uri, state.soundAlarmA.duration, state.selectedSongA)],],[If A_secondAlarm,[A_sonos.playTrack(state.soundAlarmA.uri)],],,],[If (A_alarmType == 2),[If (A_secondAlarmMusic && state.selectedSongA),[A_sonos.playSoundAndTrack(state.soundA.uri, state.soundA.duration, state.selectedSongA)],[A_sonos.playTrack(state.soundA.uri)]],,],[If (A_alarmType == 3),[A_sonos.playTrack(state.selectedSongA)],],,],]
alarm_B: [If ((B_mode || B_mode.contains(location.mode)) && this.getDayOk(B_day)),[If ((B_switches || B_dimmers) || B_thermostats),[(dimLevel = (java.lang.Integer -> java.lang.Integer) B_level)][If B_thermostats,[(thermostatState = B_thermostats.currentThermostatMode)][If (thermostatState == auto),,[If (thermostatState == heat),,],],,],,],[If B_phrase,,],[If (B_triggerMode && (location.mode != B_triggerMode)),[If location.modes?.find({ -> ... }),,],,],[If B_volume,,],[If ((B_alarmType == 2) || ((B_alarmType == 1) && (B_secondAlarm == 1))),[(state.fullMsgB = )][If B_wakeMsg,,],[If (((B_weatherReport || B_humidity) || B_includeTemp) || B_localTemp),,],[If (B_includeSunrise || B_includeSunset),,],[If (((B_switches || B_dimmers) || B_thermostats) && B_confirmSwitches),,],[If (B_phrase && B_confirmPhrase),,],[If (B_triggerMode && B_confirmMode),,],[(state.soundB = this.textToSpeech(state.fullMsgB, true))],],[If (B_alarmType == 1),[If ((B_secondAlarm == 1) && state.soundAlarmB),[B_sonos.playSoundAndTrack(state.soundAlarmB.uri, state.soundAlarmB.duration, state.soundB.uri)],],[If (((B_secondAlarm == 2) && state.selectedSongB) && state.soundAlarmB),[B_sonos.playSoundAndTrack(state.soundAlarmB.uri, state.soundAlarmB.duration, state.selectedSongB)],],[If B_secondAlarm,[B_sonos.playTrack(state.soundAlarmB.uri)],],,],[If (B_alarmType == 2),[If (B_secondAlarmMusic && state.selectedSongB),[B_sonos.playSoundAndTrack(state.soundB.uri, state.soundB.duration, state.selectedSongB)],[B_sonos.playTrack(state.soundB.uri)]],,],[If (B_alarmType == 3),[B_sonos.playTrack(state.selectedSongB)],],,],]
alarm_C: [If ((C_mode || C_mode.contains(location.mode)) && this.getDayOk(C_day)),[If ((C_switches || C_dimmers) || C_thermostats),[(dimLevel = (java.lang.Integer -> java.lang.Integer) C_level)][If C_thermostats,[(thermostatState = C_thermostats.currentThermostatMode)][If (thermostatState == auto),,[If (thermostatState == heat),,],],,],,],[If C_phrase,,],[If (C_triggerMode && (location.mode != C_triggerMode)),[If location.modes?.find({ -> ... }),,],,],[If C_volume,,],[If ((C_alarmType == 2) || ((C_alarmType == 1) && (C_secondAlarm == 1))),[(state.fullMsgC = )][If C_wakeMsg,,],[If (((C_weatherReport || C_humidity) || C_includeTemp) || C_localTemp),,],[If (C_includeSunrise || C_includeSunset),,],[If (((C_switches || C_dimmers) || C_thermostats) && C_confirmSwitches),,],[If (C_phrase && C_confirmPhrase),,],[If (C_triggerMode && C_confirmMode),,],[(state.soundC = this.textToSpeech(state.fullMsgC, true))],],[If (C_alarmType == 1),[If ((C_secondAlarm == 1) && state.soundAlarmC),[C_sonos.playSoundAndTrack(state.soundAlarmC.uri, state.soundAlarmC.duration, state.soundC.uri)],],[If (((C_secondAlarm == 2) && state.selectedSongC) && state.soundAlarmC),[C_sonos.playSoundAndTrack(state.soundAlarmC.uri, state.soundAlarmC.duration, state.selectedSongC)],],[If C_secondAlarm,[C_sonos.playTrack(state.soundAlarmC.uri)],],,],[If (C_alarmType == 2),[If (C_secondAlarmMusic && state.selectedSongC),[C_sonos.playSoundAndTrack(state.soundC.uri, state.soundC.duration, state.selectedSongC)],[C_sonos.playTrack(state.soundC.uri)]],,],[If (C_alarmType == 3),[C_sonos.playTrack(state.selectedSongC)],],,],]
alarm_D: [If ((D_mode || D_mode.contains(location.mode)) && this.getDayOk(D_day)),[If ((D_switches || D_dimmers) || D_thermostats),[(dimLevel = (java.lang.Integer -> java.lang.Integer) D_level)][If D_thermostats,[(thermostatState = D_thermostats.currentThermostatMode)][If (thermostatState == auto),,[If (thermostatState == heat),,],],,],,],[If D_phrase,,],[If (D_triggerMode && (location.mode != D_triggerMode)),[If location.modes?.find({ -> ... }),,],,],[If D_volume,,],[If ((D_alarmType == 2) || ((D_alarmType == 1) && (D_secondAlarm == 1))),[(state.fullMsgD = )][If D_wakeMsg,,],[If (((D_weatherReport || D_humidity) || D_includeTemp) || D_localTemp),,],[If (D_includeSunrise || D_includeSunset),,],[If (((D_switches || D_dimmers) || D_thermostats) && D_confirmSwitches),,],[If (D_phrase && D_confirmPhrase),,],[If (D_triggerMode && D_confirmMode),,],[(state.soundD = this.textToSpeech(state.fullMsgD, true))],],[If (D_alarmType == 1),[If ((D_secondAlarm == 1) && state.soundAlarmD),[D_sonos.playSoundAndTrack(state.soundAlarmD.uri, state.soundAlarmD.duration, state.soundD.uri)],],[If (((D_secondAlarm == 2) && state.selectedSongD) && state.soundAlarmD),[D_sonos.playSoundAndTrack(state.soundAlarmD.uri, state.soundAlarmD.duration, state.selectedSongD)],],[If D_secondAlarm,[D_sonos.playTrack(state.soundAlarmD.uri)],],,],[If (D_alarmType == 2),[If (D_secondAlarmMusic && state.selectedSongD),[D_sonos.playSoundAndTrack(state.soundD.uri, state.soundD.duration, state.selectedSongD)],[D_sonos.playTrack(state.soundD.uri)]],,],[If (D_alarmType == 3),[D_sonos.playTrack(state.selectedSongD)],],,],]
appTouchHandler: [If (summaryMode || summaryMode.contains(location.mode)),[(state.summaryMsg = The following is a summary of the alarm settings. )][log.debug(Summary message = $state.summaryMsg)][(summarySound = this.textToSpeech(state.summaryMsg, true))][If summaryVolume,,],,],]
getSummary: [If (alarmOn && scenarioName),[(state.summaryMsg = $state.summaryMsg Alarm $num, $scenarioName, set for $this.parseDate(timeStart, , h:mm a), is enabled. )],[If ((summaryDisabled && alarmOn) && scenarioName),[(state.summaryMsg = $state.summaryMsg Alarm $num, $scenarioName, set for $this.parseDate(timeStart, , h:mm a), is disabled. )],[If (summaryDisabled && scenarioName),[(state.summaryMsg = $state.summaryMsg Alarm $num is not configured. )],],],],]
getDesc: [(desc = Tap to set alarm)][If timeStart,[(desc = ((Alarm set to  + this.parseDate(timeStart, , h:mm a)) +  on $sonos))][(dayListSize = (day) ? day.size() : 7)][If (day && (dayListSize < 7)),[(desc = (desc +  on))][For day,[(desc = (desc +  $dayName))][(dayListSize = (dayListSize - 1))][If dayListSize,[(desc = $desc, )],],][(desc = (desc +  on))][For day,[(desc = (desc +  $dayName))][(dayListSize = (dayListSize - 1))][If dayListSize,[(desc = $desc, )],],],[(desc = (desc +  every day))]],[If mode,[(modeListSize = mode.size())][(modePrefix =  in the following modes: )][If (modeListSize == 1),[(modePrefix =  in the following mode: )],],[(desc = (desc + $modePrefix))][For mode,[(desc = (desc + '$modeName'))][(modeListSize = (modeListSize - 1))][If modeListSize,[(desc = $desc, )],[(desc = $desc)]],][(modeListSize = mode.size())][(modePrefix =  in the following modes: )][If (modeListSize == 1),[(modePrefix =  in the following mode: )],],[(desc = (desc + $modePrefix))][For mode,[(desc = (desc + '$modeName'))][(modeListSize = (modeListSize - 1))][If modeListSize,[(desc = $desc, )],[(desc = $desc)]],],[(desc = (desc +  in all modes))]],,],]
greyOut: [(result = (((((scenario && sonos) && alarmTime) && alarmOn) && alarmType)) ? complete : )]]
greyOut1: [(result = ((((((param1 || param2) || param3) || param4) || param5) || param6)) ? complete : )]]
getWeatherDesc: [(title = ((((((param1 || param2) || param3) || param4) || param5) || param6)) ? Tap to edit weather reporting options : Tap to setup weather reporting options)]]
greyOutOption: [(result = (param) ? complete : )]]
getTitle: [(title = (scenario) ? scenario : Alarm $num not configured)]]
dimmerDesc: [(desc = (dimmer) ? Tap to edit dimmer settings : Tap to set dimmer setting)]]
thermostatDesc: [(tempText = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (heating || cooling),[If heating,[(tempText = $heating heat)],],[If cooling,[(tempText = $cooling cool)],],[If (heating && cooling),[(tempText = $heating heat / $cooling cool)],],,[(tempText = Tap to edit thermostat settings)]],[(desc = (thermostat) ? $tempText : Tap to set thermostat settings)]]
getDayOk: [(result = true)][If dayList,[(result = dayList.contains(this.getDay()))],],]
getDay: [(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))]]
parseDate: [(parseDate = )][If epoch,[(longDate = java.lang.Long.valueOf(epoch).longValue())][(parseDate = new java.util.Date(longDate).format(yyyy-MM-dd'T'HH:mm:ss.SSSZ, location.timeZone))],[(parseDate = date)]],]
getSunriseSunset: [If (location.timeZone || zipCode),[(todayDate = new java.util.Date())][(s = this.getSunriseAndSunset([zipcode:zipCode, date:todayDate]))][(riseTime = this.parseDate(, s.sunrise.time, h:mm a))][(setTime = this.parseDate(, s.sunset.time, h:mm a))][(msg = )][(currTime = this.now())][(verb1 = ((currTime >= s.sunrise.time)) ? rose : will rise)][(verb2 = ((currTime >= s.sunset.time)) ? set : will set)][If (includeSunrise && includeSunset),[(msg = The sun $verb1 this morning at $riseTime and $verb2 at $setTime. )],[If (includeSunrise && includeSunset),[(msg = The sun $verb1 this morning at $riseTime. )],[If (includeSunrise && includeSunset),[(msg = The sun $verb2 tonight at $setTime. )],],],],,[(msg = Please set the location of your hub with the SmartThings mobile app, or enter a zip code to receive sunset and sunrise information. )]],]
getGreeting: [(day = this.getDay())][(time = this.parseDate(, this.now(), h:mm a))][(month = this.parseDate(, this.now(), MMMM))][(year = this.parseDate(, this.now(), yyyy))][(dayNum = this.parseDate(, this.now(), dd))][(msg = msg.replace(%day%, day))][(msg = msg.replace(%date%, $month $dayNum, $year))][(msg = msg.replace(%time%, $time))][(msg = $msg )]]
getWeatherReport: [If (location.timeZone || zipCode),[(isMetric = (location.temperatureScale == C))][(sb = new java.lang.StringBuilder())][If includeTemp,[(current = this.getWeatherFeature(conditions, zipCode))][If isMetric,,],,],[If localTemp,,],[If humidity,,],[If weatherReport,[(weather = this.getWeatherFeature(forecast, zipCode))][If isMetric,,],,],[(msg = sb.toString())][(msg = msg.replaceAll(([0-9]+)C, $1 degrees))][(msg = msg.replaceAll(([0-9]+)F, $1 degrees))],[(msg = Please set the location of your hub with the SmartThings mobile app, or enter a zip code to receive weather forecasts.)]],]
getOnConfimation: [(msg = )][If ((switches || dimmers) && thermostats),[(msg = All switches)],],[If ((switches && dimmers) && thermostats),[(msg = All Thermostats)],],[If ((switches || dimmers) && thermostats),[(msg = All switches and thermostats)],],[(msg = $msg are now on and set. )]]
getPhraseConfirmation: [(msg = The Smart Things Hello Home phrase, $phrase, has been activated. )]]
getModeConfirmation: [(msg = The Smart Things mode is now being set to, $mode. )]]
compileMsg: [log.debug(msg = $msg)][If (scenario == 1),[(state.fullMsgA = (state.fullMsgA + $msg))],],[If (scenario == 2),[(state.fullMsgB = (state.fullMsgB + $msg))],],[If (scenario == 3),[(state.fullMsgC = (state.fullMsgC + $msg))],],[If (scenario == 4),[(state.fullMsgD = (state.fullMsgD + $msg))],],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
alarmSoundUri: [(soundUri = )][(soundLength = )]]
songOptions: [If sonos,[(options = new java.util.LinkedHashSet())][If (scenario == 1),[If state.selectedSongA?.station,[(options << state.selectedSongA.station)],[If state.selectedSongA?.description,[(options << state.selectedSongA.description)],],],,],[If (scenario == 2),[If state.selectedSongB?.station,[(options << state.selectedSongB.station)],[If state.selectedSongB?.description,[(options << state.selectedSongB.description)],],],,],[If (scenario == 3),[If state.selectedSongC?.station,[(options << state.selectedSongC.station)],[If state.selectedSongC?.description,[(options << state.selectedSongC.description)],],],,],[If (scenario == 4),[If state.selectedSongD?.station,[(options << state.selectedSongD.station)],[If state.selectedSongD?.description,[(options << state.selectedSongD.description)],],],,],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))],],]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSong: ]
textAppName: [(text = Talking Alarm Clock)]]
textVersion: [(text = Version 1.4.5 (06/17/2015))]]
textCopyright: [(text = Copyright  2015 Michael Struck)]]
textLicense: [(text = ((((((((((Licensed under the Apache License, Version 2.0 (the 'License');  + you may not use this file except in compliance with the License. ) + You may obtain a copy of the License at) + 

) +     http://www.apache.org/licenses/LICENSE-2.0) + 

) + Unless required by applicable law or agreed to in writing, software ) + distributed under the License is distributed on an 'AS IS' BASIS, ) + WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ) + See the License for the specific language governing permissions and ) + limitations under the License.))]]
textHelp: [(text = ((((((Within each alarm scenario, choose a Sonos speaker, an alarm time and alarm type along with  + switches, dimmers and thermostat to control when the alarm is triggered. Hello, Home phrases and modes can be triggered at alarm time. ) + You also have the option of setting up different alarm sounds, tracks and a personalized spoken greeting that can include a weather report. ) + Variables that can be used in the voice greeting include %day%, %time% and %date%.

) + From the main SmartApp convenience page, tapping the 'Talking Alarm Clock' icon (if enabled within the app) will ) + speak a summary of the alarms enabled or disabled without having to go into the application itself. This ) + functionality is optional and can be configured from the main setup page.))]]
Starting Points: []
IT HAS STATE
--app-start--
processing tcp-bulb.groovy
DECLARED METHODS
parse: [(results = [])][If (description == updated),,],[If (description?.name && description?.value),,],]
setBulbPower: [(state.bulbPower = value)][log.debug(In child with bulbPower of $state.bulbPower)]]
on: [(levelSetting = ((java.lang.Float -> java.lang.Float) device.latestValue(level)) ? (java.lang.Float -> java.lang.Float) device.latestValue(level) : 1.0)][(bulbPowerMax = (java.lang.Float -> java.lang.Float) device.latestValue(setBulbPower))][(calculatedPower = (bulbPowerMax * (levelSetting / 100)))][If (device.latestValue(level) == null),,],]
off: ]
levelUp: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][(step = (float) state.stepsize)][(level += step)][If (level > 100),[(level = 100)],],]
levelDown: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][(step = (float) state.stepsize)][(level -= step)][If (level < 1),[(level = 1)],],]
setLevel: [(level = (java.lang.Integer -> java.lang.Integer) value)][If ((level > 0) && (level <= 100)),,],[(levelSetting = (float) level)][(bulbPowerMax = (float) device.latestValue(setBulbPower))][(calculatedPower = (bulbPowerMax * (levelSetting / 100)))]]
poll: ]
refresh: ]
installed: ]
updated: ]
initialize: [If settings.stepsize,[(state.stepsize = 10)],[(state.stepsize = settings.stepsize)]],]
uninstalled: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tcp-bulb.metadata() is applicable for argument types: (tcp-bulb$_run_closure1) values: [tcp-bulb$_run_closure1@2af46afd]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing temperature-measurement-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: temperature-measurement-capability.metadata() is applicable for argument types: (temperature-measurement-capability$_run_closure1) values: [temperature-measurement-capability$_run_closure1@53830483]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing temperature-sensor.groovy
DECLARED METHODS
parse: [(name = this.parseName(description))][(value = this.parseValue(description))][(unit = ((name == temperature)) ? this.getTemperatureScale() : ((name == humidity)) ? % : null)][(result = this.createEvent([name:name, value:value, unit:unit]))]]
parseName: [If description?.startsWith(temperature: ),,[If description?.startsWith(humidity: ),,],],]
parseValue: [If description?.startsWith(temperature: ),,[If description?.startsWith(humidity: ),[(pct = ((description - humidity: ) - %).trim())][If pct.isNumber(),,],,],],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: temperature-sensor.metadata() is applicable for argument types: (temperature-sensor$_run_closure1) values: [temperature-sensor$_run_closure1@2ec3633f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing text-me-when-it-opens.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@574cd322[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@45c2e0a6[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@119c745c[org.codehaus.groovy.ast.expr.VariableExpression@a7ad6e5[variable: contact1], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@3b1ed14b[variable: contactOpenHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@690bc15e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1bc776b7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@475646d4[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@a0f53fc[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3db972d2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1debc91c[org.codehaus.groovy.ast.expr.VariableExpression@687e4c93[variable: contact1], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@181e72d3[variable: contactOpenHandler]]]]]]
contactOpenHandler: [If location.contactBookEnabled,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing text-me-when-theres-motion-and-im-not-here.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6c6333cd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3e47a03[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7d9ba6c[org.codehaus.groovy.ast.expr.VariableExpression@8deb645[variable: motion1], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@7dd611c8[variable: motionActiveHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@5d425813[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1702830d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6a937336[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@278667fd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@684b31de[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6b52dd31[org.codehaus.groovy.ast.expr.VariableExpression@1a2909ae[variable: motion1], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@e042c99[variable: motionActiveHandler]]]]]]
motionActiveHandler: [If (presence1.latestValue(presence) == not present),[(deltaSeconds = 10)][(timeAgo = new java.util.Date((this.now() - (1000 * deltaSeconds))))][(recentEvents = motion1.eventsSince(timeAgo))][(alreadySentSms = (recentEvents.count({ -> ... }) > 1))][If alreadySentSms,,[If location.contactBookEnabled,,],],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing the-big-switch.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1894593a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@14b0e127[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@10823d72[org.codehaus.groovy.ast.expr.VariableExpression@7cea0110[variable: master], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@468dda3e[variable: onHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5527b211[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@54cf7c6a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@78010562[org.codehaus.groovy.ast.expr.VariableExpression@50756c76[variable: master], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@38aafb53[variable: offHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1729ec00[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@67f3d192[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1c9e07c6[org.codehaus.groovy.ast.expr.VariableExpression@73010765[variable: master], ConstantExpression[level], org.codehaus.groovy.ast.expr.VariableExpression@2b10ace9[variable: dimHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@52169758[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3eda0aeb[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@459b187a[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6b4283c4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@d0865a3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@636bbbbb[org.codehaus.groovy.ast.expr.VariableExpression@7eae3764[variable: master], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@10dc7d6[variable: onHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4f668f29[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@716e431d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7e744f43[org.codehaus.groovy.ast.expr.VariableExpression@11a8042c[variable: master], ConstantExpression[switch.off], org.codehaus.groovy.ast.expr.VariableExpression@6a4ccef7[variable: offHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@69391e08[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@35eb4a3b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@64b3b1ce[org.codehaus.groovy.ast.expr.VariableExpression@6884f0d9[variable: master], ConstantExpression[level], org.codehaus.groovy.ast.expr.VariableExpression@49ec6a9f[variable: dimHandler]]]]]]
logHandler: ]
onHandler: ]
offHandler: ]
dimHandler: ]
onSwitches: [If (switches && onSwitches),,[If switches,,],],]
offSwitches: [If (switches && offSwitches),,[If switches,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing the-flasher.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@245ec1a6[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@782be4eb[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@38792286[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@34d4860f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@665522c2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@41fe8e5f[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3062f9f4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2016f509[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6f1a80fb[]]]]]
subscribe: [If contact,[org.codehaus.groovy.ast.stmt.ExpressionStatement@5a237731[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7d2998d8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6a0094c9[org.codehaus.groovy.ast.expr.VariableExpression@51a6cc2a[variable: contact], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@10fda3d0[variable: contactOpenHandler]]]]],],[If acceleration,[org.codehaus.groovy.ast.stmt.ExpressionStatement@2123064f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4f6b687e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@28cb3a25[org.codehaus.groovy.ast.expr.VariableExpression@5555ffcf[variable: acceleration], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@6cfd9a54[variable: accelerationActiveHandler]]]]],],[If motion,[org.codehaus.groovy.ast.stmt.ExpressionStatement@78c1372d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@9aa2002[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@73fb1d7f[org.codehaus.groovy.ast.expr.VariableExpression@73d4066e[variable: motion], ConstantExpression[motion.active], org.codehaus.groovy.ast.expr.VariableExpression@25d2f66[variable: motionActiveHandler]]]]],],[If mySwitch,[org.codehaus.groovy.ast.stmt.ExpressionStatement@5a2fa51f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@71945bc0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@22a0d4ea[org.codehaus.groovy.ast.expr.VariableExpression@49ede9c7[variable: mySwitch], ConstantExpression[switch.on], org.codehaus.groovy.ast.expr.VariableExpression@6ecdbab8[variable: switchOnHandler]]]]],],[If myPresence,[org.codehaus.groovy.ast.stmt.ExpressionStatement@3dd4a6fa[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@19f7222e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3f725306[org.codehaus.groovy.ast.expr.VariableExpression@3c69362a[variable: myPresence], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@2412a42b[variable: presenceHandler]]]]],],]
motionActiveHandler: ]
contactOpenHandler: ]
accelerationActiveHandler: ]
switchOnHandler: ]
presenceHandler: [If (evt.value == present),,[If (evt.value == not present),,],],]
flashLights: [(doFlash = true)][(onFor = (onFor) ? onFor : 1000)][(offFor = (offFor) ? offFor : 1000)][(numFlashes = (numFlashes) ? numFlashes : 3)][log.debug(LAST ACTIVATED IS: $state.lastActivated)][If state.lastActivated,[(elapsed = (this.now() - state.lastActivated))][(sequenceTime = ((numFlashes + 1) * (onFor + offFor)))][(doFlash = (elapsed > sequenceTime))][log.debug(DO FLASH: $doFlash, ELAPSED: $elapsed, LAST ACTIVATED: $state.lastActivated)],],[If doFlash,[(state.lastActivated = this.now())][log.debug(LAST ACTIVATED SET TO: $state.lastActivated)][(initialActionOn = switches.collect({ -> ... }))][(delay = 0)],],]
Starting Points: []
IT HAS STATE
--app-start--
processing the-gun-case-moved.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@10afe71a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@741f8dbe[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@212dfd39[org.codehaus.groovy.ast.expr.VariableExpression@a2ddf26[variable: accelerationSensor], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@65d57e4e[variable: accelerationActiveHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6daf7d37[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@23a5818e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4715ae33[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@9fc9f91[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1fac1d5c[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@108a46d6[org.codehaus.groovy.ast.expr.VariableExpression@7a8406c2[variable: accelerationSensor], ConstantExpression[acceleration.active], org.codehaus.groovy.ast.expr.VariableExpression@17690e14[variable: accelerationActiveHandler]]]]]]
accelerationActiveHandler: [(deltaSeconds = 5)][(timeAgo = new java.util.Date((this.now() - (1000 * deltaSeconds))))][(recentEvents = accelerationSensor.eventsSince(timeAgo))][(alreadySentSms = (recentEvents.count({ -> ... }) > 1))][If alreadySentSms,,[If location.contactBookEnabled,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing thermostat-auto-off.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@29a1505c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@24db6ce[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@320a8ebf[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@67b100fe[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@44b18fe4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2ba5aa7a[]]]]]
initialize: [(state.changed = false)][org.codehaus.groovy.ast.stmt.ExpressionStatement@4d3ca6c7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@22e5f96e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6a638c79[org.codehaus.groovy.ast.expr.VariableExpression@6c931d35[variable: sensors], ConstantExpression[contact], ConstantExpression[sensorChange]]]]]]
sensorChange: [If ((evt.value == open) && state.changed),[org.codehaus.groovy.ast.stmt.ExpressionStatement@44b194fe[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@49122b8f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3fe46690[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4beabeec[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3b4d50b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5b22d8a1[org.codehaus.groovy.ast.expr.VariableExpression@476ee5b3[variable: delay], ConstantExpression[turnOff]]]]],[If ((evt.value == closed) && state.changed),[(isOpen = false)][For sensors,[If ((sensor.id != evt.deviceId) && (sensor.currentValue(contact) == open)),[(isOpen = true)],],][(isOpen = false)][For sensors,[If ((sensor.id != evt.deviceId) && (sensor.currentValue(contact) == open)),[(isOpen = true)],],][If isOpen,[org.codehaus.groovy.ast.stmt.ExpressionStatement@59ed3e6c[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7cd4a4d7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@317e9c3c[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@18da4dd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@31a3f4de[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@68880c21[org.codehaus.groovy.ast.expr.VariableExpression@2dd2e270[variable: delay], ConstantExpression[restore]]]]],],,],],]
turnOff: [(state.thermostatMode = thermostat.currentValue(thermostatMode))][(state.changed = true)]]
restore: [log.debug(Setting thermostat to $state.thermostatMode)][thermostat.setThermostatMode(state.thermostatMode)][(state.changed = false)]]
Starting Points: []
IT HAS STATE
--app-start--
processing thermostat-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))][(map = this.createEvent([name:pair[0].trim(), value:pair[1].trim()]))][(result = [map])][If (map.isStateChange && (map.name in [heatingSetpoint, coolingSetpoint, thermostatMode])),[(map2 = [name:thermostatSetpoint, unit:F])][If (map.name == thermostatMode),[If (map.value == cool),[(map2.value = device.latestValue(coolingSetpoint))][log.info(THERMOSTAT, latest cooling setpoint = $map2.value)],[(map2.value = device.latestValue(heatingSetpoint))][log.info(THERMOSTAT, latest heating setpoint = $map2.value)]],,[(mode = device.latestValue(thermostatMode))][log.info(THERMOSTAT, latest mode = $mode)][If (((map.name == heatingSetpoint) && (mode == heat)) || ((map.name == coolingSetpoint) && (mode == cool))),[(map2.value = map.value)][(map2.unit = map.unit)],],],[If (map2.value != null),,],,],]
setHeatingSetpoint: ]
setCoolingSetpoint: ]
setThermostatMode: ]
setThermostatFanMode: ]
off: ]
heat: ]
emergencyHeat: ]
cool: ]
fanOn: ]
fanAuto: ]
fanCirculate: ]
poll: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: thermostat-capability.metadata() is applicable for argument types: (thermostat-capability$_run_closure1) values: [thermostat-capability$_run_closure1@3ad4a7d6]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing thermostat-window-check.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@eca6a74[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@79fd6f95[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@48840594[org.codehaus.groovy.ast.expr.VariableExpression@49c675f0[variable: thermostats], ConstantExpression[thermostatMode], org.codehaus.groovy.ast.expr.VariableExpression@14823f76[variable: thermoChange]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6917bb4[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6ed16657[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1442f788[org.codehaus.groovy.ast.expr.VariableExpression@113e13f9[variable: sensors], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@1c7f96b1[variable: windowChange]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@7979b8b7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7a04fea7[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1bc49bc5[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7b6e5c12[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4f66ffc8[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@124ac145[org.codehaus.groovy.ast.expr.VariableExpression@2def7a7a[variable: thermostats], ConstantExpression[thermostatMode], org.codehaus.groovy.ast.expr.VariableExpression@24e83d19[variable: thermoChange]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5c080ef3[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@188cbcde[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@4ee6291f[org.codehaus.groovy.ast.expr.VariableExpression@2b03d52f[variable: sensors], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@37e0292a[variable: windowChange]]]]]]
thermoChange: [If ((evt.value == heat) || (evt.value == cool)),[(open = sensors.findAll({ -> ... }))][If open,[(plural = ((open.size() > 1)) ? are : is)],],,],]
windowChange: [(heating = thermostats.findAll({ -> ... }))][(cooling = thermostats.findAll({ -> ... }))][If (heating || cooling),[(open = sensors.findAll({ -> ... }))][(tempDirection = (heating) ? heating : cooling)][(plural = ((open.size() > 1)) ? were : was)],],]
thermoShutOffTrigger: [If (turnOffTherm == Yes),[(delay = (((turnOffDelay != null) && (turnOffDelay != ))) ? (turnOffDelay * 60) : 60)][(state.turnOffTime = this.now())][org.codehaus.groovy.ast.stmt.ExpressionStatement@4af70944[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@35267fd4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@397ef2[org.codehaus.groovy.ast.expr.VariableExpression@36a6bea6[variable: delay], ConstantExpression[thermoShutOff]]]]],],]
thermoShutOff: [(open = sensors.findAll({ -> ... }))][(tempDirection = (heating) ? heating : cooling)][(plural = ((open.size() > 1)) ? are : is)][If open.size(),,],]
send: [If (sendPushMessage != No),,],[If phone,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing thermostats.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@336206d8[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5ec4ff02[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1f11f64e[]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@2b2f5fcf[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@858d8b4[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@711d1a52[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@612e21b9[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@302edb74[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribeToEvents] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7efd28bd[]]]]]
subscribeToEvents: [org.codehaus.groovy.ast.stmt.ExpressionStatement@672b72ba[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7718a40f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@312b34e3[org.codehaus.groovy.ast.expr.VariableExpression@26844abb[variable: smokeDevices], ConstantExpression[smoke.detected], org.codehaus.groovy.ast.expr.VariableExpression@1a865273[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@288ca5f0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4068102e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@44bd4b0a[org.codehaus.groovy.ast.expr.VariableExpression@6c008c24[variable: smokeDevices], ConstantExpression[smoke.tested], org.codehaus.groovy.ast.expr.VariableExpression@216e0771[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@21079a12[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@fcc6023[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@67c5ac52[org.codehaus.groovy.ast.expr.VariableExpression@36417a54[variable: smokeDevices], ConstantExpression[carbonMonoxide.detected], org.codehaus.groovy.ast.expr.VariableExpression@2b8bb184[variable: eventHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@472a11ae[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@dc79225[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@30e9ca13[org.codehaus.groovy.ast.expr.VariableExpression@46185a1b[variable: carbonMonoxideDevices], ConstantExpression[carbonMonoxide.detected], org.codehaus.groovy.ast.expr.VariableExpression@51288417[variable: eventHandler]]]]]]
eventHandler: [If frequency,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],]
sendMessage: [(msg = messageText)][(options = [:])][If messageText,[(msg = {{ triggerEvent.descriptionText }})][(options = [translatable:true, triggerEvent:evt])],],[If location.contactBookEnabled,,[If phone,[(options.phone = phone)][If (pushAndPhone != No),[(options.method = both)],[(options.method = phone)]],,[If (pushAndPhone != No),[(options.method = push)],[(options.method = none)]],],],[If frequency,[(state[evt.deviceId] = this.now())],],]
Starting Points: []
IT HAS STATE
--app-start--
processing thing.groovy
DECLARED METHODS
parse: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: thing.metadata() is applicable for argument types: (thing$_run_closure1) values: [thing$_run_closure1@4c777e7b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing three-axis-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: three-axis-capability.metadata() is applicable for argument types: (three-axis-capability$_run_closure1) values: [three-axis-capability$_run_closure1@6f49d153]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-carousel.groovy
DECLARED METHODS
installed: ]
parse: ]
evaluate: [(threshold = 1.0)][(current = device.currentValue(thermostatOperatingState))][(mode = device.currentValue(thermostatMode))][(heating = false)][(cooling = false)][(idle = false)][If (mode in [heat, emergency heat, auto]),[If ((heatingSetpoint - temp) >= threshold),[(heating = true)],[If ((temp - heatingSetpoint) >= threshold),[(idle = true)],],],,],[If (mode in [cool, auto]),[If ((temp - coolingSetpoint) >= threshold),[(cooling = true)],[If (((coolingSetpoint - temp) >= threshold) && heating),[(idle = true)],],],,],[If ((idle && heating) && cooling),,],]
setHeatingSetpoint: ]
setCoolingSetpoint: ]
setThermostatMode: ]
setThermostatFanMode: ]
off: ]
heat: ]
auto: ]
emergencyHeat: ]
cool: ]
fanOn: ]
fanAuto: ]
fanCirculate: ]
tempUp: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue + 1) : 72)]]
tempDown: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue - 1) : 72)]]
setTemperature: [(ts = device.currentState(temperature))]]
heatUp: [(ts = device.currentState(heatingSetpoint))][(value = (ts) ? (ts.integerValue + 1) : 68)]]
heatDown: [(ts = device.currentState(heatingSetpoint))][(value = (ts) ? (ts.integerValue - 1) : 68)]]
coolUp: [(ts = device.currentState(coolingSetpoint))][(value = (ts) ? (ts.integerValue + 1) : 76)]]
coolDown: [(ts = device.currentState(coolingSetpoint))][(value = (ts) ? (ts.integerValue - 1) : 76)]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-carousel.metadata() is applicable for argument types: (tile-basic-carousel$_run_closure1) values: [tile-basic-carousel$_run_closure1@78d6447a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-colorwheel.groovy
DECLARED METHODS
parse: ]
setColor: [If value.hex,,],[If value.hue,,],[If value.saturation,,],]
setSaturation: ]
setHue: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-colorwheel.metadata() is applicable for argument types: (tile-basic-colorwheel$_run_closure1) values: [tile-basic-colorwheel$_run_closure1@767191b1]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-presence.groovy
DECLARED METHODS
installed: ]
parse: ]
arrived: ]
departed: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-presence.metadata() is applicable for argument types: (tile-basic-presence$_run_closure1) values: [tile-basic-presence$_run_closure1@587a1cfb]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-slider.groovy
DECLARED METHODS
installed: ]
parse: ]
setLevel: ]
setRangedLevel: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-slider.metadata() is applicable for argument types: (tile-basic-slider$_run_closure1) values: [tile-basic-slider$_run_closure1@3d904e9c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-standard.groovy
DECLARED METHODS
installed: ]
parse: ]
on: ]
off: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-standard.metadata() is applicable for argument types: (tile-basic-standard$_run_closure1) values: [tile-basic-standard$_run_closure1@433348bc]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-value.groovy
DECLARED METHODS
installed: ]
parse: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-value.metadata() is applicable for argument types: (tile-basic-value$_run_closure1) values: [tile-basic-value$_run_closure1@476fe690]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-multiattribute-generic.groovy
DECLARED METHODS
installed: ]
parse: ]
on: ]
off: ]
setLevel: ]
randomizeLevel: [(level = java.lang.Math.round((java.lang.Math.random() * 100)))]]
levelUp: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][If (level < 100),[(level = (level + 1))],],]
levelDown: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][If (level > 0),[(level = (level - 1))],],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-generic.metadata() is applicable for argument types: (tile-multiattribute-generic$_run_closure1) values: [tile-multiattribute-generic$_run_closure1@78054f54]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-multiattribute-lighting.groovy
DECLARED METHODS
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],]
on: ]
off: ]
nextLevel: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][If (level <= 100),[(level = (java.lang.Integer -> java.lang.Integer) java.lang.Math.min((25 * (java.lang.Math.round((level / 25)) + 1)), 100))],[(level = 25)]],]
setLevel: [(power = (java.lang.Math.round((percent / 1.175)) * 0.1))]]
setSaturation: ]
setHue: ]
setColor: [If value.hue,,],[If value.saturation,,],[If value.hex,,],[If value.level,,],[If value.switch,,],]
reset: ]
setAdjustedColor: [If value,[(adjusted = (value + [:]))][(adjusted.hue = this.adjustOutgoingHue(value.hue))][(adjusted.level = null)],],]
refresh: ]
adjustOutgoingHue: [(adjusted = percent)][If (percent > 31),[If (percent < 63.0),[(adjusted = (percent + ((7 * (percent - 30)) / 32)))],[If (percent < 73.0),[(adjusted = (69 + ((5 * (percent - 62)) / 10)))],[(adjusted = (percent + ((2 * (100 - percent)) / 28)))]],],,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-lighting.metadata() is applicable for argument types: (tile-multiattribute-lighting$_run_closure1) values: [tile-multiattribute-lighting$_run_closure1@77bbadc]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-multiattribute-mediaplayer.groovy
DECLARED METHODS
installed: [(state.tracks = [Gangnam Style (?)
PSY
Psy 6 (Six Rules), Part 1, Careless Whisper
Wham!
Make It Big, Never Gonna Give You Up
Rick Astley
Whenever You Need Somebody, Shake It Off
Taylor Swift
1989, Ironic
Alanis Morissette
Jagged Little Pill, Hotline Bling
Drake
Hotline Bling - Single])][(state.currentTrack = 0)]]
parse: ]
play: [this.sendEvent([name:trackDescription, value:state.tracks[state.currentTrack]])]]
pause: [this.sendEvent([name:trackDescription, value:state.tracks[state.currentTrack]])]]
stop: ]
previousTrack: [(state.currentTrack = (state.currentTrack - 1))][If (state.currentTrack < 0),[(state.currentTrack = (state.tracks.size() - 1))],],[this.sendEvent([name:trackDescription, value:state.tracks[state.currentTrack]])]]
nextTrack: [(state.currentTrack = (state.currentTrack + 1))][If (state.currentTrack == state.tracks.size()),[(state.currentTrack = 0)],],[this.sendEvent([name:trackDescription, value:state.tracks[state.currentTrack]])]]
mute: ]
unmute: ]
setLevel: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-mediaplayer.metadata() is applicable for argument types: (tile-multiattribute-mediaplayer$_run_closure1) values: [tile-multiattribute-mediaplayer$_run_closure1@524a076e]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-multiattribute-thermostat.groovy
DECLARED METHODS
installed: ]
parse: ]
evaluate: [(threshold = 1.0)][(current = device.currentValue(thermostatOperatingState))][(mode = device.currentValue(thermostatMode))][(heating = false)][(cooling = false)][(idle = false)][If (mode in [heat, emergency heat, auto]),[If ((heatingSetpoint - temp) >= threshold),[(heating = true)],[If ((temp - heatingSetpoint) >= threshold),[(idle = true)],],],,],[If (mode in [cool, auto]),[If ((temp - coolingSetpoint) >= threshold),[(cooling = true)],[If (((coolingSetpoint - temp) >= threshold) && heating),[(idle = true)],],],,],[If (mode == off),[(idle = true)],],[If ((idle && heating) && cooling),,],]
setHeatingSetpoint: ]
setCoolingSetpoint: ]
setThermostatMode: ]
setThermostatFanMode: ]
off: ]
heat: ]
auto: ]
emergencyHeat: ]
cool: ]
fanOn: ]
fanAuto: ]
fanCirculate: ]
poll: ]
tempUp: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue + 1) : 72)]]
tempDown: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue - 1) : 72)]]
setTemperature: [(ts = device.currentState(temperature))]]
heatUp: [(ts = device.currentState(heatingSetpoint))][(value = (ts) ? (ts.integerValue + 1) : 68)]]
heatDown: [(ts = device.currentState(heatingSetpoint))][(value = (ts) ? (ts.integerValue - 1) : 68)]]
coolUp: [(ts = device.currentState(coolingSetpoint))][(value = (ts) ? (ts.integerValue + 1) : 76)]]
coolDown: [(ts = device.currentState(coolingSetpoint))][(value = (ts) ? (ts.integerValue - 1) : 76)]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-thermostat.metadata() is applicable for argument types: (tile-multiattribute-thermostat$_run_closure1) values: [tile-multiattribute-thermostat$_run_closure1@40e37b06]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-multiattribute-videoplayer.groovy
DECLARED METHODS
installed: ]
parse: ]
refresh: ]
on: ]
off: ]
setProfile: ]
setProfileHD: ]
setProfileSDH: ]
setProfileSDL: ]
start: [(dataLiveVideo = [OutHomeURL:https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/bipbop_4x3_variant.m3u8, InHomeURL:https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/bipbop_4x3_variant.m3u8, ... ])][(event = [name:stream, value:groovy.json.JsonOutput.toJson(dataLiveVideo).toString(), data:groovy.json.JsonOutput.toJson(dataLiveVideo), ... ])]]
stop: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-videoplayer.metadata() is applicable for argument types: (tile-multiattribute-videoplayer$_run_closure1) values: [tile-multiattribute-videoplayer$_run_closure1@dc4a691]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing turn-it-on-for-5-minutes.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4613311f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6540cf1d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@ec8f4b9[org.codehaus.groovy.ast.expr.VariableExpression@bc042d5[variable: contact1], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@5484117b[variable: contactOpenHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@37df14d1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7efb53af[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7724704f[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@3dfa819[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4ce94d2f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@68ab0936[org.codehaus.groovy.ast.expr.VariableExpression@3cd9aa64[variable: contact1], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@42b84286[variable: contactOpenHandler]]]]]]
contactOpenHandler: [(fiveMinuteDelay = (60 * 5))][org.codehaus.groovy.ast.stmt.ExpressionStatement@443effcb[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@74ecacc3[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[runIn] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@517a2b0[org.codehaus.groovy.ast.expr.VariableExpression@53b7ce6[variable: fiveMinuteDelay], org.codehaus.groovy.ast.expr.VariableExpression@36480b2d[variable: turnOffSwitch]]]]]]
turnOffSwitch: ]
Starting Points: []
IT HAS STATE
--app-start--
processing turn-it-on-when-im-here.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@7640a5b1[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@642f9a77[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@23f3da8b[org.codehaus.groovy.ast.expr.VariableExpression@5634d0f4[variable: presence1], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@252a8aae[variable: presenceHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@3d4e405e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@54e2fe[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@70972170[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@119aa36[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4e1a46fb[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@69fe0ed4[org.codehaus.groovy.ast.expr.VariableExpression@20ab3e3a[variable: presence1], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@6caf7803[variable: presenceHandler]]]]]]
presenceHandler: [(current = presence1.currentValue(presence))][(presenceValue = presence1.find({ -> ... }))][If presenceValue,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing turn-it-on-when-it-opens.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@518bfd90[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@317a118b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@56dfab87[org.codehaus.groovy.ast.expr.VariableExpression@715b886f[variable: contact1], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@7fb29ca9[variable: contactOpenHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1e253c9d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@350d3f4d[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@18b8d173[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@73844119[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@44f24a20[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1859e2a4[org.codehaus.groovy.ast.expr.VariableExpression@46349b95[variable: contact1], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@176996c3[variable: contactOpenHandler]]]]]]
contactOpenHandler: ]
Starting Points: []
IT HAS STATE
--app-start--
processing turn-off-with-motion.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@58f39564[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7b948f3e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2f4c2cd4[org.codehaus.groovy.ast.expr.VariableExpression@77a074b4[variable: motion1], ConstantExpression[motion], org.codehaus.groovy.ast.expr.VariableExpression@333c8791[variable: motionHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@6c0e13b7[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@22eaa86e[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@561b7d53[ConstantExpression[0 * * * * ?], ConstantExpression[scheduleCheck]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1cc680e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1dc3502b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6a1d3225[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@67e13bd0[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@50fb33a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2cae9b8[org.codehaus.groovy.ast.expr.VariableExpression@1457fde[variable: motion1], ConstantExpression[motion], org.codehaus.groovy.ast.expr.VariableExpression@6f94fb9d[variable: motionHandler]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@17fa1336[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4228bf58[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@68b9834c[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@20b9d5d5[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@671d1157[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@60c8a093[ConstantExpression[0 * * * * ?], ConstantExpression[scheduleCheck]]]]]]
motionHandler: [If (evt.value == active),[(state.inactiveAt = null)],[If (evt.value == inactive),[If state.inactiveAt,[(state.inactiveAt = this.now())],],,],],]
scheduleCheck: [log.debug(schedule check, ts = $state.inactiveAt)][If state.inactiveAt,[(elapsed = (this.now() - state.inactiveAt))][(threshold = ((1000 * 60) * minutes1))][If (elapsed >= threshold),[(state.inactiveAt = null)],],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing turn-on-only-if-i-arrive-after-sunset.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@3204e238[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@38ed139b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@a5272be[org.codehaus.groovy.ast.expr.VariableExpression@58ba5b30[variable: presence1], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@4dba773d[variable: presenceHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1d9bd4da[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4c58255[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@eac3a26[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@10b1a751[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@53cf9c99[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7b306b9f[org.codehaus.groovy.ast.expr.VariableExpression@142213d5[variable: presence1], ConstantExpression[presence], org.codehaus.groovy.ast.expr.VariableExpression@934b52f[variable: presenceHandler]]]]]]
presenceHandler: [(now = new java.util.Date())][(sunTime = this.getSunriseAndSunset())][(current = presence1.currentValue(presence))][(presenceValue = presence1.find({ -> ... }))][If (presenceValue && (now > sunTime.sunset)),,[If (presenceValue && (now < sunTime.sunset)),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing undead-early-warning.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6f911326[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@f1d0004[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6e4f263e[org.codehaus.groovy.ast.expr.VariableExpression@48b4a043[variable: contacts], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@2f5b8250[variable: contactOpenHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4821aa9f[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5f481b73[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@32130e61[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@41294371[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4996c99[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1b956cfa[org.codehaus.groovy.ast.expr.VariableExpression@315f09ef[variable: contacts], ConstantExpression[contact.open], org.codehaus.groovy.ast.expr.VariableExpression@3a66e67e[variable: contactOpenHandler]]]]]]
contactOpenHandler: ]
Starting Points: []
IT HAS STATE
--app-start--
processing unknown.groovy
DECLARED METHODS
parse: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: unknown.metadata() is applicable for argument types: (unknown$_run_closure1) values: [unknown$_run_closure1@181d8899]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing unlock-it-when-i-arrive.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6e041285[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@267dc982[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@439b15f2[org.codehaus.groovy.ast.expr.VariableExpression@3aa41da1[variable: presence1], ConstantExpression[presence.present], org.codehaus.groovy.ast.expr.VariableExpression@74fab04a[variable: presence]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@3c83468e[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@272ce069[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@3d7fb838[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@1c26273d[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3a37a501[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7a583586[org.codehaus.groovy.ast.expr.VariableExpression@3a26ec8d[variable: presence1], ConstantExpression[presence.present], org.codehaus.groovy.ast.expr.VariableExpression@17143b3b[variable: presence]]]]]]
presence: [(anyLocked = (lock1.count({ -> ... }) != lock1.size()))][If anyLocked,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing virtual-thermostat.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@2bfb6b49[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1f346ad2[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@46a145ba[org.codehaus.groovy.ast.expr.VariableExpression@7ab34619[variable: sensor], ConstantExpression[temperature], org.codehaus.groovy.ast.expr.VariableExpression@ae2db25[variable: temperatureHandler]]]]][If motion,[org.codehaus.groovy.ast.stmt.ExpressionStatement@363c4251[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7afc4db9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1a1f5f71[org.codehaus.groovy.ast.expr.VariableExpression@63884e4[variable: motion], ConstantExpression[motion], org.codehaus.groovy.ast.expr.VariableExpression@524270b8[variable: motionHandler]]]]],],]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@4acb7ecc[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@2a4f5433[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@6812fa3a[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@29149030[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@38b8b6c0[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@68868328[org.codehaus.groovy.ast.expr.VariableExpression@173a6728[variable: sensor], ConstantExpression[temperature], org.codehaus.groovy.ast.expr.VariableExpression@1a22e0ef[variable: temperatureHandler]]]]][If motion,[org.codehaus.groovy.ast.stmt.ExpressionStatement@67514bdd[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3b920bdc[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7f5538a1[org.codehaus.groovy.ast.expr.VariableExpression@72fd8a3c[variable: motion], ConstantExpression[motion], org.codehaus.groovy.ast.expr.VariableExpression@1f9f381d[variable: motionHandler]]]]],],]
temperatureHandler: [(isActive = this.hasBeenRecentMotion())][If (isActive || emergencySetpoint),,],]
motionHandler: [If (evt.value == active),[(lastTemp = sensor.currentTemperature)][If (lastTemp != null),,],,[If (evt.value == inactive),[(isActive = this.hasBeenRecentMotion())][If (isActive || emergencySetpoint),[(lastTemp = sensor.currentTemperature)][If (lastTemp != null),,],,],,],],]
evaluate: [(threshold = 1.0)][If (mode == cool),[If ((currentTemp - desiredTemp) >= threshold),,[If ((desiredTemp - currentTemp) >= threshold),,],],,[If ((desiredTemp - currentTemp) >= threshold),,[If ((currentTemp - desiredTemp) >= threshold),,],],],]
hasBeenRecentMotion: [(isActive = false)][If (motion && minutes),[(deltaMinutes = (java.lang.Long -> java.lang.Long) minutes)][If deltaMinutes,[(motionEvents = motion.eventsSince(new java.util.Date((this.now() - (60000 * deltaMinutes)))))][If motionEvents.find({ -> ... }),[(isActive = true)],],,],,[(isActive = true)]],]
Starting Points: []
IT HAS STATE
--app-start--
processing water-sensor-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: water-sensor-capability.metadata() is applicable for argument types: (water-sensor-capability$_run_closure1) values: [water-sensor-capability$_run_closure1@64db4967]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing wattvision.groovy
DECLARED METHODS
refresh: ]
parse: ]
setGraphUrl: ]
addWattvisionData: [(data = this.parseJson(json.data.toString()))][(units = (json.units) ? json.units : watts)][If (data.size() > 0),[(latestData = data[-1])],],]
sendPowerEvent: [(wattvisionDateFormat = parent.wattvisionDateFormat())][(eventData = [date:new java.util.Date().parse(wattvisionDateFormat, time), value:value, name:power, displayed:isLatest, isStateChange:isLatest, ... ])]]
parseJson: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: wattvision.metadata() is applicable for argument types: (wattvision$_run_closure1) values: [wattvision$_run_closure1@5c5d6175]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing weather-windows.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@6c841199[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@6a818392[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@489091bd[org.codehaus.groovy.ast.expr.VariableExpression@512d6e60[variable: inTemp], ConstantExpression[temperature], org.codehaus.groovy.ast.expr.VariableExpression@1de9b505[variable: temperatureHandler]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@7b122839[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3743539f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@d277579[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@5db6b845[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@378f002a[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@1afd72ef[org.codehaus.groovy.ast.expr.VariableExpression@2cc75074[variable: inTemp], ConstantExpression[temperature], org.codehaus.groovy.ast.expr.VariableExpression@445bb139[variable: temperatureHandler]]]]]]
temperatureHandler: [(currentOutTemp = null)][If outTemp,[(currentOutTemp = outTemp.latestValue(temperature))],[(currentOutTemp = this.weatherCheck())]],[(currentInTemp = evt.doubleValue)][(openWindows = sensors.findAll({ -> ... }))][(retryPeriodInMinutes = (retryPeriod) ? retryPeriod : 30)][(timeAgo = new java.util.Date((this.now() - ((1000 * 60) * retryPeriodInMinutes).toLong())))][(recentEvents = inTemp.eventsSince(timeAgo))][If ((currentInTemp > minTemp) && (currentInTemp < maxTemp)),,[If (currentInTemp > maxTemp),[(alreadyNotified = (recentEvents.count({ -> ... }) > 1))][If alreadyNotified,[If ((currentOutTemp < maxTemp) && openWindows),,[If ((currentOutTemp > maxTemp) && openWindows),,],],,],,[If (currentInTemp < minTemp),[(alreadyNotified = (recentEvents.count({ -> ... }) > 1))][If alreadyNotified,[If ((currentOutTemp > minTemp) && openWindows),,[If ((currentOutTemp < minTemp) && openWindows),,],],,],,],],],]
weatherCheck: [(json = this.getWeatherFeature(conditions, zipCode))][(currentTemp = json?.current_observation?.temp_f)][If currentTemp,,],]
send: [If (sendPushMessage != No),,],[If phone1,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing wemo-bulb.groovy
DECLARED METHODS
parse: [If description?.startsWith(catchall:),[If description?.endsWith(0100),[(result = this.createEvent([name:switch, value:on]))],],[If description?.endsWith(0000),[(result = this.createEvent([name:switch, value:off]))],],,],[If description?.startsWith(read attr),[(i = java.lang.Math.round(((this.convertHexToInt(description[(-2..-1)]) / 256) * 100)))],],]
on: ]
off: ]
refresh: ]
setLevel: [(cmds = [])][If (value == 0),,[If (device.latestValue(switch) == off),,],],[(level = this.hexString(java.lang.Math.round(((value * 255) / 100))))]]
configure: [(configCmds = [zcl global send-me-a-report 6 0 0x10 0 3600 {01}, delay 500, send 0x$device.deviceNetworkId 1 1, delay 1000, zcl global send-me-a-report 8 0 0x20 5 3600 {0010}, delay 200, send 0x$device.deviceNetworkId 1 1, delay 1500, zdo bind 0x$device.deviceNetworkId 1 1 6 {$device.zigbeeId} {}, delay 1000, zdo bind 0x$device.deviceNetworkId 1 1 8 {$device.zigbeeId} {}, delay 500])]]
hex: [(s = new java.math.BigInteger(java.lang.Math.round(value).toString()).toString(16))][While (s.size() < width),[(s = (0 + s))]]hex: [(s = new java.math.BigInteger(java.lang.Math.round(value).toString()).toString(16))][While (s.size() < width),[(s = (0 + s))]]]
convertHexToInt: ]
swapEndianHex: ]
reverseArray: [(i = 0)][(j = (array.length - 1))][(tmp = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While (j > i),[(tmp = array[j])][(array[j] = array[i])][(array[i] = tmp)]]reverseArray: [(i = 0)][(j = (array.length - 1))][(tmp = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While (j > i),[(tmp = array[j])][(array[j] = array[i])][(array[i] = tmp)]]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: wemo-bulb.metadata() is applicable for argument types: (wemo-bulb$_run_closure1) values: [wemo-bulb$_run_closure1@2b960a7]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing when-its-going-to-rain.groovy
DECLARED METHODS
installed: [org.codehaus.groovy.ast.stmt.ExpressionStatement@60e9c3a5[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@7e5843db[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@459f703f[org.codehaus.groovy.ast.expr.VariableExpression@188ac8a3[variable: time], ConstantExpression[scheduleCheck]]]]]]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@3650d4fc[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@aaa0f76[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@340a8894[]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@7a8b9166[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4acc5dff[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@10c72a6f[org.codehaus.groovy.ast.expr.VariableExpression@70e94ecb[variable: time], ConstantExpression[scheduleCheck]]]]]]
scheduleCheck: [(response = this.getWeatherFeature(forecast, zipcode))][If this.isStormy(response),[(open = sensors.findAll({ -> ... }))][If open,[If location.contactBookEnabled,,],,],,],]
isStormy: [(STORMY = [rain, snow, showers, sprinkles, precipitation])][(forecast = json?.forecast?.txt_forecast?.forecastday?.first())][If forecast,[(text = forecast?.fcttext?.toLowerCase())][If text,[(result = false)][For ((i = 0); ((i < STORMY.size()) && result); (i++)),[(result = text.contains(STORMY[i]))]][(result = false)][For ((i = 0); ((i < STORMY.size()) && result); (i++)),[(result = text.contains(STORMY[i]))]],],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing whole-house-fan.groovy
DECLARED METHODS
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@11900483[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@14a049f9[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unsubscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@94e51e8[]]]]]
initialize: [(state.fanRunning = false)][org.codehaus.groovy.ast.stmt.ExpressionStatement@5de6cf3a[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4cc36c19[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@5a3a1bf9[org.codehaus.groovy.ast.expr.VariableExpression@2100d047[variable: outTemp], ConstantExpression[temperature], ConstantExpression[checkThings]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@4af45442[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@1d805aa1[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@176f7f3b[org.codehaus.groovy.ast.expr.VariableExpression@30ca0779[variable: inTemp], ConstantExpression[temperature], ConstantExpression[checkThings]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@58740366[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@47be0f9b[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@2bc426f0[org.codehaus.groovy.ast.expr.VariableExpression@4bd51d3e[variable: thermostat], ConstantExpression[thermostatMode], ConstantExpression[checkThings]]]]][org.codehaus.groovy.ast.stmt.ExpressionStatement@33425811[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@4b74b35[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[subscribe] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@e4e1ef5[org.codehaus.groovy.ast.expr.VariableExpression@6d11ceef[variable: contacts], ConstantExpression[contact], ConstantExpression[checkThings]]]]]]
checkThings: [(outsideTemp = settings.outTemp.currentTemperature)][(insideTemp = settings.inTemp.currentTemperature)][(thermostatMode = settings.thermostat.currentThermostatMode)][(somethingOpen = ((settings.checkContacts == No) || settings.contacts?.find({ -> ... })))][(shouldRun = true)][If (thermostatMode != off),[(shouldRun = false)],],[If (insideTemp < outsideTemp),[(shouldRun = false)],],[If (insideTemp < settings.minTemp),[(shouldRun = false)],],[If somethingOpen,[(shouldRun = false)],],[If (shouldRun && state.fanRunning),[(state.fanRunning = true)],[If (shouldRun && state.fanRunning),[(state.fanRunning = false)],],],]
Starting Points: []
IT HAS STATE
--app-start--
processing working-from-home.groovy
DECLARED METHODS
configActions: ]
installed: ]
updated: [org.codehaus.groovy.ast.stmt.ExpressionStatement@37c36608[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@5d497a91[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[unschedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@617389a[]]]]]
initialize: [org.codehaus.groovy.ast.stmt.ExpressionStatement@1c8f6a90[expression:org.codehaus.groovy.ast.expr.MethodCallExpression@3050ac2f[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[schedule] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@265bd546[org.codehaus.groovy.ast.expr.MethodCallExpression@1937eaff[object: org.codehaus.groovy.ast.expr.VariableExpression@18d87d80[variable: this] method: ConstantExpression[timeToday] arguments: org.codehaus.groovy.ast.expr.ArgumentListExpression@7e0bc8a3[org.codehaus.groovy.ast.expr.VariableExpression@4b0f2299[variable: timeOfDay], org.codehaus.groovy.ast.expr.PropertyExpression@33063f5b[object: org.codehaus.groovy.ast.expr.VariableExpression@15405bd6[variable: location] property: ConstantExpression[timeZone]]]], ConstantExpression[checkPresence]]]]][If customName,,],]
checkPresence: [If (daysOk && modeOk),[If (person.latestValue(presence) == present),[(message = $location.name executed '$settings.wfhPhrase' because $person is home.)],],,],]
send: [If (sendPushMessage != No),,],[If phone,,],]
getModeOk: [(result = (modes || modes.contains(location.mode)))]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],]
hideOptions: ]
Starting Points: []
IT HAS STATE
--app-start--
processing zigbee-switch.groovy
DECLARED METHODS
parse: [(event = zigbee.getEvent(description))][If event,,],]
off: ]
on: ]
ping: ]
refresh: ]
configure: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: zigbee-switch.metadata() is applicable for argument types: (zigbee-switch$_run_closure1) values: [zigbee-switch$_run_closure1@18578491]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing zigbee-white-color-temperature-bulb.groovy
DECLARED METHODS
getMOVE_TO_COLOR_TEMPERATURE_COMMAND: ]
getCOLOR_CONTROL_CLUSTER: ]
getATTRIBUTE_COLOR_TEMPERATURE: ]
parse: [(event = zigbee.getEvent(description))][If event,[If ((event.name == level) && (event.value == 0)),,[If (event.name == colorTemperature),,],],,[(cluster = zigbee.parse(description))][If ((cluster && (cluster.clusterId == 6)) && (cluster.command == 7)),[If (cluster.data[0] == 0),,],,],],]
off: ]
on: ]
setLevel: ]
ping: ]
refresh: ]
configure: ]
setColorTemperature: [(value = (java.lang.Integer -> java.lang.Integer) value)][(tempInMired = java.lang.Math.round((1000000 / value)))][(finalHex = zigbee.swapEndianHex(zigbee.convertToHexString(tempInMired, 4)))][(cmds = [])][If ((device.getDataValue(manufacturer) == sengled) && (device.getDataValue(model) == Z01-A19NAE26)),,],]
setGenericName: [If (value != null),[(genericName = White)][If (value < 3300),[(genericName = Soft White)],[If (value < 4150),[(genericName = Moonlight)],[If (value <= 5000),[(genericName = Cool White)],[If (value >= 5000),[(genericName = Daylight)],],],],],,],]
installed: [If (((((device.getDataValue(manufacturer) == MRVL) && (device.getDataValue(model) == MZ100)) || (device.getDataValue(manufacturer) == OSRAM SYLVANIA)) || (device.getDataValue(manufacturer) == OSRAM)) || (device.getDataValue(manufacturer) == sengled)),[If ((device.currentState(level)?.value == null) || (device.currentState(level)?.value == 0)),,],,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: zigbee-white-color-temperature-bulb.metadata() is applicable for argument types: (zigbee-white-color-temperature-bulb$_run_closure1) values: [zigbee-white-color-temperature-bulb$_run_closure1@5ad5be4a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing zooz-power-strip-outlet.groovy
DECLARED METHODS
on: ]
off: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: zooz-power-strip-outlet.metadata() is applicable for argument types: (zooz-power-strip-outlet$_run_closure1) values: [zooz-power-strip-outlet$_run_closure1@cda6019]
Possible solutions: metaClass(groovy.lang.Closure)
summary
cmd overpriv:0
attr overpriv:0
num reflection:0
total:0
type2 overprivilege total:0
samename_flags:0
type2 cmd/attr uses:0
numSendSms: 0
numOAuth: 0
numInternet: 0
--app-start--
processing acceleration-sensor-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: acceleration-sensor-capability.metadata() is applicable for argument types: (acceleration-sensor-capability$_run_closure1) values: [acceleration-sensor-capability$_run_closure1@57d7f8ca]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing alarm-capability.groovy
DECLARED METHODS
strobe: ]
siren: ]
both: ]
off: ]
parse: [(pair = description.split(:))]]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: alarm-capability.metadata() is applicable for argument types: (alarm-capability$_run_closure1) values: [alarm-capability$_run_closure1@3232a28a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing app_test
DECLARED METHODS
--app-start--
processing acceleration-sensor-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: acceleration-sensor-capability.metadata() is applicable for argument types: (acceleration-sensor-capability$_run_closure1) values: [acceleration-sensor-capability$_run_closure1@57d7f8ca]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing alarm-capability.groovy
DECLARED METHODS
strobe: ]
siren: ]
both: ]
off: ]
parse: [(pair = description.split(:))]]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: alarm-capability.metadata() is applicable for argument types: (alarm-capability$_run_closure1) values: [alarm-capability$_run_closure1@3232a28a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing app_test
DECLARED METHODS
installed: [this.subscribe(people, presence, presence)]]
updated: [this.unsubscribe()][this.subscribe(people, presence, presence)]]
presence: [If (evt.value == not present),[If (location.mode != newMode),[If this.everyoneIsAway(),[this.runIn((this.findFalseAlarmThreshold() * 60), takeAction, [overwrite:false])],],,],,],]
takeAction: [If this.everyoneIsAway(),[(threshold = (((1000 * 60) * this.findFalseAlarmThreshold()) - 1000))][(awayLongEnough = people.findAll({ java.lang.Object person -> ... }))][If (awayLongEnough.size() == people.size()),[(message = SmartThings changed your mode to '$newMode' because everyone left home)],],,],]
everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],]everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],]]
send: [If location.contactBookEnabled,,[If (sendPushMessage != No),,],[If phone,,],],]
findFalseAlarmThreshold: [(((falseAlarmThreshold != null) && (falseAlarmThreshold != ))) ? falseAlarmThreshold : 10]]
Starting Points: []
--app-start--
processing arduino-thingshield.groovy
DECLARED METHODS
parse: [(value = zigbee.parse(description)?.text)][(name = ((value && (value != ping))) ? response : null)][(result = this.createEvent([name:name, value:value]))]]
Starting Points: []
missing method: groovy.lang.MissingMethodException: No signature of method: arduino-thingshield.metadata() is applicable for argument types: (arduino-thingshield$_run_closure1) values: [arduino-thingshield$_run_closure1@593aaf41]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing arrival-sensor-ha.groovy
DECLARED METHODS
updated: ]
installed: ]
configure: [(cmds = (zigbee.readAttribute(zigbee.POWER_CONFIGURATION_CLUSTER, 32) + zigbee.batteryConfig(20, 20, 1)))]]
beep: ]
parse: [(state.lastCheckin = this.now())][If description?.startsWith(read attr -),,],]
handleReportAttributeMessage: [(descMap = zigbee.parseDescriptionAsMap(description))][If ((descMap.clusterInt == 1) && (descMap.attrInt == 32)),,],]
handleBatteryEvent: [(descriptionText = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If ((volts == 0) || (volts == 255)),,[(batteryMap = [28:100, 27:100, 26:100, 25:90, 24:90, 23:70, 22:70, 21:50, 20:50, 19:30, 18:30, 17:15, 16:1, 15:0])][(minVolts = 15)][(maxVolts = 28)][If (volts < minVolts),[(volts = minVolts)],[If (volts > maxVolts),[(volts = maxVolts)],],],[(value = batteryMap[volts])][If (value != null),[(linkText = this.getLinkText(device))][(descriptionText = {{ linkText }} battery was {{ value }})][(eventMap = [name:battery, value:value, descriptionText:descriptionText, translatable:true])][log.debug(Creating battery event for voltage=$(volts / 10)V: $linkText $eventMap.name is $eventMap.value%)],],],]
handlePresenceEvent: [(wasPresent = (device.currentState(presence)?.value == present))][If (wasPresent && present),,[If present,,],],[(linkText = this.getLinkText(device))][(descriptionText = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If present,[(descriptionText = {{ linkText }} has arrived)],[(descriptionText = {{ linkText }} has left)]],[(eventMap = [name:presence, value:(present) ? present : not present, linkText:linkText, descriptionText:descriptionText, translatable:true])]]
startTimer: ]
stopTimer: [this.unschedule()]]
checkPresenceCallback: [(timeSinceLastCheckin = ((this.now() - state.lastCheckin) / 1000))][(theCheckInterval = ((checkInterval) ? (int) checkInterval : 2 * 60))][If (timeSinceLastCheckin >= theCheckInterval),,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: arrival-sensor-ha.metadata() is applicable for argument types: (arrival-sensor-ha$_run_closure1) values: [arrival-sensor-ha$_run_closure1@4dbb42b7]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing arrival-sensor.groovy
DECLARED METHODS
beep: ]
installed: ]
parse: [(results = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If this.isBatteryMessage(description),[(results = this.parseBatteryMessage(description))],[(results = this.parsePresenceMessage(description))]],]
parsePresenceMessage: [(name = this.parseName(description))][(value = this.parseValue(description))][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(handlerName = this.getState(value))][(isStateChange = this.isStateChange(device, name, value))][(results = [name:name, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName, isStateChange:isStateChange, ... ])]]
parseName: [If description?.startsWith(presence: ),,],]
parseValue: [If description?.startsWith(presence: ),[If description?.endsWith(1),,[If description?.endsWith(0),,],],,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseDescriptionText: ]
getState: [(state = value)][If (value == present),[(state = arrived)],[If (value == not present),[(state = left)],],],]
isBatteryMessage: [(description ==~ .*battery:.*rssi:.*lqi:.*)]]
parseBatteryMessage: [(results = [])][(parts = description.split(,))]]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText battery was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
getRssiResult: [(name = rssi)][(parts = part.split(:))][If (parts.size() != 2),,],[(valueString = parts[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(value = (valueInt - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]]
getLqiResult: [(name = lqi)][(parts = part.split(:))][If (parts.size() != 2),,],[(valueString = parts[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(percentageOf = 255)][(value = java.lang.Math.round(((valueInt / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText Signal (LQI) was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: arrival-sensor.metadata() is applicable for argument types: (arrival-sensor$_run_closure1) values: [arrival-sensor$_run_closure1@4b8ee4de]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing auto-humidity-vent.groovy
DECLARED METHODS
installed: [(state.app_enabled = false)][(state.fan_control_enabled = false)][(state.fansOn = false)][(state.fansOnTime = this.now())][(state.fansLastRunTime = 0)]]
uninstalled: [(state.app_enabled = false)][(state.fan_control_enabled = false)]]
updated: [this.unsubscribe()]]
initialize: [If settings.fan_control_enabled,[If (state.fan_control_enabled == false),,],[(state.fan_control_enabled = true)],[If (state.fan_control_enabled == true),,],[(state.fan_control_enabled = false)]],[If settings.app_enabled,[If (state.app_enabled == false),,],[this.subscribe(humidity_sensor, humidity, handleThings)][(state.app_enabled = true)],[If (state.app_enabled == true),,],[(state.app_enabled = false)]],]
handleThings: [If evt,,],[(h = (java.math.BigDecimal -> java.math.BigDecimal) 0.0)][If settings.app_enabled,[(h = settings.humidity_sensor.currentValue(humidity))],],[(activateFans = false)][(deactivateFans = false)][If settings.app_enabled,[If state.fansOn,[If (h > humidity_d),,[log.debug(Humidity sufficient to deactivate vent fans: $h <= $humidity_d)][(deactivateFans = true)]],,[If (h < humidity_a),,[log.debug(Humidity sufficient to activate vent fans: $h >= $humidity_a)][(activateFans = true)]],],,],[If activateFans,,],[If deactivateFans,,],]
set_fans: [If fan_state,[If (state.fansOn == false),[(state.fansOnTime = this.now())][If settings.fan_control_enabled,[If emeters,,],,],[(state.fansOn = true)],],,[If (state.fansOn == true),[(state.fansLastRunTime = (this.now() - state.fansOnTime))][(ms = new java.math.BigInteger(state.fansLastRunTime))][(seconds = (java.math.BigInteger -> java.math.BigInteger) (((java.math.BigInteger -> java.math.BigInteger) ms / 1000) % 60))][(minutes = (java.math.BigInteger -> java.math.BigInteger) (((java.math.BigInteger -> java.math.BigInteger) ms / (1000 * 60)) % 60))][(hours = (java.math.BigInteger -> java.math.BigInteger) (((java.math.BigInteger -> java.math.BigInteger) ms / ((1000 * 60) * 60)) % 24))][(days = (java.math.BigInteger -> java.math.BigInteger) ((java.math.BigInteger -> java.math.BigInteger) ms / (((1000 * 60) * 60) * 24)))][(sb = java.lang.String.format($app.label cycle: %d:%02d:%02d:%02d, days, hours, minutes, seconds))][If settings.fan_control_enabled,[If emeters,[(state.fansLastRunEnergy = emeters.currentValue(energy).sum())][(state.fansLastRunCost = ((state.fansLastRunEnergy * price_kwh) / 100.0))][this.send($app.label cycle: $state.fansLastRunEnergykWh @ $$state.fansLastRunCost)],],,],[(state.fansOn = false)][(state.fansHoldoff = this.now())],],],]
send: [If sendPushMessage,,],[If phone,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing beacon-control.groovy
DECLARED METHODS
mainPage: ]
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(beacons, presence, beaconHandler)]]
beaconHandler: [If allOk,[(data = new groovy.json.JsonSlurper().parseText(evt.data))][(beaconName = this.getBeaconName(evt))][(phoneName = this.getPhoneName(data))][If (phoneName != null),[(action = ((data.presence == 1)) ? arrived : left)][(msg = $phoneName has $action $((action == arrived)) ? at  : the $beaconName)][If (action == arrived),[(msg = this.arriveActions(msg))],[If (action == left),[(msg = this.departActions(msg))],],],[If (pushNotification || phone),[(options = [method:((pushNotification && phone)) ? both : (pushNotification) ? push : sms, phone:phone])],],,],,],]
arriveActions: [If (((arrivalPhrase || arrivalOnSwitches) || arrivalOffSwitches) || arrivalLocks),[(msg += , so)],],[If arrivalPhrase,[(msg +=  $this.prefix(executed) $arrivalPhrase.)],],[If arrivalOnSwitches,[(msg +=  $this.prefix(turned) $this.list(arrivalOnSwitches) on.)],],[If arrivalOffSwitches,[(msg +=  $this.prefix(turned) $this.list(arrivalOffSwitches) off.)],],[If arrivalLocks,[(msg +=  $this.prefix(unlocked) $this.list(arrivalLocks).)],],]
departActions: [If (((departPhrase || departOnSwitches) || departOffSwitches) || departLocks),[(msg += , so)],],[If departPhrase,[(msg +=  $this.prefix(executed) $departPhrase.)],],[If departOnSwitches,[(msg +=  $this.prefix(turned) $this.list(departOnSwitches) on.)],],[If departOffSwitches,[(msg +=  $this.prefix(turned) $this.list(departOffSwitches) off.)],],[If departLocks,[(msg +=  $this.prefix(locked) $this.list(departLocks).)],],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
prefix: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(index = ((settings.prefixIndex == null)) ? 0 : (settings.prefixIndex + 1))]]
listPhrases: ]
executePhrase: [If phraseName,,],]
getBeaconName: [(beaconName = beacons.find({ java.lang.Object b -> ... }))]]
getPhoneName: [(phoneName = phones.find({ java.lang.Object phone -> ... }))]]
hideOptionsSection: ]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(<beacon-control> modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(<beacon-control> daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(<beacon-control> timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
timeIntervalLabel: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
list: ]
Starting Points: []
IT HAS STATE
--app-start--
processing beaconthing.groovy
DECLARED METHODS
parse: ]
installed: [(emptyList = [])][(json = new groovy.json.JsonBuilder(emptyList))]]
setPresence: ]
arrived: [(theList = device.latestValue(inRange))][(inRangeList = new groovy.json.JsonSlurper().parseText(theList))][If inRangeList.contains(id),,],[(inRangeList += id)][(json = new groovy.json.JsonBuilder(inRangeList))][(friendlyList = (Nearby:  + inRangeList.join(, )))][If (inRangeList.size() == 1),,],]
left: [(theList = device.latestValue(inRange))][(inRangeList = new groovy.json.JsonSlurper().parseText(theList))][(inRangeList -= id)][(json = new groovy.json.JsonBuilder(inRangeList))][(friendlyList = (Nearby:  + inRangeList.join(, )))][If inRangeList.empty,[(friendlyList = No one is nearby)],],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: beaconthing.metadata() is applicable for argument types: (beaconthing$_run_closure1) values: [beaconthing$_run_closure1@4a883b15]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing big-turn-off.groovy
DECLARED METHODS
installed: [this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]]
updated: [this.unsubscribe()][this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]]
changedLocationMode: ]
appTouch: ]
Starting Points: []
IT HAS STATE
--app-start--
processing big-turn-on.groovy
DECLARED METHODS
installed: [this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]]
updated: [this.unsubscribe()][this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]]
changedLocationMode: ]
appTouch: ]
Starting Points: []
IT HAS STATE
--app-start--
processing bon-voyage.groovy
DECLARED METHODS
installed: [this.subscribe(people, presence, presence)]]
updated: [this.unsubscribe()][this.subscribe(people, presence, presence)]]
presence: [If (evt.value == not present),[If (location.mode != newMode),[If this.everyoneIsAway(),[this.runIn((this.findFalseAlarmThreshold() * 60), takeAction, [overwrite:false])],],,],,],]
takeAction: [If this.everyoneIsAway(),[(threshold = (((1000 * 60) * this.findFalseAlarmThreshold()) - 1000))][(awayLongEnough = people.findAll({ java.lang.Object person -> ... }))][If (awayLongEnough.size() == people.size()),[(message = SmartThings changed your mode to '$newMode' because everyone left home)],],,],]
everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],]everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],]]
send: [If location.contactBookEnabled,,[If (sendPushMessage != No),,],[If phone,,],],]
findFalseAlarmThreshold: [(((falseAlarmThreshold != null) && (falseAlarmThreshold != ))) ? falseAlarmThreshold : 10]]
Starting Points: []
IT HAS STATE
--app-start--
processing bose-soundtouch-control.groovy
DECLARED METHODS
mainPage: ]
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]]
ifUnset: [If settings[name],,],]
ifSet: [If settings[name],,],]
installed: [this.subscribeToEvents()]]
updated: [this.unsubscribe()][this.unschedule()][this.subscribeToEvents()]]
subscribeToEvents: [log.trace(subscribeToEvents())][this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,[this.schedule(timeOfDay, scheduledTimeHandler)],],]
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],]
modeChangeHandler: [If (evt.value in triggerModes),,],]
scheduledTimeHandler: ]
appTouchHandler: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
takeAction: [(options = [:])][If volume,[(options.delay = 1000)],],]
frequencyKey: ]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],]
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
timeIntervalLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing bright-when-dark-and-or-bright-after-sunset.groovy
DECLARED METHODS
configurations: ]
options: [If ((dark == true) && (sun == true)),,[If ((dark == true) && (sun == false)),,[If ((sun == true) && (dark == false)),,],],],]
installed: ]
updated: [this.unsubscribe()][this.unschedule()]]
initialize: [this.subscribe(motionSensor, motion, motionHandler)][If ((((lights != null) && (lights != )) && (dimmers != null)) && (dimmers != )),[this.subscribe(lights, switch, lightsHandler)][this.subscribe(dimmers, switch, dimmersHandler)][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[this.subscribe(lightSensor, illuminance, illuminanceHandler, [filterEvents:false])],],[If (sun == true),[this.subscribe(location, position, locationPositionChange)][this.subscribe(location, sunriseTime, sunriseSunsetTimeHandler)][this.subscribe(location, sunsetTime, sunriseSunsetTimeHandler)],[If ((dark != true) && (sun != true)),,],],,[If ((lights != null) && (lights != )),[this.subscribe(lights, switch, lightsHandler)][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[this.subscribe(lightSensor, illuminance, illuminanceHandler, [filterEvents:false])],],[If (sun == true),[this.subscribe(location, position, locationPositionChange)][this.subscribe(location, sunriseTime, sunriseSunsetTimeHandler)][this.subscribe(location, sunsetTime, sunriseSunsetTimeHandler)],[If ((dark != true) && (sun != true)),,],],,[If ((dimmers != null) && (dimmers != )),[this.subscribe(dimmers, switch, dimmersHandler)][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[this.subscribe(lightSensor, illuminance, illuminanceHandler, [filterEvents:false])],],[If (sun == true),[this.subscribe(location, position, locationPositionChange)][this.subscribe(location, sunriseTime, sunriseSunsetTimeHandler)][this.subscribe(location, sunsetTime, sunriseSunsetTimeHandler)],[If ((dark != true) && (sun != true)),,],],,],],],[If ((lights != null) && (lights != )),[If lights.currentValue(switch).toString().contains(on),[(state.lightsState = on)][log.debug(Lights $state.lightsState.)],[If lights.currentValue(switch).toString().contains(off),[(state.lightsState = off)][log.debug(Lights $state.lightsState.)],],],,],[If ((dimmers != null) && (dimmers != )),[If dimmers.currentValue(switch).toString().contains(on),[(state.dimmersState = on)][log.debug(Dimmers $state.dimmersState.)],[If dimmers.currentValue(switch).toString().contains(off),[(state.dimmersState = off)][log.debug(Dimmers $state.dimmersState.)],],],,],]
locationPositionChange: ]
sunriseSunsetTimeHandler: [(state.lastSunriseSunsetEvent = this.now())]]
motionHandler: [If (evt.value == active),[this.unschedule(turnOffLights)][this.unschedule(turnOffDimmers)][If ((dark == true) && (sun == true)),[If ((darkOk == true) && (sunOk == true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((darkOk == true) && (sunOk != true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If ((darkOk != true) && (sunOk == true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],],,[If ((dark == true) && (sun != true)),[If (darkOk == true),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],,[If ((dark != true) && (sun == true)),[If (sunOk == true),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],,[If ((dark != true) && (sun != true)),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],],],,[If (evt.value == inactive),[this.unschedule(turnOffLights)][this.unschedule(turnOffDimmers)][If ((state.lightsState != off) || (state.dimmersState != off)),[If delayMinutes,[(delay = (delayMinutes * 60))][If ((dark == true) && (sun == true)),[If ((lights != null) && (lights != )),[this.runIn(delay, turnOffLights)],],[If ((dimmers != null) && (dimmers != )),[this.runIn(delay, turnOffDimmers)],],,[If ((dark == true) && (sun != true)),[If ((lights != null) && (lights != )),[this.runIn(delay, turnOffLights)],],[If ((dimmers != null) && (dimmers != )),[this.runIn(delay, turnOffDimmers)],],,[If ((dark != true) && (sun == true)),[If ((lights != null) && (lights != )),[this.runIn(delay, turnOffLights)],],[If ((dimmers != null) && (dimmers != )),[this.runIn(delay, turnOffDimmers)],],,[If ((dark != true) && (sun != true)),[If ((lights != null) && (lights != )),[this.runIn(delay, turnOffLights)],],[If ((dimmers != null) && (dimmers != )),[this.runIn(delay, turnOffDimmers)],],,],],],],,],,[If ((state.lightsState == off) && (state.dimmersState == off)),,],],,],],]
lightsHandler: [If (evt.value == on),[this.unschedule(turnOffLights)][(state.lightsState = on)],[If (evt.value == off),[this.unschedule(turnOffLights)][(state.lightsState = off)],],],]
dimmersHandler: [If (evt.value == on),[this.unschedule(turnOffDimmers)][(state.dimmersState = on)],[If (evt.value == off),[this.unschedule(turnOffDimmers)][(state.dimmersState = off)],],],]
illuminanceHandler: [log.debug($evt.name: $evt.value, lastStatus lights: $state.lightsState, lastStatus dimmers: $state.dimmersState, motionStopTime: $state.motionStopTime)][this.unschedule(turnOffLights)][this.unschedule(turnOffDimmers)][If (evt.integerValue > 999),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,[If (evt.integerValue > (((luxLevel != null) && (luxLevel != ))) ? luxLevel : 50),[If ((lights != null) && (lights != )),,],[If ((dimmers != null) && (dimmers != )),,],,],],]
turnOnLights: [If allOk,[If (state.lightsState != on),[(state.lightsState = on)],],,],]
turnOnDimmers: [If allOk,[If (state.dimmersState != on),[(state.dimmersState = on)],],,],]
turnOffLights: [If allOk,[If (state.lightsState != off),[(state.lightsState = on)],],,],]
turnOffDimmers: [If allOk,[If (state.dimmersState != off),[(state.dimmersState = off)],],,],]
astroCheck: [(s = this.getSunriseAndSunset([zipCode:zipCode, sunriseOffset:sunriseOffset, sunsetOffset:sunsetOffset]))][(state.riseTime = s.sunrise.time)][(state.setTime = s.sunset.time)][log.debug(Sunrise: $new Date(state.riseTime)($state.riseTime), Sunset: $new Date(state.setTime)($state.setTime))]]
getDarkOk: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (((dark == true) && (lightSensor != null)) && (lightSensor != )),[(result = (lightSensor.currentIlluminance < (((luxLevel != null) && (luxLevel != ))) ? luxLevel : 50))],],[log.trace(darkOk = $result)]]
getSunOk: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (sun == true),[(t = this.now())][(result = ((t < state.riseTime) || (t > state.setTime)))],],[log.trace(sunOk = $result)]]
getSunriseOffset: [(sunriseOffsetValue) ? ((sunriseOffsetDir == Before)) ? -$sunriseOffsetValue : sunriseOffsetValue : null]]
getSunsetOffset: [(sunsetOffsetValue) ? ((sunsetOffsetDir == Before)) ? -$sunsetOffsetValue : sunsetOffsetValue : null]]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting).time)][(stop = this.timeToday(ending).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
hideOptionsSection: ]
timeIntervalLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing brighten-dark-places.groovy
DECLARED METHODS
installed: [this.subscribe(contact1, contact.open, contactOpenHandler)]]
updated: [this.unsubscribe()][this.subscribe(contact1, contact.open, contactOpenHandler)]]
contactOpenHandler: [(lightSensorState = luminance1.currentIlluminance)][log.debug(SENSOR = $lightSensorState)][If ((lightSensorState != null) && (lightSensorState < 10)),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing brighten-my-path.groovy
DECLARED METHODS
installed: [this.subscribe(motion1, motion.active, motionActiveHandler)]]
updated: [this.unsubscribe()][this.subscribe(motion1, motion.active, motionActiveHandler)]]
motionActiveHandler: ]
Starting Points: []
IT HAS STATE
--app-start--
processing button-capability.groovy
DECLARED METHODS
parse: [(results = [])][If description.startsWith(Err),[(results = this.createEvent([descriptionText:description, displayed:true]))],[(cmd = zwave.parse(description, [43:1, 128:1, 132:1]))][If cmd,[(results += this.zwaveEvent(cmd))],],[If results,[(results = [descriptionText:cmd, displayed:false])],],],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: button-capability.metadata() is applicable for argument types: (button-capability$_run_closure1) values: [button-capability$_run_closure1@742ff096]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing button-controller.groovy
DECLARED METHODS
selectButton: ]
createPage: [If ((state.numButton == pageNum) || (pageNum == 8)),[(state.installCondition = true)],],[this.dynamicPage([name:configureButton$pageNum, title:Set up button $pageNum here, nextPage:configureButton$(pageNum + 1), install:state.installCondition, ... ], this.getButtonSections(pageNum))]]
configureButton1: [(state.numButton = (buttonDevice.currentState(numberOfButtons)?.longValue) ? buttonDevice.currentState(numberOfButtons)?.longValue : 4)][log.debug(state variable numButton: $state.numButton)][(state.installCondition = false)]]
configureButton2: ]
configureButton3: ]
configureButton4: ]
configureButton5: ]
configureButton6: ]
configureButton7: ]
configureButton8: ]
getButtonSections: ]
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(buttonDevice, button, buttonEvent)]]
configured: ]
buttonConfigured: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
buttonEvent: [If allOk,[(buttonNumber = evt.data)][(value = evt.value)][log.debug(buttonEvent: $evt.name = $evt.value ($evt.data))][(recentEvents = buttonDevice.eventsSince(new java.util.Date((this.now() - 3000))).findAll({ -> ... }))][If (recentEvents.size <= 1),,],,],]
executeHandlers: [(lights = this.find(lights, buttonNumber, value))][If (lights != null),,],[(locks = this.find(locks, buttonNumber, value))][If (locks != null),,],[(sonos = this.find(sonos, buttonNumber, value))][If (sonos != null),,],[(mode = this.find(mode, buttonNumber, value))][If (mode != null),,],[(phrase = this.find(phrase, buttonNumber, value))][If (phrase != null),,],[(textMessage = this.findMsg(textMessage, buttonNumber))][(notifications = this.find(notifications, buttonNumber, value))][If notifications?.toBoolean(),,],[(phone = this.find(phone, buttonNumber, value))][If (phone != null),,],[(sirens = this.find(sirens, buttonNumber, value))][If (sirens != null),,],]
find: [(preferenceName = ((((type + _) + buttonNumber) + _) + value))][(pref = settings[preferenceName])][If (pref != null),,],]
findMsg: [(preferenceName = ((type + _) + buttonNumber))][(pref = settings[preferenceName])][If (pref != null),,],]
toggle: [log.debug(toggle: $devices = $devices*.currentValue(switch))][If devices*.currentValue(switch).contains(on),,[If devices*.currentValue(switch).contains(off),,[If devices*.currentValue(lock).contains(locked),,[If devices*.currentValue(lock).contains(unlocked),,[If devices*.currentValue(alarm).contains(off),,],],],],],]
changeMode: [log.debug(changeMode: $mode, location.mode = $location.mode, location.modes = $location.modes)][If ((location.mode != mode) && location.modes?.find({ -> ... })),,],]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location.timeZone).time)][(stop = this.timeToday(ending, location.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
hideOptionsSection: ]
timeIntervalLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing camera-power-scheduler.groovy
DECLARED METHODS
installed: ]
updated: [this.unschedule()]]
initialize: [If startTime,,],[If endTime,,],]
turnOnCamera: ]
turnOffCamera: ]
Starting Points: []
IT HAS STATE
--app-start--
processing cameras-on-when-im-away.groovy
DECLARED METHODS
installed: [log.debug(Current people = $people.collect({ -> ... }))][this.subscribe(people, presence, presence)]]
updated: [log.debug(Current people = $people.collect({ -> ... }))][this.unsubscribe()][this.subscribe(people, presence, presence)]]
presence: [If (evt.value == not present),[If this.everyoneIsAway(),[this.runIn((60 * 2), turnOn)],],,[If this.everyoneIsAway(),,],],]
turnOff: [this.unschedule(turnOn)]]
turnOn: [this.unschedule(turnOn)]]
everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],]everyoneIsAway: [(result = true)][For people,[If (person.currentPresence == present),[(result = false)][(result = false)],],]]
Starting Points: []
IT HAS STATE
--app-start--
processing carpool-notifier.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(driver, presence.present, presence)]]
presence: [If ((evt.value == present) && this.riderIsHome()),,],]
riderIsHome: [If (rider.currentPresence != present),,],[(riderState = rider.currentState(presence))][If riderState,,],[(latestState = rider.latestState(presence))][(now = new java.util.Date())][(minusFive = new java.util.Date([minutes:(now.minutes - 5)]))][If (minusFive > latestState.date),,],]
sendText: [If location.contactBookEnabled,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing centralite-thermostat.groovy
DECLARED METHODS
parse: [(result = [])][(descMap = zigbee.parseDescriptionAsMap(description))][(attrData = [[cluster:descMap.cluster, attrId:descMap.attrId, value:descMap.value]])]]
getModeMap: ]
getFanModeMap: ]
refresh: ]
getTemperature: [If (value != null),[(celsius = (java.lang.Integer.parseInt(value, 16) / 100))][If (this.getTemperatureScale() == C),,],,],]
setHeatingSetpoint: [If (degrees != null),[(temperatureScale = this.getTemperatureScale())][(degreesInteger = java.lang.Math.round(degrees))][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))],],]
setCoolingSetpoint: [If (degrees != null),[(degreesInteger = java.lang.Math.round(degrees))][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))],],]
modes: ]
setThermostatMode: [(currentMode = device.currentState(thermostatMode)?.value)][(modeOrder = this.modes())][(index = modeOrder.indexOf(currentMode))][(next = (((index >= 0) && (index < (modeOrder.size() - 1)))) ? modeOrder[(index + 1)] : modeOrder[0])]]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
setThermostatFanMode: [(currentFanMode = device.currentState(thermostatFanMode)?.value)][(returnCommand = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)]]
setThermostatMode: ]
setThermostatFanMode: ]
off: ]
cool: ]
heat: ]
emergencyHeat: ]
on: ]
fanOn: ]
auto: ]
fanAuto: ]
configure: ]
hex: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: centralite-thermostat.metadata() is applicable for argument types: (centralite-thermostat$_run_closure1) values: [centralite-thermostat$_run_closure1@8462f31]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing child-button.groovy
DECLARED METHODS
installed: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: child-button.metadata() is applicable for argument types: (child-button$_run_closure1) values: [child-button$_run_closure1@2b30a42c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing close-the-valve.groovy
DECLARED METHODS
installed: [this.subscribe(sensor, water, waterHandler)]]
updated: [this.unsubscribe()][this.subscribe(sensor, water, waterHandler)]]
waterHandler: [If (evt.value == wet),,],[If frequency,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],]
sendMessage: [(msg = (messageText) ? messageText : We closed the valve because moisture was detected)][If (phone || (pushAndPhone != No)),,],[If phone,,],[If frequency,[(state[evt.deviceId] = this.now())],],]
Starting Points: []
IT HAS STATE
--app-start--
processing co2-vent.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
initialize: [(state.active = false)][this.subscribe(sensor, carbonDioxide, handleLevel)]]
handleLevel: [(co2 = sensor.currentValue(carbonDioxide).toInteger())][log.debug(CO2 Level: $co2 / $settings.level Active: $state.active)][If ((co2 >= settings.level) && state.active),[(state.active = true)],[If ((co2 < settings.level) && state.active),[(state.active = false)],],],]
Starting Points: []
IT HAS STATE
--app-start--
processing coffee-after-shower.groovy
DECLARED METHODS
installed: [this.subscribe(bathroom, humidity, coffeeMaker)]]
updated: [this.unsubscribe()][this.subscribe(bathroom, humidity, coffeeMaker)]]
coffeeMaker: [If (shower.value.toInteger() > relHum),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing color-coordinator.groovy
DECLARED METHODS
mainPage: ]
installed: ]
updated: [this.unsubscribe()]]
init: [this.subscribe(master, switch, onOffHandler)][this.subscribe(master, level, colorHandler)][this.subscribe(master, hue, colorHandler)][this.subscribe(master, saturation, colorHandler)][this.subscribe(master, colorTemperature, tempHandler)]]
onOffHandler: [If (slaves && master),[If slaves?.id.find({ -> ... }),[If (master?.currentValue(switch) == on),[If randomYes,,],,],,],,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
colorHandler: [If (slaves && master),[If (slaves?.id?.find({ -> ... }) && (master?.currentValue(switch) == on)),[(dimLevel = master?.currentValue(level))][(hueLevel = master?.currentValue(hue))][(saturationLevel = master.currentValue(saturation))][(newValue = [hue:hueLevel, saturation:saturationLevel, level:(java.lang.Integer -> java.lang.Integer) dimLevel])],],,],]
getRandomColorMaster: [(hueLevel = java.lang.Math.floor((java.lang.Math.random() * 1000)))][(saturationLevel = java.lang.Math.floor((java.lang.Math.random() * 100)))][(dimLevel = master?.currentValue(level))][(newValue = [hue:hueLevel, saturation:saturationLevel, level:(java.lang.Integer -> java.lang.Integer) dimLevel])]]
tempHandler: [If (slaves && master),[If (slaves?.id?.find({ -> ... }) && (master?.currentValue(switch) == on)),[If (evt.value != --),[(tempLevel = master.currentValue(colorTemperature))],],,],,],]
textAppName: [(text = Color Coordinator)]]
textVersion: [(text = Version 1.1.1 (12/13/2016))]]
textCopyright: [(text = Copyright  2016 Michael Struck)]]
textLicense: [(text = ((((((((((Licensed under the Apache License, Version 2.0 (the 'License');  + you may not use this file except in compliance with the License. ) + You may obtain a copy of the License at) + 

) +     http://www.apache.org/licenses/LICENSE-2.0) + 

) + Unless required by applicable law or agreed to in writing, software ) + distributed under the License is distributed on an 'AS IS' BASIS, ) + WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ) + See the License for the specific language governing permissions and ) + limitations under the License.))]]
textHelp: [(text = ((This application will allow you to control the settings of multiple colored lights with one control.  + Simply choose a master control light, and then choose the lights that will follow the settings of the master, ) + including on/off conditions, hue, saturation, level and color temperature. Also includes a random color feature.))]]
Starting Points: []
IT HAS STATE
--app-start--
processing contact-sensor-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: contact-sensor-capability.metadata() is applicable for argument types: (contact-sensor-capability$_run_closure1) values: [contact-sensor-capability$_run_closure1@5745ca0e]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing coopboss-h3vx.groovy
DECLARED METHODS
parse: [(map = [:])][If description?.startsWith(catchall:),[(map = this.parseCatchAllMessage(description))],[If description?.startsWith(read attr -),[(map = this.parseReportAttributeMessage(description))],[If (description?.startsWith(temperature: ) || description?.startsWith(humidity: )),[(map = this.parseCustomMessage(description))],],],],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseCatchAllMessage: [(resultMap = [:])][(cluster = zigbee.parse(description))][If (cluster.clusterId == 1026),,],[If ((cluster.clusterId == 257) && (cluster.command == 11)),,],]
parseReportAttributeMessage: [(resultMap = [:])][(descMap = this.parseDescriptionAsMap(description))][If ((descMap.cluster == 0101) && (descMap.attrId == 0003)),[(resultMap.name = doorState)][If (descMap.value == 00),[(resultMap.value = unknown)],[If (descMap.value == 01),[(resultMap.value = closed)],[If (descMap.value == 02),[(resultMap.value = open)],[If (descMap.value == 03),[(resultMap.value = jammed)],[If (descMap.value == 04),[(resultMap.value = forced close)],[If (descMap.value == 05),[(resultMap.value = forced close)],[If (descMap.value == 06),[(resultMap.value = closing)],[If (descMap.value == 07),[(resultMap.value = opening)],[If (descMap.value == 08),[(resultMap.value = fault)],[(resultMap.value = unknown)]],],],],],],],],],[(resultMap.descriptionText = Door State Changed to $resultMap.value)],[If ((descMap.cluster == 0101) && (descMap.attrId == 0400)),[(resultMap.name = currentLightLevel)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.displayed = false)],[If ((descMap.cluster == 0101) && (descMap.attrId == 0401)),[(resultMap.name = closeLightLevel)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0402)),[(resultMap.name = openLightLevel)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0403)),[(resultMap.name = autoCloseEnable)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 0404)),[(resultMap.name = autoOpenEnable)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 0405)),[(resultMap.name = doorCurrent)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.value = (resultMap.value * 0.001))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0408)),[(resultMap.name = doorSensitivity)][(resultMap.value = (100 - java.lang.Integer.parseInt(descMap.value, 16)))],[If ((descMap.cluster == 0101) && (descMap.attrId == 0409)),[(resultMap.name = baseDoorCurrent)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.value = (resultMap.value * 0.001))],[If ((descMap.cluster == 0101) && (descMap.attrId == 040a)),[(resultMap.name = doorVoltage)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))][(resultMap.value = (resultMap.value * 0.001))],[If ((descMap.cluster == 0101) && (descMap.attrId == 040b)),[(resultMap.name = Aux1)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 040c)),[(resultMap.name = Aux2)][If (descMap.value == 01),[(resultMap.value = on)],[(resultMap.value = off)]],,[If ((descMap.cluster == 0101) && (descMap.attrId == 040d)),[(resultMap.name = photoCalibration)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],[If ((descMap.cluster == 0101) && (descMap.attrId == 040e)),[(resultMap.name = baseCurrentNE)][(resultMap.value = java.lang.Integer.parseInt(descMap.value, 16))],],],],],],],],],],],],],],],]
parseCustomMessage: [(resultMap = [:])][If description?.startsWith(temperature: ),[(resultMap.name = temperature)][(rawT = (description - temperature: ).trim())][(resultMap.descriptionText = Temperature celsius value = $rawT)][(rawTint = java.lang.Float.parseFloat(rawT))][If (rawTint > 65),[(resultMap.name = null)][(resultMap.value = null)][(resultMap.descriptionText = Temperature celsius value = $rawT is invalid not updating)][log.warn(Invalid temperature value detected! rawT = $rawT, description = $description)],[If (rawT == -32768),[(resultMap.value = ERR)],[(resultMap.value = (java.lang.Float -> java.lang.Float) this.celsiusToFahrenheit(rawT.toFloat()))]],],,],[(resultMap.displayed = false)][log.info(Temperature reported = $resultMap.value)]]
parseDescriptionAsMap: ]
getFahrenheit: [(celsius = java.lang.Integer.parseInt(value, 16))]]
callUpdateStatusTxt: [(cTemp = device.currentState(TempProb1)?.value)][(cLight = 0)][(testNull = device.currentState(currentLightLevel)?.value)][If (testNull != null),[(cLight = (int) device.currentState(currentLightLevel)?.value)],],]
updateStatusTxt: [(cTmp = currentTemp)][(cLL = 10)][(oLL = 10)][(testNull = device.currentState(closeLightLevel)?.value)][If (testNull != null),[(cLL = (int) device.currentState(closeLightLevel)?.value)],],[(testNull = device.currentState(openLightLevel)?.value)][If (testNull != null),[(oLL = (int) device.currentState(openLightLevel)?.value)],],[(aOpnEn = device.currentState(autoOpenEnable)?.value)][(aClsEn = device.currentState(autoCloseEnable)?.value)][If (currentLight < cLL),[If (aOpnEn == on),,],,[If (aClsEn == on),,],],]
on: ]
off: ]
close: ]
open: ]
Aux1On: [log.debug(Sending Aux1 = on command)]]
Aux1Off: [log.debug(Sending Aux1 = off command)]]
Aux2On: [log.debug(Sending Aux2 = on command)]]
Aux2Off: [log.debug(Sending Aux2 = off command)]]
openDoor: ]
closeDoor: ]
closeDoorHiI: ]
autoOpenOn: ]
autoOpenOff: ]
autoCloseOn: ]
autoCloseOff: ]
setOpenLevelTo: [(cX = cValue)][log.debug(Setting Open Light Level to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]]
setCloseLevelTo: [(cX = cValue)][log.debug(Setting Close Light Level to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]]
setSensitivityLevel: [(cX = (100 - cValue))][log.debug(Setting Door sensitivity level to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]]
setNewBaseCurrent: [(cX = (int) cValue)][log.info(Setting new BaseCurrent to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]]
setNewPhotoCalibration: [(cX = (int) cValue)][log.info(Setting new Photoresister calibration to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]]
readNewPhotoCalibration: [(cmd = [])]]
readBaseCurrentNE: [(cmd = [])]]
setBaseCurrentNE: [(cX = (int) cValue)][log.info(Setting new base Current Never Exceed to $cX Hex = 0x$Integer.toHexString(cX))][(cmd = [])]]
poll: [(cmd = [])]]
updateTemp1: [(cmd = [])]]
updateTemp2: [(cmd = [])]]
updateSun: [(cmd = [])]]
updateSensitivity: [(cmd = [])]]
updateCloseLightLevel: [(cmd = [])]]
updateOpenLightLevel: [(cmd = [])]]
refresh: [(cmd = [])]]
configure: [(cmd = [])]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: coopboss-h3vx.metadata() is applicable for argument types: (coopboss-h3vx$_run_closure1) values: [coopboss-h3vx$_run_closure1@333d4a8c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing curling-iron.groovy
DECLARED METHODS
installed: [this.subscribeToEvents()]]
updated: [this.unsubscribe()][this.subscribeToEvents()]]
subscribeToEvents: [this.subscribe(motionSensors, motion.active, motionActive)][this.subscribe(motionSensors, motion.inactive, motionInactive)][this.subscribe(presenceSensors, presence.not present, notPresent)]]
motionActive: [If this.anyHere(),,],]
motionInactive: [If this.allQuiet(),,],]
notPresent: [If this.anyHere(),,],]
allQuiet: [(result = true)][For motionSensors,[If (it.currentMotion == active),[(result = false)][(result = false)],],]allQuiet: [(result = true)][For motionSensors,[If (it.currentMotion == active),[(result = false)][(result = false)],],]]
anyHere: [(result = true)][For presenceSensors,[If (it.currentPresence == not present),[(result = false)][(result = false)],],]anyHere: [(result = true)][For presenceSensors,[If (it.currentPresence == not present),[(result = false)][(result = false)],],]]
outletsOn: [this.unschedule(scheduledTurnOff)]]
outletsOff: [(delay = (minutes * 60))][this.runIn(delay, scheduledTurnOff)]]
scheduledTurnOff: [this.unschedule(scheduledTurnOff)]]
Starting Points: [this.unschedule(scheduledTurnOff)]
IT HAS STATE
--app-start--
processing darken-behind-me.groovy
DECLARED METHODS
installed: [this.subscribe(motion1, motion.inactive, motionInactiveHandler)]]
updated: [this.unsubscribe()][this.subscribe(motion1, motion.inactive, motionInactiveHandler)]]
motionInactiveHandler: ]
Starting Points: []
IT HAS STATE
--app-start--
processing device-tile-controller.groovy
DECLARED METHODS
defaultPage: ]
installed: ]
uninstalled: ]
updated: [this.unsubscribe()]]
initializeDevices: ]
labelMap: ]
Starting Points: []
IT HAS STATE
--app-start--
processing door-jammed-notification.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(doorSensor, doorState, coopDoorStateHandler)]]
coopDoorStateHandler: [If (evt.value == jammed),[(msg = WARNING $doorSensor.displayName door is jammed and did not close!)][If location.contactBookEnabled,,[If phone,,],],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing door-knocker.groovy
DECLARED METHODS
mainPage: ]
installed: ]
updated: [this.unsubscribe()]]
init: [(state.lastClosed = 0)][this.subscribe(knockSensor, acceleration.active, handleEvent)][this.subscribe(openSensor, contact.closed, doorClosed)]]
doorClosed: [(state.lastClosed = this.now())]]
doorKnock: [If ((openSensor.latestValue(contact) == closed) && ((this.now() - (60 * 1000)) > state.lastClosed)),[(kSensor = (knockSensor.label) ? knockSensor.label : knockSensor.name)],],]
handleEvent: [(delay = (knockDelay) ? knockDelay : 5)][this.runIn(delay, doorKnock)]]
send: [If (sendPushMessage != No),,],[If phone,,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: door-knocker.include() is applicable for argument types: (java.lang.String) values: [localization]
Possible solutions: installed(), evaluate(java.lang.String)
--app-start--
processing door-lock-code-distress-message.groovy
DECLARED METHODS
installed: [this.subscribe(lock1, lock, checkCode)]]
updated: [this.unsubscribe()][this.subscribe(lock1, lock, checkCode)]]
checkCode: [If ((evt.value == unlocked) && evt.data),[(lockData = new groovy.json.JsonSlurper().parseText(evt.data))][If discoveryMode,,],[If ((lockData.usedCode == distressCode) && (discoveryMode == false)),,],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing door-shield.groovy
DECLARED METHODS
parse: [(value = zigbee.parse(description)?.text)][(name = ((value && (value != ping))) ? response : null)][(result = this.createEvent([name:name, value:value]))]]
open: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: door-shield.metadata() is applicable for argument types: (door-shield$_run_closure1) values: [door-shield$_run_closure1@38145825]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing door-state-to-color-light-hue-bulb.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(doorSensor, doorState, coopDoorStateHandler)]]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
coopDoorStateHandler: [(color = White)][(hueColor = 100)][(saturation = 100)][(hClr = [:])][(hClr.hex = #FFFFFF)]]
Starting Points: []
IT HAS STATE
--app-start--
processing double-tap.groovy
DECLARED METHODS
installed: [this.subscribe(master, switch, switchHandler, [filterEvents:false])]]
updated: [this.unsubscribe()][this.subscribe(master, switch, switchHandler, [filterEvents:false])]]
switchHandler: [(recentStates = master.eventsSince(new java.util.Date((this.now() - 4000)), [all:true, max:10]).findAll({ -> ... }))][If evt.physical,[If ((evt.value == on) && this.lastTwoStatesWere(on, recentStates, evt)),,[If ((evt.value == off) && this.lastTwoStatesWere(off, recentStates, evt)),,],],,],]
onSwitches: ]
offSwitches: ]
lastTwoStatesWere: [(result = false)][If states,[(onOff = states.findAll({ -> ... }))][If onOff[0].date.before(evt.date),[log.warn(Last state does not reflect current event, evt.date: $evt.dateCreated, state.date: $onOff[0].dateCreated)][(result = ((evt.value == value) && (onOff[0].value == value)))],[(result = (((onOff.size() > 1) && (onOff[0].value == value)) && (onOff[1].value == value)))]],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing dry-the-wetspot.groovy
DECLARED METHODS
installed: [this.subscribe(sensor, water.dry, waterHandler)][this.subscribe(sensor, water.wet, waterHandler)]]
updated: [this.unsubscribe()][this.subscribe(sensor, water.dry, waterHandler)][this.subscribe(sensor, water.wet, waterHandler)]]
waterHandler: [If (evt.value == wet),,[If (evt.value == dry),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing ecobee-sensor.groovy
DECLARED METHODS
refresh: ]
poll: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: ecobee-sensor.metadata() is applicable for argument types: (ecobee-sensor$_run_closure1) values: [ecobee-sensor$_run_closure1@2235eaab]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing ecobee-thermostat.groovy
currentState, arg not ConstantExpression
currentState, arg not ConstantExpression
DECLARED METHODS
installed: ]
ping: [(isAlive = ((device.currentValue(deviceAlive) == true)) ? true : false)][If isAlive,,],]
parse: ]
refresh: ]
poll: ]
generateEvent: [If results,[(linkText = this.getLinkText(device))][(supportedThermostatModes = [off])][(thermostatMode = null)][(locationScale = this.getTemperatureScale())][If (state.supportedThermostatModes != supportedThermostatModes),[(state.supportedThermostatModes = supportedThermostatModes)],],[If thermostatMode,[this.sendEvent([name:thermostatMode, value:thermostatMode, data:[supportedThermostatModes:state.supportedThermostatModes], linkText:linkText, ... ])],],,],]
getThermostatDescriptionText: [If (name == temperature),,[If (name == heatingSetpoint),,[If (name == coolingSetpoint),,[If (name == thermostatMode),,[If (name == thermostatFanMode),,[If (name == humidity),,[return $name = $value]],],],],],],]
setHeatingSetpoint: [If setpoint,[(state.heatingSetpoint = setpoint.toDouble())][this.runIn(2, updateSetpoints, [overwrite:true])],],]
setCoolingSetpoint: [If setpoint,[(state.coolingSetpoint = setpoint.toDouble())][this.runIn(2, updateSetpoints, [overwrite:true])],],]
updateSetpoints: [(deviceScale = F)][(data = [targetHeatingSetpoint:null, targetCoolingSetpoint:null])][(heatingSetpoint = this.getTempInLocalScale(heatingSetpoint))][(coolingSetpoint = this.getTempInLocalScale(coolingSetpoint))][If state.heatingSetpoint,[(data = this.enforceSetpointLimits(heatingSetpoint, [targetValue:state.heatingSetpoint, heatingSetpoint:heatingSetpoint, coolingSetpoint:coolingSetpoint]))],],[If state.coolingSetpoint,[(heatingSetpoint = (data.targetHeatingSetpoint) ? this.getTempInLocalScale(data.targetHeatingSetpoint, deviceScale) : heatingSetpoint)][(coolingSetpoint = (data.targetCoolingSetpoint) ? this.getTempInLocalScale(data.targetCoolingSetpoint, deviceScale) : coolingSetpoint)][(data = this.enforceSetpointLimits(coolingSetpoint, [targetValue:state.coolingSetpoint, heatingSetpoint:heatingSetpoint, coolingSetpoint:coolingSetpoint]))],],[(state.heatingSetpoint = null)][(state.coolingSetpoint = null)]]
resumeProgram: [this.sendEvent([name:thermostat, value:resuming schedule, description:statusText, displayed:false])][(deviceId = device.deviceNetworkId.split(\.).last())][If parent.resumeProgram(deviceId),,],[this.runIn(5, refresh, [overwrite:true])]]
modes: [return state.supportedThermostatModes]]
fanModes: ]
switchMode: [(currentMode = device.currentValue(thermostatMode))][(modeOrder = this.modes())][If modeOrder,[(next = { -> ... })][(nextMode = next.call(currentMode))],],]
switchToMode: [(deviceId = device.deviceNetworkId.split(\.).last())][If parent.setMode(((mode == emergency heat)) ? auxHeatOnly : mode, deviceId),,],[this.runIn(5, refresh, [overwrite:true])]]
switchFanMode: [(currentFanMode = device.currentValue(thermostatFanMode))][(fanModeOrder = this.fanModes())][(next = { -> ... })]]
switchToFanMode: [(heatingSetpoint = this.getTempInDeviceScale(heatingSetpoint))][(coolingSetpoint = this.getTempInDeviceScale(coolingSetpoint))][(deviceId = device.deviceNetworkId.split(\.).last())][(sendHoldType = (holdType) ? ((holdType == Temporary)) ? nextTransition : indefinite : indefinite)][If parent.setFanMode(heatingSetpoint, coolingSetpoint, deviceId, sendHoldType, fanMode),,],[this.runIn(5, refresh, [overwrite:true])]]
getDataByName: ]
setThermostatMode: [(supportedModes = this.modes())][If supportedModes,[(mode = mode.toLowerCase())][(modeIdx = supportedModes.indexOf(mode))][If (modeIdx < 0),,],[(mode = supportedModes[modeIdx])],],]
setThermostatFanMode: [(mode = mode.toLowerCase())][(supportedFanModes = this.fanModes())][(modeIdx = supportedFanModes.indexOf(mode))][If (modeIdx < 0),,],[(mode = supportedFanModes[modeIdx])]]
generateModeEvent: ]
generateFanModeEvent: ]
generateOperatingStateEvent: ]
off: ]
heat: ]
emergencyHeat: ]
cool: ]
auto: ]
fanOn: ]
fanAuto: ]
fanCirculate: ]
generateSetpointEvent: [(mode = device.currentValue(thermostatMode))][(setpoint = this.getTempInLocalScale(heatingSetpoint))][(coolingSetpoint = this.getTempInLocalScale(coolingSetpoint))][If (mode == cool),[(setpoint = coolingSetpoint)],[If ((mode == auto) || (mode == off)),[(setpoint = this.roundC(((setpoint + coolingSetpoint) / 2)))],],],]
raiseHeatingSetpoint: ]
lowerHeatingSetpoint: ]
raiseCoolSetpoint: ]
lowerCoolSetpoint: ]
alterSetpoint: [If (device.currentValue(thermostatMode) == off),,],[(locationScale = this.getTemperatureScale())][(deviceScale = F)][(heatingSetpoint = this.getTempInLocalScale(heatingSetpoint))][(coolingSetpoint = this.getTempInLocalScale(coolingSetpoint))][(targetValue = ((setpoint == heatingSetpoint)) ? heatingSetpoint : coolingSetpoint)][(delta = ((locationScale == F)) ? 1 : 0.5)][(targetValue += (raise) ? delta : delta)][(data = this.enforceSetpointLimits(setpoint, [targetValue:targetValue, heatingSetpoint:heatingSetpoint, coolingSetpoint:coolingSetpoint], raise))][If data.targetHeatingSetpoint,,],[If data.targetCoolingSetpoint,,],[this.runIn(5, updateSetpoint, [data:data, overwrite:true])]]
enforceSetpointLimits: [(locationScale = this.getTemperatureScale())][(minSetpoint = ((setpoint == heatingSetpoint)) ? device.getDataValue(minHeatingSetpointFahrenheit) : device.getDataValue(minCoolingSetpointFahrenheit))][(maxSetpoint = ((setpoint == heatingSetpoint)) ? device.getDataValue(maxHeatingSetpointFahrenheit) : device.getDataValue(maxCoolingSetpointFahrenheit))][(minSetpoint = (minSetpoint) ? java.lang.Double.parseDouble(minSetpoint) : ((setpoint == heatingSetpoint)) ? 45 : 65)][(maxSetpoint = (maxSetpoint) ? java.lang.Double.parseDouble(maxSetpoint) : ((setpoint == heatingSetpoint)) ? 79 : 92)][(deadband = (deadbandSetting) ? deadbandSetting : 5)][(delta = ((locationScale == F)) ? 1 : 0.5)][(targetValue = this.getTempInDeviceScale(data.targetValue, locationScale))][(heatingSetpoint = this.getTempInDeviceScale(data.heatingSetpoint, locationScale))][(coolingSetpoint = this.getTempInDeviceScale(data.coolingSetpoint, locationScale))][If (targetValue > maxSetpoint),[(targetValue = maxSetpoint)],[If (targetValue < minSetpoint),[(targetValue = minSetpoint)],[If ((raise != null) && (((setpoint == heatingSetpoint) && (targetValue == heatingSetpoint)) || ((setpoint == coolingSetpoint) && (targetValue == coolingSetpoint)))),[(targetValue += (raise) ? delta : delta)],],],],[If (setpoint == heatingSetpoint),[(heatingSetpoint = targetValue)][(coolingSetpoint = (((heatingSetpoint + deadband) > coolingSetpoint)) ? (heatingSetpoint + deadband) : coolingSetpoint)],],[If (setpoint == coolingSetpoint),[(coolingSetpoint = targetValue)][(heatingSetpoint = (((coolingSetpoint - deadband) < heatingSetpoint)) ? (coolingSetpoint - deadband) : heatingSetpoint)],],]
updateSetpoint: [(deviceId = device.deviceNetworkId.split(\.).last())][(sendHoldType = (holdType) ? ((holdType == Temporary)) ? nextTransition : indefinite : indefinite)][If parent.setHold(data.targetHeatingSetpoint, data.targetCoolingSetpoint, deviceId, sendHoldType),,],[this.runIn(5, refresh, [overwrite:true])]]
generateStatusEvent: [(mode = device.currentValue(thermostatMode))][(heatingSetpoint = device.currentValue(heatingSetpoint))][(coolingSetpoint = device.currentValue(coolingSetpoint))][(temperature = device.currentValue(temperature))][(statusText = Right Now: Idle)][(operatingState = idle)][If ((mode == heat) || (mode == emergency heat)),[If (temperature < heatingSetpoint),[(statusText = Heating to $heatingSetpoint$location.temperatureScale)][(operatingState = heating)],],,[If (mode == cool),[If (temperature > coolingSetpoint),[(statusText = Cooling to $coolingSetpoint$location.temperatureScale)][(operatingState = cooling)],],,[If (mode == auto),[If (temperature < heatingSetpoint),[(statusText = Heating to $heatingSetpoint$location.temperatureScale)][(operatingState = heating)],[If (temperature > coolingSetpoint),[(statusText = Cooling to $coolingSetpoint$location.temperatureScale)][(operatingState = cooling)],],],,[If (mode == off),[(statusText = Right Now: Off)],[(statusText = ?)]],],],],]
generateActivityFeedsEvent: ]
getTempInLocalScale: [(temp = device.currentState(state))][(scaledTemp = this.convertTemperatureIfNeeded(temp.value.toBigDecimal(), temp.unit).toDouble())][return ((this.getTemperatureScale() == F)) ? scaledTemp.round(0).toInteger() : this.roundC(scaledTemp)]]
getTempInLocalScale: [(scaledTemp = this.convertTemperatureIfNeeded(temp.toBigDecimal(), scale).toDouble())][return ((this.getTemperatureScale() == F)) ? scaledTemp.round(0).toInteger() : this.roundC(scaledTemp)]]
getTempInDeviceScale: [(temp = device.currentState(state))][If ((temp && temp.value) && temp.unit),,],]
getTempInDeviceScale: [If (temp && scale),[return ((F == scale)) ? temp : this.celsiusToFahrenheit(temp).toDouble().round(0).toInteger()],],]
roundC: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: ecobee-thermostat.metadata() is applicable for argument types: (ecobee-thermostat$_run_closure1) values: [ecobee-thermostat$_run_closure1@7d9f158f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing elder-care-daily-routine.groovy
DECLARED METHODS
installed: [this.schedule(time1, scheduleCheck)]]
updated: [this.unsubscribe()][this.unschedule()][this.schedule(time1, scheduleCheck)]]
scheduleCheck: [If (this.noRecentContact() && this.noRecentMotion()),[(person = (person1) ? person1 : your elder)][(msg = Alert! There has been no activity at $person's place $timePhrase)][If location.contactBookEnabled,,[If phone1,,],],,],]
noRecentMotion: [If motion1,[(motionEvents = motion1.eventsSince(sinceTime))][If motionEvents.find({ -> ... }),,],,],]
noRecentContact: [If contact1,[(contactEvents = contact1.eventsSince(sinceTime))][If contactEvents.find({ -> ... }),,],,],]
getSinceTime: [If time0,,],]
getTimePhrase: [(interval = (this.now() - sinceTime.time))][If (interval < 3600000),,[If (interval < 7200000),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing elder-care-slip-fall.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
initialize: [(state.active = 0)][this.subscribe(bedroomMotion, motion.active, bedroomActive)][this.subscribe(bathroomMotion, motion.active, bathroomActive)]]
bedroomActive: [(start = this.timeToday(startTime, location?.timeZone))][(stop = this.timeToday(stopTime, location?.timeZone))][(now = new java.util.Date())][log.debug(bedroomActive, status: $state.ststus, start: $start, stop: $stop, now: $now)][If (state.status == waiting),[this.unschedule(sendMessage)][(state.status = null)],[If (start.before(now) && stop.after(now)),[(state.status = pending)],],],]
bathroomActive: [log.debug(bathroomActive, status: $state.status)][If (state.status == pending),[(delay = (threshold.toInteger() * 60))][(state.status = waiting)][log.debug(runIn($delay))][this.runIn(delay, sendMessage)],],]
sendMessage: [(msg = warnMessage)][If location.contactBookEnabled,,[If phone1,,],[If phone2,,],[If phone3,,],],[(state.status = null)]]
Starting Points: []
IT HAS STATE
--app-start--
processing energy-alerts.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(meter, power, meterHandler)]]
meterHandler: [(meterValue = (double) evt.value)][If atomicState.lastValue,[(atomicState.lastValue = meterValue)],],[(lastValue = (double) atomicState.lastValue)][(atomicState.lastValue = meterValue)][(dUnit = (evt.unit) ? evt.unit : Watts)][(aboveThresholdValue = (int) aboveThreshold)][If (meterValue > aboveThresholdValue),[If (lastValue < aboveThresholdValue),[(msg = $meter reported $evt.value $dUnit which is above your threshold of $aboveThreshold.)],],,],[(belowThresholdValue = (int) belowThreshold)][If (meterValue < belowThresholdValue),[If (lastValue > belowThresholdValue),[(msg = $meter reported $evt.value $dUnit which is below your threshold of $belowThreshold.)],],,],]
sendMessage: [If location.contactBookEnabled,,[If sms,,],[If pushNotification,,],],]
Starting Points: []
IT HAS ATOMICSTATE
--app-start--
processing energy-saver.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(meter, power, meterHandler)]]
meterHandler: [(meterValue = (double) evt.value)][(thresholdValue = (int) threshold)][If (meterValue > thresholdValue),,],]
Starting Points: []
IT HAS ATOMICSTATE
--app-start--
processing enhanced-auto-lock-door.groovy
DECLARED METHODS
mainPage: ]
installed: ]
updated: [this.unsubscribe()][this.unschedule()]]
initialize: [this.subscribe(lock1, lock, doorHandler, [filterEvents:false])][this.subscribe(lock1, unlock, doorHandler, [filterEvents:false])][this.subscribe(contact, contact.open, doorHandler)][this.subscribe(contact, contact.closed, doorHandler)]]
lockDoor: [If location.contactBookEnabled,[If recipients,,],,],[If phoneNumber,,],]
unlockDoor: [If location.contactBookEnabled,[If recipients,,],,],[If phoneNumber,,],]
doorHandler: [If ((contact.latestValue(contact) == open) && (evt.value == locked)),[this.runIn(secondsLater, unlockDoor)],[If ((contact.latestValue(contact) == open) && (evt.value == unlocked)),[this.unschedule(unlockDoor)],[If ((contact.latestValue(contact) == closed) && (evt.value == locked)),[this.unschedule(lockDoor)],[If ((contact.latestValue(contact) == closed) && (evt.value == unlocked)),[this.runIn((minutesLater * 60), lockDoor)],[If ((lock1.latestValue(lock) == unlocked) && (evt.value == open)),[this.unschedule(lockDoor)],[If ((lock1.latestValue(lock) == unlocked) && (evt.value == closed)),[this.runIn((minutesLater * 60), lockDoor)],[If location.contactBookEnabled,[If recipients,,],,],[If phoneNumber,,],],],],],],],]
Starting Points: [this.runIn(secondsLater, unlockDoor), this.unschedule(unlockDoor), this.unschedule(lockDoor), this.runIn((minutesLater * 60), lockDoor), this.unschedule(lockDoor), this.runIn((minutesLater * 60), lockDoor)]
IT HAS ATOMICSTATE
--app-start--
processing every-element.groovy
DECLARED METHODS
firstPage: ]
inputPage: ]
inputBooleanPage: ]
inputIconPage: ]
inputImagePage: ]
optionsGroup: [(group = [values:[], order:groups.size()])][(group.title = (title) ? title : )]]
addValues: [(lastGroup = groups[-1])]]
listToMap: ]
addGroup: [If (values instanceof java.util.List),[(values = this.listToMap(values))],],]
addGroup: ]
inputSelectionPage: [(englishOptions = [One, Two, Three])][(spanishOptions = [Uno, Dos, Tres])][(groupedOptions = [])]]
inputTextPage: ]
inputTimePage: ]
inputDevicePage: ]
inputCapabilityPage: ]
inputRoomPage: ]
inputModePage: ]
inputHubPage: ]
inputContactBookPage: ]
appPage: ]
labelPage: ]
modePage: ]
paragraphPage: ]
hrefPage: ]
buttonsPage: ]
imagePage: ]
videoPage: ]
flattenedPage: [(allSections = [])][(flattenedPage = this.dynamicPage([name:flattenedPage, title:All elements in one page!], { -> ... }))][(flattenedPage.sections = allSections)]]
foo: ]
installed: ]
updated: [this.unsubscribe()]]
initialize: ]
Starting Points: []
IT HAS ATOMICSTATE
--app-start--
processing feed-my-pet.groovy
DECLARED METHODS
installed: [this.schedule(time1, scheduleCheck)]]
updated: [this.unschedule()][this.schedule(time1, scheduleCheck)]]
scheduleCheck: [log.trace(scheduledFeeding)]]
Starting Points: [log.trace(scheduledFeeding)]
IT HAS ATOMICSTATE
--app-start--
processing fidure-thermostat.groovy
DECLARED METHODS
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
getMin: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
getMax: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parse: [(result = [])][If description?.startsWith(read attr -),[(descMap = this.parseDescriptionAsMap(description))][For descMap.attrs,[(map = [:])][If (descMap.cluster == 0201),,[If (descMap.cluster == 0204),[If (atMap.attrId == 0001),[(map.name = lockLevel)][(map.value = this.getLockMap()[atMap.value])],],,],],[If map,[(result += this.createEvent(map))],],][(descMap = this.parseDescriptionAsMap(description))][For descMap.attrs,[(map = [:])][If (descMap.cluster == 0201),,[If (descMap.cluster == 0204),[If (atMap.attrId == 0001),[(map.name = lockLevel)][(map.value = this.getLockMap()[atMap.value])],],,],],[If map,[(result += this.createEvent(map))],],],],]
parseDescriptionAsMap: [(map = (description - read attr - ).split(,).inject([:], { java.lang.Object map, java.lang.Object param -> ... }))][(attrId = map.get(attrId))][(encoding = map.get(encoding))][(value = map.get(value))][(result = map.get(result))][(list = [])][If (this.getDataLengthByType(map.get(encoding)) < map.get(value).length()),[(raw = map.get(raw))][(size = java.lang.Long.parseLong(( + map.get(size)), 16))][(index = 12)][(len = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While ((index - 12) < size),[(attrId = this.flipHexStringEndianness(raw[(index..(index + 3))]))][(index += 4)][If (result == success),[(index += 2)],],[(encoding = raw[(index..(index + 1))])][(index += 2)][(len = this.getDataLengthByType(encoding))][(value = this.flipHexStringEndianness(raw[(index..((index + len) - 1))]))][(index += len)][(list += [attrId:$attrId, encoding:$encoding, value:$value])]][(raw = map.get(raw))][(size = java.lang.Long.parseLong(( + map.get(size)), 16))][(index = 12)][(len = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While ((index - 12) < size),[(attrId = this.flipHexStringEndianness(raw[(index..(index + 3))]))][(index += 4)][If (result == success),[(index += 2)],],[(encoding = raw[(index..(index + 1))])][(index += 2)][(len = this.getDataLengthByType(encoding))][(value = this.flipHexStringEndianness(raw[(index..((index + len) - 1))]))][(index += len)][(list += [attrId:$attrId, encoding:$encoding, value:$value])]],[(list += [attrId:$attrId, encoding:$encoding, value:$value])]],[(map += [attrs:list])]]
flipHexStringEndianness: [(s = s.reverse())][(sb = new java.lang.StringBuilder())][For ((i = 0); (i < (s.length() - 1)); (i += 2)),]flipHexStringEndianness: [(s = s.reverse())][(sb = new java.lang.StringBuilder())][For ((i = 0); (i < (s.length() - 1)); (i += 2)),]]
getDataLengthByType: [(map = [08:1, 09:2, 0a:3, 0b:4, 0c:5, 0d:6, 0e:7, 0f:8, 10:1, 18:1, 19:2, 1a:3, 1b:4, 1c:5, 1d:6, 1e:7, 1f:8, 20:1, 21:2, 22:3, 23:4, ... ])]]
getProgrammingMap: ]
getModeMap: ]
getFanModeMap: ]
getHoldMap: ]
updateSetpoint: [(cool = device.currentState(coolingSetpoint)?.value)][(heat = device.currentState(heatingSetpoint)?.value)][(runningMode = device.currentState(runningMode)?.value)][(mode = device.currentState(thermostatMode)?.value)][(value = --)][If ((heat == mode) && (heat != null)),[(value = heat)],[If ((cool == mode) && (cool != null)),[(value = cool)],[If (((auto == mode) && (runningMode == cool)) && (cool != null)),[(value = cool)],[If (((auto == mode) && (runningMode == heat)) && (heat != null)),[(value = heat)],],],],],]
raiseSetpoint: ]
lowerSetpoint: ]
adjustSetpoint: [(runningMode = device.currentState(runningMode)?.value)][(mode = device.currentState(thermostatMode)?.value)][(modeData = 2)][If ((heat == mode) || (heat == runningMode)),[(modeData = 00)],[If ((cool == mode) || (cool == runningMode)),[(modeData = 01)],],],[(amountData = java.lang.String.format(%02X, value)[(-2..-1)])]]
getDisplayTemperature: [(t = java.lang.Integer.parseInt($value, 16))][If (this.getTemperatureScale() == C),[(t = ((java.lang.Integer -> java.lang.Integer) ((t + 4) / 10) / 10))],[(t = ((java.lang.Integer -> java.lang.Integer) (10 * this.celsiusToFahrenheit((t / 100))) / 10))]],]
updateHoldLabel: [(currentHold = (device?.currentState(setpointHold)?.value) ? device?.currentState(setpointHold)?.value : ...)][(holdExp = device?.currentState(holdExpiary)?.value)][(holdExp = (holdExp) ? holdExp : $new Date().getTime())][If (Hold == attr),[(currentHold = value)],],[If (HoldExp == attr),[(holdExp = value)],],[(past = (new java.util.Date(holdExp.toLong()).getTime() < new java.util.Date().getTime()))][If (HoldExp == attr),[If past,[(currentHold = On)],[(currentHold = Off)]],,],[(holdString = ((currentHold == On)) ? (past) ? Is On : Ends $this.compareWithNow(holdExp.toLong()) : ((currentHold == Off)) ?  is Off :  ...)]]
getSetPointHoldDuration: [(holdTime = 0)][If settings.hold_time?.contains(Hours),[(holdTime = java.lang.Integer.parseInt(settings.hold_time[(0..1)].trim()))],[If settings.hold_time?.contains(Day),[(holdTime = (java.lang.Integer.parseInt(settings.hold_time[(0..1)].trim()) * 24))],],],[(currentHoldDuration = device.currentState(setpointHoldDuration)?.value)][If (java.lang.Short.parseShort((0 + (currentHoldDuration) ? currentHoldDuration : 0)) != (holdTime * 60)),,],]
Hold: [(currentHold = device.currentState(setpointHold)?.value)][(next = ((currentHold == On)) ? 00 : 01)][(nextHold = this.getHoldMap()[next])]]
compareWithNow: [(mins = (new java.util.Date(d).getTime() - new java.util.Date().getTime()))][(mins /= (1000 * 60))][(past = (mins < 0))][(ret = (past) ?  : in )][If past,[(mins *= -1)],],[(t = 0)][If (mins < 60),[(ret += (((java.lang.Integer -> java.lang.Integer) mins +  min) + ((mins > 1)) ? s : ))],[If (mins < 1440),[(t = ((java.lang.Integer -> java.lang.Integer) java.lang.Math.round(((14 + mins) / 30)) / 2))][(ret += ((t +  hr) + ((t > 1)) ? s : ))],[(t = ((java.lang.Integer -> java.lang.Integer) java.lang.Math.round(((359 + mins) / 720)) / 2))][(ret += ((t +  day) + ((t > 1)) ? s : ))]],],[(ret += (past) ?  ago : )]]
convertToTime: [(time = (long) java.lang.Integer.parseInt($data, 16))][(time *= 1000)][(time += 946684800000)][(time -= (location.timeZone.getRawOffset() + location.timeZone.getDSTSavings()))][(d = new java.util.Date(time))]]
Program: [(currentSched = device.currentState(prorgammingOperation)?.value)][(next = java.lang.Integer.parseInt((currentSched) ? currentSched : 00, 16))][If ((next & 1) == 1),[(next = (next & 254))],[(next = (next | 1))]],[(nextSched = this.getProgrammingMap()[(next & 1)])]]
getThermostatOperatingState: [(m = [heating, cooling, fan, Heat2, Cool2, Fan2, Fan3])][(desc = idle)][(value = java.lang.Integer.parseInt(( + value), 16))][For (0..2),[If (value & (1 << i)),[(desc = m[i])],],]getThermostatOperatingState: [(m = [heating, cooling, fan, Heat2, Cool2, Fan2, Fan3])][(desc = idle)][(value = java.lang.Integer.parseInt(( + value), 16))][For (0..2),[If (value & (1 << i)),[(desc = m[i])],],]]
checkLastTimeSync: [(lastSync = device.currentState(lastTimeSync)?.value)][If lastSync,[(lastSync = $new Date(0))],],[If (settings.sync_clock) ? settings.sync_clock : (false && (lastSync != new java.util.Date(0))),,],[(duration = (new java.util.Date().getTime() - new java.util.Date(lastSync).getTime()))][If (duration > 86400000),,],]
readAttributesCommand: [(attrString = )][For attribList,[(attrString += (  + java.lang.String.format(%02X %02X, (val & 255), ((val >> 8) & 255))))]]readAttributesCommand: [(attrString = )][For attribList,[(attrString += (  + java.lang.String.format(%02X %02X, (val & 255), ((val >> 8) & 255))))]]]
refresh: ]
poll: ]
getTemperature: [(celsius = (java.lang.Integer.parseInt($value, 16) / 100))][If (this.getTemperatureScale() == C),,],]
setHeatingSetpoint: [(temperatureScale = this.getTemperatureScale())][(degreesInteger = (java.lang.Integer -> java.lang.Integer) degrees)][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))]]
setCoolingSetpoint: [(degreesInteger = (java.lang.Integer -> java.lang.Integer) degrees)][(celsius = ((this.getTemperatureScale() == C)) ? degreesInteger : (java.lang.Double -> java.lang.Double) this.fahrenheitToCelsius(degreesInteger).round(2))]]
modes: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
setThermostatFanMode: [(currentFanMode = device.currentState(thermostatFanMode)?.value)][(returnCommand = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)]]
setThermostatMode: [(currentMode = device.currentState(thermostatMode)?.value)][(modeOrder = this.modes())][(index = modeOrder.indexOf(currentMode))][(next = (((index >= 0) && (index < (modeOrder.size() - 1)))) ? modeOrder[(index + 1)] : modeOrder[0])]]
setThermostatMode: [(val = (this.getModeMap().find({ -> ... })?.key) ? this.getModeMap().find({ -> ... })?.key : 00)]]
setThermostatFanMode: ]
off: ]
cool: ]
heat: ]
auto: ]
on: ]
fanOn: ]
fanAuto: ]
updated: [(lastSync = device.currentState(lastTimeSync)?.value)][If ((settings.sync_clock) ? settings.sync_clock : false == false),,],]
getLockMap: ]
lock: [(currentLock = device.currentState(lockLevel)?.value)][(val = this.getLockMap().find({ -> ... })?.key)][If (val == 00),[(val = this.getLockMap().find({ -> ... })?.key)],[(val = 00)]],]
setThermostatTime: [If (settings.sync_clock) ? settings.sync_clock : false,,],[(date = new java.util.Date())][(zone = ((location.timeZone.getRawOffset() +  DST ) + location.timeZone.getDSTSavings()))][(millis = date.getTime())][(millis -= 946684800000)][(millis += (location.timeZone.getRawOffset() + location.timeZone.getDSTSavings()))][(millis /= 1000)][(s = java.lang.String.format(%08X, millis))][(data = (((((((  + s.substring(6, 8)) +  ) + s.substring(4, 6)) +  ) + s.substring(2, 4)) +  ) + s.substring(0, 2)))]]
configure: ]
hex: ]
getEndpointId: ]
Starting Points: []
IT HAS ATOMICSTATE
missing method: groovy.lang.MissingMethodException: No signature of method: fidure-thermostat.metadata() is applicable for argument types: (fidure-thermostat$_run_closure1) values: [fidure-thermostat$_run_closure1@13bc8645]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing flood-alert.groovy
DECLARED METHODS
installed: [this.subscribe(alarm, water.wet, waterWetHandler)]]
updated: [this.unsubscribe()][this.subscribe(alarm, water.wet, waterWetHandler)]]
waterWetHandler: [(deltaSeconds = 60)][(timeAgo = new java.util.Date((this.now() - (1000 * deltaSeconds))))][(recentEvents = alarm.eventsSince(timeAgo))][(alreadySentSms = (recentEvents.count({ -> ... }) > 1))][If alreadySentSms,,[(msg = $alarm.displayName is wet!)][If location.contactBookEnabled,,[If phone,,],],],]
Starting Points: []
IT HAS ATOMICSTATE
--app-start--
processing forgiving-security.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
init: [(state.lastTrigger = this.now())][(state.deviceTriggers = [])][this.subscribe(contacts, contact.open, triggerAlarm)][this.subscribe(motions, motion.active, triggerAlarm)]]
triggerAlarm: [(presenceDelay = (presenceDelay) ? presenceDelay : 15)][If ((this.now() - (presenceDelay * 1000)) > state.lastTrigger),[(state.deviceTriggers = [])],],[state.deviceTriggers.add(evt.displayName)][(state.triggerMode = location.mode)][(state.lastTrigger = this.now())][this.runIn(presenceDelay, fireAlarm)]]
fireAlarm: [If (state.deviceTriggers.size() > 0),[(devices = state.deviceTriggers.unique().join(, ))][If (location.mode == state.triggerMode),,],,],[(state.deviceTriggers = [])]]
send: [(delay = (((messageDelay != null) && (messageDelay != ))) ? ((messageDelay * 60) * 1000) : 0)][If ((this.now() - delay) > state.lastMessage),[(state.lastMessage = this.now())][If (sendPushMessage == Yes),,],[If phone,,],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing garage-door-monitor.groovy
DECLARED METHODS
installed: [this.subscribe(multisensor, acceleration, accelerationHandler)]]
updated: [this.unsubscribe()][this.subscribe(multisensor, acceleration, accelerationHandler)]]
accelerationHandler: [(latestThreeAxisState = multisensor.threeAxisState)][If latestThreeAxisState,[(isOpen = (java.lang.Math.abs(latestThreeAxisState.xyzValue.z) > 250))][(isNotScheduled = (state.status != scheduled))][If isOpen,,],[If (isOpen && isNotScheduled),[this.runIn((maxOpenTime * 60), takeAction, [overwrite:false])][(state.status = scheduled)],],,],]
takeAction: [If (state.status == scheduled),[(deltaMillis = ((1000 * 60) * maxOpenTime))][(timeAgo = new java.util.Date((this.now() - deltaMillis)))][(openTooLong = (multisensor.threeAxisState.dateCreated.toSystemDate() < timeAgo))][(recentTexts = state.smsHistory.find({ -> ... }))][If recentTexts,,],[this.runIn((maxOpenTime * 60), takeAction, [overwrite:false])],[log.trace(Status is no longer scheduled. Not sending text.)]],]
sendTextMessage: [(openMinutes = (maxOpenTime * (state.smsHistory?.size()) ? state.smsHistory?.size() : 1))][(msg = Your $(multisensor.label) ? multisensor.label : multisensor.name has been open for more than $openMinutes minutes!)][If location.contactBookEnabled,,[If phone,,],],]
updateSmsHistory: [If state.smsHistory,[(state.smsHistory = [])],],[If (state.smsHistory.size() > 9),[(state.smsHistory = state.smsHistory[(-9..-1)])],],[(state.smsHistory << [sentDate:new java.util.Date().toSystemFormat()])]]
clearSmsHistory: [(state.smsHistory = null)]]
clearStatus: [(state.status = null)]]
Starting Points: []
IT HAS STATE
--app-start--
processing garage-door-opener.groovy
subscribeToCommand
subscribeToCommand
DECLARED METHODS
installed: [this.subscribe(app, appTouchHandler)][this.subscribeToCommand(switch1, on, onCommand)]]
updated: [this.unsubscribe()][this.subscribe(app, appTouchHandler)][this.subscribeToCommand(switch1, on, onCommand)]]
appTouch: ]
onCommand: ]
Starting Points: []
IT HAS STATE
--app-start--
processing gentle-wake-up-controller.groovy
DECLARED METHODS
parse: ]
on: ]
off: ]
setTimeRemaining: ]
start: ]
stop: ]
pause: ]
cancel: ]
startDimming: ]
stopDimming: ]
controllerEvent: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: gentle-wake-up-controller.metadata() is applicable for argument types: (gentle-wake-up-controller$_run_closure1) values: [gentle-wake-up-controller$_run_closure1@6692b6c6]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing gentle-wake-up.groovy
DECLARED METHODS
rootPage: ]
unsupportedDevicesPage: [(unsupportedDimmers = dimmers.findAll({ -> ... }))]]
controllerExplanationPage: ]
numbersPage: ]
defaultStart: [If ((this.usesOldSettings() && direction) && (direction == Down)),,],]
defaultEnd: [If ((this.usesOldSettings() && direction) && (direction == Down)),,],]
startLevelLabel: [If this.usesOldSettings(),[If (direction && (direction == Down)),,],,],]
endLevelLabel: [If this.usesOldSettings(),[If (direction && (direction == Down)),,],,],]
weekdays: ]
weekends: ]
schedulingPage: ]
completionPage: ]
installed: ]
updated: [this.unschedule()][(controller = this.getController())][If controller,[(controller.label = app.label)],],]
initialize: [If startTime,[this.schedule(startTime, scheduledStart)],],[this.subscribe(app, appHandler)][this.subscribe(location, locationHandler)][If manualOverride,[this.subscribe(dimmers, switch.off, stopDimmersHandler)],],[If this.getAllChildDevices(),[(dni = $new Date().getTime())][(state.controllerDni = dni)],],]
appHandler: [If (evt.value == touch),[If atomicState.running,,],,],]
locationHandler: [If modeStart,,],[(isSpecifiedMode = (evt.value == modeStart))][(modeStopIsTrue = (modeStop && (modeStop != false)))][If (isSpecifiedMode && this.canStartAutomatically()),,[If (isSpecifiedMode && modeStopIsTrue),,],],]
stopDimmersHandler: [(percentComplete = this.completionPercentage())][If ((percentComplete > 2) && (percentComplete < 98)),[If (manualOverride == cancel),,[If (manualOverride == jumpTo),[(end = this.dynamicEndLevel())],],],,],]
scheduledStart: [If this.canStartAutomatically(),[this.start(schedule)],],]
start: [(atomicState.running = true)][(atomicState.runCounter = 0)][(atomicState.start = new java.util.Date().getTime())][this.schedule(0 * * * * ?, healthCheck)]]
stop: [(atomicState.running = false)][(atomicState.start = 0)][(atomicState.runCounter = 0)][this.unschedule(healthCheck)]]
healthCheck: [If atomicState.running,,],]
sendStartEvent: [(eventData = [name:sessionStatus, value:running, descriptionText:$app.label has started dimming, displayed:true, linkText:app.label, isStateChange:true])][If (source == modeChange),[(eventData.descriptionText +=  because of a mode change)],[If (source == schedule),[(eventData.descriptionText +=  as scheduled)],[If (source == appTouch),[(eventData.descriptionText +=  because you pressed play on the app)],[If (source == controller),[(eventData.descriptionText +=  because you pressed play on the controller)],],],],],]
sendStopEvent: [(eventData = [name:sessionStatus, value:stopped, descriptionText:$app.label has stopped dimming, displayed:true, linkText:app.label, isStateChange:true])][If (source == modeChange),[(eventData.descriptionText +=  because of a mode change)][(eventData.value += cancelled)],[If (source == schedule),[(eventData.descriptionText = $app.label has finished dimming)],[If (source == appTouch),[(eventData.descriptionText +=  because you pressed play on the app)][(eventData.value += cancelled)],[If (source == controller),[(eventData.descriptionText +=  because you pressed stop on the controller)][(eventData.value += cancelled)],[If (source == settingsChange),[(eventData.descriptionText +=  because the settings have changed)][(eventData.value += cancelled)],[If (source == manualOverride),[(eventData.descriptionText +=  because the dimmer was manually turned off)][(eventData.value += cancelled)],],],],],],],]
sendTimeRemainingEvent: [(percentCompleteEventData = [name:percentComplete, value:(int) percentComplete, displayed:displayed, isStateChange:true])][(duration = this.sanitizeInt(duration, 30))][(timeRemaining = (duration - (duration * (percentComplete / 100))))][(timeRemainingEventData = [name:timeRemaining, value:this.displayableTime(timeRemaining), displayed:displayed, isStateChange:true])]]
sendControllerEvent: [(controller = this.getController())][If controller,,],]
getController: [(dni = state.controllerDni)][If dni,,],[(controller = this.getChildDevice(dni))][If controller,,],]
increment: [If atomicState.running,,],[If (atomicState.runCounter == null),[(atomicState.runCounter = 1)],[(atomicState.runCounter = (atomicState.runCounter + 1))]],[(percentComplete = this.completionPercentage())][If (percentComplete > 99),[(percentComplete = 99)],],[If (atomicState.runCounter > 100),[(percentComplete = 100)],],[If (percentComplete < 99),[(runAgain = this.stepDuration())][this.runIn(runAgain, increment, [overwrite:true])],[(completionDelay = this.completionDelaySeconds())][If completionDelay,[this.runIn(completionDelay, completion, [overwrite:true])][this.unschedule(healthCheck)],],],]
updateDimmers: ]
dynamicLevel: [(start = atomicState.startLevels[dimmer.id])][(end = this.dynamicEndLevel())][If percentComplete,,],[(totalDiff = (end - start))][(actualPercentage = (percentComplete / 100))][(percentOfTotalDiff = (totalDiff * actualPercentage))]]
completion: [If atomicState.running,,],[this.stop(schedule)]]
handleCompletionSwitches: ]
handleCompletionMessaging: [If completionMessage,[If location.contactBookEnabled,,[If completionPhoneNumber,,],[If completionPush,,],],[If completionMusicPlayer,,],,],]
handleCompletionModesAndPhrases: [If completionMode,,],[If completionPhrase,,],]
speak: [(sound = this.textToSpeech(message))][(soundDuration = ((java.lang.Integer -> java.lang.Integer) sound.duration + 2))][log.debug(Scheduled resume in $soundDuration sec)][this.runIn(soundDuration, resumePlaying, [overwrite:true])]]
resumePlaying: [(sonos = completionMusicPlayer)][If sonos,[(currentTrack = sonos.currentState(trackData).jsonValue)][If (currentTrack.status == playing),,],,],]
setLevelsInState: [(startLevels = [:])][(atomicState.startLevels = startLevels)]]
canStartAutomatically: [(today = new java.util.Date().format(EEEE))][If (days || days.contains(today)),,],]
completionPercentage: [If atomicState.running,,],[(now = new java.util.Date().getTime())][(timeElapsed = (now - atomicState.start))][(totalRunTime = (this.totalRunTimeMillis()) ? this.totalRunTimeMillis() : 1)][(percentComplete = ((timeElapsed / totalRunTime) * 100))]]
totalRunTimeMillis: [(minutes = this.sanitizeInt(duration, 30))]]
convertToMillis: [(seconds = (minutes * 60))][(millis = (seconds * 1000))]]
timeRemaining: [(normalizedPercentComplete = (percentComplete / 100))][(duration = this.sanitizeInt(duration, 30))][(timeElapsed = (duration * normalizedPercentComplete))][(timeRemaining = (duration - timeElapsed))]]
millisToEnd: ]
displayableTime: [(timeString = $timeRemaining)][(parts = timeString.split(\.))][If parts.size(),,],[(minutes = parts[0])][If (parts.size() == 1),,],[(fraction = (double) 0.$parts[1])][(seconds = $(int) (60 * fraction).padLeft(2, 0))]]
jumpTo: [(millisToEnd = this.millisToEnd(percentComplete))][(endTime = (new java.util.Date().getTime() + millisToEnd))][(duration = this.sanitizeInt(duration, 30))][(durationMillis = this.convertToMillis(duration))][(shiftedStart = (endTime - durationMillis))][(atomicState.start = shiftedStart)]]
dynamicEndLevel: [If this.usesOldSettings(),[If (direction && (direction == Down)),,],,],]
getHue: [(start = (int) atomicState.startLevels[dimmer.id])][(end = this.dynamicEndLevel())][If (start > end),,],]
getUpHue: ]
getDownHue: ]
getBlueHue: [If (level < 5),,],[If (level < 10),,],[If (level < 15),,],[If (level < 20),,],[If (level < 25),,],[If (level < 30),,],[If (level < 35),,],[If (level < 40),,],[If (level < 45),,],[If (level < 50),,],[If (level < 55),,],[If (level < 60),,],[If (level < 65),,],[If (level < 70),,],[If (level < 75),,],[If (level < 80),,],[If (level < 85),,],[If (level < 90),,],[If (level < 95),,],[If (level >= 95),,],]
getRedHue: [If (level < 6),,],[If (level < 12),,],[If (level < 18),,],[If (level < 24),,],[If (level < 30),,],[If (level < 36),,],[If (level < 42),,],[If (level < 48),,],[If (level < 54),,],[If (level < 60),,],[If (level < 66),,],[If (level < 72),,],[If (level < 78),,],[If (level < 84),,],[If (level < 90),,],[If (level < 96),,],[If (level >= 96),,],]
dimmersContainUnsupportedDevices: [(found = dimmers.find({ -> ... }))][return (found != null)]]
hasSetLevelCommand: ]
hasSetColorCommand: ]
hasCommand: [return (device.supportedCommands.find({ -> ... }) != null)]]
dimmersWithSetColorCommand: [(colorDimmers = [])]]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
sanitizeInt: ]
completionDelaySeconds: [(completionDelayMinutes = this.sanitizeInt(completionDelay))][(completionDelaySeconds = (completionDelayMinutes * 60))]]
stepDuration: [(minutes = this.sanitizeInt(duration, 30))][(stepDuration = ((minutes * 60) / 100))]]
debug: ]
smartThingsDateFormat: ]
humanReadableStartDate: ]
fancyString: [(fancify = { java.lang.Object list -> ... })]]
fancyDeviceString: ]
deviceLabel: ]
schedulingHrefDescription: [(descriptionParts = [])][If days,[If (days == this.weekdays()),,[If (days == this.weekends()),,],],,],[If startTime,,],[If modeStart,[If startTime,,],,],[If (descriptionParts.size() <= 1),,],]
completionHrefDescription: [(descriptionParts = [])][(example = Switch1 will be turned on. Switch2, Switch3, and Switch4 will be dimmed to 50%. The message '<message>' will be spoken, sent as a text, and sent as a push notification. The mode will be changed to '<mode>'. The phrase '<phrase>' will be executed)][If completionSwitches,[(switchesList = [])][(dimmersList = [])][If switchesList,,],[If dimmersList,,],,],[If (completionMessage && ((completionPhoneNumber || completionPush) || completionMusicPlayer)),[(messageParts = [])][If completionMusicPlayer,,],[If completionPhoneNumber,,],[If completionPush,,],,],[If completionMode,,],[If completionPhrase,,],]
numbersPageHrefDescription: [(title = All dimmers will dim for $(duration) ? duration : 30 minutes from $this.startLevelLabel() to $this.endLevelLabel())][If colorize,[(colorDimmers = this.dimmersWithSetColorCommand())][If (colorDimmers == dimmers),[(title +=  and will gradually change color.)],[(title += .
$this.fancyDeviceString(colorDimmers) will gradually change color.)]],,],]
hueSatToHex: [(convertedRGB = this.hslToRgb(h, s, 0.5))]]
hslToRgb: [(r = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(g = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(b = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (s == 0),[(r = (g = (b = l)))],[(hue2rgb = { java.lang.Object p, java.lang.Object q, java.lang.Object t -> ... })][(q = ((l < 0.5)) ? (l * (1 + s)) : ((l + s) - (l * s)))][(p = ((2 * l) - q))][(r = hue2rgb.call(p, q, (h + (1 / 3))))][(g = hue2rgb.call(p, q, h))][(b = hue2rgb.call(p, q, (h - (1 / 3))))]],]
rgbToHex: [(toHex = { -> ... })][(rgbToHex = { java.lang.Object r, java.lang.Object g, java.lang.Object b -> ... })]]
usesOldSettings: ]
hasStartLevel: [return ((startLevel != null) && (startLevel != ))]]
hasEndLevel: [return ((endLevel != null) && (endLevel != ))]]
Starting Points: []
IT HAS ATOMICSTATE
--app-start--
processing good-night-house.groovy
DECLARED METHODS
installed: [log.debug(Current mode = $location.mode)][this.subscribe(app, appTouch)]]
updated: [log.debug(Current mode = $location.mode)][this.unsubscribe()][this.subscribe(app, appTouch)]]
appTouch: [log.debug(changeMode, location.mode = $location.mode, newMode = $newMode, location.modes = $location.modes)][If (location.mode != newMode),,],[(delay = (((waitfor != null) && (waitfor != ))) ? (waitfor * 1000) : 120000)]]
Starting Points: []
IT HAS ATOMICSTATE
--app-start--
processing good-night.groovy
DECLARED METHODS
installed: [log.debug(Current mode = $location.mode)]]
updated: [log.debug(Current mode = $location.mode)][this.unsubscribe()]]
createSubscriptions: [this.subscribe(motionSensors, motion.active, motionActiveHandler)][this.subscribe(motionSensors, motion.inactive, motionInactiveHandler)][this.subscribe(switches, switch.off, switchOffHandler)][this.subscribe(location, modeChangeHandler)][If (state.modeStartTime == null),[(state.modeStartTime = 0)],],]
modeChangeHandler: [(state.modeStartTime = this.now())]]
switchOffHandler: [If (this.correctMode() && this.correctTime()),[If (this.allQuiet() && this.switchesOk()),,],,],]
motionActiveHandler: ]
motionInactiveHandler: [If (state.modeStartTime == null),[this.subscribe(location, modeChangeHandler)][(state.modeStartTime = 0)],],[If (this.correctMode() && this.correctTime()),[this.runIn((minutes * 60), scheduleCheck, [overwrite:false])],],]
scheduleCheck: [log.debug(scheduleCheck, currentMode = $location.mode, newMode = $newMode)][If (this.correctMode() && this.correctTime()),[If (this.allQuiet() && this.switchesOk()),,],,],]
takeActions: [(message = Goodnight! SmartThings changed the mode to '$newMode')]]
correctMode: [If (location.mode != newMode),,],]
correctTime: [(t0 = this.now())][(modeStartTime = new java.util.Date(state.modeStartTime))][(startTime = this.timeTodayAfter(modeStartTime, timeOfDay, location.timeZone))][If (t0 >= startTime.time),,],]
switchesOk: [(result = true)][For (switches) ? switches : [],[If (it.currentSwitch == on),[(result = false)][(result = false)],],]switchesOk: [(result = true)][For (switches) ? switches : [],[If (it.currentSwitch == on),[(result = false)][(result = false)],],]]
allQuiet: [(threshold = (((1000 * 60) * minutes) - 1000))][(states = motionSensors.collect({ -> ... }).sort({ java.lang.Object a, java.lang.Object b -> ... }))][If states,[If states.find({ -> ... }),,[(sensor = states.first())][(elapsed = (this.now() - sensor.rawDateCreated.time))][If (elapsed >= threshold),,],],,],]
send: [If location.contactBookEnabled,,[If (sendPushMessage != No),,],[If phoneNumber,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing goodnight-ubi.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(trigger, switch.on, switchOnHandler)]]
switchOnHandler: [(timeDelay = (minutes * 60))][this.runIn(timeDelay, lightsOut)][(phrase = )][If (phrase == ),[(phrase = The%20house%20is%20ready%20for%20night.)],[(phrase = ((You%20have%20left%20 + phrase) + open))]],[this.httpGet(https://portal.theubi.com/webapi/behaviour?access_token=$behaviorToken&variable=$phrase)][If (sayPhrase == Yes),,],]
lightsOut: [If (theSwitches == ),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing greetings-earthling.groovy
DECLARED METHODS
installed: [this.subscribe(people, presence, presence)]]
updated: [this.unsubscribe()][this.subscribe(people, presence, presence)]]
presence: [(threshold = (((falseAlarmThreshold != null) && (falseAlarmThreshold != ))) ? (java.lang.Long -> java.lang.Long) ((falseAlarmThreshold * 60) * 1000) : ((10 * 60) * 1000))][If (location.mode != newMode),[(t0 = new java.util.Date((this.now() - threshold)))][If (evt.value == present),[(person = this.getPerson(evt))][(recentNotPresent = person.statesSince(presence, t0).find({ -> ... }))][If recentNotPresent,,[(message = $person.displayName arrived at home, changing mode to '$newMode')]],,],,],]
getPerson: ]
send: [If location.contactBookEnabled,,[If (sendPushMessage != No),,],[If phone,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing habit-helper.groovy
DECLARED METHODS
installed: [this.schedule(time1, scheduleCheck)]]
updated: [this.unschedule()][this.schedule(time1, scheduleCheck)]]
scheduleCheck: [log.trace(scheduledCheck)][(message = (message1) ? message1 : SmartThings - Habit Helper Reminder!)][If location.contactBookEnabled,,],]
Starting Points: [log.trace(scheduledCheck)]
IT HAS STATE
--app-start--
processing hall-light-welcome-home.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
init: [(state.lastClosed = this.now())][this.subscribe(people, presence.present, presence)][this.subscribe(sensors, contact.open, doorOpened)]]
presence: [(delay = (contactDelay) ? contactDelay : 10)][(state.lastPresence = this.now())][If ((this.now() - (delay * 1000)) < state.lastContact),,],]
doorOpened: [(delay = (presenceDelay) ? presenceDelay : 30)][(state.lastContact = this.now())][If ((this.now() - (delay * 1000)) < state.lastPresence),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing harmony-activity.groovy
DECLARED METHODS
parse: ]
on: ]
off: ]
huboff: ]
alloff: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: harmony-activity.metadata() is applicable for argument types: (harmony-activity$_run_closure1) values: [harmony-activity$_run_closure1@1ef6d34c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing has-barkley-been-fed.groovy
DECLARED METHODS
installed: [this.schedule(time1, scheduleCheck)]]
updated: [this.unsubscribe()][this.unschedule()][this.schedule(time1, scheduleCheck)]]
scheduleCheck: [log.trace(scheduledCheck)][(midnight = new java.util.Date().clearTime())][(now = new java.util.Date())][(feederEvents = feeder1.eventsBetween(midnight, now))][(feederOpened = (feederEvents.count({ -> ... }) > 0))][If feederOpened,,[If location.contactBookEnabled,,],],]
Starting Points: [log.trace(scheduledCheck)]
IT HAS STATE
--app-start--
processing hello-home-phrase-director.groovy
DECLARED METHODS
selectPhrases: [(configured = (((settings.awayDay && settings.awayNight) && settings.homeDay) && settings.homeNight))]]
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(people, presence, presence)][this.runIn(60, checkSun)][this.subscribe(location, sunrise, setSunrise)][this.subscribe(location, sunset, setSunset)]]
checkSun: [(zip = (java.lang.String -> java.lang.String) settings.zip)][(sunInfo = this.getSunriseAndSunset([zipCode:zip]))][(current = this.now())][If ((sunInfo.sunrise.time < current) && (sunInfo.sunset.time > current)),[(state.sunMode = sunrise)],[(state.sunMode = sunset)]],]
setSunrise: [(state.sunMode = sunrise)]]
setSunset: [(state.sunMode = sunset)]]
changeSunMode: [If allOk,[If (this.everyoneIsAway() && (state.sunMode == sunrise)),[(delay = (((falseAlarmThreshold != null) && (falseAlarmThreshold != ))) ? (falseAlarmThreshold * 60) : (10 * 60))][this.runIn(delay, setAway)],],[If (this.everyoneIsAway() && (state.sunMode == sunset)),[(delay = (((falseAlarmThreshold != null) && (falseAlarmThreshold != ))) ? (falseAlarmThreshold * 60) : (10 * 60))][this.runIn(delay, setAway)],],,],]
presence: [If allOk,[If (evt.value == not present),[If this.everyoneIsAway(),[(delay = (((falseAlarmThreshold != null) && (falseAlarmThreshold != ))) ? (falseAlarmThreshold * 60) : (10 * 60))][this.runIn(delay, setAway)],],,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (1 * 60000))),,],[(state[evt.deviceId] = this.now())]],,],]
setAway: [If this.everyoneIsAway(),[If (state.sunMode == sunset),[(message = Performing "$awayNight" for you as requested.)],[If (state.sunMode == sunrise),[(message = Performing "$awayDay" for you as requested.)],],],,],]
setHome: [If this.anyoneIsHome(),[If (state.sunMode == sunset),[If (location.mode != $homeModeNight),[(message = Performing "$homeNight" for you as requested.)],],,],[If (state.sunMode == sunrise),[If (location.mode != $homeModeDay),[(message = Performing "$homeDay" for you as requested.)],],,],,],]
everyoneIsAway: [(result = true)][If people.findAll({ -> ... }),[(result = false)],],]
anyoneIsHome: [(result = false)][If people.findAll({ -> ... }),[(result = true)],],]
sendAway: [If (sendPushMessage != No),,],]
sendHome: [If (sendPushMessageHome != No),,],]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
getTimeIntervalLabel: ]
hideOptionsSection: ]
sendOutOfDateNotification: [If state.lastTime,[(state.lastTime = (new java.util.Date() + 31).getTime())],[If (new java.util.Date().getTime() >= state.lastTime),[(state.lastTime = (new java.util.Date() + 31).getTime())],],],]
Starting Points: []
IT HAS STATE
--app-start--
processing hub-ip-notifier.groovy
DECLARED METHODS
pageWithIp: [(currentIp = (state.localip) ? state.localip : unknown)][(registerDate = (state.lastRegister) ? state.lastRegister : null)]]
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(hub, hubInfo, registrationHandler, [filterEvents:false])]]
registrationHandler: [(hubInfo = evt.description.split(,).inject([:], { java.lang.Object map, java.lang.Object token -> ... }))][(state.localip = hubInfo.localip)][(state.lastRegister = new java.util.Date())]]
Starting Points: []
IT HAS STATE
--app-start--
processing hue-bloom.groovy
DECLARED METHODS
initialize: ]
installed: ]
updated: ]
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],]
on: ]
off: ]
setLevel: [If this.verifyPercent(percent),,],]
setSaturation: [If this.verifyPercent(percent),,],]
setHue: [If this.verifyPercent(percent),,],]
setColor: [(events = [])][(validValues = [:])][If this.verifyPercent(value.hue),[(validValues.hue = value.hue)],],[If this.verifyPercent(value.saturation),[(validValues.saturation = value.saturation)],],[If (value.hex != null),[If (value.hex ==~ ^\#([A-Fa-f0-9]){6}$),[(validValues.hex = value.hex)],],,],[If this.verifyPercent(value.level),[(validValues.level = value.level)],],[If ((value.switch == off) || ((value.level != null) && (value.level <= 0))),[(validValues.switch = off)],[(validValues.switch = on)]],[If validValues.isEmpty(),,],]
reset: [(value = [hue:20, saturation:2])]]
setAdjustedColor: [If value,[(adjusted = (value + [:]))][(adjusted.level = null)],],]
refresh: ]
verifyPercent: [If (percent == null),,[If ((percent >= 0) && (percent <= 100)),,],],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: hue-bloom.metadata() is applicable for argument types: (hue-bloom$_run_closure1) values: [hue-bloom$_run_closure1@6cb6decd]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing hue-bulb.groovy
DECLARED METHODS
initialize: ]
installed: ]
updated: ]
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],]
on: ]
off: ]
setLevel: [If this.verifyPercent(percent),,],]
setSaturation: [If this.verifyPercent(percent),,],]
setHue: [If this.verifyPercent(percent),,],]
setColor: [(events = [])][(validValues = [:])][If this.verifyPercent(value.hue),[(validValues.hue = value.hue)],],[If this.verifyPercent(value.saturation),[(validValues.saturation = value.saturation)],],[If (value.hex != null),[If (value.hex ==~ ^\#([A-Fa-f0-9]){6}$),[(validValues.hex = value.hex)],],,],[If this.verifyPercent(value.level),[(validValues.level = value.level)],],[If ((value.switch == off) || ((value.level != null) && (value.level <= 0))),[(validValues.switch = off)],[(validValues.switch = on)]],[If validValues.isEmpty(),,],]
reset: ]
setAdjustedColor: [If value,[(adjusted = (value + [:]))][(adjusted.level = null)],],]
setColorTemperature: [If value,,],]
refresh: ]
verifyPercent: [If (percent == null),,[If ((percent >= 0) && (percent <= 100)),,],],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: hue-bulb.metadata() is applicable for argument types: (hue-bulb$_run_closure1) values: [hue-bulb$_run_closure1@1bae316d]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing hue-lux-bulb.groovy
DECLARED METHODS
initialize: ]
installed: ]
updated: ]
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],]
on: ]
off: ]
setLevel: [If (((percent != null) && (percent >= 0)) && (percent <= 100)),,],]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: hue-lux-bulb.metadata() is applicable for argument types: (hue-lux-bulb$_run_closure1) values: [hue-lux-bulb$_run_closure1@5082d622]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing hue-mood-lighting.groovy
DECLARED METHODS
mainPage: ]
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]]
ifUnset: [If settings[name],,],]
ifSet: [If settings[name],,],]
installed: [this.subscribeToEvents()]]
updated: [this.unsubscribe()][this.unschedule()][this.subscribeToEvents()]]
subscribeToEvents: [this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,[this.schedule(timeOfDay, scheduledTimeHandler)],],]
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],]
modeChangeHandler: [If (evt.value in triggerModes),,],]
scheduledTimeHandler: [log.trace(scheduledTimeHandler())]]
appTouchHandler: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
takeAction: [If (frequency || oncePerDay),[(state[this.frequencyKey(evt)] = this.now())],],[(hueColor = 0)][(saturation = 100)]]
frequencyKey: ]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],]
oncePerDayOk: [(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result - $lastTime)]]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
timeIntervalLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing hue-white-ambiance-bulb.groovy
DECLARED METHODS
initialize: ]
installed: ]
updated: ]
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],]
on: ]
off: ]
setLevel: [If (((percent != null) && (percent >= 0)) && (percent <= 100)),,],]
setColorTemperature: [If value,,],]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: hue-white-ambiance-bulb.metadata() is applicable for argument types: (hue-white-ambiance-bulb$_run_closure1) values: [hue-white-ambiance-bulb$_run_closure1@44c73c26]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing humidity-alert.groovy
DECLARED METHODS
installed: [this.subscribe(humiditySensor1, humidity, humidityHandler)]]
updated: [this.unsubscribe()][this.subscribe(humiditySensor1, humidity, humidityHandler)]]
humidityHandler: [(currentHumidity = java.lang.Double.parseDouble(evt.value.replace(%, )))][(tooHumid = humidity1)][(notHumidEnough = humidity2)][(mySwitch = settings.switch1)][(deltaMinutes = 10)][(timeAgo = new java.util.Date((this.now() - ((1000 * 60) * deltaMinutes).toLong())))][(recentEvents = humiditySensor1.eventsSince(timeAgo))][(alreadySentSms = ((recentEvents.count({ -> ... }) > 1) || (recentEvents.count({ -> ... }) > 1)))][If (currentHumidity >= tooHumid),[log.debug(Checking how long the humidity sensor has been reporting >= $tooHumid)][If alreadySentSms,,],,],[If (currentHumidity <= notHumidEnough),[log.debug(Checking how long the humidity sensor has been reporting <= $notHumidEnough)][If alreadySentSms,,],,],]
send: [If (sendPushMessage != No),,],[If phone1,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing illuminance-measurement-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: illuminance-measurement-capability.metadata() is applicable for argument types: (illuminance-measurement-capability$_run_closure1) values: [illuminance-measurement-capability$_run_closure1@20f5281c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing it-moved.groovy
DECLARED METHODS
installed: [this.subscribe(accelerationSensor, acceleration.active, accelerationActiveHandler)]]
updated: [this.unsubscribe()][this.subscribe(accelerationSensor, acceleration.active, accelerationActiveHandler)]]
accelerationActiveHandler: [(deltaSeconds = 5)][(timeAgo = new java.util.Date((this.now() - (1000 * deltaSeconds))))][(recentEvents = accelerationSensor.eventsSince(timeAgo))][(alreadySentSms = (recentEvents.count({ -> ... }) > 1))][If alreadySentSms,,[If location.contactBookEnabled,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing its-too-cold.groovy
DECLARED METHODS
installed: [this.subscribe(temperatureSensor1, temperature, temperatureHandler)]]
updated: [this.unsubscribe()][this.subscribe(temperatureSensor1, temperature, temperatureHandler)]]
temperatureHandler: [(tooCold = temperature1)][(mySwitch = settings.switch1)][If (evt.doubleValue <= tooCold),[log.debug(Checking how long the temperature sensor has been reporting <= $tooCold)][(deltaMinutes = 10)][(timeAgo = new java.util.Date((this.now() - ((1000 * 60) * deltaMinutes).toLong())))][(recentEvents = temperatureSensor1.eventsSince(timeAgo)?.findAll({ -> ... }))][(alreadySentSms = (recentEvents.count({ -> ... }) > 1))][If alreadySentSms,,[(tempScale = (location.temperatureScale) ? location.temperatureScale : F)]],,],]
send: [If location.contactBookEnabled,,[If (sendPushMessage != No),,],[If phone1,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing its-too-hot.groovy
DECLARED METHODS
installed: [this.subscribe(temperatureSensor1, temperature, temperatureHandler)]]
updated: [this.unsubscribe()][this.subscribe(temperatureSensor1, temperature, temperatureHandler)]]
temperatureHandler: [(tooHot = temperature1)][(mySwitch = settings.switch1)][If (evt.doubleValue >= tooHot),[log.debug(Checking how long the temperature sensor has been reporting <= $tooHot)][(deltaMinutes = 10)][(timeAgo = new java.util.Date((this.now() - ((1000 * 60) * deltaMinutes).toLong())))][(recentEvents = temperatureSensor1.eventsSince(timeAgo)?.findAll({ -> ... }))][(alreadySentSms = (recentEvents.count({ -> ... }) > 1))][If alreadySentSms,,[(tempScale = (location.temperatureScale) ? location.temperatureScale : F)]],,],]
send: [If location.contactBookEnabled,,[If (sendPushMessage != No),,],[If phone1,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing jawbone-button-notifier.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(jawbone, sleeping, sendit)]]
sendit: ]
sendMessage: [(msg = warnMessage)][If phone1,,],[If phone2,,],[If phone3,,],[If ((phone1 && phone2) && phone3),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing jawbone-user.groovy
DECLARED METHODS
generateSleepingEvent: [(value = this.formatValue(sleeping))][(linkText = this.getLinkText(device))][(descriptionText = this.formatDescriptionText(linkText, sleeping))][(handlerName = this.getState(sleeping))][(results = [name:sleeping, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName])][(results2 = [name:button, value:held, unit:null, linkText:linkText, descriptionText:$linkText button was pressed, handlerName:buttonHandler, ... ])]]
poll: [(results = parent.pollChild(this))]]
setMemberId: [log.debug(MemberId = $memberId)][(state.jawboneMemberId = memberId)]]
getMemberId: [log.debug(MemberId = $state.jawboneMemberId)][return state.jawboneMemberId]]
uninstalled: ]
formatValue: [If sleeping,,],]
formatDescriptionText: [If sleeping,,],]
getState: [If sleeping,,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: jawbone-user.metadata() is applicable for argument types: (jawbone-user$_run_closure1) values: [jawbone-user$_run_closure1@5ef5c734]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing jenkins-notifier.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
getHueColors: ]
getSaturation: ]
getMaxLevel: ]
initialize: [(successColor = [switch:on, hue:this.getHueColors()[colorSuccess], saturation:this.getSaturation(), level:(lightLevelSuccess) ? lightLevelSuccess : this.getMaxLevel()])][(failColor = [switch:on, hue:this.getHueColors()[colorFail], saturation:this.getSaturation(), level:(lightLevelFail) ? lightLevelFail : this.getMaxLevel()])][(state.successColor = successColor)][(state.failColor = failColor)][(cron = * */$(refreshInterval) ? refreshInterval : 15 * * * ?)][this.schedule(cron, checkServer)]]
checkServer: [(successColor = state.successColor)][(failColor = state.failColor)][(basicCredentials = $jenkinsUsername:$jenkinsPassword)][(encodedCredentials = basicCredentials.encodeAsBase64().toString())][(basicAuth = Basic $encodedCredentials)][(head = [Authorization:basicAuth])][(host = (jenkinsUrl.contains(lastBuild/api/json)) ? jenkinsUrl : $jenkinsUrl/lastBuild/api/json)]]
Starting Points: []
IT HAS STATE
--app-start--
processing keen-home-smart-vent.groovy
DECLARED METHODS
parse: [(map = [:])][If description?.startsWith(catchall:),[(map = this.parseCatchAllMessage(description))],[If description?.startsWith(read attr -),[(map = this.parseReportAttributeMessage(description))],[If (description?.startsWith(temperature: ) || description?.startsWith(humidity: )),[(map = this.parseCustomMessage(description))],[If description?.startsWith(on/off: ),[(map = this.parseOnOffMessage(description))],],],],],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseCatchAllMessage: [(cluster = zigbee.parse(description))][If this.shouldProcessMessage(cluster),,],]
shouldProcessMessage: [If ((((cluster.profileId != 260) || (cluster.command == 11)) || (cluster.command == 7)) || ((cluster.data.size() > 0) && (cluster.data.first() == 62))),,],]
parseReportAttributeMessage: [(descMap = (description - read attr - ).split(,).inject([:], { java.lang.Object map, java.lang.Object param -> ... }))][If ((descMap.cluster == 0006) && (descMap.attrId == 0000)),,[If ((descMap.cluster == 0008) && (descMap.attrId == 0000)),,[If ((descMap.cluster == 0402) && (descMap.attrId == 0000)),[(value = this.convertTemperatureHex(descMap.value))],[If ((descMap.cluster == 0001) && (descMap.attrId == 0021)),,[If ((descMap.cluster == 0403) && (descMap.attrId == 0020)),,[If ((descMap.cluster == 0000) && (descMap.attrId == 0006)),,],],],],],],]
parseCustomMessage: [(resultMap = [:])][If description?.startsWith(temperature: ),[(value = java.lang.Double.parseDouble(description.split(: )[1]))][(resultMap = this.makeTemperatureResult(this.convertTemperature(value)))],],]
parseOnOffMessage: [(resultMap = [:])][If description?.startsWith(on/off: ),[(value = java.lang.Integer.parseInt((description - on/off: )))][(resultMap = this.makeOnOffResult(value))],],]
makeOnOffResult: [(linkText = this.getLinkText(device))][(value = ((rawValue == 1)) ? on : off)]]
makeLevelResult: [(linkText = this.getLinkText(device))][(value = java.lang.Integer.parseInt(rawValue, 16))][(rangeMax = 254)][If (value == 255),,],[(value = java.lang.Math.floor(((value / rangeMax) * 100)))]]
makePressureResult: [(linkText = this.getLinkText(device))][(pascals = (rawValue / 10))][(result = [name:pressure, descriptionText:$linkText pressure is $pascalsPa, value:pascals])]]
makeBatteryResult: [(linkText = this.getLinkText(device))]]
makeTemperatureResult: [(linkText = this.getLinkText(device))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],]
convertTemperatureHex: [(celsius = (java.lang.Integer.parseInt(value, 16).shortValue() / 100))]]
convertTemperature: [If (this.getTemperatureScale() == C),,[(fahrenheit = (java.lang.Math.round((this.celsiusToFahrenheit(celsius) * 100)) / 100))]],]
makeSerialResult: [(linkText = this.getLinkText(device))]]
makeLevelCommand: [(rangeMax = 254)][(scaledLevel = java.lang.Math.round(((level * rangeMax) / 100)))][(hexLevel = new java.math.BigInteger(scaledLevel.toString()).toString(16).padLeft(2, 0))]]
on: [(linkText = this.getLinkText(device))][If (device.currentValue(switch) == obstructed),,],]
off: [(linkText = this.getLinkText(device))][If (device.currentValue(switch) == obstructed),,],]
clearObstruction: [(linkText = this.getLinkText(device))]]
setLevel: [(linkText = this.getLinkText(device))][(currentState = device.currentValue(switch))][If (currentState == obstructed),,],[If (value > 0),,],]
getOnOff: [If (device.currentValue(switch) == obstructed),,],]
getPressure: ]
getLevel: [If (device.currentValue(switch) == obstructed),,],]
getTemperature: ]
getBattery: ]
setZigBeeIdTile: [(linkText = this.getLinkText(device))]]
refresh: ]
ping: ]
configure: [(configCmds = [zdo bind 0x$device.deviceNetworkId 1 1 0x0008 {$device.zigbeeId} {}, delay 500, zdo bind 0x$device.deviceNetworkId 1 1 0x0402 {$device.zigbeeId} {}, delay 500, zdo bind 0x$device.deviceNetworkId 1 1 0x0403 {$device.zigbeeId} {}, delay 500, zdo bind 0x$device.deviceNetworkId 1 1 0x0001 {$device.zigbeeId} {}, delay 500])]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: keen-home-smart-vent.metadata() is applicable for argument types: (keen-home-smart-vent$_run_closure1) values: [keen-home-smart-vent$_run_closure1@3e6104fc]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing keep-me-cozy-ii.groovy
DECLARED METHODS
installed: [this.subscribeToEvents()]]
updated: [this.unsubscribe()][this.subscribeToEvents()]]
subscribeToEvents: [this.subscribe(location, changedLocationMode)][If sensor,[this.subscribe(sensor, temperature, temperatureHandler)][this.subscribe(thermostat, temperature, temperatureHandler)][this.subscribe(thermostat, thermostatMode, temperatureHandler)],],]
changedLocationMode: ]
temperatureHandler: ]
evaluate: [If sensor,[(threshold = 1.0)][(tm = thermostat.currentThermostatMode)][(ct = thermostat.currentTemperature)][(currentTemp = sensor.currentTemperature)][If (tm in [cool, auto]),[If ((currentTemp - coolingSetpoint) >= threshold),,[If (((coolingSetpoint - currentTemp) >= threshold) && ((ct - thermostat.currentCoolingSetpoint) >= threshold)),,],],,],[If (tm in [heat, emergency heat, auto]),[If ((heatingSetpoint - currentTemp) >= threshold),,[If (((currentTemp - heatingSetpoint) >= threshold) && ((thermostat.currentHeatingSetpoint - ct) >= threshold)),,],],,],,],]
coolingSetpointHandler: ]
heatingSetpointHandler: ]
Starting Points: []
IT HAS STATE
--app-start--
processing keep-me-cozy.groovy
DECLARED METHODS
installed: [this.subscribe(thermostat, heatingSetpoint, heatingSetpointHandler)][this.subscribe(thermostat, coolingSetpoint, coolingSetpointHandler)][this.subscribe(thermostat, temperature, temperatureHandler)][this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]]
updated: [this.unsubscribe()][this.subscribe(thermostat, heatingSetpoint, heatingSetpointHandler)][this.subscribe(thermostat, coolingSetpoint, coolingSetpointHandler)][this.subscribe(thermostat, temperature, temperatureHandler)][this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]]
heatingSetpointHandler: ]
coolingSetpointHandler: ]
temperatureHandler: ]
changedLocationMode: ]
appTouch: ]
event: ]
Starting Points: []
IT HAS STATE
--app-start--
processing laundry-monitor.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(sensor1, acceleration.active, accelerationActiveHandler)][this.subscribe(sensor1, acceleration.inactive, accelerationInactiveHandler)]]
accelerationActiveHandler: [If state.isRunning,[(state.isRunning = true)][(state.startedAt = this.now())],],[(state.stoppedAt = null)]]
accelerationInactiveHandler: [log.trace(no vibration, isRunning: $state.isRunning)][If state.isRunning,[log.debug(startedAt: $state.startedAt, stoppedAt: $state.stoppedAt)][If state.stoppedAt,[(state.stoppedAt = this.now())][(delay = java.lang.Math.floor((fillTime * 60)).toInteger())][this.runIn(delay, checkRunning, [overwrite:false])],],,],]
checkRunning: [If state.isRunning,[(fillTimeMsec = (fillTime) ? (fillTime * 60000) : 300000)][(sensorStates = sensor1.statesSince(acceleration, new java.util.Date((java.lang.Long -> java.lang.Long) (this.now() - fillTimeMsec))))][If sensorStates.find({ -> ... }),[(cycleTimeMsec = (cycleTime) ? (cycleTime * 60000) : 600000)][(duration = (this.now() - state.startedAt))][If ((duration - fillTimeMsec) > cycleTimeMsec),[(msg = $sensor1.displayName is finished)][If location.contactBookEnabled,,[If phone,,],],[If switches,[If lightMode?.equals(Turn On Lights),,],,],,],[(state.isRunning = false)],],,],]
flashLights: [(doFlash = true)][(onFor = (onFor) ? onFor : 1000)][(offFor = (offFor) ? offFor : 1000)][(numFlashes = (numFlashes) ? numFlashes : 3)][log.debug(LAST ACTIVATED IS: $state.lastActivated)][If state.lastActivated,[(elapsed = (this.now() - state.lastActivated))][(sequenceTime = ((numFlashes + 1) * (onFor + offFor)))][(doFlash = (elapsed > sequenceTime))][log.debug(DO FLASH: $doFlash, ELAPSED: $elapsed, LAST ACTIVATED: $state.lastActivated)],],[If doFlash,[(state.lastActivated = this.now())][log.debug(LAST ACTIVATED SET TO: $state.lastActivated)][(initialActionOn = switches.collect({ -> ... }))][(delay = 1)],],]
Starting Points: []
IT HAS STATE
--app-start--
processing left-it-open.groovy
DECLARED METHODS
installed: [this.subscribe()]]
updated: [this.unsubscribe()][this.subscribe()]]
subscribe: [this.subscribe(contact, contact.open, doorOpen)][this.subscribe(contact, contact.closed, doorClosed)]]
doorOpen: [(delay = (((openThreshold != null) && (openThreshold != ))) ? (openThreshold * 60) : 600)][this.runIn(delay, doorOpenTooLong, [overwrite:true])]]
doorClosed: [this.unschedule(doorOpenTooLong)]]
doorOpenTooLong: [(contactState = contact.currentState(contact))][(freq = (((frequency != null) && (frequency != ))) ? (frequency * 60) : 600)][If (contactState.value == open),[(elapsed = (this.now() - contactState.rawDateCreated.time))][(threshold = ((((openThreshold != null) && (openThreshold != ))) ? (openThreshold * 60000) : 60000 - 1000))][If (elapsed >= threshold),[this.runIn(freq, doorOpenTooLong, [overwrite:false])],],,],]
sendMessage: [(minutes = (((openThreshold != null) && (openThreshold != ))) ? openThreshold : 10)][(msg = $contact.displayName has been left open for $minutes minutes.)][If location.contactBookEnabled,,[If phone,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing let-there-be-dark.groovy
DECLARED METHODS
installed: [this.subscribe(contact1, contact, contactHandler)]]
updated: [this.unsubscribe()][this.subscribe(contact1, contact, contactHandler)]]
contactHandler: [If (evt.value == open),[(state.wasOn = (switch1.currentValue(switch) == on))],],[If (evt.value == closed),[If state.wasOn,,],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing let-there-be-light.groovy
DECLARED METHODS
installed: [this.subscribe(contact1, contact, contactHandler)]]
updated: [this.unsubscribe()][this.subscribe(contact1, contact, contactHandler)]]
contactHandler: [If (evt.value == open),,[If (evt.value == closed),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing life360-user.groovy
DECLARED METHODS
generatePresenceEvent: [(value = this.formatValue(present))][(linkText = this.getLinkText(device))][(descriptionText = this.formatDescriptionText(linkText, present))][(handlerName = this.getState(present))][(results = [name:presence, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName])]]
setMemberId: [log.debug(MemberId = $memberId)][(state.life360MemberId = memberId)]]
getMemberId: [log.debug(MemberId = $state.life360MemberId)][return state.life360MemberId]]
formatValue: [If present,,],]
formatDescriptionText: [If present,,],]
getState: [If present,,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: life360-user.metadata() is applicable for argument types: (life360-user$_run_closure1) values: [life360-user$_run_closure1@c9d0d6]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing lifx-color-bulb.groovy
DECLARED METHODS
initialize: ]
installed: ]
updated: ]
setHue: ]
setSaturation: ]
setColor: [(attrs = [])][(events = [])]]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
setLevel: [If ((percentage < 1) && (percentage > 0)),[(percentage = 1)],],[If (percentage == 0),,],]
setColorTemperature: ]
on: ]
off: ]
refresh: [(resp = parent.apiGET(/lights/$this.selector()))][If (resp.status == 404),[(state.online = false)],[If (resp.status != 200),,],],[(data = resp.data[0])][If data.connected,,],]
selector: [If device.deviceNetworkId.contains(:),,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: lifx-color-bulb.metadata() is applicable for argument types: (lifx-color-bulb$_run_closure1) values: [lifx-color-bulb$_run_closure1@3cdf2c61]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing lifx-white-bulb.groovy
DECLARED METHODS
initialize: ]
installed: ]
updated: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
setLevel: [If ((percentage < 1) && (percentage > 0)),[(percentage = 1)],],[If (percentage == 0),,],]
setColorTemperature: ]
on: ]
off: ]
refresh: [(resp = parent.apiGET(/lights/$this.selector()))][If (resp.status == 404),[(state.online = false)],[If (resp.status != 200),,],],[(data = resp.data[0])][If data.connected,,],]
selector: [If device.deviceNetworkId.contains(:),,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: lifx-white-bulb.metadata() is applicable for argument types: (lifx-white-bulb$_run_closure1) values: [lifx-white-bulb$_run_closure1@38234a38]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing light-follows-me.groovy
DECLARED METHODS
installed: [this.subscribe(motion1, motion, motionHandler)]]
updated: [this.unsubscribe()][this.subscribe(motion1, motion, motionHandler)]]
motionHandler: [If (evt.value == active),,[If (evt.value == inactive),[this.runIn((minutes1 * 60), scheduleCheck, [overwrite:false])],],],]
scheduleCheck: [log.debug(schedule check)][(motionState = motion1.currentState(motion))][If (motionState.value == inactive),[(elapsed = (this.now() - motionState.rawDateCreated.time))][(threshold = (((1000 * 60) * minutes1) - 1000))][If (elapsed >= threshold),,],,],]
Starting Points: [log.debug(schedule check)]
IT HAS STATE
--app-start--
processing light-sensor.groovy
DECLARED METHODS
parse: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If description?.startsWith(illuminance: ),[(raw = (description - illuminance: ))][If raw.isNumber(),[(result = this.createEvent([name:illuminance, value:java.lang.Math.round(zigbee.lux((java.lang.Integer -> java.lang.Integer) raw)).toString(), unit:lux]))],],,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: light-sensor.metadata() is applicable for argument types: (light-sensor$_run_closure1) values: [light-sensor$_run_closure1@3d3e5463]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing light-up-the-night.groovy
DECLARED METHODS
installed: [this.subscribe(lightSensor, illuminance, illuminanceHandler)]]
updated: [this.unsubscribe()][this.subscribe(lightSensor, illuminance, illuminanceHandler)]]
illuminanceHandler: [(lastStatus = state.lastStatus)][If ((lastStatus != on) && (evt.integerValue < 30)),[(state.lastStatus = on)],[If ((lastStatus != off) && (evt.integerValue > 50)),[(state.lastStatus = off)],],],]
Starting Points: []
IT HAS STATE
--app-start--
processing lights-off-when-closed.groovy
DECLARED METHODS
installed: [this.subscribe(contact1, contact.closed, contactClosedHandler)]]
updated: [this.unsubscribe()][this.subscribe(contact1, contact.closed, contactClosedHandler)]]
contactClosedHandler: ]
Starting Points: []
IT HAS STATE
--app-start--
processing lights-off-with-no-motion-and-presence.groovy
DECLARED METHODS
installed: [this.subscribe(motionSensor, motion, motionHandler)][this.subscribe(presenceSensors, presence, presenceHandler)]]
updated: [this.unsubscribe()][this.subscribe(motionSensor, motion, motionHandler)][this.subscribe(presenceSensors, presence, presenceHandler)]]
motionHandler: [If (evt.value == inactive),[this.runIn((delayMins * 60), scheduleCheck, [overwrite:true])],],]
presenceHandler: [If (evt.value == not present),[this.runIn((delayMins * 60), scheduleCheck, [overwrite:true])],],]
isActivePresence: [(noPresence = (presenceSensors.find({ -> ... }) == null))]]
scheduleCheck: [log.debug(scheduled check)][(motionState = motionSensor.currentState(motion))][If (motionState.value == inactive),[(elapsed = (this.now() - motionState.rawDateCreated.time))][(threshold = (((1000 * 60) * delayMins) - 1000))][If (elapsed >= threshold),[If this.isActivePresence(),,],,],,],]
Starting Points: [log.debug(scheduled check)]
IT HAS STATE
--app-start--
processing lock-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
lock: ]
unlock: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: lock-capability.metadata() is applicable for argument types: (lock-capability$_run_closure1) values: [lock-capability$_run_closure1@7e4204e2]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing lock-it-at-a-specific-time.groovy
DECLARED METHODS
installed: [this.schedule(time, setTimeCallback)]]
updated: [this.unschedule()][this.schedule(time, setTimeCallback)]]
setTimeCallback: [If contact,,],]
doorOpenCheck: [(currentState = contact.contactState)][If (currentState?.value == open),[(msg = $contact.displayName is open.  Scheduled lock failed.)][If sendPushMessage,,],[If phone,,],,],]
lockMessage: [(msg = Locking $lock.displayName due to scheduled lock.)][If sendPushMessage,,],[If phone,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing lock-it-when-i-leave.groovy
DECLARED METHODS
installed: [this.subscribe(presence1, presence, presence)]]
updated: [this.unsubscribe()][this.subscribe(presence1, presence, presence)]]
presence: [If (evt.value == present),[If (unlock == Yes),[(anyLocked = (lock1.count({ -> ... }) != lock1.size()))][If anyLocked,,],,],,[(nobodyHome = (presence1.find({ -> ... }) == null))][If nobodyHome,[(anyUnlocked = (lock1.count({ -> ... }) != lock1.size()))][If anyUnlocked,,],,],],]
sendMessage: [If location.contactBookEnabled,,[If (spam == Yes),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing logitech-harmony-hub-c2c.groovy
DECLARED METHODS
initialize: ]
installed: ]
updated: ]
startActivity: ]
activityoff: ]
alloff: ]
poll: ]
ping: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: logitech-harmony-hub-c2c.metadata() is applicable for argument types: (logitech-harmony-hub-c2c$_run_closure1) values: [logitech-harmony-hub-c2c$_run_closure1@39655d3e]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing mail-arrived.groovy
DECLARED METHODS
installed: [this.subscribe(accelerationSensor, acceleration.active, accelerationActiveHandler)]]
updated: [this.unsubscribe()][this.subscribe(accelerationSensor, acceleration.active, accelerationActiveHandler)]]
accelerationActiveHandler: [(deltaSeconds = 5)][(timeAgo = new java.util.Date((this.now() - (1000 * deltaSeconds))))][(recentEvents = accelerationSensor.eventsSince(timeAgo))][(alreadySentNotifications = (recentEvents.count({ -> ... }) > 1))][If alreadySentNotifications,,[If location.contactBookEnabled,,[If ((phone1 != null) && (phone1 != )),,],[If pushNotification,,],],],]
Starting Points: []
IT HAS STATE
--app-start--
processing make-it-so.groovy
DECLARED METHODS
installed: [this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]]
updated: [this.unsubscribe()][this.subscribe(location, changedLocationMode)][this.subscribe(app, appTouch)]]
appTouch: ]
changedLocationMode: ]
restoreState: [(map = (state[mode]) ? state[mode] : [:])]]
saveState: [(mode = currentMode)][(map = (state[mode]) ? state[mode] : [:])][(state[mode] = map)]]
getCurrentMode: ]
Starting Points: []
IT HAS STATE
--app-start--
processing medicine-management-contact-sensor.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(deviceContactSensor, contact, contactHandler)][(state.minutesToCheckOpenDraw = 60)][(state.ledNotificationTriggered = false)][this.schedule(reminderTime, checkOpenDrawInPast)]]
contactHandler: [If (evt.value == open),[If state.ledNotificationTriggered,,],,],]
checkOpenDrawInPast: [(cabinetOpened = this.isOpened(state.minutesToCheckOpenDraw))][If cabinetOpened,[(reminderTimePlus10 = new java.util.Date((this.now() + (10 * 60000))))][this.runOnce(reminderTimePlus10, checkOpenDrawAfterReminder)],],]
checkOpenDrawAfterReminder: [(cabinetOpened = this.isOpened(10))][If cabinetOpened,,],]
sendNotification: ]
isOpened: [(previousDateTime = new java.util.Date((this.now() - (minutes * 60000))))][(evts = deviceContactSensor.eventsSince(previousDateTime))][(cabinetOpened = false)][If (evts.size() > 0),,],]
setLEDNotification: [(state.ledNotificationTriggered = true)][(state.ledState = deviceLight.currentValue(switch))][(state.origColor = deviceLight.currentValue(hue))][log.debug(LED set to RED. Original color stored: $state.origColor)]]
resetLEDNotification: [(state.ledNotificationTriggered = false)][log.debug(Reset LED color to: $state.origColor)][If (state.origColor != null),[deviceLight.setHue(state.origColor)],],[If (state.ledState == off),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing medicine-management-temp-motion.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(deviceTemperatureMeasurement, temperature, tempHandler)][this.subscribe(deviceAccelerationSensor, acceleration.active, motionHandler)][(state.minutesToCheckPriorToReminder = 60)][this.schedule(reminderTime, checkMotionInPast)]]
tempHandler: [If (evt.doubleValue > tempThreshold),,],]
motionHandler: ]
checkMotionInPast: [(movement = this.isMoved(state.minutesToCheckPriorToReminder))][If movement,[(reminderTimePlus10 = new java.util.Date((this.now() + (10 * 60000))))][this.runOnce(reminderTimePlus10, checkMotionAfterReminder)],],]
checkMotionAfterReminder: [(movement = this.isMoved(10))][If movement,,],]
sendNotification: ]
isMoved: [(previousDateTime = new java.util.Date((this.now() - (minutes * 60000))))][(evts = deviceAccelerationSensor.eventsSince(previousDateTime))][(motion = false)][If (evts.size() > 0),,],]
setLEDNotification: [(state.ledState = deviceLight.currentValue(switch))][(state.origColor = deviceLight.currentValue(hue))][log.debug(LED set to RED. Original color stored: $state.origColor)]]
resetLEDNotification: [log.debug(Reset LED color to: $state.origColor)][deviceLight.setHue(state.origColor)][If (state.ledState == off),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing medicine-reminder.groovy
DECLARED METHODS
installed: ]
updated: [this.unschedule()]]
initialize: [(window = timeWindowMsec)]]
scheduleCheck0: [this.scheduleCheck()]]
scheduleCheck1: [this.scheduleCheck()]]
scheduleCheck2: [this.scheduleCheck()]]
scheduleCheck3: [this.scheduleCheck()]]
scheduleCheck: [log.debug(scheduleCheck)][(t0 = new java.util.Date((this.now() - (2 * timeWindowMsec))))][(t1 = new java.util.Date())][(cabinetOpened = cabinet1.eventsBetween(t0, t1).find({ -> ... }))][If cabinetOpened,,],]
sendMessage: [(msg = Please remember to take your medicine)][If location.contactBookEnabled,,[If phone1,,],[If (sendPush == Yes),,],],]
getTimeWindowMsec: ]
Starting Points: []
IT HAS STATE
--app-start--
processing mini-hue-controller.groovy
DECLARED METHODS
installed: [(state.colorIndex = -1)]]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(controller, button, buttonHandler)]]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
buttonHandler: ]
toggleState: [If (currentSwitchState == on),,],]
levelUp: [(level = java.lang.Math.min((currentSwitchLevel + 10), 100))][log.debug(level = $level)]]
levelDown: [(level = java.lang.Math.max((currentSwitchLevel - 10), 10))][log.debug(level = $level)]]
changeColor: [(colors = [[name:Soft White, hue:23, saturation:56], [name:Daylight, hue:53, saturation:91], [name:White, hue:52, saturation:19], [name:Warm White, hue:20, saturation:80], [name:Blue, hue:70, saturation:100], [name:Green, hue:39, saturation:100], [name:Yellow, hue:25, saturation:100], [name:Orange, hue:10, saturation:100], [name:Purple, hue:75, saturation:100], [name:Pink, hue:83, saturation:100], [name:Red, hue:100, saturation:100]])][(maxIndex = (colors.size() - 1))][If (state.colorIndex < maxIndex),[(state.colorIndex = (state.colorIndex + 1))],[(state.colorIndex = 0)]],[(color = colors[state.colorIndex])]]
getCurrentSwitchState: [(on = 0)][(off = 0)]]
getCurrentSwitchLevel: [(level = 0)]]
Starting Points: []
IT HAS STATE
--app-start--
processing mobile-presence.groovy
DECLARED METHODS
parse: [(name = this.parseName(description))][(value = this.parseValue(description))][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(handlerName = this.getState(value))][(isStateChange = this.isStateChange(device, name, value))][(results = [translatable:true, name:name, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName, ... ])]]
parseName: [If description?.startsWith(presence: ),,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseValue: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseDescriptionText: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
getState: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: mobile-presence.metadata() is applicable for argument types: (mobile-presence$_run_closure1) values: [mobile-presence$_run_closure1@31bcf236]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing momentary-button-tile.groovy
DECLARED METHODS
parse: ]
push: ]
on: ]
off: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: momentary-button-tile.metadata() is applicable for argument types: (momentary-button-tile$_run_closure1) values: [momentary-button-tile$_run_closure1@71529963]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing momentary-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
push: ]
off: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: momentary-capability.metadata() is applicable for argument types: (momentary-capability$_run_closure1) values: [momentary-capability$_run_closure1@8dbfffb]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing monitor-on-sense.groovy
DECLARED METHODS
installed: [this.subscribe(accelerationSensor, acceleration.active, accelerationActiveHandler)]]
updated: [this.unsubscribe()][this.subscribe(accelerationSensor, acceleration.active, accelerationActiveHandler)]]
accelerationActiveHandler: ]
Starting Points: []
IT HAS STATE
--app-start--
processing mood-cube.groovy
DECLARED METHODS
scenesPage: [(sceneId = this.getOrientation())]]
scenePage: [(currentSceneId = this.getOrientation())][(sceneId = ((java.lang.Integer -> java.lang.Integer) params.sceneId) ? (java.lang.Integer -> java.lang.Integer) params.sceneId : state.lastDisplayedSceneId)][(state.lastDisplayedSceneId = sceneId)]]
devicePage: [(sceneId = ((java.lang.Integer -> java.lang.Integer) params.sceneId) ? (java.lang.Integer -> java.lang.Integer) params.sceneId : state.lastDisplayedSceneId)]]
saveStatesPage: ]
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(cube, threeAxis, positionHandler)]]
positionHandler: [(sceneId = this.getOrientation(evt.xyzValue))][If (sceneId != state.lastActiveSceneId),,],[(state.lastActiveSceneId = sceneId)]]
sceneIsDefined: [(tgt = onoff_$sceneId.toString())][(settings.find({ -> ... }) != null)]]
updateSetting: [(settings[name] = value)]]
closestLevel: ]
saveStates: [(sceneId = (java.lang.Integer -> java.lang.Integer) params.sceneId)]]
restoreStates: ]
switchLevel: [(percent = settings.level_$sceneId_$light.id)][If percent,,],]
getDeviceCapabilities: [(caps = [:])][(state.lightCapabilities = caps)]]
getLevels: [(levels = [])][For ((i = 0); (i <= 100); (i += 5)),]getLevels: [(levels = [])][For ((i = 0); (i <= 100); (i += 5)),]]
getOrientation: [(threshold = 250)][(value = (xyz) ? xyz : cube.currentValue(threeAxis))][(x = ((java.lang.Math.abs(value.x) > threshold)) ? ((value.x > 0)) ? 1 : -1 : 0)][(y = ((java.lang.Math.abs(value.y) > threshold)) ? ((value.y > 0)) ? 1 : -1 : 0)][(z = ((java.lang.Math.abs(value.z) > threshold)) ? ((value.z > 0)) ? 1 : -1 : 0)][(orientation = 0)][If (z > 0),[If ((x == 0) && (y == 0)),[(orientation = 1)],],,[If (z < 0),[If ((x == 0) && (y == 0)),[(orientation = 2)],],,[If (x > 0),[If (y == 0),[(orientation = 3)],],,[If (x < 0),[If (y == 0),[(orientation = 4)],],,[If (y > 0),[(orientation = 5)],[If (y < 0),[(orientation = 6)],],],],],],],]
sceneName: [(names = [UNDEFINED, One, Two, Three, Four, Five, Six])]]
Starting Points: []
IT HAS STATE
--app-start--
processing motion-detector.groovy
DECLARED METHODS
parse: [(name = null)][(value = description)][(descriptionText = null)][If zigbee.isZoneType19(description),[(name = motion)][(isActive = zigbee.translateStatusZoneType19(description))][(value = (isActive) ? active : inactive)][(descriptionText = (isActive) ? $device.displayName detected motion : $device.displayName motion has stopped)],],[(result = this.createEvent([name:name, value:value, descriptionText:descriptionText]))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: motion-detector.metadata() is applicable for argument types: (motion-detector$_run_closure1) values: [motion-detector$_run_closure1@35229f85]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing motion-sensor-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: motion-sensor-capability.metadata() is applicable for argument types: (motion-sensor-capability$_run_closure1) values: [motion-sensor-capability$_run_closure1@4d9ac0b4]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing my-light-toggle.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(motionToggler, motion, toggleSwitches)]]
toggleSwitches: [If ((evt.value == active) && (masterToggle.currentSwitch == off)),,[If ((evt.value == active) && (masterToggle.currentSwitch == on)),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing netatmo-additional-module.groovy
DECLARED METHODS
parse: ]
poll: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: netatmo-additional-module.metadata() is applicable for argument types: (netatmo-additional-module$_run_closure1) values: [netatmo-additional-module$_run_closure1@2a76840c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing netatmo-basestation.groovy
DECLARED METHODS
parse: ]
poll: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: netatmo-basestation.metadata() is applicable for argument types: (netatmo-basestation$_run_closure1) values: [netatmo-basestation$_run_closure1@74c79fa2]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing netatmo-outdoor-module.groovy
DECLARED METHODS
parse: ]
poll: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: netatmo-outdoor-module.metadata() is applicable for argument types: (netatmo-outdoor-module$_run_closure1) values: [netatmo-outdoor-module$_run_closure1@32193bea]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing netatmo-rain.groovy
DECLARED METHODS
parse: ]
poll: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: netatmo-rain.metadata() is applicable for argument types: (netatmo-rain$_run_closure1) values: [netatmo-rain$_run_closure1@2dca0d64]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing nfc-tag-toggle.groovy
currentValue, arg not ConstantExpression
currentValue, arg not ConstantExpression
DECLARED METHODS
pageTwo: ]
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(tag, nfcTouch, touchHandler)][this.subscribe(app, touchHandler)]]
currentStatus: [(result = null)][If master,[(result = devices.find({ -> ... })?.currentValue(attribute))],[(map = [:])][(result = map.collect({ -> ... }).sort({ -> ... })[-1].key)]],[log.debug($attribute = $result)]]
touchHandler: [If switch1,[(status = this.currentStatus(switch1, masterSwitch, switch))],],[If lock,[(status = this.currentStatus(lock, masterLock, lock))],],[If garageDoor,[(status = this.currentStatus(garageDoor, masterDoor, status))],],]
Starting Points: []
IT HAS STATE
--app-start--
processing nobody-home.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
init: [this.subscribe(people, presence, presence)][this.subscribe(location, sunrise, setSunrise)][this.subscribe(location, sunset, setSunset)][(state.sunMode = location.mode)]]
setSunrise: ]
setSunset: ]
changeSunMode: [(state.sunMode = newMode)][If (this.everyoneIsAway() && (location.mode == newAwayMode)),,[If (location.mode != newMode),[(message = $app.label changed your mode to '$newMode')],],],]
presence: [If (evt.value == not present),[If this.everyoneIsAway(),[(delay = (((awayThreshold != null) && (awayThreshold != ))) ? (awayThreshold * 60) : (10 * 60))][this.runIn(delay, setAway)],],,[If (location.mode != state.sunMode),[If this.anyoneIsHome(),[log.info(Starting $state.sunMode sequence)][this.changeSunMode(state.sunMode)],],,],],]
setAway: [If this.everyoneIsAway(),[If (location.mode != newAwayMode),[(message = $app.label changed your mode to '$newAwayMode' because everyone left home)],],,],]
everyoneIsAway: [(result = true)][If people.findAll({ -> ... }),[(result = false)],],]
anyoneIsHome: [(result = false)][If people.findAll({ -> ... }),[(result = true)],],]
send: [If (sendPushMessage != No),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing notify-me-when-it-opens.groovy
DECLARED METHODS
installed: [this.subscribe(contact1, contact.open, contactOpenHandler)]]
updated: [this.unsubscribe()][this.subscribe(contact1, contact.open, contactOpenHandler)]]
contactOpenHandler: ]
Starting Points: []
IT HAS STATE
--app-start--
processing notify-me-when.groovy
DECLARED METHODS
installed: [this.subscribeToEvents()]]
updated: [this.unsubscribe()][this.subscribeToEvents()]]
subscribeToEvents: [this.subscribe(button, button.pushed, eventHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)]]
eventHandler: [If frequency,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],]
sendMessage: [(msg = messageText)][(options = [:])][If messageText,[(msg = this.defaultText(evt))][(options = [translatable:true, triggerEvent:evt])],],[If location.contactBookEnabled,,[If phone,[(options.phone = phone)][If (pushAndPhone != No),[(options.method = both)],[(options.method = phone)]],,[If (pushAndPhone != No),[(options.method = push)],[(options.method = none)]],],],[If frequency,[(state[evt.deviceId] = this.now())],],]
defaultText: [If (evt.name == presence),[If (evt.value == present),[If includeArticle,,],,[If includeArticle,,],],,],]
getIncludeArticle: [(name = location.name.toLowerCase())][(segs = name.split( ))]]
Starting Points: []
IT HAS STATE
--app-start--
processing notify-me-with-hue.groovy
DECLARED METHODS
installed: [this.subscribeToEvents()]]
updated: [this.unsubscribe()][this.unschedule()][this.subscribeToEvents()]]
subscribeToEvents: [this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,[this.schedule(timeOfDay, scheduledTimeHandler)],],]
eventHandler: [If frequency,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],]
modeChangeHandler: [If (evt.value in triggerModes),,],]
scheduledTimeHandler: ]
appTouchHandler: ]
takeAction: [If frequency,[(state[evt.deviceId] = this.now())],],[(hueColor = 0)][If (color == Blue),[(hueColor = 70)],[If (color == Green),[(hueColor = 39)],[If (color == Yellow),[(hueColor = 25)],[If (color == Orange),[(hueColor = 10)],[If (color == Purple),[(hueColor = 75)],[If (color == Pink),[(hueColor = 83)],],],],],],],[(state.previous = [:])][log.debug(current values = $state.previous)][(newValue = [hue:hueColor, saturation:100, level:((java.lang.Integer -> java.lang.Integer) lightLevel) ? (java.lang.Integer -> java.lang.Integer) lightLevel : 100])][log.debug(new value = $newValue)]]
setTimer: [If duration,,[If (duration < 10),,[log.debug(runIn $duration, resetHue)][this.runIn(duration, resetHue, [overwrite:false])]],],]
resetHue: ]
Starting Points: []
IT HAS STATE
--app-start--
processing obything-music-connect.groovy
DECLARED METHODS
installed: ]
updated: ]
initialize: [(parts = theAddr.split(:))][(iphex = this.convertIPtoHex(parts[0]))][(porthex = this.convertPortToHex(parts[1]))][(dni = $iphex:$porthex)][(hubNames = location.hubs*?.name.findAll({ -> ... }))][(d = this.addChildDevice(com.obycode, ObyThing Music, dni, theHub.id, [label:$app.label, name:ObyThing]))]]
convertIPtoHex: [(hex = ipAddress.tokenize(.).collect({ -> ... }).join())]]
convertPortToHex: [(hexport = port.toString().format(%04X, port.toInteger()))]]
Starting Points: []
IT HAS STATE
--app-start--
processing on-off-button-tile.groovy
DECLARED METHODS
parse: ]
on: ]
off: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: on-off-button-tile.metadata() is applicable for argument types: (on-off-button-tile$_run_closure1) values: [on-off-button-tile$_run_closure1@fade1fc]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing on-off-shield.groovy
DECLARED METHODS
parse: [(value = zigbee.parse(description)?.text)][(name = ((value in [on, off])) ? switch : null)][(result = this.createEvent([name:name, value:value]))]]
on: ]
off: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: on-off-shield.metadata() is applicable for argument types: (on-off-shield$_run_closure1) values: [on-off-shield$_run_closure1@2c532cd8]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing once-a-day.groovy
DECLARED METHODS
installed: [this.schedule(startTime, startTimerCallback)][this.schedule(stopTime, stopTimerCallback)]]
updated: [this.unschedule()][this.schedule(startTime, startTimerCallback)][this.schedule(stopTime, stopTimerCallback)]]
startTimerCallback: ]
stopTimerCallback: ]
Starting Points: []
IT HAS STATE
--app-start--
processing open-closed-sensor.groovy
DECLARED METHODS
parse: [(resMap = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If description.startsWith(zone),[(resMap = this.createEvent([name:contact, value:(zigbee.parseZoneStatus(description).isAlarm1Set()) ? open : closed]))],],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: open-closed-sensor.metadata() is applicable for argument types: (open-closed-sensor$_run_closure1) values: [open-closed-sensor$_run_closure1@45815ffc]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing particulate-detector.groovy
DECLARED METHODS
parse: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: particulate-detector.metadata() is applicable for argument types: (particulate-detector$_run_closure1) values: [particulate-detector$_run_closure1@4fce136b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing pet-feeder-shield.groovy
DECLARED METHODS
parse: [(value = zigbee.parse(description)?.text)][(name = ((value && (value != ping))) ? response : null)][(result = this.createEvent([name:name, value:value]))]]
feed: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: pet-feeder-shield.metadata() is applicable for argument types: (pet-feeder-shield$_run_closure1) values: [pet-feeder-shield$_run_closure1@49872d67]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing photo-burst-when.groovy
DECLARED METHODS
installed: [this.subscribeToEvents()]]
updated: [this.unsubscribe()][this.subscribeToEvents()]]
subscribeToEvents: [this.subscribe(contact, contact.open, sendMessage)][this.subscribe(acceleration, acceleration.active, sendMessage)][this.subscribe(motion, motion.active, sendMessage)][this.subscribe(mySwitch, switch.on, sendMessage)][this.subscribe(arrivalPresence, presence.present, sendMessage)][this.subscribe(departurePresence, presence.not present, sendMessage)]]
sendMessage: [If location.contactBookEnabled,,[If phone,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing plant-link.groovy
DECLARED METHODS
updated: ]
parse: [(map = [:])][If description?.startsWith(read attr -),[(descMap = this.parseDescriptionAsMap(description))][If ((descMap.cluster == 0405) && (descMap.attrId == 0000)),[(map.name = humidity)][(map.value = this.calculateHumidity(descMap.value))],[If ((descMap.cluster == 0001) && (descMap.attrId == 0000)),[(map.name = battery)][(map.value = this.calculateBattery(descMap.value))],],],,],[(result = null)][If map,[(result = this.createEvent(map))],],]
parseDescriptionAsMap: ]
calculateHumidity: [(range = 576)][(percent = ((java.lang.Integer.parseInt(value, 16) / range) * 100))][(percent = java.lang.Math.max(0.0, java.lang.Math.min(percent, 100.0)))]]
calculateBattery: [(min = 2300)][(percent = ((java.lang.Integer.parseInt(value, 16) - min) / 10))][(percent = java.lang.Math.max(0.0, java.lang.Math.min(percent, 100.0)))]]
hex: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: plant-link.metadata() is applicable for argument types: (plant-link$_run_closure1) values: [plant-link$_run_closure1@616fe72b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing plantlink.groovy
DECLARED METHODS
updated: ]
installed: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
setStatusIcon: [(status = )]]
setPlantFuelLevel: ]
setBatteryLevel: ]
setInstallSmartApp: ]
parse: [(description_map = this.parseDescriptionAsMap(description))][(event_name = )][(measurement_map = [type:link, signal:0x00, zigbeedeviceid:device.zigbeeId, created:(int) (new java.util.Date().time / 1000)])][If (description_map.cluster == 0001),[(event_name = battery_status)][(measurement_map[battery] = 0x$description_map.value)],[If (description_map.cluster == 0B04),[(measurement_map[moisture] = 0x$description_map.value)][(event_name = moisture_status)],],],[(json_builder = new groovy.json.JsonBuilder(measurement_map))][(result = this.createEvent([name:event_name, value:json_builder.toString()]))]]
parseDescriptionAsMap: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: plantlink.metadata() is applicable for argument types: (plantlink$_run_closure1) values: [plantlink$_run_closure1@2c7b5824]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing power-allowance.groovy
DECLARED METHODS
installed: [this.subscribe(theSwitch, switch.on, switchOnHandler, [filterEvents:false])]]
updated: [this.unsubscribe()][this.subscribe(theSwitch, switch.on, switchOnHandler, [filterEvents:false])]]
switchOnHandler: [(delay = (minutesLater * 60))][this.runIn(delay, turnOffSwitch)]]
turnOffSwitch: ]
Starting Points: []
IT HAS STATE
--app-start--
processing presence-change-push.groovy
DECLARED METHODS
installed: [this.subscribe(presence, presence, presenceHandler)]]
updated: [this.unsubscribe()][this.subscribe(presence, presence, presenceHandler)]]
presenceHandler: [If (evt.value == present),,[If (evt.value == not present),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing presence-change-text.groovy
DECLARED METHODS
installed: [this.subscribe(presence, presence, presenceHandler)]]
updated: [this.unsubscribe()][this.subscribe(presence, presence, presenceHandler)]]
presenceHandler: [If (evt.value == present),[If location.contactBookEnabled,,],,[If (evt.value == not present),[If location.contactBookEnabled,,],,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing presence-sensor-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: presence-sensor-capability.metadata() is applicable for argument types: (presence-sensor-capability$_run_closure1) values: [presence-sensor-capability$_run_closure1@4c5474f5]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-eggtray.groovy
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],]
eggReport: ]
poll: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-eggtray.metadata() is applicable for argument types: (quirky-wink-eggtray$_run_closure1) values: [quirky-wink-eggtray$_run_closure1@704f1591]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-nimbus.groovy
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],]
poll: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-nimbus.metadata() is applicable for argument types: (quirky-wink-nimbus$_run_closure1) values: [quirky-wink-nimbus$_run_closure1@395b56bb]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-porkfolio.groovy
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],]
poll: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-porkfolio.metadata() is applicable for argument types: (quirky-wink-porkfolio$_run_closure1) values: [quirky-wink-porkfolio$_run_closure1@485e36bc]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-powerstrip.groovy
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],]
on: ]
off: ]
poll: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-powerstrip.metadata() is applicable for argument types: (quirky-wink-powerstrip$_run_closure1) values: [quirky-wink-powerstrip$_run_closure1@2374d36a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing quirky-wink-spotter.groovy
DECLARED METHODS
parse: [(results = [])][If (description?.name && description?.value),,],]
poll: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: quirky-wink-spotter.metadata() is applicable for argument types: (quirky-wink-spotter$_run_closure1) values: [quirky-wink-spotter$_run_closure1@696f0212]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing ready-for-rain.groovy
DECLARED METHODS
mainPage: ]
installed: ]
updated: [this.unsubscribe()][this.unschedule()]]
init: [(state.lastMessage = 0)][(state.lastCheck = [time:0, result:false])][this.schedule(0 0,30 * * * ?, scheduleCheck)][this.subscribe(sensors, contact.open, scheduleCheck)]]
scheduleCheck: [(open = sensors.findAll({ -> ... }))][(plural = ((open.size() > 1)) ? are : is)][If (((this.now() - ((30 * 60) * 1000)) > state.lastCheck[time]) && open),[(response = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (location.channelName != samsungtv),[(response = this.getWeatherFeature(forecast, zipCode))],[(response = this.getWeatherFeature(forecast))]],[(weather = this.isStormy(response))][If weather,,],,[If ((((this.now() - ((30 * 60) * 1000)) <= state.lastCheck[time]) && state.lastCheck[result]) && open),[this.send($open.join(, ) $plural open and $state.lastCheck[result] coming.)],],],]
send: [(delay = (((messageDelay != null) && (messageDelay != ))) ? ((messageDelay * 60) * 1000) : 0)][If ((this.now() - delay) > state.lastMessage),[(state.lastMessage = this.now())][If (sendPushMessage == Yes),,],[If phone,,],,],]
isStormy: [(types = [rain, snow, showers, sprinkles, precipitation])][(forecast = json?.forecast?.txt_forecast?.forecastday?.first())][(result = false)][If forecast,[(text = forecast?.fcttext?.toLowerCase())][If text,[For ((i = 0); ((i < types.size()) && result); (i++)),[If text.contains(types[i]),[(result = types[i])],],][For ((i = 0); ((i < types.size()) && result); (i++)),[If text.contains(types[i]),[(result = types[i])],],],],,],[(state.lastCheck = [time:this.now(), result:result])]]
Starting Points: []
IT HAS STATE
--app-start--
processing relative-humidity-measurement-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: relative-humidity-measurement-capability.metadata() is applicable for argument types: (relative-humidity-measurement-capability$_run_closure1) values: [relative-humidity-measurement-capability$_run_closure1@3c989952]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing ridiculously-automated-garage-door.groovy
DECLARED METHODS
installed: [this.subscribe()]]
updated: [this.unsubscribe()][this.subscribe()]]
subscribe: [this.subscribe(doorSensor, contact, garageDoorContact)][this.subscribe(cars, presence, carPresence)][this.subscribe(carDoorSensors, acceleration, accelerationActive)][If interiorDoorSensor,[this.subscribe(interiorDoorSensor, contact.closed, interiorDoorClosed)],],]
doorOpenCheck: [(thresholdMinutes = openThreshold)][If thresholdMinutes,[(currentState = doorSensor.contactState)][If (currentState?.value == open),[log.debug(open for $(this.now() - currentState.date.time), openDoorNotificationSent: $state.openDoorNotificationSent)][If (state.openDoorNotificationSent && ((this.now() - currentState.date.time) > ((thresholdMinutes * 60) * 1000))),[(msg = $doorSwitch.displayName was been open for $thresholdMinutes minutes)][If location.contactBookEnabled,,[If phone,,],],[(state.openDoorNotificationSent = true)],],,[(state.openDoorNotificationSent = false)]],,],]
carPresence: [(openDoorAwayInterval = (falseAlarmThreshold) ? (falseAlarmThreshold * 60) : 600)][If (evt.value == present),[(car = this.getCar(evt))][(t0 = new java.util.Date((this.now() - (openDoorAwayInterval * 1000))))][(states = car.statesSince(presence, t0))][(recentNotPresentState = states.find({ -> ... }))][If recentNotPresentState,,[If (doorSensor.currentContact == closed),[(state.appOpenedDoor = this.now())],],],,[If (doorSensor.currentContact == open),,],],]
garageDoorContact: [If (evt.value == open),[this.schedule(0 * * * * ?, doorOpenCheck)],[this.unschedule(doorOpenCheck)]],]
interiorDoorClosed: [(threshold = ((15 * 60) * 1000))][If (state.appOpenedDoor && ((this.now() - state.appOpenedDoor) < threshold)),[(state.appOpenedDoor = 0)],],]
accelerationActive: [If (doorSensor.currentContact == closed),,],]
openDoor: [If (doorSensor.currentContact == closed),,],]
closeDoor: [If (doorSensor.currentContact == open),,],]
getCar: ]
Starting Points: []
IT HAS STATE
--app-start--
processing rise-and-shine.groovy
DECLARED METHODS
installed: [log.debug(installed, current mode = $location.mode, state.actionTakenOn = $state.actionTakenOn)]]
updated: [log.debug(updated, current mode = $location.mode, state.actionTakenOn = $state.actionTakenOn)][this.unsubscribe()]]
initialize: [this.subscribe(motionSensors, motion.active, motionActiveHandler)][this.subscribe(location, modeChangeHandler)][If (state.modeStartTime == null),[(state.modeStartTime = 0)],],]
modeChangeHandler: [(state.modeStartTime = this.now())]]
motionActiveHandler: [If (state.modeStartTime == null),[this.subscribe(location, modeChangeHandler)][(state.modeStartTime = 0)],],[(t0 = this.now())][(modeStartTime = new java.util.Date(state.modeStartTime))][(timeZone = (location.timeZone) ? location.timeZone : this.timeZone(timeOfDay))][(startTime = this.timeTodayAfter(modeStartTime, timeOfDay, timeZone))][(endTime = this.timeTodayAfter(startTime, (endTime) ? endTime : 16:00, timeZone))][log.debug(startTime: $startTime, endTime: $endTime, t0: $new Date(t0), modeStartTime: $modeStartTime,  actionTakenOn: $state.actionTakenOn, currentMode: $location.mode, newMode: $newMode )][If (((t0 >= startTime.time) && (t0 <= endTime.time)) && (location.mode != newMode)),[(message = Good morning! SmartThings changed the mode to '$newMode')][(dateString = new java.util.Date().format(yyyy-MM-dd))][log.debug(last turned on switches on $state.actionTakenOn, today is $dateString)][If (state.actionTakenOn != dateString),[(state.actionTakenOn = dateString)],],,[log.debug(not in time window, or mode is already set, currentMode = $location.mode, newMode = $newMode)]],]
send: [If location.contactBookEnabled,,[If (sendPushMessage != No),,],[If phoneNumber,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing routine-director.groovy
DECLARED METHODS
selectRoutines: [(configured = (((settings.awayDay && settings.awayNight) && settings.homeDay) && settings.homeNight))]]
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(people, presence, presence)][this.subscribe(location, sunrise, setSunrise)][this.subscribe(location, sunset, setSunset)][(state.homestate = null)]]
checkSun: [(zip = (java.lang.String -> java.lang.String) settings.zip)][(sunInfo = this.getSunriseAndSunset([zipCode:zip]))][(current = this.now())][If ((sunInfo.sunrise.time < current) && (sunInfo.sunset.time > current)),[(state.sunMode = sunrise)][this.runIn(60, setSunrise)],[(state.sunMode = sunset)][this.runIn(60, setSunset)]],]
setSunrise: [(state.sunMode = sunrise)][log.debug(Current sun mode is $state.sunMode)]]
setSunset: [(state.sunMode = sunset)][log.debug(Current sun mode is $state.sunMode)]]
changeSunMode: [If allOk,[If this.everyoneIsAway(),[(delay = (((falseAlarmThreshold != null) && (falseAlarmThreshold != ))) ? (falseAlarmThreshold * 60) : (10 * 60))],[If this.anyoneIsHome(),,],],,],]
presence: [If allOk,[If (evt.value == not present),[If this.everyoneIsAway(),[(delay = (((falseAlarmThreshold != null) && (falseAlarmThreshold != ))) ? (falseAlarmThreshold * 60) : (10 * 60))][this.runIn(delay, setAway)],],,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (1 * 60000))),,],[(state[evt.deviceId] = this.now())]],,],]
setAway: [If this.everyoneIsAway(),[If (state.sunMode == sunset),[(message = Performing "$awayNight" for you as requested.)][(state.homestate = away)],[If (state.sunMode == sunrise),[(message = Performing "$awayDay" for you as requested.)][(state.homestate = away)],],],,],]
setHome: [If this.anyoneIsHome(),[If (state.sunMode == sunset),[If (state.homestate != homeNight),[(message = Performing "$homeNight" for you as requested.)][(state.homestate = homeNight)],],,],[If (state.sunMode == sunrise),[If (state.homestate != homeDay),[(message = Performing "$homeDay" for you as requested.)][(state.homestate = homeDay)],],,],,],]
everyoneIsAway: [(result = true)][If people.findAll({ -> ... }),[(result = false)],],]
anyoneIsHome: [(result = false)][If people.findAll({ -> ... }),[(result = true)],],]
sendAway: [If sendPushMessage,[If recipients,,[If phone,,],],,],]
sendHome: [If sendPushMessageHome,[If recipients,,[If phone,,],],,],]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
getTimeIntervalLabel: ]
hideOptionsSection: ]
Starting Points: []
IT HAS STATE
--app-start--
processing safe-watch.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
init: [this.subscribe(contact, contact.open, triggerContact)][this.subscribe(motion, motion.active, triggerMotion)][this.subscribe(knock, acceleration.active, triggerKnock)][this.subscribe(temp, temperature, triggerTemp)][this.subscribe(axis, threeAxis, triggerAxis)]]
triggerContact: [If this.everyoneIsAway(),,],]
triggerMotion: [If this.everyoneIsAway(),,],]
triggerKnock: [If this.everyoneIsAway(),,],]
triggerTemp: [(temperature = evt.doubleValue)][If ((maxTemp && (maxTemp < temperature)) || (minTemp && (minTemp > temperature))),,],]
triggerAxis: [If this.everyoneIsAway(),,],]
everyoneIsAway: [(result = true)][If people.findAll({ -> ... }),[(result = false)],],]
send: [(delay = (((messageDelay != null) && (messageDelay != ))) ? ((messageDelay * 60) * 1000) : 0)][If ((this.now() - delay) > state.lastMessage),[(state.lastMessage = this.now())][If (sendPushMessage == Yes),,],[If phone,,],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing scheduled-mode-change.groovy
DECLARED METHODS
installed: ]
updated: [this.unschedule()]]
initialize: [this.schedule(time, changeMode)]]
changeMode: [log.debug(changeMode, location.mode = $location.mode, newMode = $newMode, location.modes = $location.modes)][If (location.mode != newMode),[If location.modes?.find({ -> ... }),,],,],]
send: [If location.contactBookEnabled,,[If (sendPushMessage == Yes),,],[If phoneNumber,,],],]
getLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing severe-weather-alert.groovy
DECLARED METHODS
mainPage: ]
installed: [this.scheduleJob()]]
updated: [this.unschedule()][this.scheduleJob()]]
scheduleJob: [(sec = java.lang.Math.round(java.lang.Math.floor((java.lang.Math.random() * 60))))][(min = java.lang.Math.round(java.lang.Math.floor((java.lang.Math.random() * 60))))][(cron = $sec $min * * * ?)][this.schedule(cron, checkForSevereWeather)]]
checkForSevereWeather: [(alerts = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If this.locationIsDefined(),[If this.zipcodeIsValid(),[(alerts = this.getWeatherFeature(alerts, zipCode)?.alerts)],[(alerts = this.getWeatherFeature(alerts)?.alerts)]],,],[(newKeys = (alerts?.collect({ -> ... })) ? alerts?.collect({ -> ... }) : [])][(oldKeys = (state.alertKeys) ? state.alertKeys : [])][If (newKeys != oldKeys),[(state.alertKeys = newKeys)],],]
descriptionFilter: [(filterList = [special, statement, test])][(passesFilter = true)]]
locationIsDefined: ]
zipcodeIsValid: [((zipcode && zipcode.isNumber()) && (zipcode.size() == 5))]]
send: [If location.contactBookEnabled,,[If settings.phone1,,],[If settings.phone2,,],[If settings.phone3,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing shabbat-and-holiday-modes.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.schedule(0 0 8 1/1 * ? *, poll)]]
poll: [this.unschedule(endChag)][this.unschedule(setChag)]]
Hebcal_WebRequest: [(today = new java.util.Date().format(yyyy-MM-dd))][(zip = (java.lang.String -> java.lang.String) settings.zip)][(locale = this.getWeatherFeature(geolookup, zip))][(timezone = java.util.TimeZone.getTimeZone(locale.location.tz_long))][(hebcal_date = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(hebcal_category = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(hebcal_title = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(candlelighting = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(candlelightingLocalTime = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(havdalah = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(havdalahLocalTime = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pushMessage = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(testmessage = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(urlRequest = http://www.hebcal.com/hebcal/?v=1&cfg=json&nh=off&nx=off&year=now&month=now&mf=off&c=on&zip=$zipcode&m=$havdalahOffset&s=off&D=off&d=off&o=off&ss=off)][(hebcal = { java.lang.Object response -> ... })]]
HebCal_GetTime12: [(returnTime = (((hebcal_title.split(:)[1] + :) + hebcal_title.split(:)[2]) +  ))]]
HebCal_GetTime24: [(returnTime = hebcal_date.split(T)[1])][(returnTime = returnTime.split(-)[0])]]
setChag: [If (location.mode != startMode),[If location.modes?.find({ -> ... }),[(dayofweek = new java.util.Date().format(EEE))][If (dayofweek == Fri),,],,],,],[this.unschedule(setChag)]]
endChag: [If (location.mode != endMode),[If location.modes?.find({ -> ... }),,],,],[this.unschedule(endChag)]]
sendMessage: [If (sendPushMessage != No),,],[If phone,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing simple-sync-trigger.groovy
DECLARED METHODS
agentSelection: [If agent,[(state.refreshCount = 0)],],]
control: [(activities = agent.latestValue(activities))][If (activities || state.refreshCount),[(refreshCount = (state.refreshCount) ? 0 : (int) state.refreshCount)][(state.refreshCount = (refreshCount + 1))][(refreshInterval = ((refreshCount == 0)) ? 2 : 4)][If ((refreshCount % 5) == 0),,],,],]
anythingSet: [For [motion, motionInactive, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, button1, triggerModes, timeOfDay],[If settings[name],,],]anythingSet: [For [motion, motionInactive, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, button1, triggerModes, timeOfDay],[If settings[name],,],]]
ifUnset: [If settings[name],,],]
ifSet: [If settings[name],,],]
installed: [this.subscribeToEvents()]]
updated: [this.unsubscribe()][this.unschedule()][this.subscribeToEvents()]]
subscribeToEvents: [log.trace(subscribeToEvents())][this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(motionInactive, motion.inactive, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,[this.schedule(timeOfDay, scheduledTimeHandler)],],]
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],]
modeChangeHandler: [If (evt.value in triggerModes),,],]
scheduledTimeHandler: ]
appTouchHandler: ]
startActivity: [If frequency,[(state.lastActionTimeStamp = this.now())],],]
frequencyKey: ]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],]
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting).time)][(stop = this.timeToday(ending).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
timeIntervalLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing simulated-alarm.groovy
DECLARED METHODS
strobe: ]
siren: ]
both: ]
off: ]
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-alarm.metadata() is applicable for argument types: (simulated-alarm$_run_closure1) values: [simulated-alarm$_run_closure1@5dd91bca]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-button.groovy
DECLARED METHODS
parse: ]
hold1: ]
push1: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-button.metadata() is applicable for argument types: (simulated-button$_run_closure1) values: [simulated-button$_run_closure1@5c8eee0f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-color-control.groovy
DECLARED METHODS
parse: ]
setSaturation: ]
setHue: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-color-control.metadata() is applicable for argument types: (simulated-color-control$_run_closure1) values: [simulated-color-control$_run_closure1@163d04ff]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-contact-sensor.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
open: ]
close: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-contact-sensor.metadata() is applicable for argument types: (simulated-contact-sensor$_run_closure1) values: [simulated-contact-sensor$_run_closure1@183e8023]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-dimmable-bulb.groovy
DECLARED METHODS
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],]
installed: ]
updated: ]
ping: ]
refresh: ]
configure: ]
on: ]
off: ]
setLevel: [(levelEventMap = this.buildSetLevelEvent(value))][If (levelEventMap.value == 0),,],]
setLevel: ]
getSwitch: [(switchState = device.currentState(switch))]]
getLevel: [(levelState = device.currentState(level))]]
initialize: ]
buildSetLevelEvent: [(intValue = (java.lang.Integer -> java.lang.Integer) value)][(newLevel = java.lang.Math.max(java.lang.Math.min(intValue, 99), 0))][(eventMap = [name:level, value:newLevel, unit:%])]]
implicitOn: [If (device.currentValue(switch) != on),,],]
turnOn: ]
turnOff: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-dimmable-bulb.metadata() is applicable for argument types: (simulated-dimmable-bulb$_run_closure1) values: [simulated-dimmable-bulb$_run_closure1@5af3a0f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-dimmer-switch.groovy
DECLARED METHODS
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],]
installed: ]
updated: ]
refresh: ]
configure: ]
on: ]
off: ]
setLevel: [(levelEventMap = this.buildSetLevelEvent(value))][If (levelEventMap.value == 0),,],]
setLevel: ]
initialize: ]
buildSetLevelEvent: [(intValue = (java.lang.Integer -> java.lang.Integer) value)][(newLevel = java.lang.Math.max(java.lang.Math.min(intValue, 99), 0))][(eventMap = [name:level, value:newLevel, unit:%])]]
implicitOn: [If (device.currentValue(switch) != on),,],]
turnOn: ]
turnOff: ]
onPhysical: ]
offPhysical: ]
setLevelPhysical: [(eventMap = this.buildSetLevelEvent(value))][If (eventMap.value == 0),[(eventMap.value = 1)],],[(eventMap.type = physical)]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-dimmer-switch.metadata() is applicable for argument types: (simulated-dimmer-switch$_run_closure1) values: [simulated-dimmer-switch$_run_closure1@ea9b7c6]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-garage-door-opener.groovy
DECLARED METHODS
parse: ]
open: [this.runIn(6, finishOpening)]]
close: [this.runIn(6, finishClosing)]]
finishOpening: ]
finishClosing: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-garage-door-opener.metadata() is applicable for argument types: (simulated-garage-door-opener$_run_closure1) values: [simulated-garage-door-opener$_run_closure1@75c9e76b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-lock.groovy
DECLARED METHODS
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],]
installed: ]
updated: ]
initialize: ]
processPreferences: [(strBatteryLevel = $prefBatteryLevel)][(batteryLevel = (strBatteryLevel.isInteger()) ? strBatteryLevel.toInteger() : null)][If batteryLevel,,],[If prefJamNextOperation,,],[If prefJamImmediately,,],]
refresh: ]
ping: ]
lock: [If (device.currentValue(doesNextOperationJam) == true),,],]
unlock: [If (device.currentValue(doesNextOperationJam) == true),,],]
jam: [If (device.currentValue(doesNextOperationJam) == true),,],]
setJamNextOperation: ]
clearJamNextOperation: ]
setBatteryLevel: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-lock.metadata() is applicable for argument types: (simulated-lock$_run_closure1) values: [simulated-lock$_run_closure1@51cd7ffc]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-minimote.groovy
DECLARED METHODS
parse: ]
push1: ]
push2: ]
push3: ]
push4: ]
hold1: ]
hold2: ]
hold3: ]
hold4: ]
push: ]
hold: ]
installed: ]
updated: ]
initialize: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-minimote.metadata() is applicable for argument types: (simulated-minimote$_run_closure1) values: [simulated-minimote$_run_closure1@efde75f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-motion-sensor.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
active: ]
inactive: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-motion-sensor.metadata() is applicable for argument types: (simulated-motion-sensor$_run_closure1) values: [simulated-motion-sensor$_run_closure1@1d8062d2]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-presence-sensor.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
arrived: ]
departed: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-presence-sensor.metadata() is applicable for argument types: (simulated-presence-sensor$_run_closure1) values: [simulated-presence-sensor$_run_closure1@7be58f16]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-refrigerator-door.groovy
DECLARED METHODS
installed: ]
open: ]
close: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-refrigerator-door.metadata() is applicable for argument types: (simulated-refrigerator-door$_run_closure1) values: [simulated-refrigerator-door$_run_closure1@14f5da2c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-refrigerator-temperature-control.groovy
DECLARED METHODS
installed: [this.sendEvent([name:temperature, value:((device.componentName == freezer)) ? 2 : 40])][this.sendEvent([name:coolingSetpoint, value:((device.componentName == freezer)) ? 2 : 40])]]
updated: ]
tempUp: [(value = (java.lang.Integer -> java.lang.Integer) device.currentValue(temperature))]]
tempDown: [(value = (java.lang.Integer -> java.lang.Integer) device.currentValue(temperature))]]
setpointUp: [(value = (java.lang.Integer -> java.lang.Integer) device.currentValue(coolingSetpoint))]]
setpointDown: [(value = (java.lang.Integer -> java.lang.Integer) device.currentValue(coolingSetpoint))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-refrigerator-temperature-control.metadata() is applicable for argument types: (simulated-refrigerator-temperature-control$_run_closure1) values: [simulated-refrigerator-temperature-control$_run_closure1@3c435123]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-refrigerator.groovy
DECLARED METHODS
installed: [(state.counter = (state.counter) ? (state.counter + 1) : 1)][If (state.counter == 1),,],]
doorOpen: ]
doorClosed: [If childDevices.find({ -> ... }),,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-refrigerator.metadata() is applicable for argument types: (simulated-refrigerator$_run_closure1) values: [simulated-refrigerator$_run_closure1@5ad10c1a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-rgb-bulb.groovy
DECLARED METHODS
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],]
installed: ]
updated: ]
ping: ]
refresh: [(currentMode = device.currentValue(bulbMode))][If MODE.containsValue(currentMode),,],]
configure: ]
on: [this.simulateBulbState(state.lastMode)]]
off: ]
setLevel: [(boundedPercent = this.boundInt(levelPercent, PERCENT_RANGE))][(effectiveMode = device.currentValue(bulbMode))][If (boundedPercent > 0),,[(effectiveMode = MODE.OFF)]],]
setSaturation: [(currentHue = device.currentValue(hue))]]
setHue: [(currentSaturation = device.currentValue(saturation))]]
setColor: [(boundedHue = this.boundInt(huePercent, PERCENT_RANGE))][(boundedSaturation = this.boundInt(saturationPercent, PERCENT_RANGE))][(logMsg = Executing 'setColor' from separate values hue: $boundedHue, saturation: $boundedSaturation)][If ((huePercent != boundedHue) || (saturationPercent != boundedSaturation)),[(logMsg +=  (pre-bounded values hue: $huePercent, saturation: $saturationPercent))],],[(colorHSMap = this.buildColorHSMap(hue, saturation))]]
setColor: [If (hex == #000000),,[(hsvList = colorUtil.hexToHsv(hex))][(colorHSMap = this.buildColorHSMap(hsvList[0], hsvList[1]))]],]
setColor: ]
initialize: [(state.lastMode = MODE.COLOR)]]
implicitOn: [If (device.currentValue(switch) != on),,],]
turnOn: ]
turnOff: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
buildColorHSMap: [(colorHSMap = [hue:0, saturation:0])]]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
simulateBulbState: [(valueText = ---)][(hexColor = BLACK.rgb)][(colorIndicator = 0)]]
flattenHueSat: [(flatHueSat = 0)][If (HUE_RANGE.contains(hue) && SAT_RANGE.contains(sat)),[(scaledHue = (hue * HUE_SCALE))][(flatHueSat = ((scaledHue + sat) + COLOR_OFFSET))],],]
restoreHueSat: [(flatHueSat -= COLOR_OFFSET)][(sat = (flatHueSat % HUE_SCALE))][(hue = flatHueSat.intdiv(HUE_SCALE))]]
done: ]
boundInt: [(value = java.lang.Math.max(theRange.getFrom(), value))][(value = java.lang.Math.min(theRange.getTo(), value))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-rgb-bulb.metadata() is applicable for argument types: (simulated-rgb-bulb$_run_closure1) values: [simulated-rgb-bulb$_run_closure1@4763c727]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-smoke-alarm.groovy
DECLARED METHODS
parse: ]
smoke: ]
test: ]
clear: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-smoke-alarm.metadata() is applicable for argument types: (simulated-smoke-alarm$_run_closure1) values: [simulated-smoke-alarm$_run_closure1@2692b61e]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-switch.groovy
DECLARED METHODS
parse: ]
on: ]
off: ]
onPhysical: ]
offPhysical: ]
getVersion: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-switch.metadata() is applicable for argument types: (simulated-switch$_run_closure1) values: [simulated-switch$_run_closure1@773cbf4f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-temperature-sensor.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
setLevel: ]
up: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue + 1) : 72)]]
down: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue - 1) : 72)]]
setTemperature: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-temperature-sensor.metadata() is applicable for argument types: (simulated-temperature-sensor$_run_closure1) values: [simulated-temperature-sensor$_run_closure1@2b491fee]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-thermostat.groovy
DECLARED METHODS
installed: ]
configure: ]
initialize: [(state.isHvacRunning = false)][(state.lastOperatingState = DEFAULT_OP_STATE)][(state.lastUserSetpointMode = DEFAULT_PREVIOUS_STATE)][this.unschedule()]]
parse: [(parsedEvents = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(pair = description?.split(:))][If (pair || (pair.length < 2)),,[(name = pair[0]?.trim())][If name,[(name = name.replaceAll(\W, _).replaceAll(_{2,}?, _))],],[(parsedEvents = this.createEvent([name:name, value:pair[1]?.trim()]))]],]
ping: ]
refresh: ]
getThermostatMode: ]
setThermostatMode: [If (value in SUPPORTED_MODES),[this.proposeSetpoints(this.getHeatingSetpoint(), this.getCoolingSetpoint(), state.lastUserSetpointMode)],],]
cycleMode: [(nextMode = this.nextListElement(SUPPORTED_MODES, this.getThermostatMode()))]]
isThermostatOff: [return (this.getThermostatMode() == MODE.OFF)]]
getFanMode: ]
setThermostatFanMode: [If (value in SUPPORTED_FAN_MODES),,],]
cycleFanMode: [(nextMode = this.nextListElement(SUPPORTED_FAN_MODES, this.getFanMode()))]]
no code yet for classclass org.codehaus.groovy.ast.stmt.ThrowStatement
no code yet for classclass org.codehaus.groovy.ast.stmt.ThrowStatement
nextListElement: [If (uniqueList != uniqueList.unique().asList()),,[If (currentElt in uniqueList),,],],[(listIdxMax = (uniqueList.size() - 1))][(currentEltIdx = uniqueList.indexOf(currentElt))][(nextEltIdx = ((currentEltIdx < listIdxMax)) ? (++currentEltIdx) : 0)][(nextElt = (java.lang.String -> java.lang.String) uniqueList[nextEltIdx])]]
getOperatingState: [(operatingState = (device.currentValue(thermostatOperatingState)) ? device.currentValue(thermostatOperatingState) : OP_STATE.IDLE)]]
setOperatingState: [If (operatingState in OP_STATE.values()),[If (operatingState != OP_STATE.IDLE),[(state.lastOperatingState = operatingState)],],,[log.warn('$operatingState' is not a supported operating state. Please set one of $OP_STATE.values().join(, ))]],]
getThermostatSetpoint: [(ts = device.currentState(thermostatSetpoint))]]
getHeatingSetpoint: [(hs = device.currentState(heatingSetpoint))]]
setHeatingSetpoint: [(state.lastUserSetpointMode = SETPOINT_TYPE.HEATING)]]
setHeatingSetpointInternal: ]
heatUp: [(newHsp = (this.getHeatingSetpoint() + 1))][If (this.getThermostatMode() in (HEAT_ONLY_MODES + DUAL_SETPOINT_MODES)),,],]
heatDown: [(newHsp = (this.getHeatingSetpoint() - 1))][If (this.getThermostatMode() in (HEAT_ONLY_MODES + DUAL_SETPOINT_MODES)),,],]
getCoolingSetpoint: [(cs = device.currentState(coolingSetpoint))]]
setCoolingSetpoint: [(state.lastUserSetpointMode = SETPOINT_TYPE.COOLING)]]
setCoolingSetpointInternal: ]
coolUp: [(newCsp = (this.getCoolingSetpoint() + 1))][If (this.getThermostatMode() in (COOL_ONLY_MODES + DUAL_SETPOINT_MODES)),,],]
coolDown: [(newCsp = (this.getCoolingSetpoint() - 1))][If (this.getThermostatMode() in (COOL_ONLY_MODES + DUAL_SETPOINT_MODES)),,],]
setpointUp: [(mode = this.getThermostatMode())][If (mode in COOL_ONLY_MODES),,[If (mode in (HEAT_ONLY_MODES + DUAL_SETPOINT_MODES)),,],],]
setpointDown: [(mode = this.getThermostatMode())][If (mode in (COOL_ONLY_MODES + DUAL_SETPOINT_MODES)),,[If (mode in HEAT_ONLY_MODES),,],],]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
getTemperature: [(ts = device.currentState(temperature))][(currentTemp = DEFAULT_TEMPERATURE)]]
setTemperature: ]
tempUp: [(newTemp = (this.getTemperature()) ? (this.getTemperature() + 1) : DEFAULT_TEMPERATURE)]]
tempDown: [(newTemp = (this.getTemperature()) ? (this.getTemperature() - 1) : DEFAULT_TEMPERATURE)]]
setHumidityPercent: [(curHum = (java.lang.Integer -> java.lang.Integer) device.currentValue(humidity))][If (humidityValue != null),[(hum = this.boundInt(humidityValue, (0..100)))][If (hum != humidityValue),[(humidityValue = hum)],],,],]
getHumidityPercent: [(hp = device.currentState(humidity))]]
boundInt: [(value = java.lang.Math.max(theRange.getFrom(), java.lang.Math.min(theRange.getTo(), value)))]]
proposeHeatSetpoint: ]
proposeCoolSetpoint: ]
proposeSetpoints: [(newHeatSetpoint = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(newCoolSetpoint = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][(mode = this.getThermostatMode())][(proposedHeatSetpoint = (heatSetpoint) ? heatSetpoint : this.getHeatingSetpoint())][(proposedCoolSetpoint = (coolSetpoint) ? coolSetpoint : this.getCoolingSetpoint())][If (coolSetpoint == null),[(prioritySetpointType = SETPOINT_TYPE.HEATING)],[If (heatSetpoint == null),[(prioritySetpointType = SETPOINT_TYPE.COOLING)],[If (prioritySetpointType == null),[(prioritySetpointType = DEFAULT_SETPOINT_TYPE)],],],],[If (mode in HEAT_ONLY_MODES),[(newHeatSetpoint = this.boundInt(proposedHeatSetpoint, FULL_SETPOINT_RANGE))][If (newHeatSetpoint != proposedHeatSetpoint),,],,[If (mode in COOL_ONLY_MODES),[(newCoolSetpoint = this.boundInt(proposedCoolSetpoint, FULL_SETPOINT_RANGE))][If (newCoolSetpoint != proposedCoolSetpoint),,],,[If (mode in DUAL_SETPOINT_MODES),[If (prioritySetpointType == SETPOINT_TYPE.HEATING),[(newHeatSetpoint = this.boundInt(proposedHeatSetpoint, HEATING_SETPOINT_RANGE))][(customCoolingSetpointRange = ((newHeatSetpoint + AUTO_MODE_SETPOINT_SPREAD)..COOLING_SETPOINT_RANGE.getTo()))][(newCoolSetpoint = this.boundInt(proposedCoolSetpoint, customCoolingSetpointRange))],[If (prioritySetpointType == SETPOINT_TYPE.COOLING),[(newCoolSetpoint = this.boundInt(proposedCoolSetpoint, COOLING_SETPOINT_RANGE))][(customHeatingSetpointRange = (HEATING_SETPOINT_RANGE.getFrom()..(newCoolSetpoint - AUTO_MODE_SETPOINT_SPREAD)))][(newHeatSetpoint = this.boundInt(proposedHeatSetpoint, customHeatingSetpointRange))],],],,[If (mode == MODE.OFF),,],],],],[If (newHeatSetpoint != null),,],[If (newCoolSetpoint != null),,],]
evaluateOperatingState: [(currentTemp = (overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value) ? overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value : (java.lang.Integer -> java.lang.Integer) this.getTemperature())][(heatingSetpoint = (overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value) ? overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value : (java.lang.Integer -> java.lang.Integer) this.getHeatingSetpoint())][(coolingSetpoint = (overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value) ? overrides.find({ java.lang.Object key, java.lang.Object value -> ... })?.value : (java.lang.Integer -> java.lang.Integer) this.getCoolingSetpoint())][(tsMode = this.getThermostatMode())][(currentOperatingState = this.getOperatingState())][(isHeating = false)][(isCooling = false)][(isIdle = false)][If (tsMode in (HEAT_ONLY_MODES + DUAL_SETPOINT_MODES)),[If ((heatingSetpoint - currentTemp) >= THRESHOLD_DEGREES),[(isHeating = true)],],,],[If ((tsMode in (COOL_ONLY_MODES + DUAL_SETPOINT_MODES)) && isHeating),[If ((currentTemp - coolingSetpoint) >= THRESHOLD_DEGREES),[(isCooling = true)],],,],[If (isHeating || isCooling),,],]
startSimHvac: [(operatingState = this.getOperatingState())][(isRunning = (state?.isHvacRunning) ? state?.isHvacRunning : false)][(shouldBeRunning = (operatingState in RUNNING_OP_STATES))][If (isRunning && shouldBeRunning),[(state.isHvacRunning = true)][this.runIn(SIM_HVAC_CYCLE_SECONDS, runSimHvacCycle)],[If isRunning,,[If shouldBeRunning,,],],],]
runSimHvacCycle: [(operatingState = this.getOperatingState())][(currentTemp = this.getTemperature())][(heatSet = this.getHeatingSetpoint())][(coolSet = this.getCoolingSetpoint())][If ((operatingState == OP_STATE.HEATING) && ((heatSet - currentTemp) >= THRESHOLD_DEGREES)),[this.runIn(SIM_HVAC_CYCLE_SECONDS, runSimHvacCycle)],[If ((operatingState == OP_STATE.COOLING) && ((currentTemp - coolSet) >= THRESHOLD_DEGREES)),[this.runIn(SIM_HVAC_CYCLE_SECONDS, runSimHvacCycle)],[(state.isHvacRunning = false)]],],]
done: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-thermostat.metadata() is applicable for argument types: (simulated-thermostat$_run_closure1) values: [simulated-thermostat$_run_closure1@eb6449b]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-water-sensor.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
wet: ]
dry: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-water-sensor.metadata() is applicable for argument types: (simulated-water-sensor$_run_closure1) values: [simulated-water-sensor$_run_closure1@1536602f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing simulated-water-valve.groovy
DECLARED METHODS
installed: ]
open: ]
close: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: simulated-water-valve.metadata() is applicable for argument types: (simulated-water-valve$_run_closure1) values: [simulated-water-valve$_run_closure1@4eed46ee]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing single-button-controller.groovy
DECLARED METHODS
selectButton: ]
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(buttonDevice, button, buttonEvent)]]
configured: ]
buttonConfigured: ]
buttonEvent: [(buttonNumber = evt.data)][(value = evt.value)][log.debug(buttonEvent: $evt.name = $evt.value ($evt.data))][(recentEvents = buttonDevice.eventsSince(new java.util.Date((this.now() - 3000))).findAll({ -> ... }))]]
executeHandlers: [(lights = this.find(lights, buttonNumber, value))][If (lights != null),,],[(locks = this.find(locks, buttonNumber, value))][If (locks != null),,],[(sonos = this.find(sonos, buttonNumber, value))][If (sonos != null),,],[(mode = this.find(mode, buttonNumber, value))][If (mode != null),,],[(phrase = this.find(phrase, buttonNumber, value))][If (phrase != null),,],]
find: [(preferenceName = ((((type + _) + buttonNumber) + _) + value))][(pref = settings[preferenceName])][If (pref != null),,],]
toggle: [log.debug(toggle: $devices = $devices*.currentValue(switch))][If devices*.currentValue(switch).contains(on),,[If devices*.currentValue(switch).contains(off),,[If devices*.currentValue(lock).contains(locked),,[If devices*.currentValue(lock).contains(unlocked),,],],],],]
changeMode: [log.debug(changeMode: $mode, location.mode = $location.mode, location.modes = $location.modes)][If ((location.mode != mode) && location.modes?.find({ -> ... })),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing sleepy-time.groovy
DECLARED METHODS
selectPhrases: ]
installed: [this.subscribe(jawbone, sleeping, jawboneHandler)]]
updated: [this.unsubscribe()][this.subscribe(jawbone, sleeping, jawboneHandler)]]
initialize: ]
jawboneHandler: [log.debug(In Jawbone Event Handler, Event Name = $evt.name, Value = $evt.value)][If ((evt.value == sleeping) && sleepPhrase),,[If ((evt.value == not sleeping) && wakePhrase),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-auto-lock-unlock.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()][this.unschedule()]]
initialize: [this.subscribe(lock1, lock, doorHandler, [filterEvents:false])][this.subscribe(lock1, unlock, doorHandler, [filterEvents:false])][this.subscribe(contact1, contact.open, doorHandler)][this.subscribe(contact1, contact.closed, doorHandler)]]
lockDoor: [If (lock1.latestValue(lock) == unlocked),[If (sendPushMessage != No),,],[If ((sendText == Yes) && (phoneNumber != 0)),,],,[If (lock1.latestValue(lock) == locked),,],],]
unlockDoor: [If (lock1.latestValue(lock) == locked),[If (sendPushMessage != No),,],[If ((sendText == Yes) && (phoneNumber != 0)),,],,[If (lock1.latestValue(lock) == unlocked),,],],]
doorHandler: [If ((contact1.latestValue(contact) == open) && (evt.value == locked)),[(delay = secondsLater)][this.runIn(delay, unlockDoor)],[If ((contact1.latestValue(contact) == open) && (evt.value == unlocked)),[this.unschedule(unlockDoor)],[If ((contact1.latestValue(contact) == closed) && (evt.value == locked)),[this.unschedule(lockDoor)],[If ((contact1.latestValue(contact) == closed) && (evt.value == unlocked)),[(delay = (minutesLater * 60))][this.runIn(delay, lockDoor)],[If ((lock1.latestValue(lock) == unlocked) && (evt.value == open)),[this.unschedule(lockDoor)],[If ((lock1.latestValue(lock) == unlocked) && (evt.value == closed)),[(delay = (minutesLater * 60))][this.runIn(delay, lockDoor)],[If ((lock1.latestValue(lock) == locked) && (evt.value == open)),[this.unschedule(lockDoor)],[If ((lock1.latestValue(lock) == locked) && (evt.value == closed)),[this.unschedule(lockDoor)],[this.unschedule(lockDoor)][this.unschedule(unlockDoor)]],],],],],],],],]
Starting Points: [this.runIn(delay, unlockDoor), this.unschedule(unlockDoor), this.unschedule(lockDoor), this.runIn(delay, lockDoor), this.unschedule(lockDoor), this.runIn(delay, lockDoor), this.unschedule(lockDoor), this.unschedule(lockDoor), this.unschedule(lockDoor), this.unschedule(unlockDoor)]
IT HAS STATE
--app-start--
processing smart-block.groovy
DECLARED METHODS
parse: ]
on: ]
off: ]
setLevel: [(signal = this.convertLevelToSignal((int) newLevel))]]
sendSignalToMC: [(url = http://$state.serverIp:3333/block?x=$state.x&y=$state.y&z=$state.z&name=level&value=$newSignal)][this.httpPost(url, foo=bar, { java.lang.Object response -> ... })]]
sendSwitchStateToMC: [(url = http://$state.serverIp:3333/block?x=$state.x&y=$state.y&z=$state.z&name=switch&value=$switchState)][this.httpPost(url, foo=bar, { java.lang.Object response -> ... })]]
setCoordinates: [(state.x = x)][(state.y = y)][(state.z = z)]]
getCoordinates: ]
getCoordinate: [If [x, y, z].contains(axis),,],[return state.$axis]]
isDestroyed: [state.destroyed]]
setDestroyed: [(state.destroyed = isDestroyed)]]
setWorldSeed: [(state.worldSeed = worldSeed)]]
setDimensionName: [(state.dimensionName = dimensionName)]]
setPlacedBy: [(state.placedBy = placedBy)]]
setClosestPlayer: [(state.closestPlayer = closestPlayer)][(state.closestPlayerChanged = new java.util.Date())]]
setSignalStrength: [(state.signalStrength = signalStrength)]]
setLastNeighborChanged: [(state.neighborBlockId = blockId)][(state.neighborBlockName = blockName)]]
setServerIp: [If ip,,],[(ip = ip.replace(https://, ))][(ip = ip.replace(http://, ))][(serverParts = ip.split(:))][If (serverParts.size() > 1),[(state.serverPort = serverParts[1])],],[If (serverParts.size() > 0),[(state.serverIp = serverParts[0])],],[If state.serverIp,[(state.blockServer = state.serverIp)],],[If state.serverPort,[(state.blockServer = $state.blockServer:$state.serverPort)],],[this.sendEvent([name:blockServer, value:$state.blockServer])]]
calculateDNI: [$state.worldSeed|$state.dimensionName|$this.getCoordinates().encodeAsMD5()]]
neighborBlockChange: [If data?.closestPlayer,,],[(signalStrength = (int) data?.signalStrength)][If data?.worldSeed,,],[If data?.dimensionName,,],[If data?.placedBy,,],]
convertLevelToSignal: [If (level <= 0),,],[If (level >= 99),,],[(signal = (15 - ((99 - level) / 7)))]]
convertSignalToLevel: [If (signal <= 0),,],[If (signal >= 15),,],[(level = (99 - ((15 - signal) * 7)))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smart-block.metadata() is applicable for argument types: (smart-block$_run_closure1) values: [smart-block$_run_closure1@2c9399a4]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smart-care-daily-routine.groovy
DECLARED METHODS
disclaimerPage: [(disclaimerText = ((((((((((((((((((((((((SMARTTHINGS INC. SMART CARE SUPPLEMENTAL TERMS AND DISCLAIMER
 + SmartThings Inc. is not an emergency medical response service of any kind and does not provide ) + medical or health-related advice, which should be obtained from qualified medical personnel. ) + SmartThings Inc., the contents of the app (such as text, graphics, images, videos, data and ) + information contained therein) and such materials obtained from third parties are provided for ) + information purposes only and are not substitutes for professional medical advice, diagnosis, ) + examination, or treatment by a health care provider. If you think you or a loved one has a medical ) + emergency, call your doctor or 911 immediately. Do not rely on electronic communications or ) + communication through this app for immediate, urgent medical needs. ) + THIS APP IS NOT DESIGNED TO FACILITATE OR AID IN MEDICAL EMERGENCIES.

) + If you have any concerns or questions about your health or the health of a loved one, ) + you should always consult with a physician or other health care professional.) + You understand and acknowledge that all users of this app are responsible for their own medical care, ) + treatment, and oversight. You also understand and acknowledge that you should never disregard, ) + avoid, or delay obtaining medical or health-related advice ) + relating to treatment or standard of care because of information contained in or transmitted through the app. ) + RELIANCE ON ANY INFORMATION PROVIDED BY THE APP OR OTHER THIRD-PARTY PLATFORMS IS SOLELY AT YOUR OWN RISK.

) + While SmartThings Inc. strives to make the information on the app as timely and accurate as possible, ) + SmartThings Inc. makes no claims, promises, or guarantees about the accuracy, completeness, ) + or adequacy of the content or information on the app. SmartThings Inc. expressly disclaims liability for any errors ) + and omissions in content or for the availability of content on the app. ) + SmartThings Inc. will not be liable for any losses, injuries, or damages arising from the display ) + or use of content on the app. SMARTTHINGS INC., ITS OFFICERS, ) + EMPLOYEES AND AGENTS DO NOT ACCEPT LIABILITY HOWEVER ARISING, INCLUDING LIABILITY FOR NEGLIGENCE, ) + FOR ANY LOSS RESULTING FROM THE USE OF OR RELIANCE UPON THE INFORMATION AND/OR SERVICES AT ANY TIME.))][If (disclaimerResponse && (disclaimerResponse == I agree to these terms)),,],]
configurationPage: ]
installed: [this.schedule(time1, scheduleCheck)]]
updated: [this.unsubscribe()][this.unschedule()][this.schedule(time1, scheduleCheck)]]
scheduleCheck: [If (this.noRecentContact() && this.noRecentMotion()),[(person = (person1) ? person1 : your elder)][(msg = Alert! There has been no activity at $persons place $timePhrase)][If location.contactBookEnabled,,[If phone1,,],],,],]
noRecentMotion: [If motion1,[(motionEvents = motion1.eventsSince(sinceTime))][If motionEvents.find({ -> ... }),,],,],]
noRecentContact: [If contact1,[(contactEvents = contact1.eventsSince(sinceTime))][If contactEvents.find({ -> ... }),,],,],]
getSinceTime: [If time0,,],]
getTimePhrase: [(interval = (this.now() - sinceTime.time))][If (interval < 3600000),,[If (interval < 7200000),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-care-detect-motion.groovy
DECLARED METHODS
disclaimerPage: [(disclaimerText = ((((((((((((((((((((((((SMARTTHINGS INC. SMART CARE SUPPLEMENTAL TERMS AND DISCLAIMER
 + SmartThings Inc. is not an emergency medical response service of any kind and does not provide ) + medical or health-related advice, which should be obtained from qualified medical personnel. ) + SmartThings Inc., the contents of the app (such as text, graphics, images, videos, data and ) + information contained therein) and such materials obtained from third parties are provided for ) + information purposes only and are not substitutes for professional medical advice, diagnosis, ) + examination, or treatment by a health care provider. If you think you or a loved one has a medical ) + emergency, call your doctor or 911 immediately. Do not rely on electronic communications or ) + communication through this app for immediate, urgent medical needs. ) + THIS APP IS NOT DESIGNED TO FACILITATE OR AID IN MEDICAL EMERGENCIES.

) + If you have any concerns or questions about your health or the health of a loved one, ) + you should always consult with a physician or other health care professional.) + You understand and acknowledge that all users of this app are responsible for their own medical care, ) + treatment, and oversight. You also understand and acknowledge that you should never disregard, ) + avoid, or delay obtaining medical or health-related advice ) + relating to treatment or standard of care because of information contained in or transmitted through the app. ) + RELIANCE ON ANY INFORMATION PROVIDED BY THE APP OR OTHER THIRD-PARTY PLATFORMS IS SOLELY AT YOUR OWN RISK.

) + While SmartThings Inc. strives to make the information on the app as timely and accurate as possible, ) + SmartThings Inc. makes no claims, promises, or guarantees about the accuracy, completeness, ) + or adequacy of the content or information on the app. SmartThings Inc. expressly disclaims liability for any errors ) + and omissions in content or for the availability of content on the app. ) + SmartThings Inc. will not be liable for any losses, injuries, or damages arising from the display ) + or use of content on the app. SMARTTHINGS INC., ITS OFFICERS, ) + EMPLOYEES AND AGENTS DO NOT ACCEPT LIABILITY HOWEVER ARISING, INCLUDING LIABILITY FOR NEGLIGENCE, ) + FOR ANY LOSS RESULTING FROM THE USE OF OR RELIANCE UPON THE INFORMATION AND/OR SERVICES AT ANY TIME.))][If (disclaimerResponse && (disclaimerResponse == I agree to these terms)),,],]
configurationPage: ]
installed: ]
updated: [this.unsubscribe()]]
initialize: [(state.active = 0)][this.subscribe(bedroomMotion, motion.active, bedroomActive)][this.subscribe(bathroomMotion, motion.active, bathroomActive)]]
bedroomActive: [(start = this.timeToday(startTime, location?.timeZone))][(stop = this.timeToday(stopTime, location?.timeZone))][(now = new java.util.Date())][log.debug(bedroomActive, status: $state.ststus, start: $start, stop: $stop, now: $now)][If (state.status == waiting),[this.unschedule(sendMessage)][(state.status = null)],[If (start.before(now) && stop.after(now)),[(state.status = pending)],],],]
bathroomActive: [log.debug(bathroomActive, status: $state.status)][If (state.status == pending),[(delay = (threshold.toInteger() * 60))][(state.status = waiting)][log.debug(runIn($delay))][this.runIn(delay, sendMessage)],],]
sendMessage: [(msg = warnMessage)][If location.contactBookEnabled,,[If phone1,,],[If phone2,,],[If phone3,,],],[(state.status = null)]]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-home-ventilation.groovy
DECLARED METHODS
mainPage: ]
installed: ]
updated: [this.unschedule()][this.unsubscribe()]]
init: [(midnightTime = this.timeToday(2000-01-01T00:01:00.999-0000, location.timeZone))][this.schedule(midnightTime, midNight)][this.subscribe(location, mode, locationHandler)]]
startProcess: [(state.dayCount = state.data.size())][If state.dayCount,[(state.counter = 0)],],]
startDay: [(start = this.convertEpoch(state.data[state.counter].start))][(stop = this.convertEpoch(state.data[state.counter].stop))][this.runOnce(start, turnOnSwitch, [overwrite:true])][this.runOnce(stop, incDay, [overwrite:true])]]
incDay: [If state.modeChange,,[(state.counter = (state.counter + 1))][If (state.counter < state.dayCount),,],],]
locationHandler: [(result = false)][(state.modeChange = true)][If result,,],]
midNight: ]
turnOnSwitch: ]
turnOffSwitch: ]
schedDesc: [(title = )][(dayListClean = On )][(modeListClean = Scenario runs in )][If (dayList && (dayList.size() < 7)),[(dayListSize = dayList.size())][For dayList,[(dayListClean = ($dayListClean + $dayName))][(dayListSize = (dayListSize - 1))][If dayListSize,[(dayListClean = $dayListClean, )],],][(dayListSize = dayList.size())][For dayList,[(dayListClean = ($dayListClean + $dayName))][(dayListSize = (dayListSize - 1))][If dayListSize,[(dayListClean = $dayListClean, )],],],[(dayListClean = Every day)]],[If modeList,[(modeListSize = modeList.size())][(modePrefix = modes)][If (modeListSize == 1),[(modePrefix = mode)],],[For modeList,[(modeListClean = ($modeListClean + '$modeName'))][(modeListSize = (modeListSize - 1))][If modeListSize,[(modeListClean = $modeListClean, )],[(modeListClean = $modeListClean $modePrefix)]],][(modeListSize = modeList.size())][(modePrefix = modes)][If (modeListSize == 1),[(modePrefix = mode)],],[For modeList,[(modeListClean = ($modeListClean + '$modeName'))][(modeListSize = (modeListSize - 1))][If modeListSize,[(modeListClean = $modeListClean, )],[(modeListClean = $modeListClean $modePrefix)]],],[(modeListClean = $modeListCleanall modes)]],[If (on1 && off1),[(title += Schedule 1: $this.humanReadableTime(on1) to $this.humanReadableTime(off1))],],[If (on2 && off2),[(title += 
Schedule 2: $this.humanReadableTime(on2) to $this.humanReadableTime(off2))],],[If (on3 && off3),[(title += 
Schedule 3: $this.humanReadableTime(on3) to $this.humanReadableTime(off3))],],[If (on4 && off4),[(title += 
Schedule 4: $this.humanReadableTime(on4) to $this.humanReadableTime(off4))],],[If (((on1 || on2) || on3) || on4),[(title += 
$modeListClean)][(title += 
$dayListClean)],],[If (((on1 && on2) && on3) && on4),[(title = Click to configure scenario)],],]
greyOut: [(result = ((((on1 || on2) || on3) || on4)) ? complete : )]]
humanReadableTime: ]
convertEpoch: ]
getTitle: [(title = (txt) ? txt : Scenario $scenario)]]
daysOk: [(result = true)][If dayList,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = dayList.contains(day))],],]
timeOk: [If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting).time)][(stop = this.timeToday(ending).time)][If (((start < stop) && (start >= currTime)) && (stop >= currTime)),[(state.data << [start:start, stop:stop])],],,],]
createDayArray: [(state.modeChange = false)][(state.data = [])][If (modeA && modeA.contains(location.mode)),[If this.daysOk(daysA),,],,],[If (modeB && modeB.contains(location.mode)),[If this.daysOk(daysB),,],,],[If (modeC && modeC.contains(location.mode)),[If this.daysOk(daysC),,],,],[If (modeD && modeD.contains(location.mode)),[If this.daysOk(daysD),,],,],[state.data.sort({ -> ... })]]
textAppName: [(text = Smart Home Ventilation)]]
textVersion: [(text = Version 2.1.2 (05/31/2015))]]
textCopyright: [(text = Copyright  2015 Michael Struck)]]
textLicense: [(text = ((((((((((Licensed under the Apache License, Version 2.0 (the 'License');  + you may not use this file except in compliance with the License. ) + You may obtain a copy of the License at) + 

) +     http://www.apache.org/licenses/LICENSE-2.0) + 

) + Unless required by applicable law or agreed to in writing, software ) + distributed under the License is distributed on an 'AS IS' BASIS, ) + WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ) + See the License for the specific language governing permissions and ) + limitations under the License.))]]
textHelp: [(text = ((((Within each scenario, choose a start and end time for the ventilation fan. You can have up to 4 different  + venting scenarios, and 4 schedules within each scenario. Each scenario can be restricted to specific modes or certain days of the week. It is recommended ) + that each scenario does not overlap and run in separate modes (i.e. Home, Out of town, etc). Also note that you should  ) + avoid scheduling the ventilation fan at exactly midnight; the app resets itself at that time. It is suggested to start any new schedule ) + at 12:15 am or later.))]]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-humidifier.groovy
DECLARED METHODS
installed: [this.subscribe(humiditySensor1, humidity, humidityHandler)]]
updated: [this.unsubscribe()][this.subscribe(humiditySensor1, humidity, humidityHandler)]]
humidityHandler: [(currentHumidity = java.lang.Double.parseDouble(evt.value.replace(%, )))][(humidityHigh1 = humidityHigh)][(humidityLow1 = humidityLow)][(mySwitch = settings.switch1)][If (currentHumidity >= humidityHigh1),[log.debug(Checking how long the humidity sensor has been reporting >= $humidityHigh1)][(deltaMinutes = 10)][(timeAgo = new java.util.Date((this.now() - ((1000 * 60) * deltaMinutes).toLong())))][(recentEvents = humiditySensor1.eventsSince(timeAgo))][(alreadySentSms1 = (recentEvents.count({ -> ... }) > 1))][If alreadySentSms1,,[If (state.lastStatus != off),[(state.lastStatus = off)],],],,[If (currentHumidity <= humidityLow1),[log.debug(Checking how long the humidity sensor has been reporting <= $humidityLow1)][(deltaMinutes = 10)][(timeAgo = new java.util.Date((this.now() - ((1000 * 60) * deltaMinutes).toLong())))][(recentEvents = humiditySensor1.eventsSince(timeAgo))][(alreadySentSms2 = (recentEvents.count({ -> ... }) > 1))][If alreadySentSms2,,[If (state.lastStatus != on),[(state.lastStatus = on)],],],,],],]
send: [If (sendPushMessage != No),,],[If phone1,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-light-timer-x-minutes-unless-already-on.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()][log.debug((state:  + state.myState))]]
initialize: [this.subscribe(switches, switch, switchChange)][this.subscribe(motions, motion, motionHandler)][this.subscribe(contacts, contact, contactHandler)][this.runEvery1Minute(scheduleCheck)][(state.myState = ready)]]
switchChange: [If (evt.value == on),[If (state.myState == activating),[(state.myState = active)],[If (state.myState != active),[(state.myState = already on)],],],,[If ((state.myState == active) || (state.myState == activating)),[this.unschedule()],],[(state.myState = ready)]],[log.debug((state:  + state.myState))]]
contactHandler: [If (evt.value == open),[If (state.myState == ready),[(state.inactiveAt = null)][(state.myState = activating)],],,[If (evt.value == closed),[If ((state.inactiveAt && (state.myState == active)) || (state.myState == activating)),[this.setActiveAndSchedule()],],,],],[log.debug((state:  + state.myState))]]
motionHandler: [If (evt.value == active),[If (((state.myState == ready) || (state.myState == active)) || (state.myState == activating)),[(state.inactiveAt = null)][(state.myState = activating)],],,[If (evt.value == inactive),[If ((state.inactiveAt && (state.myState == active)) || (state.myState == activating)),[this.setActiveAndSchedule()],],,],],[log.debug((state:  + state.myState))]]
setActiveAndSchedule: [this.unschedule()][(state.myState = active)][(state.inactiveAt = this.now())][this.runEvery1Minute(scheduleCheck)]]
scheduleCheck: [log.debug(schedule check, ts = $state.inactiveAt)][If (state.myState != already on),[If (state.inactiveAt != null),[(elapsed = (this.now() - state.inactiveAt))][(threshold = ((1000 * 60) * minutes1))][If (elapsed >= threshold),[If (state.myState == active),,],[(state.inactiveAt = null)][(state.myState = ready)],],,],,],[log.debug((state:  + state.myState))]]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-nightlight.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()][this.unschedule()]]
initialize: [this.subscribe(motionSensor, motion, motionHandler)][If lightSensor,[this.subscribe(lightSensor, illuminance, illuminanceHandler, [filterEvents:false])],[this.subscribe(location, position, locationPositionChange)][this.subscribe(location, sunriseTime, sunriseSunsetTimeHandler)][this.subscribe(location, sunsetTime, sunriseSunsetTimeHandler)]],]
locationPositionChange: ]
sunriseSunsetTimeHandler: [(state.lastSunriseSunsetEvent = this.now())]]
motionHandler: [If (evt.value == active),[If this.enabled(),[(state.lastStatus = on)],],[(state.motionStopTime = null)],[(state.motionStopTime = this.now())][If delayMinutes,[this.runIn((delayMinutes * 60), turnOffMotionAfterDelay, [overwrite:true])],],],]
illuminanceHandler: [log.debug($evt.name: $evt.value, lastStatus: $state.lastStatus, motionStopTime: $state.motionStopTime)][(lastStatus = state.lastStatus)][If ((lastStatus != off) && (evt.integerValue > 50)),[(state.lastStatus = off)],[If state.motionStopTime,[If (lastStatus != off),[(elapsed = (this.now() - state.motionStopTime))][If (elapsed >= (((delayMinutes) ? delayMinutes : 0 * 60000) - 2000)),[(state.lastStatus = off)],],,],,[If ((lastStatus != on) && (evt.integerValue < 30)),[(state.lastStatus = on)],],],],]
turnOffMotionAfterDelay: [log.trace(In turnOffMotionAfterDelay, state.motionStopTime = $state.motionStopTime, state.lastStatus = $state.lastStatus)][If (state.motionStopTime && (state.lastStatus != off)),[(elapsed = (this.now() - state.motionStopTime))][log.trace(elapsed = $elapsed)][If (elapsed >= (((delayMinutes) ? delayMinutes : 0 * 60000) - 2000)),[(state.lastStatus = off)],],,],]
scheduleCheck: [log.debug(In scheduleCheck - skipping)]]
astroCheck: [(s = this.getSunriseAndSunset([zipCode:zipCode, sunriseOffset:sunriseOffset, sunsetOffset:sunsetOffset]))][(state.riseTime = s.sunrise.time)][(state.setTime = s.sunset.time)][log.debug(rise: $new Date(state.riseTime)($state.riseTime), set: $new Date(state.setTime)($state.setTime))]]
enabled: [(result = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If lightSensor,[(result = (lightSensor.currentIlluminance?.toInteger() < 30))],[(t = this.now())][(result = ((t < state.riseTime) || (t > state.setTime)))]],]
getSunriseOffset: [(sunriseOffsetValue) ? ((sunriseOffsetDir == Before)) ? -$sunriseOffsetValue : sunriseOffsetValue : null]]
getSunsetOffset: [(sunsetOffsetValue) ? ((sunsetOffsetDir == Before)) ? -$sunsetOffsetValue : sunsetOffsetValue : null]]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-security.groovy
DECLARED METHODS
installed: [this.subscribeToEvents()][(state.alarmActive = null)]]
updated: [this.unsubscribe()][this.subscribeToEvents()][this.unschedule()][(state.alarmActive = null)][(state.residentsAreUp = null)][(state.lastIntruderMotion = null)]]
subscribeToEvents: [this.subscribe(intrusionMotions, motion, intruderMotion)][this.subscribe(intrusionContacts, contact, contact)][this.subscribe(alarms, alarm, alarm)][this.subscribe(app, appTouch)]]
residentsHaveBeenQuiet: [(threshold = (((((residentsQuietThreshold != null) && (residentsQuietThreshold != ))) ? residentsQuietThreshold : 3 * 60) * 1000))][(result = true)][(t0 = new java.util.Date((this.now() - threshold)))][For residentMotions,[(recentStates = sensor.statesSince(motion, t0))][If recentStates.find({ -> ... }),[(result = false)][(result = false)],],]residentsHaveBeenQuiet: [(threshold = (((((residentsQuietThreshold != null) && (residentsQuietThreshold != ))) ? residentsQuietThreshold : 3 * 60) * 1000))][(result = true)][(t0 = new java.util.Date((this.now() - threshold)))][For residentMotions,[(recentStates = sensor.statesSince(motion, t0))][If recentStates.find({ -> ... }),[(result = false)][(result = false)],],]]
intruderMotionInactive: [(result = true)][For intrusionMotions,[If (sensor.currentMotion == active),[(result = false)][(result = false)],],]intruderMotionInactive: [(result = true)][For intrusionMotions,[If (sensor.currentMotion == active),[(result = false)][(result = false)],],]]
isResidentMotionSensor: [(residentMotions?.find({ -> ... }) != null)]]
appTouch: [(state.alarmActive = false)]]
motion: [If this.isResidentMotionSensor(evt),,],]
intruderMotion: [If (evt.value == active),[log.debug(motion by potential intruder, residentsAreUp: $state.residentsAreUp)][If state.residentsAreUp,[If this.residentsHaveBeenQuiet(),,],,],,],[(state.lastIntruderMotion = this.now())]]
residentMotion: [this.unsubscribe(residentMotions)]]
contact: [If (evt.value == open),[If state.residentsAreUp,[If this.residentsHaveBeenQuiet(),,],,],,],]
alarm: [If (evt.value == off),[(state.alarmActive = false)],],]
disarmIntrusionDetection: [(state.residentsAreUp = true)][this.scheduleReArmCheck()]]
scheduleReArmCheck: [(cron = 0 * * * * ?)][this.schedule(cron, checkForReArm)]]
checkForReArm: [(threshold = (((((residentsQuietThreshold != null) && (residentsQuietThreshold != ))) ? residentsQuietThreshold : 3 * 60) * 1000))][(lastIntruderMotion = state.lastIntruderMotion)][log.debug(checkForReArm: lastIntruderMotion=$lastIntruderMotion)][If (lastIntruderMotion != null),[If ((this.now() - lastIntruderMotion) > threshold),[(state.residentsAreUp = false)][this.unschedule()],],,],]
startAlarmSequence: [If state.alarmActive,,[(state.alarmActive = true)][If newMode,,],[If this.silentAlarm(),[If location.contactBookEnabled,,[If phone,,],],,[(delayTime = seconds)][If delayTime,[this.runIn(delayTime, soundSiren)],],],[If lights,,],],]
soundSiren: [If state.alarmActive,[If location.contactBookEnabled,,[If phone,,],],[If lights,,],,],[this.unschedule(soundSiren)]]
continueFlashing: [this.unschedule()][If state.alarmActive,[this.schedule(util.cronExpression((this.now() + 10000)), continueFlashing)],],]
flashLights: [(onFor = 1000)][(offFor = 1000)][(delay = 1)]]
silentAlarm: ]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-turn-it-on.groovy
DECLARED METHODS
installed: [If timeOne,[this.schedule(timeOne, turnOn)],],]
updated: [this.unsubscribe()][this.unschedule()][If timeOne,[this.schedule(timeOne, turnOn)],],]
turnOn: [(dayCheck = dayOne.contains(new java.util.Date().format(EEE)))][(dayTwo = new java.util.Date().format(EEE))][If dayCheck,[(presenceTwo = presenceOne.latestValue(presence).contains(present))][If presenceTwo,[(delay = (timeTwo * 60))][this.runIn(delay, turnOff)],],,],]
turnOff: ]
Starting Points: []
IT HAS STATE
--app-start--
processing smart-windows.groovy
DECLARED METHODS
installed: [this.subscribe(inTemp, temperature, temperatureHandler)]]
updated: [this.unsubscribe()][this.subscribe(inTemp, temperature, temperatureHandler)]]
temperatureHandler: [(currentOutTemp = null)][If outTemp,[(currentOutTemp = outTemp.latestValue(temperature))],[(currentOutTemp = this.weatherCheck())]],[(currentInTemp = evt.doubleValue)][(openWindows = sensors.findAll({ -> ... }))][If retryPeriod,[(retryPeriod = 30)],],[(timeAgo = new java.util.Date((this.now() - ((1000 * 60) * retryPeriod).toLong())))][(recentEvents = inTemp.eventsSince(timeAgo))][If ((currentInTemp > minTemp) && (currentInTemp < maxTemp)),,[If (currentInTemp > maxTemp),[(alreadyNotified = (recentEvents.count({ -> ... }) > 1))][If alreadyNotified,[If ((currentOutTemp < maxTemp) && openWindows),,[If ((currentOutTemp > maxTemp) && openWindows),,],],,],,[If (currentInTemp < minTemp),[(alreadyNotified = (recentEvents.count({ -> ... }) > 1))][If alreadyNotified,[If ((currentOutTemp > minTemp) && openWindows),,[If ((currentOutTemp < minTemp) && openWindows),,],],,],,],],],]
weatherCheck: [(json = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (location.channelName != samsungtv),[(json = this.getWeatherFeature(conditions, zipCode))],[(json = this.getWeatherFeature(conditions))]],[(currentTemp = json?.current_observation?.temp_f)][If currentTemp,,],]
send: [If (sendPushMessage != No),,],[If phone1,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing smartblock-chat-sender.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(location, modeChangeHandler)]]
modeChangeHandler: [(newMode = evt.value)][If (modes && modes.contains(newMode)),[(message = (customMessage) ? customMessage : SmartThings mode has changed to: "$newMode")],],]
chatMessageToMC: [(parent = app.getParent())][(url = $parent.getServerURL()/chat?message=$message.encodeAsURL())][If username,[(url += &username=$username.encodeAsURL())],],[this.httpPost(url, foo=bar, { java.lang.Object response -> ... })]]
Starting Points: []
IT HAS STATE
--app-start--
processing smartblock-linker.groovy
DECLARED METHODS
linkerPage: ]
installed: ]
updated: [this.unsubscribe()]]
initialize: [If blockUpdatesSwitch,[this.subscribe(linkedSmartBlock, level, updateSwitchLevel)][this.subscribe(linkedSmartBlock, switch, updateSwitchState)],],[If switchUpdatesBlock,[this.subscribe(linkedSwitch, level, updateBlockLevel)][this.subscribe(linkedSwitch, switch, updateBlockState)],],]
updateSwitchLevel: [(level = (int) evt.value)]]
updateBlockLevel: [(level = (int) evt.value)]]
updateSwitchState: ]
updateBlockState: ]
getBlockId: ]
getLinkerDescription: [(left = (linkedSmartBlock) ? $(linkedSmartBlock.label) ? linkedSmartBlock.label : linkedSmartBlock.name : )][(right = (linkedSwitch) ? $(linkedSwitch.label) ? linkedSwitch.label : linkedSwitch.name : )][(leftLink = (switchUpdatesBlock) ? < : )][(rightLink = (blockUpdatesSwitch) ? > : )][If ((leftLink == ) && (rightLink == )),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing smartblock-notifier.groovy
latestValue, arg not ConstantExpression
DECLARED METHODS
firstPage: [(defaultLabelValue = (smartBlock) ? (smartBlock.label) ? smartBlock.label : smartBlock.name : null)][(destroyedPageName = destroyedPage)][(destroyedComplete = this.pageStateComplete(destroyedPageName))][(destroyedState = (destroyedComplete) ? complete : null)][(destroyedDescription = (destroyedComplete) ? this.messageDescriptionForPage(destroyedPageName) : null)][(redstonePageName = redstonePage)][(redstoneComplete = this.pageStateComplete(redstonePageName))][(redstoneState = (redstoneComplete) ? complete : null)][(redstoneDescription = (redstoneComplete) ? this.messageDescriptionForPage(redstonePageName) : null)][(neighborPageName = neighborBlockPage)][(neighborComplete = this.pageStateComplete(neighborPageName))][(neighborState = (neighborComplete) ? complete : null)][(neighborDescription = (neighborComplete) ? this.messageDescriptionForPage(neighborPageNamePageName) : null)]]
destroyedPage: [(pageName = destroyedPage)]]
redstonePage: [(pageName = redstonePage)]]
neighborBlockPage: [(pageName = neighborBlockPage)]]
messageBuilderPage: [(pageName = params.pageName)][(size = (this.messageBuilderOptions().size() * 2))]]
smartPhoneNotificationSection: ]
chatSection: ]
messageBuilderSection: ]
messageBuilderHref: [(partsAreSet = this.messagePartsSet(pageName))][(messageState = (partsAreSet) ? complete : )][(messageDescription = (partsAreSet) ? this.messageDescriptionForPage(pageName) : this.defaultMessageDescription(pageName))]]
chatClosestPlayerSection: ]
pageStateComplete: [If (pageName == redstonePage),[If redstoneGreaterThan,,],[If redstoneLessThan,,],[If redstoneEqualTo,,],,],[If (pageName == neighborBlockPage),[If neighborBlockParsed,,],,],[If app.$pageNameWantsPush,,],[If app.$pageNameWantsSms,,],[If app.$pageNameWantsHH,,],[If app.$pageNameChatAllUsers,,],[If app.$pageNameChatUsername,,],[If app.$pageNameClosestPlayer,,],]
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(smartBlock, redstoneSignalStrength, redstoneSignalStrengthHandler)][this.subscribe(smartBlock, smartBlockNeighborChanged, smartBlockNeighborChangedHandler, [filterEvents:false])][this.subscribe(smartBlock, smartBlockNeighborChanged, smartBlockNeighborChangedHandler, [filterEvents:false])][this.subscribe(smartBlock, blockDestroyed.true, smartBlockDestroyedHandler, [filterEvents:false])]]
smartBlockDestroyedHandler: [(pageName = destroyedPage)][(message = this.message(pageName))]]
smartBlockNeighborChangedHandler: [If neighborBlockParsed?.contains(evt.value),,],]
redstoneSignalStrengthHandler: [(newValue = (int) evt.value)][(lastValue = (int) smartBlock.latestState(redstoneSignalStrength).value)][If redstoneGreaterThan,[(gt = (int) redstoneGreaterThan)][If (newValue > gt),,],,],[If redstoneLessThan,[(lt = (int) redstoneLessThan)][If (newValue < lt),,],,],[If redstoneEqualTo,[(et = (int) redstoneEqualTo)][If (newValue == et),,],,],]
notifyUserOfRedstoneChange: [(msg = this.message(redstonePage))][(notificationMessage = (msg) ? msg : $smartBlock redstone signal is $value)]]
notifyUserOfNeighborChange: [(msg = this.message(neighborPage))][(notificationMessage = (msg) ? msg : $smartBlock was updated by $value)]]
notifyUser: [(closestPlayerMessage = this.message($pageNameClosestPlayer))][log.debug(closestPlayerMessage = $closestPlayerMessage)][(latestClosePlayer = this.getLatestClosePlayer())][log.debug(latestClosePlayer = $latestClosePlayer)][If (closestPlayerMessage && (latestClosePlayer != unknown)),,],[(wantsHH = app.$pageNameWantsHH)][log.debug(wantsHH = $wantsHH)][If wantsHH,,[If location.contactBookEnabled,,[(wantsPush = app.$pageNameWantsPush)][log.debug(wantsPush = $wantsPush)][If (wantsPush && (wantsPush != false)),,],[(wantsSms = app.$pageNameWantsSms)][log.debug(wantsSms = $wantsSms)][If wantsSms,,],],],[(username = app.$pageNameChatUsername)][(allUsers = app.$pageNameChatAllUsers)][log.debug(username = $username)][log.debug(allUsers = $allUsers)][If (username && (username != )),,[If allUsers,,],],]
chatMessageToMC: [(url = $app.getParent().getServerURL()/chat?message=$message.encodeAsURL())][If username,[(url = $url&username=$username.encodeAsURL())],],[this.httpPost(url, foo=bar, { -> ... })]]
messageDescriptionPartsForPage: [(size = (this.messageBuilderOptions().size() * 2))]]
messagePartsSet: ]
defaultMessageDescription: [(description = )][If (((pageName == destroyedPage) || (pageName == redstonePage)) || (pageName == neighborBlockPage)),[(second = this.messageBuilderOptions()[this.messagePartDefaultValue(pageName, 1)])][If second,[(description = ${$second})],],[(third = this.messagePartDefaultValue(pageName, 2))][If third,[(description = $description $third)],],[(fourth = this.messageBuilderOptions()[this.messagePartDefaultValue(pageName, 3)])][If fourth,[(description = $description ${$fourth})],],,],]
messageDescriptionForPage: [(parts = this.messageDescriptionPartsForPage(pageName))][(messageParts = [])][If messageParts,,],]
messagePartDefaultValue: [If (pageName == destroyedPage),[If (part == 1),,],[If (part == 2),,],[If (part == 3),,],,],[If (pageName == neighborBlockPage),[If (part == 1),,],[If (part == 2),,],[If (part == 3),,],,],[If (pageName == redstonePage),[If (part == 1),,],[If (part == 2),,],[If (part == 3),,],,],]
message: [(messageParts = [])][(message = messageParts.join( ).trim())]]
messageBuilderOptions: ]
getMessagePartFromOption: [If (optionKey == name),,],[If (optionKey == closestPlayer),,],[If (optionKey == blockDestroyed),,],]
getLatestClosePlayer: [(now = new java.util.Date())][(minusOne = new java.util.Date([minutes:(now.minutes - 1)]))][(latestStates = smartBlock.statesSince(closestPlayer, minusOne))][If latestStates.size,,],]
settingsAsIds: [(subscribedIds = [])][subscribedIds]]
convertBlockSettingToBlockId: [(id = setting.substring(0, setting.indexOf( )))][(name = this.allBlocks()[id])]]
allBlocksParsed: ]
allBlocks: ]
Starting Points: []
IT HAS STATE
--app-start--
processing smartpower-dimming-outlet.groovy
DECLARED METHODS
parse: [(event = zigbee.getEvent(description))][If event,,[If (event.name == power),[(event.value = (event.value / 10))],],],]
setLevel: ]
off: ]
on: ]
refresh: ]
configure: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartpower-dimming-outlet.metadata() is applicable for argument types: (smartpower-dimming-outlet$_run_closure1) values: [smartpower-dimming-outlet$_run_closure1@a1217f9]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartpower-outlet-v1.groovy
DECLARED METHODS
parse: [If description?.startsWith(catchall: 0104 000A),,[(name = (description?.startsWith(on/off: )) ? switch : null)][(value = ((name == switch)) ? (description?.endsWith( 1)) ? on : off : null)][(result = this.createEvent([name:name, value:value]))]],]
on: ]
off: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartpower-outlet-v1.metadata() is applicable for argument types: (smartpower-outlet-v1$_run_closure1) values: [smartpower-outlet-v1$_run_closure1@5dcbb60]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartpower-outlet.groovy
DECLARED METHODS
parse: [(event = zigbee.getEvent(description))][If event,[If (event.name == power),[(value = ((java.lang.Integer -> java.lang.Integer) event.value / 10))][(event = this.createEvent([name:event.name, value:value, descriptionText:{{ device.displayName }} power is {{ value }} Watts, translatable:true]))],[If (event.name == switch),[(descriptionText = ((event.value == on)) ? {{ device.displayName }} is On : {{ device.displayName }} is Off)][(event = this.createEvent([name:event.name, value:event.value, descriptionText:descriptionText, translatable:true]))],],],,[(cluster = zigbee.parse(description))][If ((cluster && (cluster.clusterId == 6)) && (cluster.command == 7)),[If (cluster.data[0] == 0),[(event = this.createEvent([name:checkInterval, value:(60 * 12), displayed:false, data:[protocol:zigbee, hubHardwareId:device.hub.hardwareID]]))],[(event = null)]],,],],]
off: ]
on: ]
ping: ]
refresh: ]
configure: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartpower-outlet.metadata() is applicable for argument types: (smartpower-outlet$_run_closure1) values: [smartpower-outlet$_run_closure1@f415a95]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartsense-garage-door-multi.groovy
DECLARED METHODS
parse: [(results = [:])][If (this.isSupportedDescription(description) || description.startsWith(zone)),,[(results = this.parseMultiSensorMessage(description))]],]
updated: [(threeAxis = device.currentState(threeAxis))][If threeAxis,[(xyz = threeAxis.xyzValue)][(value = ((java.lang.Math.round(xyz.z) > 925)) ? open : closed)],],]
actuate: ]
parseMultiSensorMessage: [(results = [])][If this.isAccelerationMessage(description),[(results = this.parseAccelerationMessage(description))],[If this.isContactMessage(description),[(results = this.parseContactMessage(description))],[If this.isRssiLqiMessage(description),[(results = this.parseRssiLqiMessage(description))],[If this.isOrientationMessage(description),[(results = this.parseOrientationMessage(description))],],],],],]
parseAccelerationMessage: [(results = [])][(parts = description.split(,))]]
parseContactMessage: [(results = [])][(parts = description.split(,))]]
parseOrientationMessage: [(results = [])][(xyzResults = [x:0, y:0, z:0])][(parts = description.split(,))][(xyz = this.getXyzResult(xyzResults, description))][(a = xyz.value.split(,).collect({ -> ... }))][(absValueXY = java.lang.Math.max(java.lang.Math.abs(a[0]), java.lang.Math.abs(a[1])))][(absValueZ = java.lang.Math.abs(a[2]))][If ((absValueZ > 825) && (absValueXY < 175)),,[If ((absValueZ < 75) && (absValueXY > 825)),,],],]
parseRssiLqiMessage: [(results = [])][(parts = description.split(,))]]
getAccelerationResult: [(name = acceleration)][(value = (part.endsWith(1)) ? active : inactive)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]]
getTempResult: [(name = temperature)][(temperatureScale = this.getTemperatureScale())][(value = zigbee.parseSmartThingsTemperatureValue(part, temp: , temperatureScale))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],[(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value$temperatureScale)][(isStateChange = this.isTemperatureStateChange(device, name, value.toString()))]]
getXyzResult: [(name = threeAxis)][(value = $results.x,$results.y,$results.z)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
getRssiResult: [(name = (lastHop) ? lastHopRssi : rssi)][(valueString = part.split(:)[1].trim())][(value = (java.lang.Integer.parseInt(valueString) - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]]
getLqiResult: [(name = (lastHop) ? lastHopLqi : lqi)][(valueString = part.split(:)[1].trim())][(percentageOf = 255)][(value = java.lang.Math.round(((java.lang.Integer.parseInt(valueString) / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was: $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
isAccelerationMessage: [(description ==~ acceleration:.*rssi:.*lqi:.*)]]
isContactMessage: [(description ==~ contactState:.*accelerationState:.*temp:.*battery:.*rssi:.*lqi:.*)]]
isRssiLqiMessage: [(description ==~ lastHopRssi:.*lastHopLqi:.*rssi:.*lqi:.*)]]
isOrientationMessage: [(description ==~ x:.*y:.*z:.*rssi:.*lqi:.*)]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-garage-door-multi.metadata() is applicable for argument types: (smartsense-garage-door-multi$_run_closure1) values: [smartsense-garage-door-multi$_run_closure1@64712be]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartsense-garage-door-sensor-button.groovy
DECLARED METHODS
open: [If (device.currentValue(status) != open),,],]
close: [If (device.currentValue(status) != closed),,],]
parse: [(results = null)][If (this.isSupportedDescription(description) || description.startsWith(zone)),,[(results = this.parseMultiSensorMessage(description))]],]
actuate: ]
parseMultiSensorMessage: [(results = [])][If this.isAccelerationMessage(description),[(results = this.parseAccelerationMessage(description))],[If this.isContactMessage(description),[(results = this.parseContactMessage(description))],[If this.isRssiLqiMessage(description),[(results = this.parseRssiLqiMessage(description))],[If this.isOrientationMessage(description),[(results = this.parseOrientationMessage(description))],],],],],]
parseAccelerationMessage: [(results = [])][(parts = description.split(,))]]
parseContactMessage: [(results = [])][(parts = description.split(,))]]
parseOrientationMessage: [(results = [])][(xyzResults = [x:0, y:0, z:0])][(parts = description.split(,))][(xyz = this.getXyzResult(xyzResults, description))][(a = xyz.value.split(,).collect({ -> ... }))][(absValueXY = java.lang.Math.max(java.lang.Math.abs(a[0]), java.lang.Math.abs(a[1])))][(absValueZ = java.lang.Math.abs(a[2]))][If ((absValueZ > 825) && (absValueXY < 175)),,[If ((absValueZ < 75) && (absValueXY > 825)),,],],]
parseRssiLqiMessage: [(results = [])][(parts = description.split(,))]]
getAccelerationResult: [(name = acceleration)][(value = (part.endsWith(1)) ? active : inactive)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]]
getTempResult: [(name = temperature)][(temperatureScale = this.getTemperatureScale())][(value = zigbee.parseSmartThingsTemperatureValue(part, temp: , temperatureScale))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],[(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value$temperatureScale)][(isStateChange = this.isTemperatureStateChange(device, name, value.toString()))]]
getXyzResult: [(name = threeAxis)][(value = $results.x,$results.y,$results.z)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
getRssiResult: [(name = (lastHop) ? lastHopRssi : rssi)][(valueString = part.split(:)[1].trim())][(value = (java.lang.Integer.parseInt(valueString) - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]]
getLqiResult: [(name = (lastHop) ? lastHopLqi : lqi)][(valueString = part.split(:)[1].trim())][(percentageOf = 255)][(value = java.lang.Math.round(((java.lang.Integer.parseInt(valueString) / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was: $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
isAccelerationMessage: [(description ==~ acceleration:.*rssi:.*lqi:.*)]]
isContactMessage: [(description ==~ contactState:.*accelerationState:.*temp:.*battery:.*rssi:.*lqi:.*)]]
isRssiLqiMessage: [(description ==~ lastHopRssi:.*lastHopLqi:.*rssi:.*lqi:.*)]]
isOrientationMessage: [(description ==~ x:.*y:.*z:.*rssi:.*lqi:.*)]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-garage-door-sensor-button.metadata() is applicable for argument types: (smartsense-garage-door-sensor-button$_run_closure1) values: [smartsense-garage-door-sensor-button$_run_closure1@6cea706c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartsense-motion.groovy
DECLARED METHODS
parse: [(results = [:])][If (description.startsWith(zone) || this.isSupportedDescription(description)),[(results = this.parseBasicMessage(description))],[If this.isMotionStatusMessage(description),[(results = this.parseMotionStatusMessage(description))],],],]
parseBasicMessage: [(name = this.parseName(description))][(results = [:])][If (name != null),[(value = this.parseValue(description))][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(handlerName = value)][(isStateChange = this.isStateChange(device, name, value))][(results = [name:name, value:value, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName, isStateChange:isStateChange, ... ])],],]
parseName: [If this.isSupportedDescription(description),,],]
parseValue: [(zs = zigbee.parseZoneStatus(description))][If zs,,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
parseDescriptionText: ]
isMotionStatusMessage: [((description ==~ raw:.*dni:.*motion:.*battery:.*powerSource:.*rssi:.*lqi:.*) || (description ==~ raw:.*dni:.*motion:.*powerSource:.*battery:.*rssi:.*lqi:.*))]]
parseMotionStatusMessage: [(results = [])][(parts = description.split(,))]]
getMotionResult: [(name = motion)][(valueString = part.split(:)[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(value = ((valueInt == 0)) ? inactive : active)][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(isStateChange = this.isStateChange(device, name, value))]]
getPowerSourceResult: [(name = powerSource)][(valueString = part.split(:)[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(value = ((valueInt == 0)) ? battery : powered)][(linkText = this.getLinkText(device))][(descriptionText = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (value == battery),[(descriptionText = $linkText is $value powered)],[(descriptionText = $linkText is plugged in)]],[(isStateChange = this.isStateChange(device, name, value))]]
getBatteryResult: [(name = battery)][(valueString = part.split(:)[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][If (valueInt == 0),,],[(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText battery was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
getRssiResult: [(name = rssi)][(parts = part.split(:))][If (parts.size() != 2),,],[(valueString = parts[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(value = (valueInt - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]]
getLqiResult: [(name = lqi)][(parts = part.split(:))][If (parts.size() != 2),,],[(valueString = parts[1].trim())][(valueInt = java.lang.Integer.parseInt(valueString, 16))][(percentageOf = 255)][(value = java.lang.Math.round(((valueInt / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText Signal (LQI) was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-motion.metadata() is applicable for argument types: (smartsense-motion$_run_closure1) values: [smartsense-motion$_run_closure1@4940809c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartsense-multi.groovy
DECLARED METHODS
parse: [(results = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (this.isSupportedDescription(description) || description.startsWith(zone)),[(results = this.parseSingleMessage(description))],[If (description == updated),[(results = this.parseOtherMessage(description))],[(results = this.parseMultiSensorMessage(description))]],],]
parseSingleMessage: [(name = this.parseName(description))][(value = this.parseValue(description))][(linkText = this.getLinkText(device))][(descriptionText = this.parseDescriptionText(linkText, value, description))][(handlerName = ((value == open)) ? opened : value)][(isStateChange = this.isStateChange(device, name, value))][(results = [])]]
parseOtherMessage: [(name = null)][(value = description)][(linkText = this.getLinkText(device))][(descriptionText = description)][(handlerName = description)][(isStateChange = this.isStateChange(device, name, value))][(results = [name:name, value:value, unit:null, linkText:linkText, descriptionText:descriptionText, handlerName:handlerName, isStateChange:isStateChange, ... ])]]
parseMultiSensorMessage: [(results = [])][If this.isAccelerationMessage(description),[(results = this.parseAccelerationMessage(description))],[If this.isContactMessage(description),[(results = this.parseContactMessage(description))],[If this.isRssiLqiMessage(description),[(results = this.parseRssiLqiMessage(description))],[If this.isOrientationMessage(description),[(results = this.parseOrientationMessage(description))],],],],],]
parseAccelerationMessage: [(results = [])][(parts = description.split(,))]]
parseContactMessage: [(results = [])][(parts = description.split(,))]]
parseOrientationMessage: [(results = [])][(xyzResults = [x:0, y:0, z:0])][(parts = description.split(,))]]
parseRssiLqiMessage: [(results = [])][(parts = description.split(,))]]
getContactResult: [(name = contact)][(value = (part.endsWith(1)) ? open : closed)][(handlerName = ((value == open)) ? opened : value)][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $handlerName)][(isStateChange = this.isStateChange(device, name, value))][(results = [])]]
getAccelerationResult: [(name = acceleration)][(value = (part.endsWith(1)) ? active : inactive)][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value)][(isStateChange = this.isStateChange(device, name, value))]]
getTempResult: [(name = temperature)][(temperatureScale = this.getTemperatureScale())][(value = zigbee.parseSmartThingsTemperatureValue(part, temp: , temperatureScale))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],[(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value$temperatureScale)][(isStateChange = this.isTemperatureStateChange(device, name, value.toString()))]]
getXyzResult: [(name = threeAxis)][(value = $results.x,$results.y,$results.z)][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value)][(isStateChange = this.isStateChange(device, name, value))]]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText Battery was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
getRssiResult: [(name = (lastHop) ? lastHopRssi : rssi)][(valueString = part.split(:)[1].trim())][(value = (java.lang.Integer.parseInt(valueString) - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value dBm)][If lastHop,[(descriptionText +=  on the last hop)],],[(isStateChange = this.isStateChange(device, name, value))]]
getLqiResult: [(name = (lastHop) ? lastHopLqi : lqi)][(valueString = part.split(:)[1].trim())][(percentageOf = 255)][(value = java.lang.Math.round(((java.lang.Integer.parseInt(valueString) / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText Signal (LQI) was: $value$unit)][If lastHop,[(descriptionText +=  on the last hop)],],[(isStateChange = this.isStateChange(device, name, value))]]
isAccelerationMessage: [(description ==~ acceleration:.*rssi:.*lqi:.*)]]
isContactMessage: [(description ==~ contactState:.*accelerationState:.*temp:.*battery:.*rssi:.*lqi:.*)]]
isRssiLqiMessage: [(description ==~ lastHopRssi:.*lastHopLqi:.*rssi:.*lqi:.*)]]
isOrientationMessage: [(description ==~ x:.*y:.*z:.*rssi:.*lqi:.*)]]
parseName: [If this.isSupportedDescription(description),,],]
parseValue: [If this.isSupportedDescription(description),,],]
parseDescriptionText: [If this.isSupportedDescription(description),,],[(value) ? $linkText was $((value == open)) ? opened : value : ]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-multi.metadata() is applicable for argument types: (smartsense-multi$_run_closure1) values: [smartsense-multi$_run_closure1@43ed0ff3]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartsense-virtual-open-closed.groovy
DECLARED METHODS
parse: [(results = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (this.isSupportedDescription(description) || description.startsWith(zone)),,[(results = this.parseMultiSensorMessage(description))]],]
parseMultiSensorMessage: [(results = [])][If this.isAccelerationMessage(description),[(results = this.parseAccelerationMessage(description))],[If this.isContactMessage(description),[(results = this.parseContactMessage(description))],[If this.isRssiLqiMessage(description),[(results = this.parseRssiLqiMessage(description))],[If this.isOrientationMessage(description),[(results = this.parseOrientationMessage(description))],],],],],]
parseAccelerationMessage: [(results = [])][(parts = description.split(,))]]
parseContactMessage: [(results = [])][(parts = description.split(,))]]
parseOrientationMessage: [(results = [])][(xyzResults = [x:0, y:0, z:0])][(parts = description.split(,))][(xyz = this.getXyzResult(xyzResults, description))][(a = xyz.value.split(,).collect({ -> ... }))][(absValueXY = java.lang.Math.max(java.lang.Math.abs(a[0]), java.lang.Math.abs(a[1])))][(absValueZ = java.lang.Math.abs(a[2]))][If ((absValueZ > 825) && (absValueXY < 175)),,[If ((absValueZ < 75) && (absValueXY > 825)),,],],]
parseRssiLqiMessage: [(results = [])][(parts = description.split(,))]]
getAccelerationResult: [(name = acceleration)][(value = (part.endsWith(1)) ? active : inactive)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]]
getTempResult: [(name = temperature)][(temperatureScale = this.getTemperatureScale())][(value = zigbee.parseSmartThingsTemperatureValue(part, temp: , temperatureScale))][If tempOffset,[(offset = (int) tempOffset)][(v = (int) value)][(value = (v + offset))],],[(linkText = this.getLinkText(device))][(descriptionText = $linkText was $value$temperatureScale)][(isStateChange = this.isTemperatureStateChange(device, name, value.toString()))]]
getXyzResult: [(name = threeAxis)][(value = $results.x,$results.y,$results.z)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value)][(isStateChange = this.isStateChange(device, name, value))]]
getBatteryResult: [(batteryDivisor = (description.split(,).find({ -> ... })) ? description.split(,).find({ -> ... }).split(:)[1].trim() : null)][(name = battery)][(value = zigbee.parseSmartThingsBatteryValue(part, batteryDivisor))][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
getRssiResult: [(name = (lastHop) ? lastHopRssi : rssi)][(valueString = part.split(:)[1].trim())][(value = (java.lang.Integer.parseInt(valueString) - 128).toString())][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was $value dBm)][(isStateChange = this.isStateChange(device, name, value))]]
getLqiResult: [(name = (lastHop) ? lastHopLqi : lqi)][(valueString = part.split(:)[1].trim())][(percentageOf = 255)][(value = java.lang.Math.round(((java.lang.Integer.parseInt(valueString) / percentageOf) * 100)).toString())][(unit = %)][(linkText = this.getLinkText(device))][(descriptionText = $linkText $name was: $value$unit)][(isStateChange = this.isStateChange(device, name, value))]]
isAccelerationMessage: [(description ==~ acceleration:.*rssi:.*lqi:.*)]]
isContactMessage: [(description ==~ contactState:.*accelerationState:.*temp:.*battery:.*rssi:.*lqi:.*)]]
isRssiLqiMessage: [(description ==~ lastHopRssi:.*lastHopLqi:.*rssi:.*lqi:.*)]]
isOrientationMessage: [(description ==~ x:.*y:.*z:.*rssi:.*lqi:.*)]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartsense-virtual-open-closed.metadata() is applicable for argument types: (smartsense-virtual-open-closed$_run_closure1) values: [smartsense-virtual-open-closed$_run_closure1@6e57e95e]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing smartweather-station-controller.groovy
DECLARED METHODS
installed: ]
updated: [this.unschedule()]]
initialize: [this.scheduledEvent()]]
scheduledEvent: [log.info(SmartWeather Station Controller / scheduledEvent terminated due to deprecation)]]
Starting Points: [log.info(SmartWeather Station Controller / scheduledEvent terminated due to deprecation)]
IT HAS STATE
--app-start--
processing smartweather-station-tile.groovy
DECLARED METHODS
parse: ]
installed: ]
uninstalled: [this.unschedule()]]
poll: [(obs = this.get(conditions)?.current_observation)][If obs,[(weatherIcon = obs.icon_url.split(/)[-1].split(\.)[0])][If (this.getTemperatureScale() == C),,],[If (obs.local_tz_offset != device.currentValue(timeZoneOffset)),,],[(cityValue = $obs.display_location.city, $obs.display_location.state)][If (cityValue != device.currentValue(city)),,],[(a = this.get(astronomy)?.moon_phase)][(today = this.localDate(GMT$obs.local_tz_offset))][(ltf = new java.text.SimpleDateFormat(yyyy-MM-dd HH:mm))][(utf = new java.text.SimpleDateFormat(yyyy-MM-dd'T'HH:mm:ss.SSS'Z'))][(sunriseDate = ltf.parse($today $a.sunrise.hour:$a.sunrise.minute))][(sunsetDate = ltf.parse($today $a.sunset.hour:$a.sunset.minute))][(tf = new java.text.SimpleDateFormat(h:mm a))][(localSunrise = $tf.format(sunriseDate))][(localSunset = $tf.format(sunsetDate))][(f = this.get(forecast))][(f1 = f?.forecast?.simpleforecast?.forecastday)][If f1,[(icon = f1[0].icon_url.split(/)[-1].split(\.)[0])][(value = (java.lang.String -> java.lang.String) f1[0].pop)],],[(alerts = this.get(alerts)?.alerts)][(newKeys = (alerts?.collect({ -> ... })) ? alerts?.collect({ -> ... }) : [])][log.debug(WUSTATION: newKeys = $newKeys)][(oldKeys = device.currentState(alertKeys)?.jsonValue)][log.debug(WUSTATION: oldKeys = $oldKeys)][(noneString = no current weather alerts)][If (newKeys && (oldKeys == null)),,[If (newKeys != oldKeys),[If (oldKeys == null),[(oldKeys = [])],],[(newAlerts = false)][If (newAlerts && (device.currentValue(alert) != noneString)),,],,],],,],]
refresh: ]
configure: ]
pad: [(n = ((size - s.size()) / 2))][If (n > 0),[(sb = )][(sb += s)],],]
get: ]
localDate: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))]]
send: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
estimateLux: [(lux = 0)][(now = new java.util.Date().time)][If ((now > sunriseDate.time) && (now < sunsetDate.time)),,[(lux = 10)]],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: smartweather-station-tile.metadata() is applicable for argument types: (smartweather-station-tile$_run_closure1) values: [smartweather-station-tile$_run_closure1@1ac85b0c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing sonos-music-modes.groovy
DECLARED METHODS
songOptions: [(options = new java.util.LinkedHashSet())][If state.selectedSong?.station,[(options << state.selectedSong.station)],[If state.selectedSong?.description,[(options << state.selectedSong.description)],],],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))]]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSongs: ]
mainPage: ]
chooseTrack: ]
installed: [this.subscribeToEvents()]]
updated: [this.unsubscribe()][this.subscribeToEvents()]]
subscribeToEvents: [log.trace(subscribeToEvents())][this.subscribe(location, modeChangeHandler)]]
modeChangeHandler: [If allOk,[If frequency,[(lastTime = state[this.frequencyKey(evt)])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],]
takeAction: [(name = mode_$evt.value.toString())][(selectedSong = state.selectedSongs.$name)][If (selectedSong == PAUSE),,[If (volume != null),,],],[If (frequency || oncePerDay),[(state[this.frequencyKey(evt)] = this.now())],],]
frequencyKey: ]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],]
oncePerDayOk: [(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)]]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
timeIntervalLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing sonos-remote-control.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
initialize: [this.subscribe(buttonDevice, button, buttonEvent)]]
buttonEvent: [(buttonNumber = evt.data)][(value = evt.value)][log.debug(buttonEvent: $evt.name = $evt.value ($evt.data))][(recentEvents = buttonDevice.eventsSince(new java.util.Date((this.now() - 2000))).findAll({ -> ... }))][If (recentEvents.size <= 1),,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
extractButtonNumber: [(buttonNumber = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)]]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
handleButton: ]
togglePlayPause: [(currentStatus = sonos.currentValue(status))][If (currentStatus == playing),,],]
adjustVolume: [(changeAmount = ((volumeOffset) ? volumeOffset : 5 * (doubleAmount) ? 2 : 1))][(currentVolume = sonos.currentValue(level))][If up,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing spark.groovy
DECLARED METHODS
parse: ]
on: ]
off: ]
put: [(apiKey = fb91rfPFS84wmzH3)]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: spark.metadata() is applicable for argument types: (spark$_run_closure1) values: [spark$_run_closure1@3546d80f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing speaker-control.groovy
DECLARED METHODS
mainPage: ]
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, triggerModes, timeOfDay],[If settings[name],,],]]
ifUnset: [If settings[name],,],]
ifSet: [If settings[name],,],]
installed: [this.subscribeToEvents()]]
updated: [this.unsubscribe()][this.unschedule()][this.subscribeToEvents()]]
subscribeToEvents: [log.trace(subscribeToEvents())][this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,[this.schedule(timeOfDay, scheduledTimeHandler)],],]
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],]
modeChangeHandler: [If (evt.value in triggerModes),,],]
scheduledTimeHandler: ]
appTouchHandler: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
takeAction: [(options = [:])][If volume,[(options.delay = 1000)],],]
frequencyKey: ]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],]
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
timeIntervalLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing speaker-mood-music.groovy
DECLARED METHODS
songOptions: [(options = new java.util.LinkedHashSet())][If state.selectedSong?.station,[(options << state.selectedSong.station)],[If state.selectedSong?.description,[(options << state.selectedSong.description)],],],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))]]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSong: ]
mainPage: ]
chooseTrack: ]
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes, timeOfDay],[If settings[name],,],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes, timeOfDay],[If settings[name],,],]]
ifUnset: [If settings[name],,],]
ifSet: [If settings[name],,],]
installed: [this.subscribeToEvents()]]
updated: [this.unsubscribe()][this.unschedule()][this.subscribeToEvents()]]
subscribeToEvents: [log.trace(subscribeToEvents())][this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,[this.schedule(timeOfDay, scheduledTimeHandler)],],]
eventHandler: [If allOk,[If frequency,[(lastTime = state[this.frequencyKey(evt)])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],]
modeChangeHandler: [If (evt.value in triggerModes),,],]
scheduledTimeHandler: ]
appTouchHandler: ]
takeAction: [log.info(Playing '$state.selectedSong)][If (volume != null),,],[sonos.playTrack(state.selectedSong)][If (frequency || oncePerDay),[(state[this.frequencyKey(evt)] = this.now())],],]
frequencyKey: ]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],]
oncePerDayOk: [(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)]]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
timeIntervalLabel: ]
Starting Points: []
IT HAS STATE
--app-start--
processing speaker-notify-with-sound.groovy
DECLARED METHODS
mainPage: ]
chooseTrack: ]
songOptions: [(options = new java.util.LinkedHashSet())][If state.selectedSong?.station,[(options << state.selectedSong.station)],[If state.selectedSong?.description,[(options << state.selectedSong.description)],],],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))]]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSong: ]
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes, timeOfDay],[If settings[name],,],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes, timeOfDay],[If settings[name],,],]]
ifUnset: [If settings[name],,],]
ifSet: [If settings[name],,],]
installed: [this.subscribeToEvents()]]
updated: [this.unsubscribe()][this.unschedule()][this.subscribeToEvents()]]
subscribeToEvents: [this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,[this.schedule(timeOfDay, scheduledTimeHandler)],],[If song,,],]
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],]
modeChangeHandler: [If (evt.value in triggerModes),,],]
scheduledTimeHandler: ]
appTouchHandler: ]
takeAction: [If song,[sonos.playSoundAndTrack(state.sound.uri, state.sound.duration, state.selectedSong, volume)],[If resumePlaying,[sonos.playTrackAndResume(state.sound.uri, state.sound.duration, volume)],[sonos.playTrackAndRestore(state.sound.uri, state.sound.duration, volume)]],],[If (frequency || oncePerDay),[(state[this.frequencyKey(evt)] = this.now())],],]
frequencyKey: ]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],]
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
getTimeLabel: ]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
loadText: ]
Starting Points: []
IT HAS STATE
--app-start--
processing speaker-weather-forecast.groovy
DECLARED METHODS
mainPage: ]
chooseTrack: ]
anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes],[If settings[name],,],]anythingSet: [For [motion, contact, contactClosed, acceleration, mySwitch, mySwitchOff, arrivalPresence, departurePresence, smoke, water, button1, timeOfDay, triggerModes],[If settings[name],,],]]
ifUnset: [If settings[name],,],]
ifSet: [If settings[name],,],]
installed: [this.subscribeToEvents()]]
updated: [this.unsubscribe()][this.unschedule()][this.subscribeToEvents()]]
subscribeToEvents: [this.subscribe(app, appTouchHandler)][this.subscribe(contact, contact.open, eventHandler)][this.subscribe(contactClosed, contact.closed, eventHandler)][this.subscribe(acceleration, acceleration.active, eventHandler)][this.subscribe(motion, motion.active, eventHandler)][this.subscribe(mySwitch, switch.on, eventHandler)][this.subscribe(mySwitchOff, switch.off, eventHandler)][this.subscribe(arrivalPresence, presence.present, eventHandler)][this.subscribe(departurePresence, presence.not present, eventHandler)][this.subscribe(smoke, smoke.detected, eventHandler)][this.subscribe(smoke, smoke.tested, eventHandler)][this.subscribe(smoke, carbonMonoxide.detected, eventHandler)][this.subscribe(water, water.wet, eventHandler)][this.subscribe(button1, button.pushed, eventHandler)][If triggerModes,[this.subscribe(location, modeChangeHandler)],],[If timeOfDay,[this.schedule(timeOfDay, scheduledTimeHandler)],],[If song,,],]
eventHandler: [If allOk,[(lastTime = state[this.frequencyKey(evt)])][If this.oncePerDayOk(lastTime),[If frequency,[If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],,],,],]
modeChangeHandler: [If (evt.value in triggerModes),,],]
scheduledTimeHandler: ]
appTouchHandler: ]
takeAction: [If song,[sonos.playSoundAndTrack(state.sound.uri, state.sound.duration, state.selectedSong, volume)],[If resumePlaying,[sonos.playTrackAndResume(state.sound.uri, state.sound.duration, volume)],[If volume,[sonos.playTrackAtVolume(state.sound.uri, volume)],[sonos.playTrack(state.sound.uri)]],],],[If (frequency || oncePerDay),[(state[this.frequencyKey(evt)] = this.now())],],]
songOptions: [(options = new java.util.LinkedHashSet())][If state.selectedSong?.station,[(options << state.selectedSong.station)],[If state.selectedSong?.description,[(options << state.selectedSong.description)],],],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))]]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSong: ]
frequencyKey: ]
dayString: [(df = new java.text.SimpleDateFormat(yyyy-MM-dd))][If location.timeZone,,],]
oncePerDayOk: [(result = true)][If oncePerDay,[(result = (lastTime) ? (this.dayString(new java.util.Date()) != this.dayString(new java.util.Date(lastTime))) : true)][log.trace(oncePerDayOk = $result)],],]
getAllOk: ]
getModeOk: [(result = (modes || modes.contains(location.mode)))][log.trace(modeOk = $result)]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],[log.trace(daysOk = $result)]]
getTimeOk: [(result = true)][If (starting && ending),[(currTime = this.now())][(start = this.timeToday(starting, location?.timeZone).time)][(stop = this.timeToday(ending, location?.timeZone).time)][(result = ((start < stop)) ? ((currTime >= start) && (currTime <= stop)) : ((currTime <= stop) || (currTime >= start)))],],[log.trace(timeOk = $result)]]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
getTimeLabel: ]
loadText: [If (location.timeZone || zipCode),[(weather = this.getWeatherFeature(forecast, zipCode))][(current = this.getWeatherFeature(conditions, zipCode))][(isMetric = (location.temperatureScale == C))][(delim = )][(sb = new java.lang.StringBuilder())][(msg = sb.toString())][(msg = msg.replaceAll(([0-9]+)C, $1 degrees))][log.debug(msg = $msg)][(state.sound = this.textToSpeech(msg, true))],[(state.sound = this.textToSpeech(Please set the location of your hub with the SmartThings mobile app, or enter a zip code to receive weather forecasts.))]],]
list: ]
list: ]
Starting Points: []
IT HAS STATE
--app-start--
processing sprayer-controller-2.groovy
DECLARED METHODS
installed: [(startHour = startHour1)][(stopHour = stopHour1)][(startTime = minutes)][If (minutes == 1),[(startTime = ((((0 0  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 2),[(startTime = ((((0 0,30  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 3),[(startTime = ((((0 0,20,40  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 4),[(startTime = ((((0 0,15,30,45  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 5),[(startTime = ((((0 0,12,24,36,48  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 6),[(startTime = ((((0 0,10,20,30,40,50  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 12),[(startTime = ((((0 0,5,10,15,20,25,30,35,40,45,50,55  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 20),[(startTime = ((((0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 30),[(startTime = ((((0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58  + startHour) + -) + stopHour) +  * * ?))],[(startTime = ((((0 0  + startHour) + -) + stopHour) +  * * ?))]],],],],],],],],],[this.schedule(startTime, openValve)][this.subscribe(valves1, switch.on, valveOnHandler, [filterEvents:false])]]
updated: [this.unschedule()][this.unsubscribe()][(startHour = startHour1)][(stopHour = stopHour1)][(startTime = minutes)][If (minutes == 1),[(startTime = ((((0 0  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 2),[(startTime = ((((0 0,30  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 3),[(startTime = ((((0 0,20,40  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 4),[(startTime = ((((0 0,15,30,45  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 5),[(startTime = ((((0 0,12,24,36,48  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 6),[(startTime = ((((0 0,10,20,30,40,50  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 12),[(startTime = ((((0 0,5,10,15,20,25,30,35,40,45,50,55  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 20),[(startTime = ((((0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57  + startHour) + -) + stopHour) +  * * ?))],[If (minutes == 30),[(startTime = ((((0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58  + startHour) + -) + stopHour) +  * * ?))],[(startTime = ((((0 0  + startHour) + -) + stopHour) +  * * ?))]],],],],],],],],],[this.schedule(startTime, openValve)][this.subscribe(valves1, switch.on, valveOnHandler, [filterEvents:false])]]
openValve: ]
closeValve: ]
valveOnHandler: [(delay = duration)][this.runIn(delay, closeValve)]]
setStartTime: [If (minutes == 1),[(startTime = 0 0 $startHour * * ?)],[If (minutes == 2),[(startTime = 0 0,30 $startHour * * ?)],[If (minutes == 3),[(startTime = 0 0,20,40 $startHour * * ?)],[If (minutes == 4),[(startTime = 0 0,15,30,45 $startHour * * ?)],[If (minutes == 5),[(startTime = 0 0,12,24,36,48 $startHour * * ?)],[If (minutes == 6),[(startTime = 0 0,10,20,30,40,50 $startHour * * ?)],[If (minutes == 12),[(startTime = 0 0,5,10,15,20,25,30,35,40,45,50,55 $startHour * * ?)],[If (minutes == 20),[(startTime = 0 0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57 $startHour * * ?)],[If (minutes == 30),[(startTime = 0 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58 $startHour * * ?)],[(startTime = 0 0 $startHour * * ?)]],],],],],],],],],]
Starting Points: []
IT HAS STATE
--app-start--
processing spruce-scheduler.groovy
subscribe: not a ConstantExpression!
subscribe: first arg not a VariableExpression
subscribe: not a ConstantExpression!
subscribe: first arg not a VariableExpression
subscribe: not a ConstantExpression!
subscribe: first arg not a VariableExpression
subscribe: not a ConstantExpression!
subscribe: first arg not a VariableExpression
DECLARED METHODS
startPage: ]
globalPage: ]
weatherPage: ]
zipcodePage: ]
getPWSID: [(PWSID = location.zipCode)][If zipcode,[(PWSID = zipcode)],],[If (nearestPWS && zipcode),[(geoLocation = location.zipCode)][If (location.latitude && location.longitude),[(geoLocation = $location.latitude%2C$location.longitude)],],[(wdata = this.getWeatherFeature(geolookup, geoLocation))][If ((wdata && wdata.response) && wdata.response.containsKey(error)),[If ((wdata.response.features.containsKey(geolookup) && (wdata.response.features.geolookup.toInteger() == 1)) && wdata.location),[(PWSID = wdata.location.nearby_weather_stations.pws.station[0].id)],],,],,],]
startTimeString: [If startTime,,],]
enableString: [If (enable && enableManual),,[If enable,,[If enableManual,,],],],]
waterStoppersString: [(stoppers = Contact Sensor)][If settings.contacts,[If (settings.contacts.size() != 1),[(stoppers += s)],],[(stoppers += : )][(i = 1)][(stoppers = $stoppers
Pause: When $settings.contactStop
)],[(stoppers += : None
)]],[(stoppers += Switch)][If settings.toggles,[If (settings.toggles.size() != 1),[(stoppers += es)],],[(stoppers += : )][(i = 1)][(stoppers = $stoppers
Pause: When switched $settings.toggleStop
)],[(stoppers += : None
)]],[(cd = 10)][If (settings.contactDelay && (settings.contactDelay > 10)),[(cd = settings.contactDelay.toInteger())],],[(stoppers += Restart Delay: $cd secs)]]
isRainString: [If (settings.isRain && settings.rainDelay),,],[If settings.isRain,,],]
seasonalAdjString: [If settings.isSeason,,],]
syncString: [If settings.sync,,],]
notifyString: [(notifyStr = )][If settings.notify,[If settings.notify.contains(Daily),[(notifyStr +=  Daily)],],[If settings.notify.contains(Delays),[(notifyStr +=  Delays)],],[If settings.notify.contains(Warnings),[(notifyStr +=  Warnings)],],[If settings.notify.contains(Weather),[(notifyStr +=  Weather)],],[If settings.notify.contains(Moisture),[(notifyStr +=  Moisture)],],[If settings.notify.contains(Events),[(notifyStr +=  Events)],],,],[If (notifyStr == ),[(notifyStr =  None)],],[If settings.logAll,[(notifyStr += 
Sending all Notifications to Hello Home log)],],]
daysString: [(daysString = )][If days,[If (days.contains(Even) || days.contains(Odd)),[If days.contains(Even),[(daysString +=  Even)],],[If days.contains(Odd),[(daysString +=  Odd)],],,[If days.contains(Monday),[(daysString +=  M)],],[If days.contains(Tuesday),[(daysString +=  Tu)],],[If days.contains(Wednesday),[(daysString +=  W)],],[If days.contains(Thursday),[(daysString +=  Th)],],[If days.contains(Friday),[(daysString +=  F)],],[If days.contains(Saturday),[(daysString +=  Sa)],],[If days.contains(Sunday),[(daysString +=  Su)],],],,],[If (daysString == ),,],]
hhmm: [(t = this.timeToday(time, location.timeZone))][(f = new java.text.SimpleDateFormat(fmt))]]
pumpDelayString: [If pumpDelay,,],]
delayPage: ]
zonePage: ]
zoneActive: [If ((zoneNumberEnum && zoneNumber) && (zoneNumber >= z.toInteger())),,[If ((zoneNumberEnum && zoneNumber) && (zoneNumber != z.toInteger())),,[If (zoneNumberEnum && zoneNumberEnum.contains(z)),,],],],]
zoneString: [(numberString = Add zones to setup)][If zoneNumber,[(numberString = Zones enabled: $zoneNumber)],],[If learn,[(numberString = $numberString
Sensor mode: Adaptive)],[(numberString = $numberString
Sensor mode: Delay)]],]
zoneSettingsPage: ]
zoneSetPage: [this.dynamicPage([name:zoneSetPage, title:Zone $state.app Setup], { -> ... })]]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
setString: ]
plantSetPage: [this.dynamicPage([name:plantSetPage, title:$settings[name$state.app] Landscape Select], { -> ... })]]
sprinklerSetPage: [this.dynamicPage([name:sprinklerSetPage, title:$settings[name$state.app] Sprinkler Select], { -> ... })]]
optionSetPage: [this.dynamicPage([name:optionSetPage, title:$settings[name$state.app] Options], { -> ... })]]
setPage: [If i,[(state.app = i)],],[return state.app]]
getaZoneSummary: [If (settings.zone$zone || (settings.zone$zone == Off)),,],[(daysString = )][(tpw = this.initTPW(zone))][(dpw = this.initDPW(zone))][(runTime = this.calcRunTime(tpw, dpw))][If (learn && settings.sensor$zone),[(daysString = if Moisture is low on: )][(dpw = this.daysAvailable())],],[If (days && (days.contains(Even) || days.contains(Odd))),[If (dpw == 1),[(daysString = Every 8 days)],],[If (dpw == 2),[(daysString = Every 4 days)],],[If (dpw == 4),[(daysString = Every 2 days)],],[If (days.contains(Even) && days.contains(Odd)),[(daysString = any day)],],,[(dpwMap = [0, 0, 0, 0, 0, 0, 0])][(dpwMap = this.getDPWDays(dpw))][(daysString += this.getRunDays(dpwMap))]],]
getZoneSummary: [(summary = )][If learn,[(summary = Moisture Learning enabled)],[(summary = Moisture Learning disabled)]],[(zone = 1)][While (zone <= 16),[If (this.nozzle(zone) == 4),[(summary = $summary
$zone: $settings.zone$zone)],[If ((this.initDPW(zone) != 0) && this.zoneActive(zone.toString())),[(summary = $summary
$this.getaZoneSummary(zone))],],],]getZoneSummary: [(summary = )][If learn,[(summary = Moisture Learning enabled)],[(summary = Moisture Learning disabled)]],[(zone = 1)][While (zone <= 16),[If (this.nozzle(zone) == 4),[(summary = $summary
$zone: $settings.zone$zone)],[If ((this.initDPW(zone) != 0) && this.zoneActive(zone.toString())),[(summary = $summary
$this.getaZoneSummary(zone))],],],][If summary,,],]
display: [(displayString = )][(tpw = this.initTPW(i.toInteger()))][(dpw = this.initDPW(i.toInteger()))][(runTime = this.calcRunTime(tpw, dpw))][If settings.zone$i,[(displayString += (settings.zone$i +  : ))],],[If settings.plant$i,[(displayString += (settings.plant$i +  : ))],],[If settings.option$i,[(displayString += (settings.option$i +  : ))],],[(j = i.toInteger())][If settings.sensor$i,[(displayString += settings.sensor$i)][(displayString += =$this.getDrySp(j)% : )],],[If ((runTime != 0) && (dpw != 0)),[(displayString = $displayString$runTime minutes, $dpw days per week)],],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
getimage: [(imageStr = image)][If image.isNumber(),[(zoneStr = settings.zone$image)][If zoneStr,[If (zoneStr == Off),,],[If (zoneStr == Master Valve),,],[If (zoneStr == Pump),,],[If settings.plant$image,[(imageStr = settings.plant$image)],],,],,],]
getname: [If settings.name$i,,],]
zipString: [If settings.zipcode,,],[If settings.zipcode.isNumber(),,],]
installed: [(state.dpwMap = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])][(state.tpwMap = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])][(state.Rain = [0, 0, 0, 0, 0, 0, 0])][(state.daycount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])][(atomicState.run = false)][(state.pauseTime = null)][(atomicState.startTime = null)][(atomicState.finishTime = null)][this.installSchedule()]]
updated: [this.installSchedule()]]
installSchedule: [If state.seasonAdj,[(state.seasonAdj = 100.0)],],[If state.weekseasonAdj,[(state.weekseasonAdj = 0)],],[If (state.daysAvailable != 0),[(state.daysAvailable = 0)],],[(state.daysAvailable = this.daysAvailable())][If atomicState.run,,[this.unsubscribe()]],[this.subscribe(app, appTouch)][(rand = new java.util.Random())][(randomOffset = 0)][(randomSeconds = rand.nextInt(59))][If (settings.isRain || settings.isSeason),[this.schedule($randomSeconds 57 23 1/1 * ? *, getRainToday)],],[If ((settings.switches && settings.startTime) && settings.enable),[(randomOffset = (rand.nextInt(60000) + 20000))][(checktime = (this.timeToday(settings.startTime, location.timeZone).getTime() + randomOffset))][this.schedule(checktime, preCheck)][this.note(schedule, $app.label: Starts at $this.startTimeString(), i)],[this.unschedule(preCheck)]],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
attemptRecovery: [If atomicState.run,,[(csw = settings.switches.currentSwitch)][(cst = settings.switches.currentStatus)]],]
resetEverything: [If atomicState.run,[(atomicState.run = false)],],[this.unschedule(cycleOn)][this.unschedule(checkRunMap)][this.unschedule(writeCycles)][this.unschedule(subOff)][If settings.enableManual,[this.subscribe(settings.switches, switch.programOn, manualStart)],],]
unsubAllBut: [this.unsubscribe(settings.switches)][If settings.sync,[this.unsubscribe(settings.sync)],],]
appTouch: [log.debug(appTouch(): atomicState.run = $atomicState.run)][this.runIn(2, preCheck)]]
isWaterStopped: [If (settings.contacts && settings.contacts.currentContact.contains(settings.contactStop)),,],[If (settings.toggles && settings.toggles.currentSwitch.contains(settings.toggleStop)),,],]
subWaterStop: [If settings.contacts,[this.unsubscribe(settings.contacts)][this.subscribe(settings.contacts, contact.$settings.contactStop, waterStop)],],[If settings.toggles,[this.unsubscribe(settings.toggles)][this.subscribe(settings.toggles, switch.$settings.toggleStop, waterStop)],],]
subWaterStart: [If settings.contacts,[this.unsubscribe(settings.contacts)][(cond = ((settings.contactStop == open)) ? closed : open)][this.subscribe(settings.contacts, contact.$cond, waterStart)],],[If settings.toggles,[this.unsubscribe(settings.toggles)][(cond = ((settings.toggleStop == on)) ? off : on)][this.subscribe(settings.toggles, switch.$cond, waterStart)],],]
unsubWaterStoppers: [If settings.contacts,[this.unsubscribe(settings.contacts)],],[If settings.toggles,[this.unsubscribe(settings.toggles)],],]
getWaterStopList: [(deviceList = )][(i = 1)][If settings.contacts,,],[If settings.toggles,,],]
writeSettings: [If state.tpwMap,[(state.tpwMap = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])],],[If state.dpwMap,[(state.dpwMap = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])],],[If state.setMoisture,[(state.setMoisture = null)],],[If state.seasonAdj,[(state.seasonAdj = 100.0)],],[If state.weekseasonAdj,[(state.weekseasonAdj = 0)],],]
getWeekDay: [(weekdays = [Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday])][(mapDay = [Monday:1, Tuesday:2, Wednesday:3, Thursday:4, Friday:5, Saturday:6, Sunday:7])][If (day && weekdays.contains(day)),,],[(today = new java.util.Date().format(EEEE, location.timeZone))]]
getRunDays: [(str = )][If day1,[(str += M)],],[If day2,[(str += T)],],[If day3,[(str += W)],],[If day4,[(str += Th)],],[If day5,[(str += F)],],[If day6,[(str += Sa)],],[If day7,[(str += Su)],],[If (str == ),[(str = 0 Days/week)],],]
manualStart: [(running = this.attemptRecovery())][If ((settings.enableManual && running) && (settings.switches.currentStatus != pause)),[If (settings.sync && ((settings.sync.currentSwitch != off) || (settings.sync.currentStatus == pause))),,[(runNowMap = [])][(runNowMap = this.cycleLoop(0))][If runNowMap,[(atomicState.run = true)][this.subscribe(settings.switches, switch.off, cycleOff)][this.runIn(60, cycleOn)][(newString = )][(tt = state.totalTime)][If tt,[(hours = (tt / 60))][(mins = (tt - (hours * 60)))][(hourString = )][(s = )][If (hours > 1),[(s = s)],],[If (hours > 0),[(hourString = $hours hour$s & )],],[(s = s)][If (mins == 1),[(s = )],],[(newString = run time: $hourString$mins minute$s:
)],],,],],,],]
busy: [If atomicState.run,[If this.attemptRecovery(),,],,],[If settings.sync,[If ((settings.sync.currentSwitch != off) || (settings.sync.currentStatus == pause)),[this.subscribe(settings.sync, switch.off, syncOn)],],,],[(csw = settings.switches.currentSwitch)][(cst = settings.switches.currentStatus)][If ((csw == off) && (cst != pause)),,],[If this.isDay(),[this.subscribe(settings.switches, switch.off, busyOff)][this.note(delayed, $app.label: Waiting for currently running schedule to complete before starting, c)],],[log.debug(Another schedule is running, but $app.label is not scheduled for today anyway)]]
busyOff: [(cst = settings.switches.currentStatus)][If ((settings.switches.currentSwitch == off) && (cst != pause)),[this.unsubscribe(switches)][(rand = new java.util.Random())][(randomSeconds = (rand.nextInt(120) + 15))][this.runIn(randomSeconds, preCheck)],],]
preCheck: [If this.isDay(),[log.debug(preCheck() Skipping: $app.label is not scheduled for today)],],[If this.busy(),[(atomicState.run = true)][this.runIn(45, checkRunMap)][this.subscribe(settings.switches, switch.off, cycleOff)][(start = this.now())][(end = this.now())][If this.isWeather(),,[this.runIn(2, checkRunMap)]],,],]
cycleOn: [If atomicState.run,[If this.isWaterStopped(),[this.subscribe(settings.switches, switch.off, cycleOff)][(newString = $app.label: Starting...)][If atomicState.startTime,[(atomicState.startTime = this.now())][If atomicState.startTime,[(atomicState.finishTime = null)],],[If state.pauseTime,[(state.pauseTime = null)],],[If state.totalTime,[(finishTime = new java.util.Date((this.now() + (60000 * state.totalTime).toLong())).format(EE @ h:mm a, location.timeZone))][(newString = $app.label: Starting - ETC: $finishTime)],],,[If state.pauseTime,[(elapsedTime = java.lang.Math.round(((this.now() - state.pauseTime) / 60000)))][(tt = ((state.totalTime + elapsedTime) + 1))][(state.totalTime = tt)][(finishTime = new java.util.Date((atomicState.startTime + (60000 * tt).toLong())).format(EE @ h:mm a, location.timeZone))][(state.pauseTime = null)][(newString = $app.label: Resuming - New ETC: $finishTime)],],],,],,],]
cycleOff: [If atomicState.run,[(ft = new java.util.Date())][(atomicState.finishTime = ft)][(finishTime = ft.format(h:mm a, location.timeZone))],],]
checkRunMap: [If atomicState.run,[(runNowMap = [])][(runNowMap = this.cycleLoop(1))][If runNowMap,[this.runIn(60, cycleOn)][this.subscribe(settings.switches, switch.off, cycleOff)][If atomicState.startTime,[(atomicState.startTime = null)],],[If state.pauseTime,[(state.pauseTime = null)],],[(newString = )][(tt = state.totalTime)][If tt,[(hours = (tt / 60))][(mins = (tt - (hours * 60)))][(hourString = )][(s = )][If (hours > 1),[(s = s)],],[If (hours > 0),[(hourString = $hours hour$s & )],],[(s = s)][If (mins == 1),[(s = )],],[(newString = run time: $hourString$mins minute$s:
)],],,[this.unsubscribe(settings.switches)][If enableManual,[this.subscribe(settings.switches, switch.programOn, manualStart)],],[If atomicState.run,[(atomicState.run = false)],],],,[log.debug(checkRunMap(): atomicState.run = false)]],]
cycleLoop: [(isDebug = false)][If isDebug,,],[(zone = 1)][(dpw = 0)][(tpw = 0)][(cyc = 0)][(rtime = 0)][(timeMap = [:])][(pumpMap = )][(runNowMap = )][(soilString = )][(totalCycles = 0)][(totalTime = 0)][If atomicState.startTime,[(atomicState.startTime = null)],],[While (zone <= 16),[(rtime = 0)][(setZ = settings.zone$zone)][If (((setZ && (setZ != Off)) && (this.nozzle(zone) != 4)) && this.zoneActive(zone.toString())),[(dpw = this.getDPW(zone))][(runToday = 0)][If (((i == 0) || (state.daysAvailable == 7)) || settings.sensor$zone),[(runToday = 1)],[(dpw = this.getDPW(zone))][If (settings.days && (settings.days.contains(Even) || settings.days.contains(Odd))),[(daynum = new java.util.Date().format(dd, location.timeZone))][(dayint = java.lang.Integer.parseInt(daynum))][If (settings.days.contains(Odd) && (((dayint + 1) % java.lang.Math.round((31 / (dpw * 4)))) == 0)),[(runToday = 1)],[If (settings.days.contains(Even) && ((dayint % java.lang.Math.round((31 / (dpw * 4)))) == 0)),[(runToday = 1)],],],,[(weekDay = (this.getWeekDay() - 1))][(dpwMap = this.getDPWDays(dpw))][(runToday = dpwMap[weekDay])][If isDebug,,],],],[If (runToday == 1),[(soil = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (i == 0),[(soil = this.moisture(0))],[(soil = this.moisture(zone))]],[(soilString = $soilString$soil[1])][If (soil[0] == 1),[(cyc = this.cycles(zone))][(tpw = this.getTPW(zone))][(dpw = this.getDPW(zone))][(rtime = this.calcRunTime(tpw, dpw))][If (settings.isSeason && (settings.learn || settings.sensor$zone)),[(rtime = java.lang.Math.round((((rtime / cyc) * (state.seasonAdj / 100.0)) + 0.4)))],[(rtime = java.lang.Math.round(((rtime / cyc) + 0.4)))]],[(totalCycles += cyc)][(totalTime += (rtime * cyc))][(runNowMap += $settings.name$zone: $cyc x $rtime min
)][If isDebug,,],,],,],,],[If (this.nozzle(zone) == 4),[(pumpMap += $settings.name$zone: $settings.zone$zone on
)],],[(timeMap.$(zone + 1) = $rtime)]]cycleLoop: [(isDebug = false)][If isDebug,,],[(zone = 1)][(dpw = 0)][(tpw = 0)][(cyc = 0)][(rtime = 0)][(timeMap = [:])][(pumpMap = )][(runNowMap = )][(soilString = )][(totalCycles = 0)][(totalTime = 0)][If atomicState.startTime,[(atomicState.startTime = null)],],[While (zone <= 16),[(rtime = 0)][(setZ = settings.zone$zone)][If (((setZ && (setZ != Off)) && (this.nozzle(zone) != 4)) && this.zoneActive(zone.toString())),[(dpw = this.getDPW(zone))][(runToday = 0)][If (((i == 0) || (state.daysAvailable == 7)) || settings.sensor$zone),[(runToday = 1)],[(dpw = this.getDPW(zone))][If (settings.days && (settings.days.contains(Even) || settings.days.contains(Odd))),[(daynum = new java.util.Date().format(dd, location.timeZone))][(dayint = java.lang.Integer.parseInt(daynum))][If (settings.days.contains(Odd) && (((dayint + 1) % java.lang.Math.round((31 / (dpw * 4)))) == 0)),[(runToday = 1)],[If (settings.days.contains(Even) && ((dayint % java.lang.Math.round((31 / (dpw * 4)))) == 0)),[(runToday = 1)],],],,[(weekDay = (this.getWeekDay() - 1))][(dpwMap = this.getDPWDays(dpw))][(runToday = dpwMap[weekDay])][If isDebug,,],],],[If (runToday == 1),[(soil = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (i == 0),[(soil = this.moisture(0))],[(soil = this.moisture(zone))]],[(soilString = $soilString$soil[1])][If (soil[0] == 1),[(cyc = this.cycles(zone))][(tpw = this.getTPW(zone))][(dpw = this.getDPW(zone))][(rtime = this.calcRunTime(tpw, dpw))][If (settings.isSeason && (settings.learn || settings.sensor$zone)),[(rtime = java.lang.Math.round((((rtime / cyc) * (state.seasonAdj / 100.0)) + 0.4)))],[(rtime = java.lang.Math.round(((rtime / cyc) + 0.4)))]],[(totalCycles += cyc)][(totalTime += (rtime * cyc))][(runNowMap += $settings.name$zone: $cyc x $rtime min
)][If isDebug,,],,],,],,],[If (this.nozzle(zone) == 4),[(pumpMap += $settings.name$zone: $settings.zone$zone on
)],],[(timeMap.$(zone + 1) = $rtime)]][If soilString,[(seasonStr = )][(plus = )][(sa = state.seasonAdj)][If ((settings.isSeason && (sa != 100.0)) && (sa != 0.0)),[(sadj = (sa - 100.0))][If (sadj > 0.0),[(plus = +)],],[(iadj = java.lang.Math.round(sadj))][If (iadj != 0),[(seasonStr = Adjusting $plus$iadj% for weather forecast
)],],,],,],[If runNowMap,,],[this.runIn(30, writeCycles)][(pDelay = 0)][If (settings.pumpDelay && settings.pumpDelay.isNumber()),[(pDelay = settings.pumpDelay.toInteger())],],[(totalTime += java.lang.Math.round(((pDelay * (totalCycles - 1)) / 60.0)))][(state.totalTime = totalTime)][If state.pauseTime,[(state.pauseTime = null)],],]
writeCycles: [(cyclesMap = [:])][(cyclesMap.1 = this.pumpDelayString())][(zone = 1)][(cycle = 0)][While (zone <= 17),[If (this.nozzle(zone) == 4),[(cycle = 4)],[(cycle = this.cycles(zone))]],[(cyclesMap.$(zone + 1) = $cycle)]]writeCycles: [(cyclesMap = [:])][(cyclesMap.1 = this.pumpDelayString())][(zone = 1)][(cycle = 0)][While (zone <= 17),[If (this.nozzle(zone) == 4),[(cycle = 4)],[(cycle = this.cycles(zone))]],[(cyclesMap.$(zone + 1) = $cycle)]]]
resume: ]
syncOn: [If ((settings.sync.currentSwitch == off) && (settings.sync.currentStatus != pause)),[(rand = new java.util.Random())][(randomSeconds = (rand.nextInt(120) + 15))][this.runIn(randomSeconds, preCheck)][this.note(schedule, $app.label: $settings.sync finished, starting in $randomSeconds seconds, c)],],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
waterStop: [this.unschedule(cycleOn)][this.unsubscribe(settings.switches)][If state.pauseTime,[(state.pauseTime = this.now())][(cond = evt.value)],],[If (settings.switches.currentSwitch != off),[this.runIn(30, subOff)],[this.subscribe(settings.switches, switch.off, cycleOff)]],]
subOff: [this.subscribe(settings.switches, switch.off, offPauseCheck)]]
offPauseCheck: [this.unsubscribe(settings.switches)][this.subscribe(settings.switches, switch.off, cycleOff)][If (settings.switches.currentStatus != pause),,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
waterStart: [If this.isWaterStopped(),[(cDelay = 10)][If (settings.contactDelay > 10),[(cDelay = settings.contactDelay)],],[this.runIn(cDelay, cycleOn)][this.unsubscribe(settings.switches)][(cond = evt.value)],],]
initDPW: [If state.dpwMap,[(state.dpwMap = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])],],[(tpw = this.getTPW(zone))][(dpw = 0)][If (tpw > 0),[(perDay = 20.0)][If settings.perDay$zone,[(perDay = settings.perDay$zone.toFloat())],],[(dpw = java.lang.Math.round((tpw.toFloat() / perDay)))][If (dpw <= 1),[(dpw = 1)],],[If ((((dpw == 3) && days) && (days.contains(Even) || days.contains(Odd))) && (days.contains(Even) && days.contains(Odd))),[If ((tpw.toFloat() / perDay) < 3.0),[(dpw = 2)],[(dpw = 4)]],,],[(daycheck = this.daysAvailable())][If (daycheck < dpw),[(dpw = daycheck)],],,],[(state.dpwMap[(zone - 1)] = dpw)]]
getDPW: [If state.dpwMap,[return state.dpwMap[(zone - 1)]],],]
initTPW: [If state.tpwMap,[(state.tpwMap = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])],],[(n = this.nozzle(zone))][(zn = settings.zone$zone)][If (((((zn || (zn == Off)) || (n == 0)) || (n == 4)) || (this.plant(zone) == 0)) || this.zoneActive(zone.toString())),,],[(gainAdjust = 100.0)][If (settings.gain && (settings.gain != 0)),[(gainAdjust += settings.gain)],],[(seasonAdjust = 100.0)][(wsa = state.weekseasonAdj)][If ((wsa && isSeason) && (settings.plant$zone != New Plants)),[(seasonAdjust = wsa)],],[(tpw = 0)][If settings.sensor$zone,[(seasonAdjust = 100.0)][If (state.tpwMap && settings.learn),[(tpw = state.tpwMap[(zone - 1)])],],,],[(minWeek = 0)][(mw = settings.minWeek$zone)][If mw,[(minWeek = mw.toInteger())],],[If (minWeek != 0),[(tpw = java.lang.Math.round((minWeek * (seasonAdjust / 100.0))))],[If (tpw || (tpw == 0)),[(tpw = java.lang.Math.round((((this.plant(zone) * this.nozzle(zone)) * (gainAdjust / 100.0)) * (seasonAdjust / 100.0))))],],],[(state.tpwMap[(zone - 1)] = tpw)]]
getTPW: [If state.tpwMap,[return state.tpwMap[(zone - 1)]],],]
calcRunTime: [(duration = 0)][If ((tpw > 0) && (dpw > 0)),[(duration = java.lang.Math.round((tpw.toFloat() / dpw.toFloat())))],],]
moisture: [(isDebug = false)][If isDebug,,],[(endMsecs = 0)][If ((i == 0) || settings.sensor$i),,],[(spHum = this.getDrySp(i))][(hours = 48)][(yesterday = new java.util.Date((this.now() - (3600000 * hours).toLong())))][(latestHum = settings.sensor$i.latestValue(humidity).toFloat())][(lastHumDate = settings.sensor$i.latestState(humidity).date)][If (lastHumDate < yesterday),[If (latestHum < spHum),[(latestHum = (spHum - 1.0))],[(latestHum = (spHum + 0.99))]],,],[If settings.learn,[If (latestHum <= spHum.toFloat()),,],,],[(tpw = this.getTPW(i))][(dpw = this.getDPW(i))][(cpd = this.cycles(i))][If isDebug,,],[(diffHum = 0.0)][If (latestHum > 0.0),[(diffHum = ((spHum - latestHum) / 100.0))],[(diffHum = 0.02)]],[(daysA = state.daysAvailable)][(minimum = (cpd * dpw))][If (minimum < daysA),[(minimum = daysA)],],[(tpwAdjust = 0)][If (diffHum > 0.01),[(tpwAdjust = java.lang.Math.round(((((tpw * diffHum) + 0.5) * dpw) * cpd)))][(adjFactor = (2.0 / daysA))][If (tpwAdjust > (tpw * adjFactor)),[(tpwAdjust = java.lang.Math.round(((tpw * adjFactor) + 0.5)))],],[If (tpwAdjust < minimum),[(tpwAdjust = minimum)],],,[If (diffHum < -0.01),[If (diffHum < -0.05),[(diffHum = -0.05)],],[(tpwAdjust = java.lang.Math.round(((((tpw * diffHum) - 0.5) * dpw) * cpd)))][(adjFactor = (-0.6667 / daysA))][If (tpwAdjust < (tpw * adjFactor)),[(tpwAdjust = java.lang.Math.round(((tpw * adjFactor) - 0.5)))],],[If (tpwAdjust > (-1 * minimum)),[(tpwAdjust = (-1 * minimum))],],,],],[(seasonAdjust = 0)][If isSeason,[(sa = state.seasonAdj)][If ((sa != 100.0) && (sa != 0.0)),[(sadj = (sa - 100.0))][If (sa > 0.0),[(seasonAdjust = java.lang.Math.round((((sadj / 100.0) * tpw) + 0.5)))],[(seasonAdjust = java.lang.Math.round((((sadj / 100.0) * tpw) - 0.5)))]],,],,],[If isDebug,,],[(newTPW = ((tpw + tpwAdjust) + seasonAdjust))][(perDay = 20)][(perD = settings.perDay$i)][If perD,[(perDay = perD.toInteger())],],[If (perDay == 0),[(perDay = (daysA * cpd))],],[If (newTPW < perDay),[(newTPW = perDay)],],[(adjusted = 0)][If ((tpwAdjust + seasonAdjust) > 0),[(maxTPW = (daysA * 120))][If (newTPW > maxTPW),[(newTPW = maxTPW)],],[If (newTPW > (maxTPW * 0.75)),,],[If (state.tpwMap[(i - 1)] != newTPW),[(state.tpwMap[(i - 1)] = newTPW)][(dpw = this.initDPW(i))][(adjusted = (newTPW - tpw))],],,[If ((tpwAdjust + seasonAdjust) < 0),[(minimum = (cpd * daysA))][(minLimit = 0)][(minL = settings.minWeek$i)][If minL,[(minLimit = minL.toInteger())],],[If (minLimit > 0),[If (newTPW < minLimit),[(newTPW = minLimit)],],,[If (newTPW < minimum),[(newTPW = minimum)],],],[If (state.tpwMap[(i - 1)] != newTPW),[(state.tpwMap[(i - 1)] = newTPW)][(dpw = this.initDPW(i))][(adjusted = (newTPW - tpw))],],,],],[(moistureSum = )][(adjStr = )][(plus = )][If (adjusted > 0),[(plus = +)],],[If (adjusted != 0),[(adjStr = , $plus$adjusted min)],],[If (java.lang.Math.abs(adjusted) > 1),[(adjStr = $adjStrs)],],[If (diffHum >= 0.0),[(moistureSum = > $settings.name$i, Water: $settings.sensor$i @ $latestHum% ($spHum%)$adjStr ($newTPW min/wk)
)],[(moistureSum = > $settings.name$i, Skip: $settings.sensor$i @ $latestHum% ($spHum%)$adjStr ($newTPW min/wk)
)]],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
getDrySp: [If settings.sensorSp$i,,],[If (settings.plant$i == New Plants),,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
note: [(notifyController = true)][If (settings.notify || settings.logAll),[(spruceMsg = Spruce $msg)],],[If notifyController,[If (atomicState.run || ((settings.switches.currentSwitch == off) && (settings.switches.currentStatus != pause))),,],,],]
sendIt: [If (location.contactBookEnabled && settings.recipients),,],]
daysAvailable: [(daysA = state.daysAvailable)][If (daysA && (daysA > 0)),,],[If settings.days,[(state.daysAvailable = 7)],],[(dayCount = 0)][If (settings.days.contains(Even) || settings.days.contains(Odd)),[(dayCount = 4)][If (settings.days.contains(Even) && settings.days.contains(Odd)),[(dayCount = 7)],],,[If settings.days.contains(Monday),[(dayCount += 1)],],[If settings.days.contains(Tuesday),[(dayCount += 1)],],[If settings.days.contains(Wednesday),[(dayCount += 1)],],[If settings.days.contains(Thursday),[(dayCount += 1)],],[If settings.days.contains(Friday),[(dayCount += 1)],],[If settings.days.contains(Saturday),[(dayCount += 1)],],[If settings.days.contains(Sunday),[(dayCount += 1)],],],[(state.daysAvailable = dayCount)]]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
nozzle: [(getT = settings.zone$i)][If getT,,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
plant: [(getP = settings.plant$i)][If getP,,],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
cycles: [(getC = settings.option$i)][If getC,,],]
isDay: [If (this.daysAvailable() == 7),,],[(daynow = new java.util.Date())][(today = daynow.format(EEEE, location.timeZone))][If settings.days.contains(today),,],[(daynum = daynow.format(dd, location.timeZone))][(dayint = java.lang.Integer.parseInt(daynum))][If (settings.days.contains(Even) && ((dayint % 2) == 0)),,],[If (settings.days.contains(Odd) && ((dayint % 2) != 0)),,],]
setSeason: [(isDebug = false)][If isDebug,,],[(zone = 1)][While (zone <= 16),[If ((settings.learn || settings.sensor$zone) || (state.tpwMap[(zone - 1)] == 0)),[(tpw = this.initTPW(zone))][(dpw = this.initDPW(zone))][If isDebug,[If ((settings.learn && (tpw != 0)) && (state.weekseasonAdj != 0)),[log.debug(Zone $zone: seasonally adjusted by $(state.weekseasonAdj - 100)% to $tpw)],],,],,],]setSeason: [(isDebug = false)][If isDebug,,],[(zone = 1)][While (zone <= 16),[If ((settings.learn || settings.sensor$zone) || (state.tpwMap[(zone - 1)] == 0)),[(tpw = this.initTPW(zone))][(dpw = this.initDPW(zone))][If isDebug,[If ((settings.learn && (tpw != 0)) && (state.weekseasonAdj != 0)),[log.debug(Zone $zone: seasonally adjusted by $(state.weekseasonAdj - 100)% to $tpw)],],,],,],]]
getRainToday: [(wzipcode = this.zipString())][(wdata = this.getWeatherFeature(conditions, wzipcode))][If wdata,,[If (wdata.response || wdata.response.containsKey(error)),,[(TRain = 0.0)][If wdata.current_observation.precip_today_in.isNumber(),[(TRain = wdata.current_observation.precip_today_in.toFloat())][If (TRain > 25.0),[(TRain = 25.0)],[If (TRain < 0.0),[(TRain = 0.0)],],],,],[(day = this.getWeekDay())][If (day == 7),[(day = 0)],],[(state.Rain[day] = (java.lang.Float -> java.lang.Float) TRain)]],],]
isWeather: [(startMsecs = 0)][(endMsecs = 0)][(isDebug = false)][If isDebug,,],[If (settings.isRain && settings.isSeason),,],[(wzipcode = this.zipString())][If isDebug,,],[(featureString = forecast/conditions)][If settings.isSeason,[(featureString = $featureString/astronomy)],],[If isDebug,[(startMsecs = this.now())],],[(wdata = this.getWeatherFeature(featureString, wzipcode))][If isDebug,[(endMsecs = this.now())],],[If (wdata && wdata.response),[If isDebug,,],[If wdata.response.containsKey(error),[If (wdata.response.error.type != invalidfeature),,],,],,[If isDebug,,],],[(city = wzipcode)][If wdata.current_observation,[If (wdata.current_observation.observation_location.city != ),[(city = wdata.current_observation.observation_location.city)],[If (wdata.current_observation.observation_location.full != ),[(city = wdata.current_observation.display_location.full)],],],[If wdata.current_observation.estimated.estimated,[(city = $city (est))],],,],[(qpfTodayIn = 0.0)][(qpfTomIn = 0.0)][(popToday = 50.0)][(popTom = 50.0)][(TRain = 0.0)][(YRain = 0.0)][(weeklyRain = 0.0)][If settings.isRain,[If isDebug,,],[If wdata.forecast,,],[If wdata.forecast.simpleforecast.forecastday[0].qpf_allday.in.isNumber(),[(qpfTodayIn = wdata.forecast.simpleforecast.forecastday[0].qpf_allday.in.toFloat())],],[If wdata.forecast.simpleforecast.forecastday[0].pop.isNumber(),[(popToday = wdata.forecast.simpleforecast.forecastday[0].pop.toFloat())],],[If wdata.forecast.simpleforecast.forecastday[1].qpf_allday.in.isNumber(),[(qpfTomIn = wdata.forecast.simpleforecast.forecastday[1].qpf_allday.in.toFloat())],],[If wdata.forecast.simpleforecast.forecastday[1].pop.isNumber(),[(popTom = wdata.forecast.simpleforecast.forecastday[1].pop.toFloat())],],[If (qpfTodayIn > 25.0),[(qpfTodayIn = 25.0)],[If (qpfTodayIn < 0.0),[(qpfTodayIn = 0.0)],],],[If (qpfTomIn > 25.0),[(qpfTomIn = 25.0)],[If (qpfTomIn < 0.0),[(qpfTomIn = 0.0)],],],[If wdata.current_observation,,],[If wdata.current_observation.precip_today_in.isNumber(),[(TRain = wdata.current_observation.precip_today_in.toFloat())][If (TRain > 25.0),[(TRain = 25.0)],[If (TRain < 0.0),[(TRain = 0.0)],],],,],[If (TRain > (qpfTodayIn * (popToday / 100.0))),[(qpfTodayIn = TRain)][(popToday = 100)],],[(day = this.getWeekDay())][(YRain = state.Rain[(day - 1)])][If isDebug,,],[(i = 0)][While (i <= 6),[(factor = 0)][If ((day - i) > 0),[(factor = (day - i))],[(factor = ((day + 7) - i))]],[(getrain = state.Rain[i])][If (factor != 0),[(weeklyRain += (getrain / factor))],],][If isDebug,,],[If wdata.forecast,,],[If wdata.forecast.simpleforecast.forecastday[0].qpf_allday.in.isNumber(),[(qpfTodayIn = wdata.forecast.simpleforecast.forecastday[0].qpf_allday.in.toFloat())],],[If wdata.forecast.simpleforecast.forecastday[0].pop.isNumber(),[(popToday = wdata.forecast.simpleforecast.forecastday[0].pop.toFloat())],],[If wdata.forecast.simpleforecast.forecastday[1].qpf_allday.in.isNumber(),[(qpfTomIn = wdata.forecast.simpleforecast.forecastday[1].qpf_allday.in.toFloat())],],[If wdata.forecast.simpleforecast.forecastday[1].pop.isNumber(),[(popTom = wdata.forecast.simpleforecast.forecastday[1].pop.toFloat())],],[If (qpfTodayIn > 25.0),[(qpfTodayIn = 25.0)],[If (qpfTodayIn < 0.0),[(qpfTodayIn = 0.0)],],],[If (qpfTomIn > 25.0),[(qpfTomIn = 25.0)],[If (qpfTomIn < 0.0),[(qpfTomIn = 0.0)],],],[If wdata.current_observation,,],[If wdata.current_observation.precip_today_in.isNumber(),[(TRain = wdata.current_observation.precip_today_in.toFloat())][If (TRain > 25.0),[(TRain = 25.0)],[If (TRain < 0.0),[(TRain = 0.0)],],],,],[If (TRain > (qpfTodayIn * (popToday / 100.0))),[(qpfTodayIn = TRain)][(popToday = 100)],],[(day = this.getWeekDay())][(YRain = state.Rain[(day - 1)])][If isDebug,,],[(i = 0)][While (i <= 6),[(factor = 0)][If ((day - i) > 0),[(factor = (day - i))],[(factor = ((day + 7) - i))]],[(getrain = state.Rain[i])][If (factor != 0),[(weeklyRain += (getrain / factor))],],][If isDebug,,],,],[If isDebug,,],[(highToday = 0)][(highTom = 0)][If wdata.forecast.simpleforecast.forecastday[0].high.fahrenheit.isNumber(),[(highToday = wdata.forecast.simpleforecast.forecastday[0].high.fahrenheit.toInteger())],],[If wdata.forecast.simpleforecast.forecastday[1].high.fahrenheit.isNumber(),[(highTom = wdata.forecast.simpleforecast.forecastday[1].high.fahrenheit.toInteger())],],[(weatherString = $app.label: $city weather:
 TDA: $highTodayF)][If settings.isRain,[(weatherString = $weatherString, $qpfTodayInin rain ($Math.round(popToday)% PoP))],],[(weatherString = $weatherString
 TMW: $highTomF)][If settings.isRain,[(weatherString = $weatherString, $qpfTomInin rain ($Math.round(popTom)% PoP)
 YDA: $YRainin rain)],],[If settings.isSeason,[If settings.isRain,[If wdata.forecast,,],,],[(heatAdjust = 100.0)][(avgHigh = highToday.toFloat())][If (highToday != 0),[(totalHigh = highToday)][(j = 1)][(highs = 1)][While (j < 4),[If wdata.forecast.simpleforecast.forecastday[j].high.fahrenheit.isNumber(),[(totalHigh += wdata.forecast.simpleforecast.forecastday[j].high.fahrenheit.toInteger())],],][(totalHigh = highToday)][(j = 1)][(highs = 1)][While (j < 4),[If wdata.forecast.simpleforecast.forecastday[j].high.fahrenheit.isNumber(),[(totalHigh += wdata.forecast.simpleforecast.forecastday[j].high.fahrenheit.toInteger())],],][If (highs > 0),[(avgHigh = (totalHigh / highs))],],[(heatAdjust = (avgHigh / highToday))],],[If isDebug,,],[(humToday = 0)][If wdata.forecast.simpleforecast.forecastday[0].avehumidity.isNumber(),[(humToday = wdata.forecast.simpleforecast.forecastday[0].avehumidity.toInteger())],],[(humAdjust = 100.0)][(avgHum = humToday.toFloat())][If (humToday != 0),[(j = 1)][(highs = 1)][(totalHum = humToday)][While (j < 4),[If wdata.forecast.simpleforecast.forecastday[j].avehumidity.isNumber(),[(totalHum += wdata.forecast.simpleforecast.forecastday[j].avehumidity.toInteger())],],][(j = 1)][(highs = 1)][(totalHum = humToday)][While (j < 4),[If wdata.forecast.simpleforecast.forecastday[j].avehumidity.isNumber(),[(totalHum += wdata.forecast.simpleforecast.forecastday[j].avehumidity.toInteger())],],][If (highs > 1),[(avgHum = (totalHum / highs))],],[(humAdjust = (1.5 - ((0.5 * avgHum) / humToday)))],],[If isDebug,,],[(sa = (((heatAdjust + humAdjust) / 2) * 100.0))][(state.seasonAdj = sa)][(sa = (sa - 100.0))][(plus = )][If (sa > 0),[(plus = +)],],[(weatherString = $weatherString
 Adjusting $plus$Math.round(sa)% for weather forecast)][If ((this.getWeekDay() == 1) || (state.weekseasonAdj == 0)),[If wdata.sun_phase,[(getsunRH = 0)][(getsunRM = 0)][(getsunSH = 0)][(getsunSM = 0)][If wdata.sun_phase.sunrise.hour.isNumber(),[(getsunRH = wdata.sun_phase.sunrise.hour.toInteger())],],[If wdata.sun_phase.sunrise.minute.isNumber(),[(getsunRM = wdata.sun_phase.sunrise.minute.toInteger())],],[If wdata.sun_phase.sunset.hour.isNumber(),[(getsunSH = wdata.sun_phase.sunset.hour.toInteger())],],[If wdata.sun_phase.sunset.minute.isNumber(),[(getsunSM = wdata.sun_phase.sunset.minute.toInteger())],],[(daylight = (((getsunSH * 60) + getsunSM) - ((getsunRH * 60) + getsunRM)))][If (daylight >= 850),[(daylight = 850)],],[(qFact = 75.0)][(wa = (((daylight / 700.0) * (((avgHigh / 70.0) + (1.5 - ((avgHum * 0.5) / 65.46))) / 2.0)) * qFact))][(state.weekseasonAdj = wa)][(plus = )][If (wa != 0),[If (wa > 100.0),[(plus = +)],],[(waStr = java.lang.String.format(%.2f, (wa - 100.0)))][(weatherString = $weatherString
 Seasonal adjustment of $waStr% for the week)],],,],,],,],[If settings.isRain,,],[(setrainDelay = 0.2)][If settings.rainDelay,[(setrainDelay = settings.rainDelay.toFloat())],],[If this.anySensors(),[If (settings.switches.latestValue(rainsensor) == rainsensoron),,],[(popRain = (qpfTodayIn * (popToday / 100.0)))][If (popRain > setrainDelay),[(rainStr = java.lang.String.format(%.2f, popRain))],],[(popRain += (qpfTomIn * (popTom / 100.0)))][If (popRain > setrainDelay),[(rainStr = java.lang.String.format(%.2f, popRain))],],[If (weeklyRain > setrainDelay),[(rainStr = java.lang.String.format(%.2f, weeklyRain))],],,[(popRain = ((qpfTodayIn * (popToday / 100.0)) - TRain))][If (popRain > setrainDelay),[(rainStr = java.lang.String.format(%.2f, popRain))],],[(popRain += (qpfTomIn * (popTom / 100.0)))][If (popRain > setrainDelay),[(rainStr = java.lang.String.format(%.2f, popRain))],],],[If isDebug,,],]
anySensors: [(zone = 1)][While (zone <= 16),[(zoneStr = settings.zone$zone)][If ((zoneStr && (zoneStr != Off)) && settings.sensor$zone),,],]anySensors: [(zone = 1)][While (zone <= 16),[(zoneStr = settings.zone$zone)][If ((zoneStr && (zoneStr != Off)) && settings.sensor$zone),,],]]
getDPWDays: [If (((dpw && dpw.isNumber()) && (dpw >= 1)) && (dpw <= 7)),[return state.DPWDays$dpw],],]
createDPWMap: [(state.DPWDays1 = [])][(state.DPWDays2 = [])][(state.DPWDays3 = [])][(state.DPWDays4 = [])][(state.DPWDays5 = [])][(state.DPWDays6 = [])][(state.DPWDays7 = [])][(dayDistance = [[0, 1, 2, 3, 3, 2, 1], [1, 0, 1, 2, 3, 3, 2], [2, 1, 0, 1, 2, 3, 3], [3, 2, 1, 0, 1, 2, 3], [3, 3, 2, 1, 0, 1, 2], [2, 3, 3, 2, 1, 0, 1], [1, 2, 3, 3, 2, 1, 0]])][(ndaysAvailable = this.daysAvailable())][(i = 0)][(daysAvailable = [0, 0, 0, 0, 0, 0, 0])][If settings.days,[If (settings.days.contains(Even) || settings.days.contains(Odd)),,],[If settings.days.contains(Monday),[(daysAvailable[i] = 0)],],[If settings.days.contains(Tuesday),[(daysAvailable[i] = 1)],],[If settings.days.contains(Wednesday),[(daysAvailable[i] = 2)],],[If settings.days.contains(Thursday),[(daysAvailable[i] = 3)],],[If settings.days.contains(Friday),[(daysAvailable[i] = 4)],],[If settings.days.contains(Saturday),[(daysAvailable[i] = 5)],],[If settings.days.contains(Sunday),[(daysAvailable[i] = 6)],],[If (i != ndaysAvailable),[(ndaysAvailable = i)][(state.daysAvailable = i)],],,[(daysAvailable = [0, 1, 2, 3, 4, 5, 6])]],[(maxday = -1)][(max = -1)][(dDays = [])][(runDays = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]])][For ((a = 0); (a < ndaysAvailable); (a++)),[If (((a > 0) && (ndaysAvailable >= 2)) && (a != (ndaysAvailable - 1))),[If (a == 1),[For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If (d > max),[(max = d)][(maxday = daysAvailable[c])],],][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If (d > max),[(max = d)][(maxday = daysAvailable[c])],],][(dDays[0] = maxday)],],[If (a > 1),[(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = 5)][While (max == -1),[(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],]][(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = 5)][While (max == -1),[(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],]][(dDays[(a - 1)] = maxday)],],,],[For ((b = 0); (b < 7); (b++)),[If (a == (ndaysAvailable - 1)),[(runDays[a][b] = 0)][For ((c = 0); (c < ndaysAvailable); (c++)),[If (b == daysAvailable[c]),[(runDays[a][b] = 1)],],][(runDays[a][b] = 0)][For ((c = 0); (c < ndaysAvailable); (c++)),[If (b == daysAvailable[c]),[(runDays[a][b] = 1)],],],[If (a == 0),[If (b == daysAvailable[0]),[(runDays[a][b] = 1)],[(runDays[a][b] = 0)]],,[If (b == daysAvailable[0]),[(runDays[a][b] = 1)],[(runDays[a][b] = 0)][For ((c = 0); (c < a); (c++)),[If (b == dDays[c]),[(runDays[a][b] = 1)],],][(runDays[a][b] = 0)][For ((c = 0); (c < a); (c++)),[If (b == dDays[c]),[(runDays[a][b] = 1)],],]],],],][If (((a > 0) && (ndaysAvailable >= 2)) && (a != (ndaysAvailable - 1))),[If (a == 1),[For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If (d > max),[(max = d)][(maxday = daysAvailable[c])],],][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If (d > max),[(max = d)][(maxday = daysAvailable[c])],],][(dDays[0] = maxday)],],[If (a > 1),[(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = 5)][While (max == -1),[(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],]][(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = 5)][While (max == -1),[(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],]][(dDays[(a - 1)] = maxday)],],,],[For ((b = 0); (b < 7); (b++)),[If (a == (ndaysAvailable - 1)),[(runDays[a][b] = 0)][For ((c = 0); (c < ndaysAvailable); (c++)),[If (b == daysAvailable[c]),[(runDays[a][b] = 1)],],][(runDays[a][b] = 0)][For ((c = 0); (c < ndaysAvailable); (c++)),[If (b == daysAvailable[c]),[(runDays[a][b] = 1)],],],[If (a == 0),[If (b == daysAvailable[0]),[(runDays[a][b] = 1)],[(runDays[a][b] = 0)]],,[If (b == daysAvailable[0]),[(runDays[a][b] = 1)],[(runDays[a][b] = 0)][For ((c = 0); (c < a); (c++)),[If (b == dDays[c]),[(runDays[a][b] = 1)],],][(runDays[a][b] = 0)][For ((c = 0); (c < a); (c++)),[If (b == dDays[c]),[(runDays[a][b] = 1)],],]],],],]]createDPWMap: [(state.DPWDays1 = [])][(state.DPWDays2 = [])][(state.DPWDays3 = [])][(state.DPWDays4 = [])][(state.DPWDays5 = [])][(state.DPWDays6 = [])][(state.DPWDays7 = [])][(dayDistance = [[0, 1, 2, 3, 3, 2, 1], [1, 0, 1, 2, 3, 3, 2], [2, 1, 0, 1, 2, 3, 3], [3, 2, 1, 0, 1, 2, 3], [3, 3, 2, 1, 0, 1, 2], [2, 3, 3, 2, 1, 0, 1], [1, 2, 3, 3, 2, 1, 0]])][(ndaysAvailable = this.daysAvailable())][(i = 0)][(daysAvailable = [0, 0, 0, 0, 0, 0, 0])][If settings.days,[If (settings.days.contains(Even) || settings.days.contains(Odd)),,],[If settings.days.contains(Monday),[(daysAvailable[i] = 0)],],[If settings.days.contains(Tuesday),[(daysAvailable[i] = 1)],],[If settings.days.contains(Wednesday),[(daysAvailable[i] = 2)],],[If settings.days.contains(Thursday),[(daysAvailable[i] = 3)],],[If settings.days.contains(Friday),[(daysAvailable[i] = 4)],],[If settings.days.contains(Saturday),[(daysAvailable[i] = 5)],],[If settings.days.contains(Sunday),[(daysAvailable[i] = 6)],],[If (i != ndaysAvailable),[(ndaysAvailable = i)][(state.daysAvailable = i)],],,[(daysAvailable = [0, 1, 2, 3, 4, 5, 6])]],[(maxday = -1)][(max = -1)][(dDays = [])][(runDays = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]])][For ((a = 0); (a < ndaysAvailable); (a++)),[If (((a > 0) && (ndaysAvailable >= 2)) && (a != (ndaysAvailable - 1))),[If (a == 1),[For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If (d > max),[(max = d)][(maxday = daysAvailable[c])],],][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If (d > max),[(max = d)][(maxday = daysAvailable[c])],],][(dDays[0] = maxday)],],[If (a > 1),[(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = 5)][While (max == -1),[(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],]][(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = 5)][While (max == -1),[(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],]][(dDays[(a - 1)] = maxday)],],,],[For ((b = 0); (b < 7); (b++)),[If (a == (ndaysAvailable - 1)),[(runDays[a][b] = 0)][For ((c = 0); (c < ndaysAvailable); (c++)),[If (b == daysAvailable[c]),[(runDays[a][b] = 1)],],][(runDays[a][b] = 0)][For ((c = 0); (c < ndaysAvailable); (c++)),[If (b == daysAvailable[c]),[(runDays[a][b] = 1)],],],[If (a == 0),[If (b == daysAvailable[0]),[(runDays[a][b] = 1)],[(runDays[a][b] = 0)]],,[If (b == daysAvailable[0]),[(runDays[a][b] = 1)],[(runDays[a][b] = 0)][For ((c = 0); (c < a); (c++)),[If (b == dDays[c]),[(runDays[a][b] = 1)],],][(runDays[a][b] = 0)][For ((c = 0); (c < a); (c++)),[If (b == dDays[c]),[(runDays[a][b] = 1)],],]],],],][If (((a > 0) && (ndaysAvailable >= 2)) && (a != (ndaysAvailable - 1))),[If (a == 1),[For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If (d > max),[(max = d)][(maxday = daysAvailable[c])],],][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If (d > max),[(max = d)][(maxday = daysAvailable[c])],],][(dDays[0] = maxday)],],[If (a > 1),[(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = 5)][While (max == -1),[(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],]][(lmax = max)][(lmaxday = maxday)][(max = -1)][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][(t = (d > max))][If ((a % 2) == 0),[(t = (d >= max))],],[If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = 5)][While (max == -1),[(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],][(lmax = (lmax - 1))][For ((c = 1); (c < ndaysAvailable); (c++)),[(d = dayDistance[daysAvailable[0]][daysAvailable[c]])][If ((d < lmax) && (d >= max)),[If (d == max),[(d = dayDistance[lmaxday][daysAvailable[c]])][If (d > dayDistance[lmaxday][maxday]),[(max = d)][(maxday = daysAvailable[c])],],,[(max = d)][(maxday = daysAvailable[c])]],,],][For ((d = 0); (d < (a - 2)); (d++)),[If (maxday == dDays[d]),[(max = -1)],],]][(dDays[(a - 1)] = maxday)],],,],[For ((b = 0); (b < 7); (b++)),[If (a == (ndaysAvailable - 1)),[(runDays[a][b] = 0)][For ((c = 0); (c < ndaysAvailable); (c++)),[If (b == daysAvailable[c]),[(runDays[a][b] = 1)],],][(runDays[a][b] = 0)][For ((c = 0); (c < ndaysAvailable); (c++)),[If (b == daysAvailable[c]),[(runDays[a][b] = 1)],],],[If (a == 0),[If (b == daysAvailable[0]),[(runDays[a][b] = 1)],[(runDays[a][b] = 0)]],,[If (b == daysAvailable[0]),[(runDays[a][b] = 1)],[(runDays[a][b] = 0)][For ((c = 0); (c < a); (c++)),[If (b == dDays[c]),[(runDays[a][b] = 1)],],][(runDays[a][b] = 0)][For ((c = 0); (c < a); (c++)),[If (b == dDays[c]),[(runDays[a][b] = 1)],],]],],],]][(state.DPWDays1 = runDays[0])][(state.DPWDays2 = runDays[1])][(state.DPWDays3 = runDays[2])][(state.DPWDays4 = runDays[3])][(state.DPWDays5 = runDays[4])][(state.DPWDays6 = runDays[5])][(state.DPWDays7 = runDays[6])]]
zoneSetPage1: [(state.app = 1)]]
zoneSetPage2: [(state.app = 2)]]
zoneSetPage3: [(state.app = 3)]]
zoneSetPage4: [(state.app = 4)]]
zoneSetPage5: [(state.app = 5)]]
zoneSetPage6: [(state.app = 6)]]
zoneSetPage7: [(state.app = 7)]]
zoneSetPage8: [(state.app = 8)]]
zoneSetPage9: [(state.app = 9)]]
zoneSetPage10: [(state.app = 10)]]
zoneSetPage11: [(state.app = 11)]]
zoneSetPage12: [(state.app = 12)]]
zoneSetPage13: [(state.app = 13)]]
zoneSetPage14: [(state.app = 14)]]
zoneSetPage15: [(state.app = 15)]]
zoneSetPage16: [(state.app = 16)]]
Starting Points: []
IT HAS STATE
--app-start--
processing step-notifier.groovy
DECLARED METHODS
setupNotifications: ]
chooseTrack: ]
songOptions: [(options = new java.util.LinkedHashSet())][If state.selectedSong?.station,[(options << state.selectedSong.station)],[If state.selectedSong?.description,[(options << state.selectedSong.description)],],],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))]]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSong: ]
installed: ]
updated: [this.unsubscribe()]]
initialize: [(state.lastSteps = 0)][(state.steps = jawbone.currentValue(steps).toInteger())][(state.goal = jawbone.currentValue(goal).toInteger())][this.subscribe(jawbone, goal, goalHandler)][this.subscribe(jawbone, steps, stepHandler)][If song,,],]
goalHandler: [(goal = evt.value.toInteger())][(state.goal = goal)]]
stepHandler: [log.debug(state.steps = $state.steps)][log.debug(state.goal = $state.goal)][(steps = evt.value.toInteger())][(state.lastSteps = state.steps)][(state.steps = steps)][(stepGoal = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (settings.thresholdType == Goal),[(stepGoal = state.goal)],[(stepGoal = settings.threshold)]],[If ((state.lastSteps < stepGoal) && (state.steps >= stepGoal)),[If (settings.notificationType != None),[If location.contactBookEnabled,,[(options = [method:settings.notificationType.toLowerCase(), phone:settings.phone])]],,],[If settings.sonos,,],[If settings.hues,,],[If settings.lights,,],,],]
lightsNotification: [(state.previousLights = [:])][For (1..flashCount),]lightsNotification: [(state.previousLights = [:])][For (1..flashCount),]]
hueNotification: [(hueColor = 0)][If (color == Blue),[(hueColor = 70)],[If (color == Green),[(hueColor = 39)],[If (color == Yellow),[(hueColor = 25)],[If (color == Orange),[(hueColor = 10)],[If (color == Purple),[(hueColor = 75)],[If (color == Pink),[(hueColor = 83)],],],],],],],[(state.previousHue = [:])][log.debug(current values = $state.previousHue)][(newValue = [hue:hueColor, saturation:100, level:((java.lang.Integer -> java.lang.Integer) lightLevel) ? (java.lang.Integer -> java.lang.Integer) lightLevel : 100])][log.debug(new value = $newValue)]]
setTimer: [log.debug(runIn $duration, resetHue)][this.runIn(duration, resetHue, [overwrite:false])]]
resetHue: ]
sonosNotification: [If settings.song,[If settings.resumePlaying,[If settings.volume,[sonos.playTrackAndResume(state.selectedSong, settings.songDuration, settings.volume)],[sonos.playTrackAndResume(state.selectedSong, settings.songDuration)]],,[If settings.volume,[sonos.playTrackAtVolume(state.selectedSong, settings.volume)],[sonos.playTrack(state.selectedSong)]],],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing sunrise-sunset.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()][this.unschedule()]]
initialize: [this.subscribe(location, position, locationPositionChange)][this.subscribe(location, sunriseTime, sunriseTimeHandler)][this.subscribe(location, sunsetTime, sunsetTimeHandler)][this.scheduleWithOffset(location.currentValue(sunsetTime), sunsetOffsetValue, sunsetOffsetDir, sunsetHandler)][this.scheduleWithOffset(location.currentValue(sunriseTime), sunriseOffsetValue, sunriseOffsetDir, sunriseHandler)]]
locationPositionChange: ]
sunsetTimeHandler: [this.scheduleWithOffset(evt.value, sunsetOffsetValue, sunsetOffsetDir, sunsetHandler)]]
sunriseTimeHandler: [this.scheduleWithOffset(evt.value, sunriseOffsetValue, sunriseOffsetDir, sunriseHandler)]]
scheduleWithOffset: [(nextSunriseSunsetTimeDate = java.util.Date.parse(yyyy-MM-dd'T'HH:mm:ss.SSS'Z', nextSunriseSunsetTime))][(offsetTime = new java.util.Date((nextSunriseSunsetTimeDate.time + this.getOffset(offset, offsetDir))))][this.runOnce(offsetTime, handlerName)]]
sunriseHandler: [If sunriseOn,,],[If sunriseOff,,],]
sunsetHandler: [If sunsetOn,,],[If sunsetOff,,],]
changeMode: [If (newMode && (location.mode != newMode)),[If location.modes?.find({ -> ... }),,],,],]
send: [If location.contactBookEnabled,,[If (sendPushMessage != No),,],[If phoneNumber,,],],]
getLabel: ]
getOffset: [(timeOffsetMillis = this.calculateTimeOffsetMillis(offsetValue))][If (offsetDir == Before),,],]
calculateTimeOffsetMillis: [(result = 0)][If offset,,],[(before = offset.startsWith(-))][If (before || offset.startsWith(+)),[(offset = offset[(1..-1)])],],[If offset.isNumber(),[(result = java.lang.Math.round(((java.lang.Double -> java.lang.Double) offset * 60000)))],[If offset.contains(:),[(segs = offset.split(:))][(result = ((segs[0].toLong() * 3600000) + (segs[1].toLong() * 60000)))],],],[If before,[(result = result)],],]
Starting Points: []
IT HAS STATE
--app-start--
processing switch-activates-home-phrase-or-mode.groovy
DECLARED METHODS
getPref: ]
installed: [this.subscribe(controlSwitch, switch, switchHandler)]]
updated: [this.unsubscribe()][this.subscribe(controlSwitch, switch, switchHandler)]]
switchHandler: [If ((evt.value == on) && (phrase_on || onMode)),[If phrase_on,,],[If onMode,,],,[If ((evt.value == off) && (phrase_off || offMode)),[If phrase_off,,],[If offMode,,],,],],]
changeMode: [If (location.mode != newMode),[If location.modes?.find({ -> ... }),,],,],]
textAppName: [(text = Switch Activates Home Phrase or Mode)]]
textVersion: [(text = Version 1.0.1 (06/20/2015))]]
textCopyright: [(text = Copyright  2015 Michael Struck)]]
textLicense: [(text = ((((((((((Licensed under the Apache License, Version 2.0 (the 'License');  + you may not use this file except in compliance with the License. ) + You may obtain a copy of the License at) + 

) +     http://www.apache.org/licenses/LICENSE-2.0) + 

) + Unless required by applicable law or agreed to in writing, software ) + distributed under the License is distributed on an 'AS IS' BASIS, ) + WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ) + See the License for the specific language governing permissions and ) + limitations under the License.))]]
textHelp: [(text = ((Ties a Hello, Home phrase or mode to a switch's (virtual or real) on/off state. Perfect for use with IFTTT.  + Simple define a switch to be used, then tie the on/off state of the switch to a specific Hello, Home phrases or mode. ) + Connect the switch to an IFTTT action, and the Hello, Home phrase or mode will fire with the switch state change.))]]
Starting Points: []
IT HAS STATE
--app-start--
processing switch-activates-home-phrase.groovy
DECLARED METHODS
getPref: ]
installed: [this.subscribe(controlSwitch, switch, switchHandler)]]
updated: [this.unsubscribe()][this.subscribe(controlSwitch, switch, switchHandler)]]
switchHandler: [If (evt.value == on),,],]
Starting Points: []
IT HAS STATE
--app-start--
processing switch-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
on: ]
off: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: switch-capability.metadata() is applicable for argument types: (switch-capability$_run_closure1) values: [switch-capability$_run_closure1@24be2d9c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing switch-changes-mode.groovy
DECLARED METHODS
installed: [this.subscribe(controlSwitch, switch, switchHandler)]]
updated: [this.unsubscribe()][this.subscribe(controlSwitch, switch, switchHandler)]]
switchHandler: [If (evt.value == on),,],]
changeMode: [If (newMode && (location.mode != newMode)),[If location.modes?.find({ -> ... }),,],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing switch-child-device.groovy
DECLARED METHODS
on: ]
off: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: switch-child-device.metadata() is applicable for argument types: (switch-child-device$_run_closure1) values: [switch-child-device$_run_closure1@726386ed]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing switch-level-capability.groovy
DECLARED METHODS
parse: [(pairs = description.split(,))][(result = [])]]
on: ]
off: ]
setLevel: ]
refresh: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: switch-level-capability.metadata() is applicable for argument types: (switch-level-capability$_run_closure1) values: [switch-level-capability$_run_closure1@73393584]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing sylvania-ultra-iq.groovy
DECLARED METHODS
parse: [If description?.startsWith(catchall:),[(msg = zigbee.parse(description))],[(name = (description?.startsWith(on/off: )) ? switch : null)][(value = ((name == switch)) ? (description?.endsWith( 1)) ? on : off : null)][(result = this.createEvent([name:name, value:value]))]],]
on: ]
off: ]
setLevel: [(cmds = [])][If (value == 0),,[If (device.latestValue(switch) == off),,],],[(level = this.hexString(java.lang.Math.round(((value * 255) / 100))))]]
configure: ]
hex: [(s = new java.math.BigInteger(java.lang.Math.round(value).toString()).toString(16))][While (s.size() < width),[(s = (0 + s))]]hex: [(s = new java.math.BigInteger(java.lang.Math.round(value).toString()).toString(16))][While (s.size() < width),[(s = (0 + s))]]]
getEndpointId: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: sylvania-ultra-iq.metadata() is applicable for argument types: (sylvania-ultra-iq$_run_closure1) values: [sylvania-ultra-iq$_run_closure1@70e0accd]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing talking-alarm-clock.groovy
DECLARED METHODS
pageMain: ]
pageSetupScenarioA: ]
pageWeatherSettingsA: ]
pageSetupScenarioB: ]
pageWeatherSettingsB: ]
pageSetupScenarioC: ]
pageWeatherSettingsC: ]
pageSetupScenarioD: ]
pageWeatherSettingsD: ]
installed: ]
updated: [this.unschedule()][this.unsubscribe()]]
initialize: [If (A_alarmType == 1),,],[If (B_alarmType == 1),,],[If (C_alarmType == 1),,],[If (D_alarmType == 1),,],[If (alarmSummary && summarySonos),[this.subscribe(app, appTouchHandler)],],[If ((((ScenarioNameA && A_timeStart) && A_sonos) && A_alarmOn) && A_alarmType),[this.schedule(A_timeStart, alarm_A)][If A_musicTrack,,],,],[If ((((ScenarioNameB && B_timeStart) && B_sonos) && B_alarmOn) && B_alarmType),[this.schedule(B_timeStart, alarm_B)][If B_musicTrack,,],,],[If ((((ScenarioNameC && C_timeStart) && C_sonos) && C_alarmOn) && C_alarmType),[this.schedule(C_timeStart, alarm_C)][If C_musicTrack,,],,],[If ((((ScenarioNameD && D_timeStart) && D_sonos) && D_alarmOn) && D_alarmType),[this.schedule(D_timeStart, alarm_D)][If D_musicTrack,,],,],]
alarm_A: [If ((A_mode || A_mode.contains(location.mode)) && this.getDayOk(A_day)),[If ((A_switches || A_dimmers) || A_thermostats),[(dimLevel = (java.lang.Integer -> java.lang.Integer) A_level)][If A_thermostats,[(thermostatState = A_thermostats.currentThermostatMode)][If (thermostatState == auto),,[If (thermostatState == heat),,],],,],,],[If A_phrase,,],[If (A_triggerMode && (location.mode != A_triggerMode)),[If location.modes?.find({ -> ... }),,],,],[If A_volume,,],[If ((A_alarmType == 2) || ((A_alarmType == 1) && (A_secondAlarm == 1))),[(state.fullMsgA = )][If A_wakeMsg,,],[If (((A_weatherReport || A_humidity) || A_includeTemp) || A_localTemp),,],[If (A_includeSunrise || A_includeSunset),,],[If (((A_switches || A_dimmers) || A_thermostats) && A_confirmSwitches),,],[If (A_phrase && A_confirmPhrase),,],[If (A_triggerMode && A_confirmMode),,],[(state.soundA = this.textToSpeech(state.fullMsgA, true))],],[If (A_alarmType == 1),[If ((A_secondAlarm == 1) && state.soundAlarmA),[A_sonos.playSoundAndTrack(state.soundAlarmA.uri, state.soundAlarmA.duration, state.soundA.uri)],],[If (((A_secondAlarm == 2) && state.selectedSongA) && state.soundAlarmA),[A_sonos.playSoundAndTrack(state.soundAlarmA.uri, state.soundAlarmA.duration, state.selectedSongA)],],[If A_secondAlarm,[A_sonos.playTrack(state.soundAlarmA.uri)],],,],[If (A_alarmType == 2),[If (A_secondAlarmMusic && state.selectedSongA),[A_sonos.playSoundAndTrack(state.soundA.uri, state.soundA.duration, state.selectedSongA)],[A_sonos.playTrack(state.soundA.uri)]],,],[If (A_alarmType == 3),[A_sonos.playTrack(state.selectedSongA)],],,],]
alarm_B: [If ((B_mode || B_mode.contains(location.mode)) && this.getDayOk(B_day)),[If ((B_switches || B_dimmers) || B_thermostats),[(dimLevel = (java.lang.Integer -> java.lang.Integer) B_level)][If B_thermostats,[(thermostatState = B_thermostats.currentThermostatMode)][If (thermostatState == auto),,[If (thermostatState == heat),,],],,],,],[If B_phrase,,],[If (B_triggerMode && (location.mode != B_triggerMode)),[If location.modes?.find({ -> ... }),,],,],[If B_volume,,],[If ((B_alarmType == 2) || ((B_alarmType == 1) && (B_secondAlarm == 1))),[(state.fullMsgB = )][If B_wakeMsg,,],[If (((B_weatherReport || B_humidity) || B_includeTemp) || B_localTemp),,],[If (B_includeSunrise || B_includeSunset),,],[If (((B_switches || B_dimmers) || B_thermostats) && B_confirmSwitches),,],[If (B_phrase && B_confirmPhrase),,],[If (B_triggerMode && B_confirmMode),,],[(state.soundB = this.textToSpeech(state.fullMsgB, true))],],[If (B_alarmType == 1),[If ((B_secondAlarm == 1) && state.soundAlarmB),[B_sonos.playSoundAndTrack(state.soundAlarmB.uri, state.soundAlarmB.duration, state.soundB.uri)],],[If (((B_secondAlarm == 2) && state.selectedSongB) && state.soundAlarmB),[B_sonos.playSoundAndTrack(state.soundAlarmB.uri, state.soundAlarmB.duration, state.selectedSongB)],],[If B_secondAlarm,[B_sonos.playTrack(state.soundAlarmB.uri)],],,],[If (B_alarmType == 2),[If (B_secondAlarmMusic && state.selectedSongB),[B_sonos.playSoundAndTrack(state.soundB.uri, state.soundB.duration, state.selectedSongB)],[B_sonos.playTrack(state.soundB.uri)]],,],[If (B_alarmType == 3),[B_sonos.playTrack(state.selectedSongB)],],,],]
alarm_C: [If ((C_mode || C_mode.contains(location.mode)) && this.getDayOk(C_day)),[If ((C_switches || C_dimmers) || C_thermostats),[(dimLevel = (java.lang.Integer -> java.lang.Integer) C_level)][If C_thermostats,[(thermostatState = C_thermostats.currentThermostatMode)][If (thermostatState == auto),,[If (thermostatState == heat),,],],,],,],[If C_phrase,,],[If (C_triggerMode && (location.mode != C_triggerMode)),[If location.modes?.find({ -> ... }),,],,],[If C_volume,,],[If ((C_alarmType == 2) || ((C_alarmType == 1) && (C_secondAlarm == 1))),[(state.fullMsgC = )][If C_wakeMsg,,],[If (((C_weatherReport || C_humidity) || C_includeTemp) || C_localTemp),,],[If (C_includeSunrise || C_includeSunset),,],[If (((C_switches || C_dimmers) || C_thermostats) && C_confirmSwitches),,],[If (C_phrase && C_confirmPhrase),,],[If (C_triggerMode && C_confirmMode),,],[(state.soundC = this.textToSpeech(state.fullMsgC, true))],],[If (C_alarmType == 1),[If ((C_secondAlarm == 1) && state.soundAlarmC),[C_sonos.playSoundAndTrack(state.soundAlarmC.uri, state.soundAlarmC.duration, state.soundC.uri)],],[If (((C_secondAlarm == 2) && state.selectedSongC) && state.soundAlarmC),[C_sonos.playSoundAndTrack(state.soundAlarmC.uri, state.soundAlarmC.duration, state.selectedSongC)],],[If C_secondAlarm,[C_sonos.playTrack(state.soundAlarmC.uri)],],,],[If (C_alarmType == 2),[If (C_secondAlarmMusic && state.selectedSongC),[C_sonos.playSoundAndTrack(state.soundC.uri, state.soundC.duration, state.selectedSongC)],[C_sonos.playTrack(state.soundC.uri)]],,],[If (C_alarmType == 3),[C_sonos.playTrack(state.selectedSongC)],],,],]
alarm_D: [If ((D_mode || D_mode.contains(location.mode)) && this.getDayOk(D_day)),[If ((D_switches || D_dimmers) || D_thermostats),[(dimLevel = (java.lang.Integer -> java.lang.Integer) D_level)][If D_thermostats,[(thermostatState = D_thermostats.currentThermostatMode)][If (thermostatState == auto),,[If (thermostatState == heat),,],],,],,],[If D_phrase,,],[If (D_triggerMode && (location.mode != D_triggerMode)),[If location.modes?.find({ -> ... }),,],,],[If D_volume,,],[If ((D_alarmType == 2) || ((D_alarmType == 1) && (D_secondAlarm == 1))),[(state.fullMsgD = )][If D_wakeMsg,,],[If (((D_weatherReport || D_humidity) || D_includeTemp) || D_localTemp),,],[If (D_includeSunrise || D_includeSunset),,],[If (((D_switches || D_dimmers) || D_thermostats) && D_confirmSwitches),,],[If (D_phrase && D_confirmPhrase),,],[If (D_triggerMode && D_confirmMode),,],[(state.soundD = this.textToSpeech(state.fullMsgD, true))],],[If (D_alarmType == 1),[If ((D_secondAlarm == 1) && state.soundAlarmD),[D_sonos.playSoundAndTrack(state.soundAlarmD.uri, state.soundAlarmD.duration, state.soundD.uri)],],[If (((D_secondAlarm == 2) && state.selectedSongD) && state.soundAlarmD),[D_sonos.playSoundAndTrack(state.soundAlarmD.uri, state.soundAlarmD.duration, state.selectedSongD)],],[If D_secondAlarm,[D_sonos.playTrack(state.soundAlarmD.uri)],],,],[If (D_alarmType == 2),[If (D_secondAlarmMusic && state.selectedSongD),[D_sonos.playSoundAndTrack(state.soundD.uri, state.soundD.duration, state.selectedSongD)],[D_sonos.playTrack(state.soundD.uri)]],,],[If (D_alarmType == 3),[D_sonos.playTrack(state.selectedSongD)],],,],]
appTouchHandler: [If (summaryMode || summaryMode.contains(location.mode)),[(state.summaryMsg = The following is a summary of the alarm settings. )][log.debug(Summary message = $state.summaryMsg)][(summarySound = this.textToSpeech(state.summaryMsg, true))][If summaryVolume,,],,],]
getSummary: [If (alarmOn && scenarioName),[(state.summaryMsg = $state.summaryMsg Alarm $num, $scenarioName, set for $this.parseDate(timeStart, , h:mm a), is enabled. )],[If ((summaryDisabled && alarmOn) && scenarioName),[(state.summaryMsg = $state.summaryMsg Alarm $num, $scenarioName, set for $this.parseDate(timeStart, , h:mm a), is disabled. )],[If (summaryDisabled && scenarioName),[(state.summaryMsg = $state.summaryMsg Alarm $num is not configured. )],],],],]
getDesc: [(desc = Tap to set alarm)][If timeStart,[(desc = ((Alarm set to  + this.parseDate(timeStart, , h:mm a)) +  on $sonos))][(dayListSize = (day) ? day.size() : 7)][If (day && (dayListSize < 7)),[(desc = (desc +  on))][For day,[(desc = (desc +  $dayName))][(dayListSize = (dayListSize - 1))][If dayListSize,[(desc = $desc, )],],][(desc = (desc +  on))][For day,[(desc = (desc +  $dayName))][(dayListSize = (dayListSize - 1))][If dayListSize,[(desc = $desc, )],],],[(desc = (desc +  every day))]],[If mode,[(modeListSize = mode.size())][(modePrefix =  in the following modes: )][If (modeListSize == 1),[(modePrefix =  in the following mode: )],],[(desc = (desc + $modePrefix))][For mode,[(desc = (desc + '$modeName'))][(modeListSize = (modeListSize - 1))][If modeListSize,[(desc = $desc, )],[(desc = $desc)]],][(modeListSize = mode.size())][(modePrefix =  in the following modes: )][If (modeListSize == 1),[(modePrefix =  in the following mode: )],],[(desc = (desc + $modePrefix))][For mode,[(desc = (desc + '$modeName'))][(modeListSize = (modeListSize - 1))][If modeListSize,[(desc = $desc, )],[(desc = $desc)]],],[(desc = (desc +  in all modes))]],,],]
greyOut: [(result = (((((scenario && sonos) && alarmTime) && alarmOn) && alarmType)) ? complete : )]]
greyOut1: [(result = ((((((param1 || param2) || param3) || param4) || param5) || param6)) ? complete : )]]
getWeatherDesc: [(title = ((((((param1 || param2) || param3) || param4) || param5) || param6)) ? Tap to edit weather reporting options : Tap to setup weather reporting options)]]
greyOutOption: [(result = (param) ? complete : )]]
getTitle: [(title = (scenario) ? scenario : Alarm $num not configured)]]
dimmerDesc: [(desc = (dimmer) ? Tap to edit dimmer settings : Tap to set dimmer setting)]]
thermostatDesc: [(tempText = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][If (heating || cooling),[If heating,[(tempText = $heating heat)],],[If cooling,[(tempText = $cooling cool)],],[If (heating && cooling),[(tempText = $heating heat / $cooling cool)],],,[(tempText = Tap to edit thermostat settings)]],[(desc = (thermostat) ? $tempText : Tap to set thermostat settings)]]
getDayOk: [(result = true)][If dayList,[(result = dayList.contains(this.getDay()))],],]
getDay: [(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))]]
parseDate: [(parseDate = )][If epoch,[(longDate = java.lang.Long.valueOf(epoch).longValue())][(parseDate = new java.util.Date(longDate).format(yyyy-MM-dd'T'HH:mm:ss.SSSZ, location.timeZone))],[(parseDate = date)]],]
getSunriseSunset: [If (location.timeZone || zipCode),[(todayDate = new java.util.Date())][(s = this.getSunriseAndSunset([zipcode:zipCode, date:todayDate]))][(riseTime = this.parseDate(, s.sunrise.time, h:mm a))][(setTime = this.parseDate(, s.sunset.time, h:mm a))][(msg = )][(currTime = this.now())][(verb1 = ((currTime >= s.sunrise.time)) ? rose : will rise)][(verb2 = ((currTime >= s.sunset.time)) ? set : will set)][If (includeSunrise && includeSunset),[(msg = The sun $verb1 this morning at $riseTime and $verb2 at $setTime. )],[If (includeSunrise && includeSunset),[(msg = The sun $verb1 this morning at $riseTime. )],[If (includeSunrise && includeSunset),[(msg = The sun $verb2 tonight at $setTime. )],],],],,[(msg = Please set the location of your hub with the SmartThings mobile app, or enter a zip code to receive sunset and sunrise information. )]],]
getGreeting: [(day = this.getDay())][(time = this.parseDate(, this.now(), h:mm a))][(month = this.parseDate(, this.now(), MMMM))][(year = this.parseDate(, this.now(), yyyy))][(dayNum = this.parseDate(, this.now(), dd))][(msg = msg.replace(%day%, day))][(msg = msg.replace(%date%, $month $dayNum, $year))][(msg = msg.replace(%time%, $time))][(msg = $msg )]]
getWeatherReport: [If (location.timeZone || zipCode),[(isMetric = (location.temperatureScale == C))][(sb = new java.lang.StringBuilder())][If includeTemp,[(current = this.getWeatherFeature(conditions, zipCode))][If isMetric,,],,],[If localTemp,,],[If humidity,,],[If weatherReport,[(weather = this.getWeatherFeature(forecast, zipCode))][If isMetric,,],,],[(msg = sb.toString())][(msg = msg.replaceAll(([0-9]+)C, $1 degrees))][(msg = msg.replaceAll(([0-9]+)F, $1 degrees))],[(msg = Please set the location of your hub with the SmartThings mobile app, or enter a zip code to receive weather forecasts.)]],]
getOnConfimation: [(msg = )][If ((switches || dimmers) && thermostats),[(msg = All switches)],],[If ((switches && dimmers) && thermostats),[(msg = All Thermostats)],],[If ((switches || dimmers) && thermostats),[(msg = All switches and thermostats)],],[(msg = $msg are now on and set. )]]
getPhraseConfirmation: [(msg = The Smart Things Hello Home phrase, $phrase, has been activated. )]]
getModeConfirmation: [(msg = The Smart Things mode is now being set to, $mode. )]]
compileMsg: [log.debug(msg = $msg)][If (scenario == 1),[(state.fullMsgA = (state.fullMsgA + $msg))],],[If (scenario == 2),[(state.fullMsgB = (state.fullMsgB + $msg))],],[If (scenario == 3),[(state.fullMsgC = (state.fullMsgC + $msg))],],[If (scenario == 4),[(state.fullMsgD = (state.fullMsgD + $msg))],],]
no code yet for classclass org.codehaus.groovy.ast.stmt.SwitchStatement
alarmSoundUri: [(soundUri = )][(soundLength = )]]
songOptions: [If sonos,[(options = new java.util.LinkedHashSet())][If (scenario == 1),[If state.selectedSongA?.station,[(options << state.selectedSongA.station)],[If state.selectedSongA?.description,[(options << state.selectedSongA.description)],],],,],[If (scenario == 2),[If state.selectedSongB?.station,[(options << state.selectedSongB.station)],[If state.selectedSongB?.description,[(options << state.selectedSongB.description)],],],,],[If (scenario == 3),[If state.selectedSongC?.station,[(options << state.selectedSongC.station)],[If state.selectedSongC?.description,[(options << state.selectedSongC.description)],],],,],[If (scenario == 4),[If state.selectedSongD?.station,[(options << state.selectedSongD.station)],[If state.selectedSongD?.description,[(options << state.selectedSongD.description)],],],,],[(states = sonos.statesSince(trackData, new java.util.Date(0), [max:30]))][(dataMaps = states.collect({ -> ... }))],],]
no code yet for classclass org.codehaus.groovy.ast.stmt.TryCatchStatement
saveSelectedSong: ]
textAppName: [(text = Talking Alarm Clock)]]
textVersion: [(text = Version 1.4.5 (06/17/2015))]]
textCopyright: [(text = Copyright  2015 Michael Struck)]]
textLicense: [(text = ((((((((((Licensed under the Apache License, Version 2.0 (the 'License');  + you may not use this file except in compliance with the License. ) + You may obtain a copy of the License at) + 

) +     http://www.apache.org/licenses/LICENSE-2.0) + 

) + Unless required by applicable law or agreed to in writing, software ) + distributed under the License is distributed on an 'AS IS' BASIS, ) + WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ) + See the License for the specific language governing permissions and ) + limitations under the License.))]]
textHelp: [(text = ((((((Within each alarm scenario, choose a Sonos speaker, an alarm time and alarm type along with  + switches, dimmers and thermostat to control when the alarm is triggered. Hello, Home phrases and modes can be triggered at alarm time. ) + You also have the option of setting up different alarm sounds, tracks and a personalized spoken greeting that can include a weather report. ) + Variables that can be used in the voice greeting include %day%, %time% and %date%.

) + From the main SmartApp convenience page, tapping the 'Talking Alarm Clock' icon (if enabled within the app) will ) + speak a summary of the alarms enabled or disabled without having to go into the application itself. This ) + functionality is optional and can be configured from the main setup page.))]]
Starting Points: []
IT HAS STATE
--app-start--
processing tcp-bulb.groovy
DECLARED METHODS
parse: [(results = [])][If (description == updated),,],[If (description?.name && description?.value),,],]
setBulbPower: [(state.bulbPower = value)][log.debug(In child with bulbPower of $state.bulbPower)]]
on: [(levelSetting = ((java.lang.Float -> java.lang.Float) device.latestValue(level)) ? (java.lang.Float -> java.lang.Float) device.latestValue(level) : 1.0)][(bulbPowerMax = (java.lang.Float -> java.lang.Float) device.latestValue(setBulbPower))][(calculatedPower = (bulbPowerMax * (levelSetting / 100)))][If (device.latestValue(level) == null),,],]
off: ]
levelUp: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][(step = (float) state.stepsize)][(level += step)][If (level > 100),[(level = 100)],],]
levelDown: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][(step = (float) state.stepsize)][(level -= step)][If (level < 1),[(level = 1)],],]
setLevel: [(level = (java.lang.Integer -> java.lang.Integer) value)][If ((level > 0) && (level <= 100)),,],[(levelSetting = (float) level)][(bulbPowerMax = (float) device.latestValue(setBulbPower))][(calculatedPower = (bulbPowerMax * (levelSetting / 100)))]]
poll: ]
refresh: ]
installed: ]
updated: ]
initialize: [If settings.stepsize,[(state.stepsize = 10)],[(state.stepsize = settings.stepsize)]],]
uninstalled: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tcp-bulb.metadata() is applicable for argument types: (tcp-bulb$_run_closure1) values: [tcp-bulb$_run_closure1@344561e0]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing temperature-measurement-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: temperature-measurement-capability.metadata() is applicable for argument types: (temperature-measurement-capability$_run_closure1) values: [temperature-measurement-capability$_run_closure1@72bca894]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing temperature-sensor.groovy
DECLARED METHODS
parse: [(name = this.parseName(description))][(value = this.parseValue(description))][(unit = ((name == temperature)) ? this.getTemperatureScale() : ((name == humidity)) ? % : null)][(result = this.createEvent([name:name, value:value, unit:unit]))]]
parseName: [If description?.startsWith(temperature: ),,[If description?.startsWith(humidity: ),,],],]
parseValue: [If description?.startsWith(temperature: ),,[If description?.startsWith(humidity: ),[(pct = ((description - humidity: ) - %).trim())][If pct.isNumber(),,],,],],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: temperature-sensor.metadata() is applicable for argument types: (temperature-sensor$_run_closure1) values: [temperature-sensor$_run_closure1@5851bd4f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing text-me-when-it-opens.groovy
DECLARED METHODS
installed: [this.subscribe(contact1, contact.open, contactOpenHandler)]]
updated: [this.unsubscribe()][this.subscribe(contact1, contact.open, contactOpenHandler)]]
contactOpenHandler: [If location.contactBookEnabled,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing text-me-when-theres-motion-and-im-not-here.groovy
DECLARED METHODS
installed: [this.subscribe(motion1, motion.active, motionActiveHandler)]]
updated: [this.unsubscribe()][this.subscribe(motion1, motion.active, motionActiveHandler)]]
motionActiveHandler: [If (presence1.latestValue(presence) == not present),[(deltaSeconds = 10)][(timeAgo = new java.util.Date((this.now() - (1000 * deltaSeconds))))][(recentEvents = motion1.eventsSince(timeAgo))][(alreadySentSms = (recentEvents.count({ -> ... }) > 1))][If alreadySentSms,,[If location.contactBookEnabled,,],],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing the-big-switch.groovy
DECLARED METHODS
installed: [this.subscribe(master, switch.on, onHandler)][this.subscribe(master, switch.off, offHandler)][this.subscribe(master, level, dimHandler)]]
updated: [this.unsubscribe()][this.subscribe(master, switch.on, onHandler)][this.subscribe(master, switch.off, offHandler)][this.subscribe(master, level, dimHandler)]]
logHandler: ]
onHandler: ]
offHandler: ]
dimHandler: ]
onSwitches: [If (switches && onSwitches),,[If switches,,],],]
offSwitches: [If (switches && offSwitches),,[If switches,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing the-flasher.groovy
DECLARED METHODS
installed: [this.subscribe()]]
updated: [this.unsubscribe()][this.subscribe()]]
subscribe: [If contact,[this.subscribe(contact, contact.open, contactOpenHandler)],],[If acceleration,[this.subscribe(acceleration, acceleration.active, accelerationActiveHandler)],],[If motion,[this.subscribe(motion, motion.active, motionActiveHandler)],],[If mySwitch,[this.subscribe(mySwitch, switch.on, switchOnHandler)],],[If myPresence,[this.subscribe(myPresence, presence, presenceHandler)],],]
motionActiveHandler: ]
contactOpenHandler: ]
accelerationActiveHandler: ]
switchOnHandler: ]
presenceHandler: [If (evt.value == present),,[If (evt.value == not present),,],],]
flashLights: [(doFlash = true)][(onFor = (onFor) ? onFor : 1000)][(offFor = (offFor) ? offFor : 1000)][(numFlashes = (numFlashes) ? numFlashes : 3)][log.debug(LAST ACTIVATED IS: $state.lastActivated)][If state.lastActivated,[(elapsed = (this.now() - state.lastActivated))][(sequenceTime = ((numFlashes + 1) * (onFor + offFor)))][(doFlash = (elapsed > sequenceTime))][log.debug(DO FLASH: $doFlash, ELAPSED: $elapsed, LAST ACTIVATED: $state.lastActivated)],],[If doFlash,[(state.lastActivated = this.now())][log.debug(LAST ACTIVATED SET TO: $state.lastActivated)][(initialActionOn = switches.collect({ -> ... }))][(delay = 0)],],]
Starting Points: []
IT HAS STATE
--app-start--
processing the-gun-case-moved.groovy
DECLARED METHODS
installed: [this.subscribe(accelerationSensor, acceleration.active, accelerationActiveHandler)]]
updated: [this.unsubscribe()][this.subscribe(accelerationSensor, acceleration.active, accelerationActiveHandler)]]
accelerationActiveHandler: [(deltaSeconds = 5)][(timeAgo = new java.util.Date((this.now() - (1000 * deltaSeconds))))][(recentEvents = accelerationSensor.eventsSince(timeAgo))][(alreadySentSms = (recentEvents.count({ -> ... }) > 1))][If alreadySentSms,,[If location.contactBookEnabled,,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing thermostat-auto-off.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()][this.unschedule()]]
initialize: [(state.changed = false)][this.subscribe(sensors, contact, sensorChange)]]
sensorChange: [If ((evt.value == open) && state.changed),[this.unschedule()][this.runIn(delay, turnOff)],[If ((evt.value == closed) && state.changed),[(isOpen = false)][For sensors,[If ((sensor.id != evt.deviceId) && (sensor.currentValue(contact) == open)),[(isOpen = true)],],][(isOpen = false)][For sensors,[If ((sensor.id != evt.deviceId) && (sensor.currentValue(contact) == open)),[(isOpen = true)],],][If isOpen,[this.unschedule()][this.runIn(delay, restore)],],,],],]
turnOff: [(state.thermostatMode = thermostat.currentValue(thermostatMode))][(state.changed = true)]]
restore: [log.debug(Setting thermostat to $state.thermostatMode)][thermostat.setThermostatMode(state.thermostatMode)][(state.changed = false)]]
Starting Points: []
IT HAS STATE
--app-start--
processing thermostat-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))][(map = this.createEvent([name:pair[0].trim(), value:pair[1].trim()]))][(result = [map])][If (map.isStateChange && (map.name in [heatingSetpoint, coolingSetpoint, thermostatMode])),[(map2 = [name:thermostatSetpoint, unit:F])][If (map.name == thermostatMode),[If (map.value == cool),[(map2.value = device.latestValue(coolingSetpoint))][log.info(THERMOSTAT, latest cooling setpoint = $map2.value)],[(map2.value = device.latestValue(heatingSetpoint))][log.info(THERMOSTAT, latest heating setpoint = $map2.value)]],,[(mode = device.latestValue(thermostatMode))][log.info(THERMOSTAT, latest mode = $mode)][If (((map.name == heatingSetpoint) && (mode == heat)) || ((map.name == coolingSetpoint) && (mode == cool))),[(map2.value = map.value)][(map2.unit = map.unit)],],],[If (map2.value != null),,],,],]
setHeatingSetpoint: ]
setCoolingSetpoint: ]
setThermostatMode: ]
setThermostatFanMode: ]
off: ]
heat: ]
emergencyHeat: ]
cool: ]
fanOn: ]
fanAuto: ]
fanCirculate: ]
poll: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: thermostat-capability.metadata() is applicable for argument types: (thermostat-capability$_run_closure1) values: [thermostat-capability$_run_closure1@50d68830]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing thermostat-window-check.groovy
DECLARED METHODS
installed: [this.subscribe(thermostats, thermostatMode, thermoChange)][this.subscribe(sensors, contact.open, windowChange)]]
updated: [this.unsubscribe()][this.subscribe(thermostats, thermostatMode, thermoChange)][this.subscribe(sensors, contact.open, windowChange)]]
thermoChange: [If ((evt.value == heat) || (evt.value == cool)),[(open = sensors.findAll({ -> ... }))][If open,[(plural = ((open.size() > 1)) ? are : is)],],,],]
windowChange: [(heating = thermostats.findAll({ -> ... }))][(cooling = thermostats.findAll({ -> ... }))][If (heating || cooling),[(open = sensors.findAll({ -> ... }))][(tempDirection = (heating) ? heating : cooling)][(plural = ((open.size() > 1)) ? were : was)],],]
thermoShutOffTrigger: [If (turnOffTherm == Yes),[(delay = (((turnOffDelay != null) && (turnOffDelay != ))) ? (turnOffDelay * 60) : 60)][(state.turnOffTime = this.now())][this.runIn(delay, thermoShutOff)],],]
thermoShutOff: [(open = sensors.findAll({ -> ... }))][(tempDirection = (heating) ? heating : cooling)][(plural = ((open.size() > 1)) ? are : is)][If open.size(),,],]
send: [If (sendPushMessage != No),,],[If phone,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing thermostats.groovy
DECLARED METHODS
installed: [this.subscribeToEvents()]]
updated: [this.unsubscribe()][this.subscribeToEvents()]]
subscribeToEvents: [this.subscribe(smokeDevices, smoke.detected, eventHandler)][this.subscribe(smokeDevices, smoke.tested, eventHandler)][this.subscribe(smokeDevices, carbonMonoxide.detected, eventHandler)][this.subscribe(carbonMonoxideDevices, carbonMonoxide.detected, eventHandler)]]
eventHandler: [If frequency,[(lastTime = state[evt.deviceId])][If ((lastTime == null) || ((this.now() - lastTime) >= (frequency * 60000))),,],,],]
sendMessage: [(msg = messageText)][(options = [:])][If messageText,[(msg = {{ triggerEvent.descriptionText }})][(options = [translatable:true, triggerEvent:evt])],],[If location.contactBookEnabled,,[If phone,[(options.phone = phone)][If (pushAndPhone != No),[(options.method = both)],[(options.method = phone)]],,[If (pushAndPhone != No),[(options.method = push)],[(options.method = none)]],],],[If frequency,[(state[evt.deviceId] = this.now())],],]
Starting Points: []
IT HAS STATE
--app-start--
processing thing.groovy
DECLARED METHODS
parse: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: thing.metadata() is applicable for argument types: (thing$_run_closure1) values: [thing$_run_closure1@622ef26a]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing three-axis-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: three-axis-capability.metadata() is applicable for argument types: (three-axis-capability$_run_closure1) values: [three-axis-capability$_run_closure1@77b325b3]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-carousel.groovy
DECLARED METHODS
installed: ]
parse: ]
evaluate: [(threshold = 1.0)][(current = device.currentValue(thermostatOperatingState))][(mode = device.currentValue(thermostatMode))][(heating = false)][(cooling = false)][(idle = false)][If (mode in [heat, emergency heat, auto]),[If ((heatingSetpoint - temp) >= threshold),[(heating = true)],[If ((temp - heatingSetpoint) >= threshold),[(idle = true)],],],,],[If (mode in [cool, auto]),[If ((temp - coolingSetpoint) >= threshold),[(cooling = true)],[If (((coolingSetpoint - temp) >= threshold) && heating),[(idle = true)],],],,],[If ((idle && heating) && cooling),,],]
setHeatingSetpoint: ]
setCoolingSetpoint: ]
setThermostatMode: ]
setThermostatFanMode: ]
off: ]
heat: ]
auto: ]
emergencyHeat: ]
cool: ]
fanOn: ]
fanAuto: ]
fanCirculate: ]
tempUp: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue + 1) : 72)]]
tempDown: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue - 1) : 72)]]
setTemperature: [(ts = device.currentState(temperature))]]
heatUp: [(ts = device.currentState(heatingSetpoint))][(value = (ts) ? (ts.integerValue + 1) : 68)]]
heatDown: [(ts = device.currentState(heatingSetpoint))][(value = (ts) ? (ts.integerValue - 1) : 68)]]
coolUp: [(ts = device.currentState(coolingSetpoint))][(value = (ts) ? (ts.integerValue + 1) : 76)]]
coolDown: [(ts = device.currentState(coolingSetpoint))][(value = (ts) ? (ts.integerValue - 1) : 76)]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-carousel.metadata() is applicable for argument types: (tile-basic-carousel$_run_closure1) values: [tile-basic-carousel$_run_closure1@308a6984]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-colorwheel.groovy
DECLARED METHODS
parse: ]
setColor: [If value.hex,,],[If value.hue,,],[If value.saturation,,],]
setSaturation: ]
setHue: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-colorwheel.metadata() is applicable for argument types: (tile-basic-colorwheel$_run_closure1) values: [tile-basic-colorwheel$_run_closure1@1c4ee95c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-presence.groovy
DECLARED METHODS
installed: ]
parse: ]
arrived: ]
departed: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-presence.metadata() is applicable for argument types: (tile-basic-presence$_run_closure1) values: [tile-basic-presence$_run_closure1@51bde877]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-slider.groovy
DECLARED METHODS
installed: ]
parse: ]
setLevel: ]
setRangedLevel: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-slider.metadata() is applicable for argument types: (tile-basic-slider$_run_closure1) values: [tile-basic-slider$_run_closure1@7cc9ce8]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-standard.groovy
DECLARED METHODS
installed: ]
parse: ]
on: ]
off: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-standard.metadata() is applicable for argument types: (tile-basic-standard$_run_closure1) values: [tile-basic-standard$_run_closure1@1db0ec27]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-basic-value.groovy
DECLARED METHODS
installed: ]
parse: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-basic-value.metadata() is applicable for argument types: (tile-basic-value$_run_closure1) values: [tile-basic-value$_run_closure1@1af1347d]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-multiattribute-generic.groovy
DECLARED METHODS
installed: ]
parse: ]
on: ]
off: ]
setLevel: ]
randomizeLevel: [(level = java.lang.Math.round((java.lang.Math.random() * 100)))]]
levelUp: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][If (level < 100),[(level = (level + 1))],],]
levelDown: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][If (level > 0),[(level = (level - 1))],],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-generic.metadata() is applicable for argument types: (tile-multiattribute-generic$_run_closure1) values: [tile-multiattribute-generic$_run_closure1@515f4131]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-multiattribute-lighting.groovy
DECLARED METHODS
parse: [(results = [])][(map = description)][If (description instanceof java.lang.String),[(map = this.stringToMap(description))],],[If (map?.name && map?.value),,],]
on: ]
off: ]
nextLevel: [(level = ((java.lang.Integer -> java.lang.Integer) device.latestValue(level)) ? (java.lang.Integer -> java.lang.Integer) device.latestValue(level) : 0)][If (level <= 100),[(level = (java.lang.Integer -> java.lang.Integer) java.lang.Math.min((25 * (java.lang.Math.round((level / 25)) + 1)), 100))],[(level = 25)]],]
setLevel: [(power = (java.lang.Math.round((percent / 1.175)) * 0.1))]]
setSaturation: ]
setHue: ]
setColor: [If value.hue,,],[If value.saturation,,],[If value.hex,,],[If value.level,,],[If value.switch,,],]
reset: ]
setAdjustedColor: [If value,[(adjusted = (value + [:]))][(adjusted.hue = this.adjustOutgoingHue(value.hue))][(adjusted.level = null)],],]
refresh: ]
adjustOutgoingHue: [(adjusted = percent)][If (percent > 31),[If (percent < 63.0),[(adjusted = (percent + ((7 * (percent - 30)) / 32)))],[If (percent < 73.0),[(adjusted = (69 + ((5 * (percent - 62)) / 10)))],[(adjusted = (percent + ((2 * (100 - percent)) / 28)))]],],,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-lighting.metadata() is applicable for argument types: (tile-multiattribute-lighting$_run_closure1) values: [tile-multiattribute-lighting$_run_closure1@545f80bf]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-multiattribute-mediaplayer.groovy
DECLARED METHODS
installed: [(state.tracks = [Gangnam Style (?)
PSY
Psy 6 (Six Rules), Part 1, Careless Whisper
Wham!
Make It Big, Never Gonna Give You Up
Rick Astley
Whenever You Need Somebody, Shake It Off
Taylor Swift
1989, Ironic
Alanis Morissette
Jagged Little Pill, Hotline Bling
Drake
Hotline Bling - Single])][(state.currentTrack = 0)]]
parse: ]
play: [this.sendEvent([name:trackDescription, value:state.tracks[state.currentTrack]])]]
pause: [this.sendEvent([name:trackDescription, value:state.tracks[state.currentTrack]])]]
stop: ]
previousTrack: [(state.currentTrack = (state.currentTrack - 1))][If (state.currentTrack < 0),[(state.currentTrack = (state.tracks.size() - 1))],],[this.sendEvent([name:trackDescription, value:state.tracks[state.currentTrack]])]]
nextTrack: [(state.currentTrack = (state.currentTrack + 1))][If (state.currentTrack == state.tracks.size()),[(state.currentTrack = 0)],],[this.sendEvent([name:trackDescription, value:state.tracks[state.currentTrack]])]]
mute: ]
unmute: ]
setLevel: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-mediaplayer.metadata() is applicable for argument types: (tile-multiattribute-mediaplayer$_run_closure1) values: [tile-multiattribute-mediaplayer$_run_closure1@4f8caaf3]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-multiattribute-thermostat.groovy
DECLARED METHODS
installed: ]
parse: ]
evaluate: [(threshold = 1.0)][(current = device.currentValue(thermostatOperatingState))][(mode = device.currentValue(thermostatMode))][(heating = false)][(cooling = false)][(idle = false)][If (mode in [heat, emergency heat, auto]),[If ((heatingSetpoint - temp) >= threshold),[(heating = true)],[If ((temp - heatingSetpoint) >= threshold),[(idle = true)],],],,],[If (mode in [cool, auto]),[If ((temp - coolingSetpoint) >= threshold),[(cooling = true)],[If (((coolingSetpoint - temp) >= threshold) && heating),[(idle = true)],],],,],[If (mode == off),[(idle = true)],],[If ((idle && heating) && cooling),,],]
setHeatingSetpoint: ]
setCoolingSetpoint: ]
setThermostatMode: ]
setThermostatFanMode: ]
off: ]
heat: ]
auto: ]
emergencyHeat: ]
cool: ]
fanOn: ]
fanAuto: ]
fanCirculate: ]
poll: ]
tempUp: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue + 1) : 72)]]
tempDown: [(ts = device.currentState(temperature))][(value = (ts) ? (ts.integerValue - 1) : 72)]]
setTemperature: [(ts = device.currentState(temperature))]]
heatUp: [(ts = device.currentState(heatingSetpoint))][(value = (ts) ? (ts.integerValue + 1) : 68)]]
heatDown: [(ts = device.currentState(heatingSetpoint))][(value = (ts) ? (ts.integerValue - 1) : 68)]]
coolUp: [(ts = device.currentState(coolingSetpoint))][(value = (ts) ? (ts.integerValue + 1) : 76)]]
coolDown: [(ts = device.currentState(coolingSetpoint))][(value = (ts) ? (ts.integerValue - 1) : 76)]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-thermostat.metadata() is applicable for argument types: (tile-multiattribute-thermostat$_run_closure1) values: [tile-multiattribute-thermostat$_run_closure1@60297f36]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing tile-multiattribute-videoplayer.groovy
DECLARED METHODS
installed: ]
parse: ]
refresh: ]
on: ]
off: ]
setProfile: ]
setProfileHD: ]
setProfileSDH: ]
setProfileSDL: ]
start: [(dataLiveVideo = [OutHomeURL:https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/bipbop_4x3_variant.m3u8, InHomeURL:https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/bipbop_4x3_variant.m3u8, ... ])][(event = [name:stream, value:groovy.json.JsonOutput.toJson(dataLiveVideo).toString(), data:groovy.json.JsonOutput.toJson(dataLiveVideo), ... ])]]
stop: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: tile-multiattribute-videoplayer.metadata() is applicable for argument types: (tile-multiattribute-videoplayer$_run_closure1) values: [tile-multiattribute-videoplayer$_run_closure1@2fb69ff6]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing turn-it-on-for-5-minutes.groovy
DECLARED METHODS
installed: [this.subscribe(contact1, contact.open, contactOpenHandler)]]
updated: [this.unsubscribe()][this.subscribe(contact1, contact.open, contactOpenHandler)]]
contactOpenHandler: [(fiveMinuteDelay = (60 * 5))][this.runIn(fiveMinuteDelay, turnOffSwitch)]]
turnOffSwitch: ]
Starting Points: []
IT HAS STATE
--app-start--
processing turn-it-on-when-im-here.groovy
DECLARED METHODS
installed: [this.subscribe(presence1, presence, presenceHandler)]]
updated: [this.unsubscribe()][this.subscribe(presence1, presence, presenceHandler)]]
presenceHandler: [(current = presence1.currentValue(presence))][(presenceValue = presence1.find({ -> ... }))][If presenceValue,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing turn-it-on-when-it-opens.groovy
DECLARED METHODS
installed: [this.subscribe(contact1, contact.open, contactOpenHandler)]]
updated: [this.unsubscribe()][this.subscribe(contact1, contact.open, contactOpenHandler)]]
contactOpenHandler: ]
Starting Points: []
IT HAS STATE
--app-start--
processing turn-off-with-motion.groovy
DECLARED METHODS
installed: [this.subscribe(motion1, motion, motionHandler)][this.schedule(0 * * * * ?, scheduleCheck)]]
updated: [this.unsubscribe()][this.subscribe(motion1, motion, motionHandler)][this.unschedule()][this.schedule(0 * * * * ?, scheduleCheck)]]
motionHandler: [If (evt.value == active),[(state.inactiveAt = null)],[If (evt.value == inactive),[If state.inactiveAt,[(state.inactiveAt = this.now())],],,],],]
scheduleCheck: [log.debug(schedule check, ts = $state.inactiveAt)][If state.inactiveAt,[(elapsed = (this.now() - state.inactiveAt))][(threshold = ((1000 * 60) * minutes1))][If (elapsed >= threshold),[(state.inactiveAt = null)],],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing turn-on-only-if-i-arrive-after-sunset.groovy
DECLARED METHODS
installed: [this.subscribe(presence1, presence, presenceHandler)]]
updated: [this.unsubscribe()][this.subscribe(presence1, presence, presenceHandler)]]
presenceHandler: [(now = new java.util.Date())][(sunTime = this.getSunriseAndSunset())][(current = presence1.currentValue(presence))][(presenceValue = presence1.find({ -> ... }))][If (presenceValue && (now > sunTime.sunset)),,[If (presenceValue && (now < sunTime.sunset)),,],],]
Starting Points: []
IT HAS STATE
--app-start--
processing undead-early-warning.groovy
DECLARED METHODS
installed: [this.subscribe(contacts, contact.open, contactOpenHandler)]]
updated: [this.unsubscribe()][this.subscribe(contacts, contact.open, contactOpenHandler)]]
contactOpenHandler: ]
Starting Points: []
IT HAS STATE
--app-start--
processing unknown.groovy
DECLARED METHODS
parse: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: unknown.metadata() is applicable for argument types: (unknown$_run_closure1) values: [unknown$_run_closure1@4a325eb9]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing unlock-it-when-i-arrive.groovy
DECLARED METHODS
installed: [this.subscribe(presence1, presence.present, presence)]]
updated: [this.unsubscribe()][this.subscribe(presence1, presence.present, presence)]]
presence: [(anyLocked = (lock1.count({ -> ... }) != lock1.size()))][If anyLocked,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing virtual-thermostat.groovy
DECLARED METHODS
installed: [this.subscribe(sensor, temperature, temperatureHandler)][If motion,[this.subscribe(motion, motion, motionHandler)],],]
updated: [this.unsubscribe()][this.subscribe(sensor, temperature, temperatureHandler)][If motion,[this.subscribe(motion, motion, motionHandler)],],]
temperatureHandler: [(isActive = this.hasBeenRecentMotion())][If (isActive || emergencySetpoint),,],]
motionHandler: [If (evt.value == active),[(lastTemp = sensor.currentTemperature)][If (lastTemp != null),,],,[If (evt.value == inactive),[(isActive = this.hasBeenRecentMotion())][If (isActive || emergencySetpoint),[(lastTemp = sensor.currentTemperature)][If (lastTemp != null),,],,],,],],]
evaluate: [(threshold = 1.0)][If (mode == cool),[If ((currentTemp - desiredTemp) >= threshold),,[If ((desiredTemp - currentTemp) >= threshold),,],],,[If ((desiredTemp - currentTemp) >= threshold),,[If ((currentTemp - desiredTemp) >= threshold),,],],],]
hasBeenRecentMotion: [(isActive = false)][If (motion && minutes),[(deltaMinutes = (java.lang.Long -> java.lang.Long) minutes)][If deltaMinutes,[(motionEvents = motion.eventsSince(new java.util.Date((this.now() - (60000 * deltaMinutes)))))][If motionEvents.find({ -> ... }),[(isActive = true)],],,],,[(isActive = true)]],]
Starting Points: []
IT HAS STATE
--app-start--
processing water-sensor-capability.groovy
DECLARED METHODS
parse: [(pair = description.split(:))]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: water-sensor-capability.metadata() is applicable for argument types: (water-sensor-capability$_run_closure1) values: [water-sensor-capability$_run_closure1@11a82d0f]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing wattvision.groovy
DECLARED METHODS
refresh: ]
parse: ]
setGraphUrl: ]
addWattvisionData: [(data = this.parseJson(json.data.toString()))][(units = (json.units) ? json.units : watts)][If (data.size() > 0),[(latestData = data[-1])],],]
sendPowerEvent: [(wattvisionDateFormat = parent.wattvisionDateFormat())][(eventData = [date:new java.util.Date().parse(wattvisionDateFormat, time), value:value, name:power, displayed:isLatest, isStateChange:isLatest, ... ])]]
parseJson: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: wattvision.metadata() is applicable for argument types: (wattvision$_run_closure1) values: [wattvision$_run_closure1@13e9f2e2]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing weather-windows.groovy
DECLARED METHODS
installed: [this.subscribe(inTemp, temperature, temperatureHandler)]]
updated: [this.unsubscribe()][this.subscribe(inTemp, temperature, temperatureHandler)]]
temperatureHandler: [(currentOutTemp = null)][If outTemp,[(currentOutTemp = outTemp.latestValue(temperature))],[(currentOutTemp = this.weatherCheck())]],[(currentInTemp = evt.doubleValue)][(openWindows = sensors.findAll({ -> ... }))][(retryPeriodInMinutes = (retryPeriod) ? retryPeriod : 30)][(timeAgo = new java.util.Date((this.now() - ((1000 * 60) * retryPeriodInMinutes).toLong())))][(recentEvents = inTemp.eventsSince(timeAgo))][If ((currentInTemp > minTemp) && (currentInTemp < maxTemp)),,[If (currentInTemp > maxTemp),[(alreadyNotified = (recentEvents.count({ -> ... }) > 1))][If alreadyNotified,[If ((currentOutTemp < maxTemp) && openWindows),,[If ((currentOutTemp > maxTemp) && openWindows),,],],,],,[If (currentInTemp < minTemp),[(alreadyNotified = (recentEvents.count({ -> ... }) > 1))][If alreadyNotified,[If ((currentOutTemp > minTemp) && openWindows),,[If ((currentOutTemp < minTemp) && openWindows),,],],,],,],],],]
weatherCheck: [(json = this.getWeatherFeature(conditions, zipCode))][(currentTemp = json?.current_observation?.temp_f)][If currentTemp,,],]
send: [If (sendPushMessage != No),,],[If phone1,,],]
Starting Points: []
IT HAS STATE
--app-start--
processing wemo-bulb.groovy
DECLARED METHODS
parse: [If description?.startsWith(catchall:),[If description?.endsWith(0100),[(result = this.createEvent([name:switch, value:on]))],],[If description?.endsWith(0000),[(result = this.createEvent([name:switch, value:off]))],],,],[If description?.startsWith(read attr),[(i = java.lang.Math.round(((this.convertHexToInt(description[(-2..-1)]) / 256) * 100)))],],]
on: ]
off: ]
refresh: ]
setLevel: [(cmds = [])][If (value == 0),,[If (device.latestValue(switch) == off),,],],[(level = this.hexString(java.lang.Math.round(((value * 255) / 100))))]]
configure: [(configCmds = [zcl global send-me-a-report 6 0 0x10 0 3600 {01}, delay 500, send 0x$device.deviceNetworkId 1 1, delay 1000, zcl global send-me-a-report 8 0 0x20 5 3600 {0010}, delay 200, send 0x$device.deviceNetworkId 1 1, delay 1500, zdo bind 0x$device.deviceNetworkId 1 1 6 {$device.zigbeeId} {}, delay 1000, zdo bind 0x$device.deviceNetworkId 1 1 8 {$device.zigbeeId} {}, delay 500])]]
hex: [(s = new java.math.BigInteger(java.lang.Math.round(value).toString()).toString(16))][While (s.size() < width),[(s = (0 + s))]]hex: [(s = new java.math.BigInteger(java.lang.Math.round(value).toString()).toString(16))][While (s.size() < width),[(s = (0 + s))]]]
convertHexToInt: ]
swapEndianHex: ]
reverseArray: [(i = 0)][(j = (array.length - 1))][(tmp = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While (j > i),[(tmp = array[j])][(array[j] = array[i])][(array[i] = tmp)]]reverseArray: [(i = 0)][(j = (array.length - 1))][(tmp = <not implemented yet for class: org.codehaus.groovy.ast.expr.EmptyExpression>)][While (j > i),[(tmp = array[j])][(array[j] = array[i])][(array[i] = tmp)]]]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: wemo-bulb.metadata() is applicable for argument types: (wemo-bulb$_run_closure1) values: [wemo-bulb$_run_closure1@60e9df3c]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing when-its-going-to-rain.groovy
DECLARED METHODS
installed: [this.schedule(time, scheduleCheck)]]
updated: [this.unschedule()][this.schedule(time, scheduleCheck)]]
scheduleCheck: [(response = this.getWeatherFeature(forecast, zipcode))][If this.isStormy(response),[(open = sensors.findAll({ -> ... }))][If open,[If location.contactBookEnabled,,],,],,],]
isStormy: [(STORMY = [rain, snow, showers, sprinkles, precipitation])][(forecast = json?.forecast?.txt_forecast?.forecastday?.first())][If forecast,[(text = forecast?.fcttext?.toLowerCase())][If text,[(result = false)][For ((i = 0); ((i < STORMY.size()) && result); (i++)),[(result = text.contains(STORMY[i]))]][(result = false)][For ((i = 0); ((i < STORMY.size()) && result); (i++)),[(result = text.contains(STORMY[i]))]],],,],]
Starting Points: []
IT HAS STATE
--app-start--
processing whole-house-fan.groovy
DECLARED METHODS
installed: ]
updated: [this.unsubscribe()]]
initialize: [(state.fanRunning = false)][this.subscribe(outTemp, temperature, checkThings)][this.subscribe(inTemp, temperature, checkThings)][this.subscribe(thermostat, thermostatMode, checkThings)][this.subscribe(contacts, contact, checkThings)]]
checkThings: [(outsideTemp = settings.outTemp.currentTemperature)][(insideTemp = settings.inTemp.currentTemperature)][(thermostatMode = settings.thermostat.currentThermostatMode)][(somethingOpen = ((settings.checkContacts == No) || settings.contacts?.find({ -> ... })))][(shouldRun = true)][If (thermostatMode != off),[(shouldRun = false)],],[If (insideTemp < outsideTemp),[(shouldRun = false)],],[If (insideTemp < settings.minTemp),[(shouldRun = false)],],[If somethingOpen,[(shouldRun = false)],],[If (shouldRun && state.fanRunning),[(state.fanRunning = true)],[If (shouldRun && state.fanRunning),[(state.fanRunning = false)],],],]
Starting Points: []
IT HAS STATE
--app-start--
processing working-from-home.groovy
DECLARED METHODS
configActions: ]
installed: ]
updated: [this.unschedule()]]
initialize: [this.schedule(this.timeToday(timeOfDay, location?.timeZone), checkPresence)][If customName,,],]
checkPresence: [If (daysOk && modeOk),[If (person.latestValue(presence) == present),[(message = $location.name executed '$settings.wfhPhrase' because $person is home.)],],,],]
send: [If (sendPushMessage != No),,],[If phone,,],]
getModeOk: [(result = (modes || modes.contains(location.mode)))]]
getDaysOk: [(result = true)][If days,[(df = new java.text.SimpleDateFormat(EEEE))][If location.timeZone,,],[(day = df.format(new java.util.Date()))][(result = days.contains(day))],],]
hideOptions: ]
Starting Points: []
IT HAS STATE
--app-start--
processing zigbee-switch.groovy
DECLARED METHODS
parse: [(event = zigbee.getEvent(description))][If event,,],]
off: ]
on: ]
ping: ]
refresh: ]
configure: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: zigbee-switch.metadata() is applicable for argument types: (zigbee-switch$_run_closure1) values: [zigbee-switch$_run_closure1@36453307]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing zigbee-white-color-temperature-bulb.groovy
DECLARED METHODS
getMOVE_TO_COLOR_TEMPERATURE_COMMAND: ]
getCOLOR_CONTROL_CLUSTER: ]
getATTRIBUTE_COLOR_TEMPERATURE: ]
parse: [(event = zigbee.getEvent(description))][If event,[If ((event.name == level) && (event.value == 0)),,[If (event.name == colorTemperature),,],],,[(cluster = zigbee.parse(description))][If ((cluster && (cluster.clusterId == 6)) && (cluster.command == 7)),[If (cluster.data[0] == 0),,],,],],]
off: ]
on: ]
setLevel: ]
ping: ]
refresh: ]
configure: ]
setColorTemperature: [(value = (java.lang.Integer -> java.lang.Integer) value)][(tempInMired = java.lang.Math.round((1000000 / value)))][(finalHex = zigbee.swapEndianHex(zigbee.convertToHexString(tempInMired, 4)))][(cmds = [])][If ((device.getDataValue(manufacturer) == sengled) && (device.getDataValue(model) == Z01-A19NAE26)),,],]
setGenericName: [If (value != null),[(genericName = White)][If (value < 3300),[(genericName = Soft White)],[If (value < 4150),[(genericName = Moonlight)],[If (value <= 5000),[(genericName = Cool White)],[If (value >= 5000),[(genericName = Daylight)],],],],],,],]
installed: [If (((((device.getDataValue(manufacturer) == MRVL) && (device.getDataValue(model) == MZ100)) || (device.getDataValue(manufacturer) == OSRAM SYLVANIA)) || (device.getDataValue(manufacturer) == OSRAM)) || (device.getDataValue(manufacturer) == sengled)),[If ((device.currentState(level)?.value == null) || (device.currentState(level)?.value == 0)),,],,],]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: zigbee-white-color-temperature-bulb.metadata() is applicable for argument types: (zigbee-white-color-temperature-bulb$_run_closure1) values: [zigbee-white-color-temperature-bulb$_run_closure1@6813a331]
Possible solutions: metaClass(groovy.lang.Closure)
--app-start--
processing zooz-power-strip-outlet.groovy
DECLARED METHODS
on: ]
off: ]
Starting Points: []
IT HAS STATE
missing method: groovy.lang.MissingMethodException: No signature of method: zooz-power-strip-outlet.metadata() is applicable for argument types: (zooz-power-strip-outlet$_run_closure1) values: [zooz-power-strip-outlet$_run_closure1@3887cf88]
Possible solutions: metaClass(groovy.lang.Closure)
summary
cmd overpriv:0
attr overpriv:0
num reflection:0
total:0
type2 overprivilege total:0
samename_flags:0
type2 cmd/attr uses:0
numSendSms: 0
numOAuth: 0
numInternet: 0